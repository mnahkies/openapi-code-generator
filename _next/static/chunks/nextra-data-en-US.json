{"/getting-started/quick-start":{"title":"Requirements","data":{"":"Install the latest NodeJS LTS release, though any recent version of NodeJS will likely work.You can check the version we develop and test against here.","install-the-cli#Install the cli":"First we must install the cli package. It's recommended to install this as a devDependency in each project that\ndepends on it, though you could also install it globally if you prefer.\nnpm i -D @nahkies/openapi-code-generator\npnpm add -D @nahkies/openapi-code-generator\nyarn add --dev @nahkies/openapi-code-generator\nbun add --dev @nahkies/openapi-code-generator","optional-for-typespec-support#(Optional) For typespec support":"If you want to use typespec instead of openapi3\nas your input specifications, additionally install the typespec compiler and supporting packages.\nnpm i -D @typespec/compiler @typespec/http @typespec/openapi @typespec/openapi3 @typespec/versioning\npnpm add -D @typespec/compiler @typespec/http @typespec/openapi @typespec/openapi3 @typespec/versioning\nyarn add --dev @typespec/compiler @typespec/http @typespec/openapi @typespec/openapi3 @typespec/versioning\nbun add --dev @typespec/compiler @typespec/http @typespec/openapi @typespec/openapi3 @typespec/versioning\nDepending how your typespec specification is written, you may find you need to install additional packages such\nas @typespec/rest.","follow-the-instructions-for-the-desired-template#Follow the instructions for the desired template":"Each template has it's own dependency requirements. Please see the specific guides linked below","server-scaffolding-templates#Server Scaffolding Templates":"typescript-koa","client-sdk-templates#Client SDK Templates":"typescript-fetch\ntypescript-axios\ntypescript-angular"}},"/overview/compatibility":{"title":"Compatibility Tables","data":{"":"This page aims to document which parts of the openapi 3.1.0 specification is supported.\nIt may not be totally complete / accurate, but it should be broadly correct and give you\nan understanding of what does / doesn't work.\nIf something you need isn't supported yet, please raise a Github\nissue\ndetailing your use-case, and we can work together to get support added / extended.We will also accept pull requests where implemented functionality follows the OpenAPI\nspecification,\nand the output code is of a high quality in terms of developer experience and robustness. See\nCONTRIBUTING.md\nto get started","tldr#tldr;":"Most common functionality used by JSON based APIs should work.\nGreat support for paths using application/json request / response bodies\nComprehensive support for most schema properties, including json validation stuff like minLength,\nbut only for json content types. Notable exceptions:\nreadonly is currently implemented incorrectly\ndiscriminator is ignored, but union / intersection types will be generated based on anyOf / allOf so\nthis isn't often an issue in practice\nNo support for security schemes, you'll need to fudge these as header parameters, or implement out-of-band\nfor the specification for now.\nNo support for webhooks / callbacks yet","legend#Legend":"Symbol\tMeaning\tâœ…/ðŸš§\tSupported in some way. May be incomplete\tðŸš«\tNot supported, likely to be supported eventually\tN/A\tIgnored, unlikely to be used for anything","root-openapi-object#Root OpenAPI Object":"Root object of openapi documents. A âœ… means at least some support for this field - click through to the table\nfor each attribute for further details.\nAttribute\tSupported\tNotes\topenapi\tâœ…\tEither 3.1.x or 3.0.x is supported\tinfo\tN/A\tIgnored\tjsonSchemaDialect\tðŸš«\tNot yet supported\tservers\tâœ…\tServer URLs cam be usd to type client SDK base paths\tpaths\tâœ…\t\twebhooks\tðŸš«\tNot yet supported. Emulate by defining as normal paths.\tcomponents\tâœ…\t\tsecurity\tðŸš«\tNot yet supported. Implement out of band or using header parameters.\ttags\tâœ…\tOptionally used to split output into multiple files\texternalDocs\tN/A\tIgnored","sub-objects#Sub-objects":"","reference-object#Reference Object":"Reference objects are supported to be used in place of the actual object definition anywhere in the documents.\nThey can also cross files (and maybe urls - needs testing).\nIt's recommended to use $ref objects as much as possible. It both promotes re-use, and also allows control\nover the naming of the type / schema in the generated code.\nExample:\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/ExampleSchema\"\nAttribute\tSupported\tNotes\t$ref\tâœ…\t$ref support is robust, and works correctly across multiple input files.\tsummary\tN/A\tIgnored\tdescription\tN/A\tIgnored","server-object#Server Object":"Currently only used by the client SDKs to generate string literal types for basePath\nfor intellisense purposes.\nAttribute\tSupported\tNotes\turl\tâœ…\tOptionally used to type client SDK basePath configuration\tdescription\tN/A\tIgnored\tvariables\tðŸš«\tNot yet supported","components-object#Components Object":"Technically you can define any \"components\" you like, and $refs to them will work, regardless\nof if they appear in the official specification.The table indicates what will actually typically be used for anything right now.\nAttribute\tSupported\tNotes\tschemas\tâœ…\t\tresponses\tâœ…\t\tparameters\tâœ…\t\texamples\tN/A\t\trequestBodies\tâœ…\t\theaders\tâœ…\t\tsecuritySchemes\tðŸš«\tNot yet supported\tlinks\tðŸš«\tNot yet supported\tcallbacks\tðŸš«\tNot yet supported\tpathItems\tâœ…","paths-object#Paths Object":"Paths are well supported.\nAttribute\tSupported\tNotes\t{path}\tâœ…","path-item-object#Path Item Object":"All common http methods are supported. Overriding servers for individual paths is not supported.\nAttribute\tSupported\tNotes\tsummary\tN/A\tIgnored\tdescription\tN/A\tIgnored\tget\tâœ…\t\tput\tâœ…\t\tpost\tâœ…\t\tdelete\tâœ…\t\thead\tðŸš«\tNot yet supported\tpatch\tâœ…\t\ttrace\tðŸš«\tNot yet supported\tservers\tðŸš«\tNot yet supported\tparameters\tâœ…","operation-object#Operation Object":"Most things are supported. It's recommended you supply an operationId as otherwise\none will be generated from the path / http method, which is often overly verbose.\nAttribute\tSupported\tNotes\ttags\tâœ…\tOptionally used to split output into multiple files\tsummary\tN/A\tIgnored\tdescription\tN/A\tIgnored\texternalDocs\tN/A\tIgnored\toperationId\tâœ…\tUsed to generate names on types / methods / interfaces\tparameters\tâœ…\t\trequestBody\tâœ…\t\tresponses\tâœ…\t\tcallbacks\tðŸš«\tNot yet supported\tdeprecated\tðŸš«\tNot yet supported\tsecurity\tðŸš«\tNot yet supported\tservers\tðŸš«\tNot yet supported","parameter-object#Parameter Object":"Whilst attributes like style and explode are not yet supported, for most common parameter use-cases\neverything should just work as you'd guess/expect.\nAttribute\tSupported\tNotes\tname\tâœ…\t\tin\tâœ…/ðŸš§\tEverything supported apart from \"cookie\".\tdescription\tN/A\tIgnored\trequired\tâœ…\t\tdeprecated\tN/A\tIgnored\tallowEmptyValue\tðŸš«\tUse schema minLength: 1 to prevent empty string values in query parameters\tstyle\tðŸš«\tNot yet supported\texplode\tðŸš«\tNot yet supported\tallowReserved\tðŸš«\tUse schema pattern to emulate\tschema\tâœ…\t\texample\tN/A\tIgnored\texamples\tN/A\tIgnored\tcontent\tðŸš«\tNot yet supported","request-body-object#Request Body Object":"Well-supported for application/json content types. Support for form data, and file uploads, etc\nplanned to come soon.\nAttribute\tSupported\tNotes\tdescription\tN/A\tIgnored\tcontent\tâœ…/ðŸš§\tOnly media types of application/json work properly.\trequired\tâœ…","media-type-object#Media Type Object":"Attribute\tSupported\tNotes\tschema\tâœ…\t\texample\tN/A\tIgnored\texamples\tN/A\tIgnored\tencoding\tðŸš«\tNot yet supported","responses-object#Responses Object":"Well supported.\nAttribute\tSupported\tNotes\tdefault\tâœ…\t\t{http-status-code}\tâœ…","response-object#Response Object":"Generally well-supported for application/json content types.\nAttribute\tSupported\tNotes\tdescription\tN/A\tIgnored\theaders\tðŸš«\tNot yet supported\tcontent\tâœ…/ðŸš§\tOnly media types of application/json work properly.\tlinks\tðŸš«\tNot yet supported","header-object#Header Object":"Attribute\tSupported\tNotes\tdescription\tN/A\tIgnored\tschema\tâœ…\tComplex schemas for headers may not work. Stick to string / number if possible.","tag-object#Tag Object":"Tags are only used for code organization purposes, when passing the --grouping-strategy first-tag\nCLI option.\nAttribute\tSupported\tNotes\tname\tâœ…\tOptionally used to split output into multiple files\tdescription\tN/A\tIgnored\texternalDocs\tN/A\tIgnored","schema-object#Schema Object":"The majority of attributes that can be specified by schema objects are supported, and accurately match the underlying\nopenapi specification / json schema validation specifications.Most notable exception is readOnly / writeOnly which are currently implemented incorrectly, planned to be addressed\nas a breaking change prior to v1.\nAttribute\tSupported\tNotes\ttitle\tN/A\t\tmultipleOf\tâœ…\tApplies to type: number\tmaximum\tâœ…\tApplies to type: number\texclusiveMaximum\tâœ…\tApplies to type: number\tminimum\tâœ…\tApplies to type: number\texclusiveMinimum\tâœ…\tApplies to type: number\tmaxLength\tâœ…\tApplies to type: string\tminLength\tâœ…\tApplies to type: string\tpattern\tâœ…\tSupport for type: string\tmaxItems\tâœ…\tApplies to type: array\tminItems\tâœ…\tApplies to type: array\tuniqueItems\tâœ…\tApplies to  type: array\tmaxProperties\tðŸš«\tNot yet supported\tminProperties\tðŸš«\tNot yet supported\trequired\tâœ…\tControls whether undefined is allowed for each value in properties\tenum\tâœ…\tApplies to type: number and type: string\ttype\tâœ…\t\tnot\tðŸš«\tNot yet supported\tallOf\tâœ…\tProduces a intersection type like A & B\toneOf\tâœ…\tProduces a union type like A | B\tanyOf\tâœ…\tProduces a union type like A | B\titems\tâœ…\tApplies to type: array\tproperties\tâœ…\tApplies to type: object\tadditionalProperties\tâœ…/ðŸš§\tFairly comprehensive support, produces Record<string, T> or unknown/any (dependent on --ts-allow-any)\tformat\tâœ…/ðŸš§\tLimited support for format email and date-time\tdefault\tâœ…\t\tnullable\tâœ…\tAlso supports type: null as an alternative\tdiscriminator\tðŸš«\tIgnored. Union / Intersection types are usd based on anyOf / allOf / oneOf.\treadOnly\tðŸš«\tProduces readonly modifiers, but this behavior is incorrect\twriteOnly\tðŸš«\tNot yet supported\texample\tN/A\tIgnored\texternalDocs\tN/A\tIgnored\tdeprecated\tðŸš«\tNot yet supported\txml\tðŸš«\tNot yet supported","completely-unsupported-things#Completely unsupported things":"The following objects are completely unsupported at this stage.","encoding-object#Encoding Object":"Attribute\tSupported\tNotes\tcontentType\tðŸš«\tNot yet supported\theaders\tðŸš«\tNot yet supported\tstyle\tðŸš«\tNot yet supported\texplode\tðŸš«\tNot yet supported\tallowReserved\tðŸš«\tNot yet supported","callback-object#Callback Object":"The callback object is completely unsupported.\nAttribute\tSupported\tNotes\t\\{expression\\}\tðŸš«","link-object#Link Object":"The link object is completely unsupported.\nAttribute\tSupported\tNotes\toperationRef\tðŸš«\t\toperationId\tðŸš«\t\tparameters\tðŸš«\t\trequestBody\tðŸš«\t\tdescription\tN/A\t\tserver\tðŸš«","discriminator-object#Discriminator Object":"The discriminator object is completely unsupported.\nAttribute\tSupported\tNotes\tpropertyName\tðŸš«\t\tmapping\tðŸš«","xml-object#XML Object":"The XML object is completely unsupported.\nAttribute\tSupported\tNotes\tname\tðŸš«\t\tnamespace\tðŸš«\t\tprefix\tðŸš«\t\tattribute\tðŸš«\t\twrapped\tðŸš«","security-scheme-object#Security Scheme Object":"The security scheme object is completely unsupported.\nAttribute\tSupported\tNotes\ttype\tðŸš«\t\tdescription\tðŸš«\t\tname\tðŸš«\t\tin\tðŸš«\t\tscheme\tðŸš«\t\tbearerFormat\tðŸš«\t\tflows\tðŸš«\t\topenIdConnectUrl\tðŸš«","oauth-flows-object#OAuth Flows Object":"The oauth flows object is completely unsupported.\nAttribute\tSupported\tNotes\timplicit\tðŸš«\t\tpassword\tðŸš«\t\tclientCredentials\tðŸš«\t\tauthorizationCode\tðŸš«","oauth-flow-object#OAuth Flow Object":"The oauth flow object is completely unsupported.\nAttribute\tSupported\tNotes\tauthorizationUrl\tðŸš«\t\ttokenUrl\tðŸš«\t\trefreshUrl\tðŸš«\t\tscopes\tðŸš«","security-requirement-object---patterned-fields#Security Requirement Object - Patterned Fields":"The security requirement object is completely unsupported.\nAttribute\tSupported\tNotes\t\\{name\\}\tðŸš«"}},"/guides/client-templates/typescript-angular":{"title":"Using the typescript-angular template","data":{"":"this is the least battle tested of the templates and most likely to have critical bugs\nThe typescript-angular template outputs a client SDK based on the Angular HttpClient that gives the following:\nTyped methods to call each endpoint returning an RxJS Observable\nIt does not yet support runtime validation/parsing - compile time type safety only at this stage.See integration-tests/typescript-angular for more samples.","install-dependencies#Install dependencies":"Prerequisite installed the cliThere are no additional dependencies required for this template.","run-generation#Run generation":"npm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod\nnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/app/clients/some-service \\\n  --template typescript-angular \\\n  --schema-builder zod","using-the-generated-code#Using the generated code":"Running the above will output these files into ./src/app/clients/some-service:\n./api.module.ts: exports a class ApiModule as an NgModule\n./client.service.ts: exports a class ApiClient as injectable Angular service\n./models.ts: exports typescript types\n./schemas.ts: exports runtime parsers using the chosen schema-builder (default zod)\nOnce generated usage should look something like this:\n// Root Angular module\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule, AppRoutingModule, ApiModule],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n@Component({\n  selector: \"app-root\",\n  templateUrl: \"./app.component.html\",\n  styleUrls: [\"./app.component.css\"],\n})\nexport class AppComponent {\n  // inject into your component\n  constructor(client: ApiClient) {\n    client.updateTodoListById({listId: \"1\", requestBody: {name: \"Foo\"}}).subscribe((next) => {\n      if (next.status === 200) {\n        // TODO: body is currently incorrectly `unknown` here\n        console.log(next.body.id)\n      }\n    })\n  }\n}"}},"/guides/client-templates/typescript-axios":{"title":"Using the typescript-axios template","data":{"":"The typescript-axios template outputs a client SDK based on the axios that gives the following:\nTyped methods to call each endpoint\nOptionally, runtime response validation\nIt follows the standard axios pattern of rejecting any response that isn't 2xx and thus can't provide typed\nerror responses. If you'd like to have strong typing over your error responses consider using the typescript-fetch template.Runtime request parameter validation is not currently supported.See integration-tests/typescript-axios for more samples.","install-dependencies#Install dependencies":"Prerequisite installed the cli\nnpm i axios @nahkies/typescript-axios-runtime\npnpm add axios @nahkies/typescript-axios-runtime\nyarn add axios @nahkies/typescript-axios-runtime\nbun add axios @nahkies/typescript-axios-runtime","run-generation#Run generation":"Experimental support for runtime response validation is available behind the --enable-runtime-response-validation\nflag.\nnpm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod\nnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-axios \\\n  --schema-builder zod","using-the-generated-code#Using the generated code":"Running the above will output these files into ./src/clients/some-service:\n./client.ts: exports a class ApiClient that implements methods for calling each endpoint\n./models.ts: exports typescript types\n./schemas.ts: exports runtime parsers using the chosen schema-builder (default zod)\nOnce generated usage should look something like this:\nconst client = new ApiClient({\n  // Pass a axios instance if you wish to use interceptors for auth, logging, etc\n  // axios: axios.create({...}),\n  basePath: `http://localhost:${address.port}`,\n  defaultHeaders: {\n    \"Content-Type\": \"application/json\",\n    Authorisation: \"Bearer: <TOKEN>\", // can pass auth headers here\n  },\n})\n// rejects if status code isn't 2xx, following typical axios behavior\nconst res = await client.createTodoListItem({\n  listId: list.id,\n  requestBody: {content: \"test item\"},\n  // optionally pass a timeout (ms), or any arbitrary axios options\n  // timeout?: number,\n  // opts?: AxiosRequestConfig\n})\n// data will be typed correctly\nconsole.log(`id is: ${res.data.id}`)"}},"/guides/client-templates/typescript-fetch":{"title":"Using the typescript-fetch template","data":{"":"The typescript-fetch template outputs a client SDK based on the fetch api that gives the following:\nTyped methods to call each endpoint\nSupport for passing a timeout, abort signals are still respected\nOptionally, runtime response validation\nRuntime request parameter validation is not currently supported.See integration-tests/typescript-fetch for more samples.Dependencies:","install-dependencies#Install dependencies":"Prerequisite installed the cli\nnpm i @nahkies/typescript-fetch-runtime\npnpm add @nahkies/typescript-fetch-runtime\nyarn add @nahkies/typescript-fetch-runtime\nbun add @nahkies/typescript-fetch-runtime\nIf you're using an older version of NodeJS, or targeting very old web browsers,\nyou may need a polyfill like node-fetch-native","run-generation#Run generation":"Experimental support for runtime response validation is available behind the --enable-runtime-response-validation\nflag.\nnpm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod\nnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src/clients/some-service \\\n  --template typescript-fetch \\\n  --schema-builder zod","using-the-generated-code#Using the generated code":"Running the above will output these files into ./src/clients/some-service:\n./client.ts: exports a class ApiClient that implements methods for calling each endpoint\n./models.ts: exports typescript types\n./schemas.ts: exports runtime parsers using the chosen schema-builder (default zod)\nOnce generated usage should look something like this:\nconst client = new ApiClient({\n  basePath: `http://localhost:${address.port}`,\n  defaultHeaders: {\n    \"Content-Type\": \"application/json\",\n    Authorisation: \"Bearer: <TOKEN>\", // can pass auth headers here\n  },\n})\nconst res = await client.createTodoListItem({\n  listId: list.id,\n  requestBody: {content: \"test item\"},\n  // optionally pass a timeout (ms), or any arbitrary fetch options (eg: an abort signal)\n  // timeout?: number,\n  // opts?: RequestInit\n})\n// checking the status code narrows the response body types (ie: remove error types from the type union)\nif (res.status !== 200) {\n  throw new Error(\"failed to create item\")\n}\n// body will be typed correctly\nconst body = await res.json()\nconsole.log(`id is: ${body.id}`)"}},"/guides/concepts/extract-inline-schemas":{"title":"Extract inline schemas","data":{"":"We have experimental support for \"extracting inline schemas\" behind the\n--extract-inline-schemas / OPENAPI_EXTRACT_INLINE_SCHEMAS=true configuration flag.","what-does-this-mean#What does this mean?":"There are basically two ways you can define schemas in your openapi specifications:\nNamed schemas\nInline schemas\nThese are handled differently by code generation. Enabling --extract-inline-schemas aims to\nmake inline schemas emit similar code to named schemas.","named-schema-example#Named schema example":"Normally when writing openapi specifications it is desirable to make use of $ref and define your schemas as named\ncomponents.\npaths:\n  /list/{listId}:\n    parameters:\n      - $ref: '#/components/parameters/listId'\n    get:\n      operationId: getTodoListById\n      responses:\n        200:\n          description: 'success'\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/TodoList'\ncomponents:\n  schemas:\n    TodoList:\n      type: object\n      required:\n        - id\n        - name\n        - totalItemCount\n        - incompleteItemCount\n        - created\n      properties:\n        id:\n          type: string\n          format: uuid\n        name:\n          type: string\n        totalItemCount:\n          type: number\n        incompleteItemCount:\n          type: number\n        created:\n          type: string\n          format: date-time\nWhen we run code generation for this, we expect a type and a schema for the TodoList to be generated, something like:\nimport {z} from 'zod'\nexport type t_TodoList = {\n  id: string\n  name: string\n  totalItemCount: number\n  incompleteItemCount: number\n  created: string\n}\nexport const s_TodoList = z.object({\n  id: z.string(),\n  name: z.string(),\n  totalItemCount: z.coerce.number(),\n  incompleteItemCount: z.coerce.number(),\n  created: z.string().datetime({ offset: true }),\n})\nThis is useful, as it means that we can easily reference the type, or use the schema as we require.","inline-schema-example#Inline Schema Example":"However, not everyone will write their specifications using named $refs, and instead inline schemas may be used.\nThis is especially prolific when generating the specification from implementation code in our experience.Consider the same example as above, but with the schema inlined:\npaths:\n  /list/{listId}:\n    parameters:\n      - $ref: '#/components/parameters/listId'\n    get:\n      operationId: getTodoListById\n      responses:\n        200:\n          description: 'success'\n          content:\n            application/json:\n              schema:\n                type: object\n                required:\n                  - id\n                  - name\n                  - totalItemCount\n                  - incompleteItemCount\n                  - created\n                properties:\n                  id:\n                    type: string\n                    format: uuid\n                  name:\n                    type: string\n                  totalItemCount:\n                    type: number\n                  incompleteItemCount:\n                    type: number\n                  created:\n                    type: string\n                    format: date-time\ncomponents:\n  schemas: {}\nBy default, this will be emitted as in-line types / schemas\nexport type GetTodoListById = (\n  params: Params<t_GetTodoListByIdParamSchema, void, void>,\n  respond: GetTodoListByIdResponder,\n  ctx: RouterContext,\n) => Promise<\n  | KoaRuntimeResponse<unknown>\n  | Response<\n      200,\n      {\n        id: string\n        name: string\n        totalItemCount: number\n        incompleteItemCount: number\n        created: string\n      }\n    >\n  | Response<StatusCode4xx, t_Error>\n  | Response<StatusCode, void>\n>\nconst getTodoListByIdResponseValidator = responseValidationFactory(\n  [\n    [\n      \"200\",\n      z.object({\n        id: z.string(),\n        name: z.string(),\n        totalItemCount: z.coerce.number(),\n        incompleteItemCount: z.coerce.number(),\n        created: z.string().datetime({ offset: true }),\n      }),\n    ],\n    [\"4XX\", s_Error],\n  ],\n  z.undefined(),\n)\nrouter.get(\"getTodoListById\", \"/list/:listId\", async (ctx, next) => {\n  // ...\n  const responder = {\n    with200() {\n      return new KoaRuntimeResponse<{\n        id: string\n        name: string\n        totalItemCount: number\n        incompleteItemCount: number\n        created: string\n      }>(200)\n    }\n  }\n  // ...\n})","with---extract-inline-schemas-enabled#With --extract-inline-schemas enabled":"Notice how this:\nCreates a lot of duplication, we have to repeat the definition anytime it is used\nMakes it inconvenient, or impossible to reference the type/schema in our implementation code\nWith --extract-inline-schemas enabled, the code generator will synthesis a name for each inline schema based on\nits usage, and emit exported types/schemas, eg:\nexport type t_getTodoListByIdJson200Response = {\n  id: string\n  name: string\n  totalItemCount: number\n  incompleteItemCount: number\n  created: string\n}\nexport const s_getTodoListByIdJson200Response = z.object({\n  id: z.string(),\n  name: z.string(),\n  totalItemCount: z.coerce.number(),\n  incompleteItemCount: z.coerce.number(),\n  created: z.string().datetime({ offset: true }),\n})\nThis can be a handy trick to make the code generated from schemas you don't own/control easier to work with. In general\nyou should prefer to improve the specifications to be more suitable for code generation, which generally also improves\nthe result of documentation tools like Redoc"}},"/guides/server-templates/typescript-koa":{"title":"Using the typescript-koa template","data":{"":"The typescript-koa template outputs scaffolding code that handles the following:\nBuilding a @koa/router instance with all routes in the openapi specification\nGenerating types and runtime schema parsers for all request parameters/bodies and response bodies\nGenerating types for route implementations that receive validated inputs, and have return types that are additionally\nvalidated at runtime prior to sending the response\n(Optionally) Actually starting the server and binding to a port\nSee integration-tests/typescript-koa for more samples.","install-dependencies#Install dependencies":"Prerequisite installed the cli\nnpm i @nahkies/typescript-koa-runtime @koa/cors @koa/router koa koa-body zod\nnpm i --dev @types/koa @types/koa__router\npnpm add @nahkies/typescript-koa-runtime @koa/cors @koa/router koa koa-body zod\npnpm add --dev @types/koa @types/koa__router\nyarn add @nahkies/typescript-koa-runtime @koa/cors @koa/router koa koa-body zod\nyarn add --dev @types/koa @types/koa__router\nbun add @nahkies/typescript-koa-runtime @koa/cors @koa/router koa koa-body zod\nbun add --dev @types/koa @types/koa__router","run-generation#Run generation":"npm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./openapi.yaml \\\n  --input-type openapi3 \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod\nnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod\npnpm run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod\nyarn openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod\nbun run openapi-code-generator \\\n  --input ./typespec.tsp \\\n  --input-type typespec \\\n  --output ./src \\\n  --template typescript-koa \\\n  --schema-builder zod","using-the-generated-code#Using the generated code":"Running the above will output three files into ./src:\ngenerated.ts - exports a createRouter and bootstrap function, along with associated types used to create your server\nmodels.ts - exports typescript types for schemas\nschemas.ts - exports runtime schema validators\nOnce generated usage should look something like this:\nimport {bootstrap, createRouter, CreateTodoList, GetTodoLists} from \"../generated\"\n// Define your route implementations as async functions implementing the types\n// exported from generated.ts\nconst createTodoList: CreateTodoList = async ({body}, respond) => {\n  const list = await prisma.todoList.create({\n    data: {\n      // body is strongly typed and parsed at runtime\n      name: body.name,\n    },\n  })\n  // (recommended) the respond parameter is a strongly typed helper that\n  // provides a better editor experience.\n  // the response body is additionally validated against the response schema/status code at runtime\n  return respond.with200().body(dbListToApiList(list))\n  // (deprecated) alternatively, you can return a {status, body} object which is also strongly typed\n  // pattern matching the status code against the response schema:\n  // return {\n  //   status: 200 as const,\n  //   body: dbListToApiList(list)\n  // }\n}\nconst getTodoLists: GetTodoLists = async ({query}) => {\n  // omitted for brevity\n}\n// Starts a server listening on `port`\nbootstrap({\n  router: createRouter({getTodoLists, createTodoList}),\n  port: 8080,\n})","custom-koa-appconfig#Custom Koa app/config":"The provided bootstrap function has a limited range of options. For more advanced use-cases,\nsuch as https you will need to construct your own Koa app, and mount the router returned by createRouter.The only real requirement is that you provide a body parsing middleware before the router that places\na parsed request body on the ctx.body property.Eg:\nimport {createRouter} from \"../generated\"\nimport KoaBody from \"koa-body\"\nimport https from \"https\"\n// ...implement routes here\nconst app = new Koa()\n// it doesn't have to be koa-body, but it does need to put the parsed body on `ctx.body`\napp.use(KoaBody())\n// mount the generated router\nconst router = createRouter({getTodoLists, createTodoList})\napp.use(router.allowedMethods())\napp.use(router.routes())\nhttps\n  .createServer(\n    {\n      key: \"...\",\n      cert: \"...\",\n    },\n    app.callback(),\n  )\n  .listen(433)","error-handling#Error Handling":"Any errors thrown during the request processing will be wrapped in KoaRuntimeError objects,\nand tagged with the phase the error was thrown.\ninterface KoaRuntimeError extends Error {\n  cause: unknown // the originally thrown exception\n  phase: \"request_validation\" | \"request_handler\" | \"response_validation\"\n}\nThis allows for implementing catch-all error middleware for common concerns like failed request validation,\nor internal server errors.Eg:\nexport async function genericErrorMiddleware(ctx: Context, next: Next) {\n  try {\n    await next()\n  } catch (err) {\n    // if the request validation failed, return a 400 and include helpful\n    // information about the problem\n    if (KoaRuntimeError.isKoaError(err) && err.phase === \"request_validation\") {\n      ctx.status = 400\n      ctx.body = {\n        message: \"request validation failed\",\n        meta: err.cause instanceof ZodError ? {issues: err.cause.issues} : {},\n      } satisfies t_Error\n      return\n    }\n    // return a 500 and omit information from the response otherwise\n    logger.error(\"internal server error\", err)\n    ctx.status = 500\n    ctx.body = {\n      message: \"internal server error\",\n    } satisfies t_Error\n  }\n}"}},"/overview/about":{"title":"About","data":{"":"@nahkies/openapi-code-generator is a CLI tool that aims to generate high quality typescript client SDK's,\nand API server scaffolding (routing, validation, serialization) from OpenAPI 3 specifications.Currently, OpenAPI 3.0, OpenAPI 3.1,\nand TypeSpec are supported an input specifications.The following templates are supported.","server-scaffolding-templates#Server Scaffolding Templates":"typescript-koa","client-sdk-templates#Client SDK Templates":"typescript-fetch\ntypescript-axios\ntypescript-angular","project-goal--principals#Project Goal / Principals":"To make it fun, easy and productive to generate both client and server \"glue\"\ncode from openapi 3 definitions. This is code that is tedious and error-prone to maintain by hand,\nby automating it we can reduce toil and frustration.The generated code output should be \"stable\" in the sense that it will not\narbitrarily change between generation without need (for a given version). For\nexample outputting entities in alphabetic order where possible.It should also be generated in a way that human would reasonably write it,\nthe intent is that the generated code can and should be committed to the consuming project\nrepositories, allowing it to be reviewed, and audited overtime.This is particularly useful in the case of mistakes in the generation or schemas, and also\nserves to reduce risk of adoption. There should be no lock-in - if you wish to stop using the\ncode generation, you can simply start maintaining the previously generated code by hand.The initial focus on typescript, with an intention to later support other languages. kotlin\nis the most likely candidate for a second language.","why-schema-first#Why schema first":"Broadly speaking there are two approaches people take to maintaining API specifications:\nSchema first, where you write the schema by hand\nCode first, where you generate the schema from your code\nThis project being a code generator from API specification files is on the schema first side of the debate, but why?Ultimately this is fairly subjective, but there are four primary motivators that lead us to believe schema first\nis the better approach.","longevity#Longevity":"APIs are forever,\nchanging them in backwards incompatible ways is hard/expensive, or sometimes not possible.With that in mind, we believe it's important to be thoughtful about your API design, and\nthat writing an explicit specification/contract is a great forcing function to accomplish this.Additionally, programming languages / frameworks come and go - they are an implementation detail,\nand subject to change as business requirements evolve.\nOpenAPI (originally Swagger) has been around for over a decade now, and we're confident it'll be around for a long time.","common-language#Common Language":"Many large projects / systems will involve multiple programming languages. For example, you might have a Java backend,\nKotlin Android app, Swift iOS app, and Typescript web frontend.For writing your API contracts using OpenAPI up front, you create a common ground for developers of all languages to discuss\nand hash out the details.","constraints#Constraints":"Turing complete programming languages are very flexible. If you try hard enough, you can probably implement it.\nSpecifications like OpenAPI on the other hand are more rigid and constraining.We believe it's better to lean into this and design your systems in ways that can be represented fully by a\nspecification, rather than attempt to generate a specification from the implementation and potentially lose\ninformation/nuance in the process.","separation#Separation":"A good specification not only defines the API contract, but also includes a lot of supplementary information such as examples,\nand documentation.Generating a good specification from your code, therefore requires including all this extra metadata in the code, which\ncan make the code more difficult to work with.We prefer to separate these concerns out into the specification, and keep the implementation code leaner and simpler.","compatibility--completeness#Compatibility / Completeness":"This project should be considered beta quality, and is still pre-v1.It does not yet handle all aspects of the OpenAPI / JSON schema specification, but most common\nfeatures are implemented.In particular at the moment only JSON content types are supported properly.You can get a sense of what works by looking at the compatibility tables, or the Github issues (non-exhaustive).\nHowever often the best way is to just try it out with your API specification and see what happens!The integration tests also act as a good showcase of the sort of output you can expect.","compared-to-other-projects#Compared to other projects":"There are many similar projects out there, so why should you use this one?\nStrong emphasis on \"human like\" code output\nTackles the program space from both ends - client and server, for a single source of truth\nComprehensive runtime parsing/validation in addition to static compile time safety\nSo if you want a low risk, write-once, get strong build & runtime guarantees experience then we're worth giving a try.If you're looking to achieve the minimal runtime bundle size in your web frontends, then this project probably isn't for you (try OpenAPI TypeScript instead)."}},"/reference/architecture":{"title":"Architecture","data":{"":"The project is still evolving, but this should give a good overview\nof the current codebase structure.Broadly speaking we have the \"core\" part of the library that should be re-usable\nacross all templates / target languages, and then the template functions.Some templates also make use of a runtime library.","core#Core":"This directory ./src/core contains the generator/target language agnostic parts of the project.The process of generation resembles a pipeline.","loaders#./loaders":"Loaders are responsible for fetching a supported input format, and converting\nit to openapi3 if required, to be handed off to the openapi-validator / openapi-loader.Two loaders are supported:\ngeneric which loads openapi3 specs in JSON/YAML formats\ntypespec which loads typespec specs and converts them in-memory to openapi3","openapi-validator#openapi-validator":"Nothing particularly interesting here, just takes a loaded document and validates\nit against the OpenAPI 3 specification in JSON schema format.Useful for detecting errors due to bad input rather than bugs in the\ncode generation.Due to a bug in ajv\nvalidation is currently skipped for OpenAPI 3.1 documents.","openapi-loader#openapi-loader":"openapi-loader takes an entry point path, and loads + validates a collection\nof files ($ref to other files supported).It then provides typed access to the raw OpenAPI structures, with methods able\nto convert \"maybe refs\" into the referenced objects.This is important because one of the more painful (and bug prone) parts of\nparsing OpenAPI documents is correctly following $ref's, as you need to carry\naround the context of which document you came from.The openapi-loader makes this much less complicated by loading all files up front, and normalizing\nthe contained $refs to absolute paths.","input#input":"Ultimately an instance of the input class is passed to a generator.The goal of the input class is to provide ergonomic, target language agnostic access to\nthe OpenAPI documents given as input to the generator.It primarily surfaces API operations, with optional grouping strategies, as a normalized type\nthat has already de-referenced parameters / responses, and set default values on various properties.","templates#Templates":"Currently only typescript templates are implemented, living in ./src/typescript.Each template currently has a simple signature:\n(from ./src/templates.types.ts)\nexport interface OpenapiGeneratorConfig {\n  dest: string\n  input: Input\n  schemaBuilder: SchemaBuilderType\n  enableRuntimeResponseValidation: boolean\n  compilerOptions: CompilerOptions\n  allowUnusedImports: boolean\n  groupingStrategy: OperationGroupStrategy\n}\nexport interface OpenapiGenerator {\n  (args: OpenapiGeneratorConfig): Promise<void>\n}\nWhere dest is a path to a directory to emit code into, and input is an initialized instance\nof the Input class described above. schemaBuilder refers to zod | joiYou can find all registered generators in ./src/templates.ts - eventually this likely be split into\npackages that consume the core modules, or some other more pluggable system."}},"/reference/cli-options":{"title":"CLI Options","data":{"cli-configuration-reference#CLI Configuration Reference":"All CLI options can be provided as command-line parameters, or environment variables as you prefer.","generate#Generate":"The default action is to run code generation.","required-parameters#Required Parameters":"","-i---input-value#-i --input <value>":"As environment variable OPENAPI_INPUTPath to the input specification to generate from. Either a local path, or a url may be provided, though not all\nspecifications will build correctly from a url.By default, this must be a OpenAPI 3.0 or OpenAPI 3.1\nspecification, in either YAML or JSON format.When used in conjunction with --input-type typespec then a TypeSpec specification can be\nsupplied instead.","-o---output-value#-o --output <value>":"As environment variable OPENAPI_OUTPUTdirectory to output generated code (env: )","-t---template-value#-t --template <value>":"As environment variable OPENAPI_TEMPLATEWhich template you wish to generate, one of:\ntypescript-koa\ntypescript-fetch\ntypescript-axios\ntypescript-angular","optional-parameters#Optional Parameters":"","--input-type-value#--input-type <value>":"As environment variable OPENAPI_INPUT_TYPEWhat type of input file is being provided, one of:\nopenapi3 (default)\ntypespec","-s---schema-builder-value#-s --schema-builder <value>":"As environment variable OPENAPI_SCHEMA_BUILDERWhich runtime schema parsing library to use, one of:\nzod (default)\njoi","--grouping-strategy-value-experimental#--grouping-strategy <value> (experimental)":"As environment variable OPENAPI_GROUPING_STRATEGYStrategy to use for splitting output into separate files. Set to none for a single generated.ts file, one of:\nnone don't split output, yield single generated.ts (default)\nfirst-tag group operations based on their first tag\nfirst-slug group operations based on their first route slug/segment","--enable-runtime-response-validation-experimental#--enable-runtime-response-validation (experimental)":"As environment variable  whether to validate response bodies using the chosen runtime schema library.Default false\nNote: this is currently always true for server templates, and only applies to the client library templates.","--enable-typed-base-paths-client-sdks-only#--enable-typed-base-paths (client sdks only)":"As environment variable OPENAPI_ENABLE_TYPED_BASE_PATHSControls whether to generate a union-type of string literals + string from the openapi specifications\narray of server urls. Handy for intellisense.Default: true","--extract-inline-schemas-experimental#--extract-inline-schemas (experimental)":"As environment variable OPENAPI_EXTRACT_INLINE_SCHEMASGenerate names based on usage, and extract in-line schemas to be standalone types / schemas in the\ngenerated code. This is especially useful when dealing with input schemas that don't make good use\nof named $ref's.Default false","--allow-unused-imports#--allow-unused-imports":"As environment variable OPENAPI_ALLOW_UNUSED_IMPORTSAllow unused imports to be emitted in generated code. Offered as an escape hatch if any bugs\nin the unused-import elimination occur.Default false","--ts-allow-any#--ts-allow-any":"As environment variable OPENAPI_TS_ALLOW_ANYDetermines whether to use any or unknown when generating types for schemas that don't have\nconcrete definitions. Eg: additionalProperties: true or {} schemas.Using unknown will push you towards using type guards / making runtime checks before interacting\nwith the model and should generally result in more robust code, whilst any may be more convenient\nduring rapid prototyping.Default: false (use unknown rather than any)\nInput schema\t--ts-allow-any\t(default)\t{}\tany\tunknown\t{additionalProperties: true}\tany\tunknown\t{additionalProperties: false}\t{ [key: string]: never }\t{ [key: string]: never }\t{type: \"object\",  additionalProperties: true}\t{[key: string]: any}\t{[key: string]: unknown}\t{type: \"array\", items: {}}\tany[]\tunknown[]","misc#Misc":"","--remote-spec-request-headers-authenticated-remote-specifications#--remote-spec-request-headers (authenticated remote specifications)":"As environment variable OPENAPI_REMOTE_SPEC_REQUEST_HEADERSAllows providing request headers to use when fetching remote specifications. This allows for running\ngeneration against remote sources that require authentication.Common examples include private github repositories,\nurls secured by an authenticating proxy like GCP IAP Proxy,\nor just generally authenticated servers\nWe strongly recommend using the environment variable variant of this option\n(OPENAPI_REMOTE_SPEC_REQUEST_HEADERS), as values for this option will likely include secrets, and it\nis best to keep these out of your shell history.\nThe format of the value is a JSON object keyed by URI, with values being either an object,\nor array of {name, value} pairs. As a typescript type:\ntype value = {\n  [uri: string]: { name: string, value: string }[] | { name: string, value: string }\n}\nFor example:\n{\n  \"https://example.com\": [\n    {\"name\": \"X-Client-Id\", \"value\": \"my-client-id\"},\n    {\"name\": \"X-Client-Secret\", \"value\": \"some-secret-value\"}\n  ],\n  \"https://example.org/some/path\": {\"name\": \"Proxy-Authorization\", \"value\": \"some token\"}\n}\nA full match on the provided uri is required for the headers to be sent.\nEg: given a uri of \"https://exmaple.com:8080/openapi.yaml\" the headers would not\nbe sent for requests to other ports, resource paths, or protocols, but a less specific\nuri like \"https://example.com\" will send headers on any (https) request to that domain.\nWhy JSON you ask? Simply put it has well defined semantics, and is easy to parse without fear of jumbling the pieces together.Unfortunately it is a little annoying to formulate in shell scripts, so here's some examples to get you startedUsing jq:\njq --null-input --compact-output \\\n  --arg domain \"https://example.com\" \\\n  --arg name \"authorization\" \\\n  --arg value \"secret value\" '{$domain: {$name, $value}}'\nUsing nodejs:\nnode -p 'JSON.stringify({[process.argv[1]]: {name: process.argv[2], value: process.argv[3]}})' \\\n  https://example.com \\\n  authorization \\\n  'some secret value'\nWhere typically in either example the values would be coming from shell variables, eg: storing a short-lived\naccess token, etc.","-h---help#-h, --help":"Displays help text for command"}},"/":{"title":"Index","data":{}}}