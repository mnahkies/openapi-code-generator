"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6172],{13012:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{C:()=>s});var o=n(39807),i=n(83856),a=e([o,i]);[o,i]=a.then?(await a)():a;class s{#e;#t;#n;#r;constructor(e,t){let n=new Set,r=new Set,o=this.#t=t.map(e=>new d(e));for(let e of t)for(let[t,o]of e.entries())n.add(o),r.add(t);for(let t of(this.#e=[...r],r)){let[,r]=(0,i.cS)(e,t);if(void 0!==r){for(let e of r.getVersions())if(!n.has(e)){n.add(e);let t=function(e){for(let[t,n]of o.entries()){let r=n.getVersion(e.namespace);if(r&&e.index<r.index)return t}return -1}(e),r=new d(new Map([[e.namespace,e]]));-1===t?o.push(r):o.splice(t,0,r)}}}for(let[e,t]of(this.#r=new Map,this.#n=new Map,o.entries()))for(let n of(this.#n.set(t,e),t.versions()))this.#r.has(n)||this.#r.set(n,e)}prettySerialize(){let e="-".repeat(13*this.#e.length+1),t=this.#t.map(e=>"| "+this.#e.map(t=>(e.getVersion(t)?.name??"").padEnd(10," ")).join(" | ")+" |").join(`
${e}
`);return["",e,t,e].join("\n")}get(e){let t=this.getIndex(e);return -1===t&&(e instanceof d?(0,o.a70)(!1,`Timeline moment "${e?.name}" should have been resolved`):(0,o.a70)(!1,`Version "${e?.name}" from ${(0,o.Uzb)(e.namespace)} should have been resolved. ${this.prettySerialize()}`)),this.#t[t]}getIndex(e){let t=e instanceof d?this.#n.get(e):this.#r.get(e);return void 0===t?-1:t}isBefore(e,t){let n=this.getIndex(e),r=this.getIndex(t);return n<r}first(){return this.#t[0]}[Symbol.iterator](){return this.#t[Symbol.iterator]()}entries(){return this.#t.entries()}}class d{name;#o;constructor(e){this.#o=e,this.name=e.values().next().value?.name??""}getVersion(e){return this.#o.get(e)}versions(){return this.#o.values()}}r()}catch(e){r(e)}})},26172:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.r(t),n.d(t,{$added:()=>o.T0,$decorators:()=>s.d,$madeOptional:()=>o.Sv,$madeRequired:()=>o.x9,$onValidate:()=>i.m,$removed:()=>o.zp,$renamedFrom:()=>o.BP,$returnTypeChangedFrom:()=>o.df,$typeChangedFrom:()=>o.zZ,$useDependency:()=>o.v4,$versioned:()=>o.i2,Availability:()=>a.ev,VersionMap:()=>o.xv,createVersionMutator:()=>d.X,findVersionedNamespace:()=>o.S7,getAddedOnVersions:()=>o.ZP,getAllVersions:()=>a.JJ,getAvailabilityMap:()=>a.eH,getAvailabilityMapInTimeline:()=>a.IM,getCachedNamespaceDependencies:()=>i.l,getMadeOptionalOn:()=>o.xF,getRemovedOnVersions:()=>o.vF,getRenamedFrom:()=>o.jI,getRenamedFromVersions:()=>o.q$,getReturnTypeChangedFrom:()=>o.Zx,getTypeChangedFrom:()=>o.$7,getUseDependencies:()=>o.dL,getVersion:()=>o.HF,getVersionDependencies:()=>a.O_,getVersionForEnumMember:()=>a.zs,getVersioningMutators:()=>d.S,getVersions:()=>a.cS,getVersionsForEnum:()=>a.q4,resolveVersions:()=>a.St});var o=n(82902),i=n(30774),a=n(83856),s=n(79954),d=n(48546),m=e([o,i,a,s,d]);[o,i,a,s,d]=m.then?(await m)():m,r()}catch(e){r(e)}})},30774:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{l:()=>l,m:()=>u});var o=n(39807),i=n(82902),a=n(43655),s=n(47596),d=n(83856),m=e([o,i,a,s,d]);[o,i,a,s,d]=m.then?(await m)():m;let A=Symbol.for("TypeSpec.Versioning.NamespaceRelationCache");function l(e){return e[A]}function u(e){let t=new Map;function n(e,n){if(!n||!("namespace"in n)||!n.namespace)return;let r=t.get(e)??new Set;n.namespace!==e&&r.add(n.namespace),t.set(e,r)}e[A]=t,(0,o.mz)(e,{model:t=>{if(!(0,o.w7J)(t)&&!(0,o.rz6)(t)){for(let o of(n(t.namespace,t.sourceModel),n(t.namespace,t.baseModel),t.properties.values())){var r,s,d,m;n(t.namespace,o.type),g(e,t,o,{isTargetADependent:!0});let l=(0,i.$7)(e,o);void 0!==l?f(e,o):c(e,o,o.type),r=e,s=o,"ModelProperty"===s.kind&&(0,i.xF)(r,s)&&!s.optional&&(0,a.wl)(r,{code:"made-optional-not-optional",format:{name:s.name},target:s}),d=e,m=o,"ModelProperty"===m.kind&&(0,i.sK)(d,m)&&m.optional&&(0,a.wl)(d,{code:"made-required-optional",format:{name:m.name},target:m})}p(e,t)}},union:t=>{if(!((0,o.w7J)(t)||(0,o.rz6)(t))&&void 0!==t.namespace){for(let e of t.variants.values())n(t.namespace,e.type);p(e,t)}},operation:t=>{if((0,o.w7J)(t)||(0,o.rz6)(t))return;let r=t.namespace??t.interface?.namespace;for(let o of(n(r,t.sourceOperation),n(r,t.returnType),t.interface&&g(e,t.interface,t,{isTargetADependent:!0}),c(e,t,t.returnType),t.parameters.sourceModels))c(e,t,o.model);for(let n of t.parameters.properties.values()){g(e,t,n,{isTargetADependent:!0});let r=(0,i.$7)(e,n);void 0!==r?f(e,n):c(e,[n,t],n.type)}},interface:t=>{if(!(0,o.rz6)(t))for(let n of t.sourceInterfaces)c(e,t,n)},namespace:t=>{!function(e,t){let[n,r]=(0,d.cS)(e,t);if(void 0===r)return;let o=new Set(r.getVersions().map(e=>e.value));if(r.size!==o.size){let n=r.getVersions()[0].enumMember.enum.name;(0,a.wl)(e,{code:"version-duplicate",format:{name:n},target:t})}}(e,t);let n=(0,i.S7)(e,t),r=(0,d.O_)(e,t);if(void 0!==r)for(let[s,d]of r.entries())n?void 0!==(0,i.dL)(e,t,!1)&&(0,a.wl)(e,{code:"incompatible-versioned-namespace-use-dependency",target:t}):d instanceof Map&&(0,a.wl)(e,{code:"versioned-dependency-not-picked",format:{dependency:(0,o.QnV)(s)},target:t})},enum:n=>{p(e,n);let r=(0,i.dL)(e,n);if(r)for(let[e,n]of r){let r=new Set;if(n instanceof Map)for(let e of n.values())r.add(e.namespace);else r.add(n.namespace);t.set(e,r)}}},{includeTemplateDeclaration:!0})}function f(e,t,n){let r=function(e,t){let n,r=(0,d.JJ)(e,t);if(void 0===r)return;let o=new Map(r.map(e=>[e,void 0])),a=(0,d.eH)(e,t),s=void 0===a,m=(0,i.$7)(e,t);if(void 0!==m)for(let[e,t]of m){let n=r.indexOf(e);-1!==n&&o.set(r[n-1],t)}if("ModelProperty"===t.kind)n=t.type;else throw Error(`Not implemented '${t.kind}'.`);for(let e of r.reverse()){if(!(s||[d.ev.Added,d.ev.Available].includes(a.get(e.name)))){o.set(e,void 0);continue}let t=o.get(e);void 0!==t?n=t:o.set(e,n)}return o}(e,t);if(void 0!==r)for(let[i,m]of r)void 0!==m&&function(e,t,n,r,i){let m=[n];for(;m.length;){let n=m.pop(),l=(0,d.eH)(e,n),u=l?.get(t?.name)??d.ev.Available;if([d.ev.Added,d.ev.Available].includes(u)||(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"doesNotExist",format:{sourceName:(0,o.Uzb)(r,i),targetName:(0,o.Uzb)(n,i),version:b(t)},target:r,codefixes:(0,s.Z)(t,n,e,i)}),(0,o.w7J)(n))for(let e of n.templateMapper.args)(0,o.Xjv)(e)&&m.push(e);else if("Union"===n.kind)for(let t of n.variants.values())n.expression?m.push(t.type):g(e,t,t.type);else if("Tuple"===n.kind)for(let e of n.values)m.push(e)}}(e,i,m,t,n)}function p(e,t){let n=(0,d.JJ)(e,t);if(void 0===n)return;let r=new Map(n.map(e=>[e,[]])),o=[];for(let n of("Model"===t.kind?o=t.properties.values():"Enum"===t.kind?o=t.members.values():"Union"===t.kind&&(o=t.variants.values()),o)){let t=function(e,t){let n,r=(0,d.JJ)(e,t);if(void 0===r)return;let o=new Map(r.map(e=>[e,void 0])),a=(0,d.eH)(e,t),s=void 0===a,m=(0,i.jI)(e,t);if(void 0!==m)for(let e of m){let t=e.version,n=e.oldName,i=r.indexOf(t);-1!==i&&o.set(r[i-1],n)}switch(t.kind){case"ModelProperty":case"EnumMember":n=t.name;break;case"UnionVariant":"string"==typeof t.name&&(n=t.name);break;default:throw Error(`Not implemented '${t.kind}'.`)}for(let e of r.reverse()){if(!(s||[d.ev.Added,d.ev.Available].includes(a.get(e.name)))){o.set(e,void 0);continue}let t=o.get(e);void 0!==t?n=t:o.set(e,n)}return o}(e,n);if(void 0!==t)for(let[e,n]of t)void 0!==n&&r.get(e)?.push(n)}for(let[n,o]of r.entries()){let r=new Map;for(let e of o){let t=r.get(e)??0;r.set(e,t+1)}for(let[o,i]of r.entries())void 0!==o&&i>1&&(0,a.wl)(e,{code:"renamed-duplicate-property",format:{name:o,version:b(n)},target:t})}}function c(e,t,n){if(g(e,t,n),"templateMapper"in n)for(let r of n.templateMapper?.args??[])(0,o.Xjv)(r)&&c(e,t,r);switch(n.kind){case"Union":if("string"!=typeof n.name)for(let r of n.variants.values())c(e,t,r.type);break;case"Tuple":for(let r of n.values)c(e,t,r)}}function v(e,t){let n=Array.isArray(t)?t:[t],r=n[0],o=function(e,t){for(let n of t){let t=(0,d.eH)(e,n);if(t)return t;switch(n.kind){case"Operation":{let t=n.interface&&(0,d.eH)(e,n.interface);if(t)return t;break}case"ModelProperty":{let t=n.model&&(0,d.eH)(e,n.model);if(t)return t}}}}(e,n);return{type:r,map:o}}function g(e,t,n,r={}){let m,l=v(e,t),[u]=(0,d.cS)(e,l.type);if(void 0===l.map){let n=Array.isArray(t)?t:[t],r=(0,d.cS)(e,n[0]);for(let t of n)if((0,d.cS)(e,t)!==r)return}let f=v(e,n),[p]=(0,d.cS)(e,f.type);if(f.map&&p){if(u!==p){let t=u&&(0,d.O_)(e,u);if(m=t?.get(p),void 0===m||(f.map=function(e,t,n,r,i){if(n instanceof Map){let e=new Map;for(let[r,o]of n){let n=t.get(o.name);e.set(r.name,n)}return e}if([d.ev.Removed,d.ev.Unavailable].includes(t.get(n.name))){let m=y(n.name,d.ev.Added,t),l=h(n.name,d.ev.Removed,t);m&&(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"versionedDependencyAddedAfter",format:{sourceName:(0,o.Uzb)(r),targetName:(0,o.Uzb)(i),dependencyVersion:b(n),targetAddedOn:m},target:r,codefixes:(0,s.Z)(n,i,e)}),l&&(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"versionedDependencyRemovedBefore",format:{sourceName:(0,o.Uzb)(r),targetName:(0,o.Uzb)(i),dependencyVersion:b(n),targetAddedOn:l},target:r,codefixes:(0,s.Z)(n,i,e)})}}(e,f.map,m,l.type,f.type),!f.map))return}r.isTargetADependent?function(e,t,n,r,i,m,l){if(t)for(let m of new Set([...t.keys(),...n.keys()])){let u=t.get(m),f=n.get(m);if(u!==f){if([d.ev.Added].includes(f)&&[d.ev.Removed,d.ev.Unavailable].includes(u)&&!M(i,"added")){let n=h(m,d.ev.Added,t);(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"dependentAddedAfter",format:{sourceName:(0,o.Uzb)(r,void 0),targetName:(0,o.Uzb)(i,void 0),sourceAddedOn:n,targetAddedOn:m},target:i,codefixes:(0,s.Z)(m,r,e,l)})}if([d.ev.Removed].includes(u)&&[d.ev.Added,d.ev.Available].includes(f)&&!M(i,"removed")){let t=y(m,d.ev.Removed,n);(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"dependentRemovedBefore",format:{sourceName:(0,o.Uzb)(r),targetName:(0,o.Uzb)(i),sourceRemovedOn:m,targetRemovedOn:t},target:i,codefixes:(0,s.B)(m,i,e,l)})}}}}(e,l.map,f.map,l.type,f.type):function(e,t,n,r,m,l){if(void 0===t){if(!function(e){for(let t of e.values())if([d.ev.Removed,d.ev.Unavailable].includes(t))return!1;return!0}(n)){let t=Array.from(n.entries()).filter(([e,t])=>t===d.ev.Available||t===d.ev.Added).map(([e,t])=>e).sort().shift();(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"default",format:{sourceName:(0,o.Uzb)(r),targetName:(0,o.Uzb)(m)},target:r,codefixes:t?(0,s.Z)(t,r,e):void 0})}return}let u=[...t.keys(),...n.keys()],f=(0,i.$7)(e,r);if(void 0!==f){let e=[...f.keys()].map(e=>e.name);u=[...u,...e]}let p=(0,i.Zx)(e,r);if(void 0!==p){let e=[...p.keys()].map(e=>e.name);u=[...u,...e]}for(let i of new Set(u)){let u=t.get(i),f=n.get(i);if([d.ev.Added].includes(u)&&[d.ev.Removed,d.ev.Unavailable].includes(f)){let t=y(i,d.ev.Added,n),u=i;l&&(u=w(i,l)??i),(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"addedAfter",format:{sourceName:(0,o.Uzb)(r),targetName:(0,o.Uzb)(m),sourceAddedOn:i,targetAddedOn:t},target:r,codefixes:(0,s.Z)(u,m,e)})}if([d.ev.Removed].includes(u)&&[d.ev.Unavailable].includes(f)){let t=h(i,d.ev.Removed,n),u=i;l&&(u=w(i,l)??i),(0,a.wl)(e,{code:"incompatible-versioned-reference",messageId:"removedBefore",format:{sourceName:(0,o.Uzb)(r),targetName:(0,o.Uzb)(m),sourceRemovedOn:i,targetRemovedOn:t},target:r,codefixes:(0,s.Z)(u,m,e)})}}}(e,l.map,f.map,l.type,f.type,m instanceof Map?m:void 0)}}function y(e,t,n){let r=!1;for(let[o,i]of n){if(e===o){r=!0;continue}if(r&&i===t)return o}}function h(e,t,n){let r=!1;for(let[o,i]of n)if([d.ev.Added,d.ev.Added].includes(i)&&(r=!0),r){if(i===t)return o;if(o===e)break}}function M(e,t){return"ModelProperty"===e.kind&&function(e,t){if(void 0===e.sourceProperty)return!1;let n="added"===t?i.T0:i.zp,r=e.decorators.filter(e=>e.decorator===n),o=e.sourceProperty.decorators.filter(e=>e.decorator===n);return!r.some(e=>!o.some(t=>e.node===t.node))}(e,t)}function b(e){return e?.value??"<n/a>"}function w(e,t){for(let[n,r]of t.entries())if(n.value===e)return r}r()}catch(e){r(e)}})},43655:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{ej:()=>d,wl:()=>a});var o=n(39807),i=e([o]);o=(i.then?(await i)():i)[0];let{reportDiagnostic:a,createStateSymbol:s,stateKeys:d}=(0,o.vLS)({name:"@typespec/versioning",diagnostics:{"versioned-dependency-tuple":{severity:"error",messages:{default:"Versioned dependency mapping must be a tuple [SourceVersion, TargetVersion]."}},"versioned-dependency-tuple-enum-member":{severity:"error",messages:{default:"Versioned dependency mapping must be between enum members."}},"versioned-dependency-same-namespace":{severity:"error",messages:{default:"Versioned dependency mapping must all point to the same namespace but 2 versions have different namespaces 'namespace1' and 'namespace2'."}},"versioned-dependency-not-picked":{severity:"error",messages:{default:(0,o.J8Y)`The versionedDependency decorator must provide a version of the dependency '${"dependency"}'.`}},"version-not-found":{severity:"error",messages:{default:(0,o.J8Y)`The provided version '${"version"}' from '${"enumName"}' is not declared as a version enum. Use '@versioned(${"enumName"})' on the containing namespace.`}},"version-duplicate":{severity:"error",messages:{default:(0,o.J8Y)`Multiple versions from '${"name"}' resolve to the same value. Version enums must resolve to unique values.`}},"invalid-renamed-from-value":{severity:"error",messages:{default:"@renamedFrom.oldName cannot be empty string."}},"incompatible-versioned-reference":{severity:"error",messages:{default:(0,o.J8Y)`'${"sourceName"}' is referencing versioned type '${"targetName"}' but is not versioned itself.`,addedAfter:(0,o.J8Y)`'${"sourceName"}' was added in version '${"sourceAddedOn"}' but referencing type '${"targetName"}' added in version '${"targetAddedOn"}'.`,dependentAddedAfter:(0,o.J8Y)`'${"sourceName"}' was added in version '${"sourceAddedOn"}' but contains type '${"targetName"}' added in version '${"targetAddedOn"}'.`,removedBefore:(0,o.J8Y)`'${"sourceName"}' was removed in version '${"sourceRemovedOn"}' but referencing type '${"targetName"}' removed in version '${"targetRemovedOn"}'.`,dependentRemovedBefore:(0,o.J8Y)`'${"sourceName"}' was removed in version '${"sourceRemovedOn"}' but contains type '${"targetName"}' removed in version '${"targetRemovedOn"}'.`,versionedDependencyAddedAfter:(0,o.J8Y)`'${"sourceName"}' is referencing type '${"targetName"}' added in version '${"targetAddedOn"}' but version used is '${"dependencyVersion"}'.`,versionedDependencyRemovedBefore:(0,o.J8Y)`'${"sourceName"}' is referencing type '${"targetName"}' removed in version '${"targetAddedOn"}' but version used is '${"dependencyVersion"}'.`,doesNotExist:(0,o.J8Y)`'${"sourceName"}' is referencing type '${"targetName"}' which does not exist in version '${"version"}'.`}},"incompatible-versioned-namespace-use-dependency":{severity:"error",messages:{default:"The useDependency decorator can only be used on a Namespace if the namespace is unversioned. For versioned namespaces, put the useDependency decorator on the version enum members."}},"made-optional-not-optional":{severity:"error",messages:{default:(0,o.J8Y)`Property '${"name"}' marked with @madeOptional but is required. Should be '${"name"}?'`}},"made-required-optional":{severity:"error",messages:{default:(0,o.J8Y)`Property '${"name"}?' marked with @madeRequired but is optional. Should be '${"name"}'`}},"renamed-duplicate-property":{severity:"error",messages:{default:(0,o.J8Y)`Property '${"name"}' marked with '@renamedFrom' conflicts with existing property in version ${"version"}.`}}},state:{versionIndex:{description:"Version index"},addedOn:{description:"State for @addedOn decorator"},removedOn:{description:"State for @removedOn decorator"},versions:{description:"State for @versioned decorator"},useDependencyNamespace:{description:"State for @useDependency decorator on Namespaces"},useDependencyEnum:{description:"State for @useDependency decorator on Enums"},renamedFrom:{description:"State for @renamedFrom decorator"},madeOptional:{description:"State for @madeOptional decorator"},madeRequired:{description:"State for @madeRequired decorator"},typeChangedFrom:{description:"State for @typeChangedFrom decorator"},returnTypeChangedFrom:{description:"State for @returnTypeChangedFrom decorator"}}});r()}catch(e){r(e)}})},47596:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{B:()=>m,Z:()=>s});var o=n(39807),i=n(83856),a=e([o,i]);function s(e,t,n,r){return"string"==typeof e?function(e,t,n,r){let o=(0,i.JJ)(n,t)?.find(t=>t.value===e);if(void 0!==o)return d(o,t,r)}(e,t,n,r):d(e,t,r)}function d(e,t,n){if(void 0===t.node)return;let r=e.enumMember,i=`@added(${r.enum.name}.${r.name})`;return[l("add-version-to-type",i,(0,o.Uzb)(t,n),(0,o.F2e)(t.node))]}function m(e,t,n,r){if(void 0===t.node)return;let a=(0,i.JJ)(n,t)?.find(t=>t.value===e);if(void 0===a)return;let s=a.enumMember,d=`@removed(${s.enum.name}.${s.name})`;return[l("remove-version-from-type",d,(0,o.Uzb)(t,r),(0,o.F2e)(t.node))]}function l(e,t,n,r){return{id:e,label:`Add '${t}' to '${n}'`,fix:e=>e.prependText(r,`${t}
`)}}[o,i]=a.then?(await a)():a,r()}catch(e){r(e)}})},48546:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{S:()=>d,X:()=>m}),n(17040);var o=n(82902),i=n(13012),a=n(83856),s=e([o,i,a]);function d(e,t){let n=(0,a.St)(e,t),r=new i.C(e,n.map(e=>e.versions)),o=new l(e,r);if(1===n.length&&void 0===n[0].rootVersion&&n[0].versions.size>0)return{kind:"transient",mutator:m(o,r.get(n[0].versions.values().next().value))};let s=n.map(e=>{if(0!==e.versions.size)return{version:e.rootVersion,mutator:m(o,r.get(e.versions.values().next().value))}}).filter(e=>void 0!==e);if(0!==s.length)return{kind:"versioned",snapshots:s}}function m(e,t){function n(n){for(let[r,o]of n)e.existsAtVersion(o,t)||n.delete(r)}function r(n){for(let r=n.length-1;r>=0;r--)e.existsAtVersion(n[r],t)||n.splice(r,1)}function o(n,r){if(void 0!==r.name){let o=e.getNameAtVersion(n,t);void 0!==o&&o!==r.name&&(r.name=o)}}return{name:`VersionSnapshot ${t.name}`,Namespace:{mutate:(e,t,r,o)=>{n(t.models),n(t.operations),n(t.interfaces),n(t.enums),n(t.unions),n(t.namespaces),n(t.scalars)}},Interface:(e,t,r,i)=>{o(e,t),n(t.operations)},Model:(e,t,i,a)=>{o(e,t),n(t.properties),r(t.derivedModels)},Union:(e,t,r,i)=>{o(e,t),n(t.variants)},UnionVariant:(e,t,n,r)=>{o(e,t)},Enum:(e,t,r,i)=>{o(e,t),n(t.members)},Scalar:(e,t,n,i)=>{o(e,t),r(t.derivedScalars)},EnumMember:(e,t,n,r)=>{o(e,t)},Operation:(n,r,i,a)=>{o(n,r);let s=e.getReturnTypeAtVersion(n,t);s!==r.returnType&&(r.returnType=s)},Tuple:(e,t,n,r)=>{},ModelProperty:(n,r,i,a)=>{o(n,r),r.optional=e.getOptionalAtVersion(n,t);let s=e.getTypeAtVersion(n,t);s!==r.type&&(r.type=s)}}}[o,i,a]=s.then?(await s)():s;class l{#i;#t;constructor(e,t){this.#i=e,this.#t=t}existsAtVersion(e,t){let n=(0,a.IM)(this.#i,e,this.#t);if(!n)return!0;let r=n.get(t);return r===a.ev.Added||r===a.ev.Available}getNameAtVersion(e,t){let n=(0,o.jI)(this.#i,e);if(!n)return e.name;for(let e of n)if(this.#t.isBefore(t,e.version))return e.oldName;return e.name}getTypeAtVersion(e,t){let n=(0,o.$7)(this.#i,e);if(!n)return e.type;for(let[e,r]of n)if(this.#t.isBefore(t,e))return r;return e.type}getReturnTypeAtVersion(e,t){let n=(0,o.Zx)(this.#i,e);if(!n)return e.returnType;for(let[e,r]of n)if(this.#t.isBefore(t,e))return r;return e.returnType}getOptionalAtVersion(e,t){let n=(0,o.xF)(this.#i,e),r=(0,o.sK)(this.#i,e);if(!n&&!r)return e.optional;if(n)if(this.#t.isBefore(t,n))return!1;else return!0;if(r)if(this.#t.isBefore(t,r))return!0;else return!1;return e.optional}}r()}catch(e){r(e)}})},79954:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{d:()=>s});var o=n(82902),i=n(43655),a=e([o,i]);[o,i]=a.then?(await a)():a;let s={"TypeSpec.Versioning":{versioned:o.i2,useDependency:o.v4,added:o.T0,removed:o.zp,renamedFrom:o.BP,madeOptional:o.Sv,madeRequired:o.x9,typeChangedFrom:o.zZ,returnTypeChangedFrom:o.df}};r()}catch(e){r(e)}})},82902:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{$7:()=>m,BP:()=>$,HF:()=>y,S7:()=>h,Sv:()=>V,T0:()=>w,ZP:()=>c,Zx:()=>l,dL:()=>function e(t,n,r=!0){let a=new Map;if("Namespace"===n.kind){let o=n;for(;o;){let n=b(t,o);if(n){for(let e of n)a.set(e.namespace,e);return a}if(r){let n=y(t,o)?.getVersions();if(n?.length){let r=e(t,n[0].enumMember.enum);if(r)return r}}o=o.namespace}return}if("Enum"===n.kind){let e=t.stateMap(o.ej.useDependencyEnum).get(n);if(!e)return;let r=function(e,t){if(!(t instanceof Map))return t;let n=new Map;for(let[r,o]of t){let t=(0,i.zs)(e,r);void 0!==t&&n.set(t,o)}return n}(t,e);if(r instanceof Map)for(let[e,n]of r)for(let r of n){let n=r.enumMember.enum.namespace;if(!n)return void(0,o.wl)(t,{code:"version-not-found",target:r.enumMember.enum,format:{version:r.enumMember.name,enumName:r.enumMember.enum.name}});let i=a.get(n);i?i.set(e,r):i=new Map([[e,r]]),a.set(n,i)}}return a},df:()=>x,i2:()=>S,jI:()=>f,q$:()=>p,sK:()=>u,v4:()=>M,vF:()=>v,x9:()=>N,xF:()=>g,xv:()=>O,zZ:()=>A,zp:()=>d});var o=n(43655),i=n(83856),a=e([o,i]);function s(e,t,n){let r=(0,i.zs)(e,t);return r||(0,o.wl)(e,{code:"version-not-found",target:n,format:{version:t.name,enumName:t.enum.name}}),r}[o,i]=a.then?(await a)():a;let w=(e,t,n)=>{let{program:r}=e,i=s(e.program,n,e.getArgumentTarget(0));if(!i)return;let a=r.stateMap(o.ej.addedOn).get(t)??[];a.push(i),a.sort((e,t)=>e.index-t.index),r.stateMap(o.ej.addedOn).set(t,a)};function d(e,t,n){let{program:r}=e,i=s(e.program,n,e.getArgumentTarget(0));if(!i)return;let a=r.stateMap(o.ej.removedOn).get(t)??[];a.push(i),a.sort((e,t)=>e.index-t.index),r.stateMap(o.ej.removedOn).set(t,a)}function m(e,t){return e.stateMap(o.ej.typeChangedFrom).get(t)}let A=(e,t,n,r)=>{let{program:i}=e,a=s(e.program,n,e.getArgumentTarget(0));if(!a)return;let d=m(i,t)??new Map;d.set(a,r),d=new Map([...d.entries()].sort((e,t)=>e[0].index-t[0].index)),i.stateMap(o.ej.typeChangedFrom).set(t,d)};function l(e,t){return e.stateMap(o.ej.returnTypeChangedFrom).get(t)}let x=(e,t,n,r)=>{let{program:i}=e,a=s(e.program,n,e.getArgumentTarget(0));if(!a)return;let d=l(i,t)??new Map;d.set(a,r),d=new Map([...d.entries()].sort((e,t)=>e[0].index-t[0].index)),i.stateMap(o.ej.returnTypeChangedFrom).set(t,d)},$=(e,t,n,r)=>{let{program:i}=e,a=s(e.program,n,e.getArgumentTarget(0));if(!a)return;""===r&&(0,o.wl)(i,{code:"invalid-renamed-from-value",target:t});let d=f(i,t)??[];d.push({version:a,oldName:r}),d.sort((e,t)=>e.version.index-t.version.index),i.stateMap(o.ej.renamedFrom).set(t,d)},V=(e,t,n)=>{let{program:r}=e,i=s(e.program,n,e.getArgumentTarget(0));i&&r.stateMap(o.ej.madeOptional).set(t,i)},N=(e,t,n)=>{let{program:r}=e,i=s(e.program,n,e.getArgumentTarget(0));i&&r.stateMap(o.ej.madeRequired).set(t,i)};function u(e,t){return e.stateMap(o.ej.madeRequired).get(t)}function f(e,t){return e.stateMap(o.ej.renamedFrom).get(t)}function p(e,t){return f(e,t)?.map(e=>e.version)}function c(e,t){return e.stateMap(o.ej.addedOn).get(t)}function v(e,t){return e.stateMap(o.ej.removedOn).get(t)}function g(e,t){return e.stateMap(o.ej.madeOptional).get(t)}class O{map=new Map;constructor(e,t){let n=0;for(let r of t.members.values())this.map.set(r,{name:r.name,value:r.value?.toString()??r.name,enumMember:r,index:n,namespace:e}),n++}getVersionForEnumMember(e){return this.map.get(e)}getVersions(){return[...this.map.values()]}get size(){return this.map.size}}let S=(e,t,n)=>{e.program.stateMap(o.ej.versions).set(t,new O(t,n))};function y(e,t){return e.stateMap(o.ej.versions).get(t)}function h(e,t){let n=t;for(;n;){if(e.stateMap(o.ej.versions).has(n))return n;n=n.namespace}}function M(e,t,...n){let r=[];for(let t of n){let n=s(e.program,t,e.getArgumentTarget(0));n&&r.push(n)}if("Namespace"===t.kind){let n=b(e.program,t);n?n.push(...r):n=r,e.program.stateMap(o.ej.useDependencyNamespace).set(t,n)}else if("EnumMember"===t.kind){let n=t.enum,i=e.program.stateMap(o.ej.useDependencyEnum).get(n);i||(i=new Map);let a=i.get(t)??[];a.push(...r),i.set(t,a),e.program.stateMap(o.ej.useDependencyEnum).set(n,i)}}function b(e,t){return e.stateMap(o.ej.useDependencyNamespace).get(t)}r()}catch(e){r(e)}})},83856:(e,t,n)=>{n.a(e,async(e,r)=>{try{n.d(t,{IM:()=>function e(t,n,r){let i=new Map,s=r.first().versions().next().value,d=function(t,n,r){let i;if("ModelProperty"===n.kind&&void 0!==n.model?i=e(t,n.model,r):"Operation"===n.kind&&void 0!==n.interface&&(i=e(t,n.interface,r)),void 0!==i){for(let[e,t]of i.entries())if(t===o.Added)return e.versions().next().value}}(t,n,r)??s,m=(0,a.ZP)(t,n)??[],l=(0,a.vF)(t,n)??[],u=(0,a.$7)(t,n),f=(0,a.Zx)(t,n);if(!m.length&&!l.length&&void 0===u&&void 0===f)return;m=y(m,l,d);let p=!1;for(let[e,t]of r.entries()){let n=m.find(t=>r.getIndex(t)===e);l.find(t=>r.getIndex(t)===e)?(p=!1,i.set(t,o.Removed)):n?(p=!0,i.set(t,o.Added)):p?i.set(t,o.Available):i.set(t,o.Unavailable)}return i},JJ:()=>g,O_:()=>l,St:()=>f,cS:()=>v,eH:()=>function e(t,n){let r=new Map,i=g(t,n);if(void 0===i)return;let s=i[0],d=function(t,n,r){let i;if("ModelProperty"===n.kind&&void 0!==n.model?i=e(t,n.model):"Operation"===n.kind&&void 0!==n.interface&&(i=e(t,n.interface)),void 0!==i){for(let[e,t]of i.entries())if(t===o.Added)return r.find(t=>t.name===e)}}(t,n,i)??s,m=function(t,n,r){let i;if("ModelProperty"===n.kind&&void 0!==n.model?i=e(t,n.model):"Operation"===n.kind&&void 0!==n.interface&&(i=e(t,n.interface)),void 0!==i){for(let[e,t]of i.entries())if(t===o.Removed)return r.find(t=>t.name===e)}}(t,n,i),l=(0,a.ZP)(t,n)??[],u=(0,a.vF)(t,n)??[],f=(0,a.$7)(t,n),p=(0,a.Zx)(t,n);if(!l.length&&!u.length&&void 0===f&&void 0===p)return;l=y(l,u,d),u=function(e,t,n){if(t.length)return t;let r=!e.length||n&&e[0].index<n.index;return n&&r?[n]:[]}(l,u,m);let c=!1;for(let e of i){let t=l.find(t=>t.index===e.index);u.find(t=>t.index===e.index)?(c=!1,r.set(e.name,o.Removed)):t?(c=!0,r.set(e.name,o.Added)):c?r.set(e.name,o.Available):r.set(e.name,o.Unavailable)}return r},ev:()=>o,q4:()=>c,zs:()=>h});var o,i=n(39807),a=n(82902),s=n(30774),d=n(13012),m=e([i,a,s,d]);function l(e,t){let n=(0,a.dL)(e,t),r=(0,s.l)(e),o=r?.get(t);if(void 0===o)return n;let i=new Map(n);for(let t of o)if(!n?.has(t)){let n=(0,a.HF)(e,t);if(n){let e=n.getVersions();i.set(t,e[e.length-1])}}return i}function u(e,t){let n=new Map(t),r=[...t.entries()];for(;r.length>0;){let[t,o]=r.pop();for(let[i,a]of l(e,t)??new Map){if(n.has(i))continue;let e=a instanceof Map?a.get(o):a;r.push([i,e]),n.set(i,e)}}return n}function f(e,t){let[n,r]=v(e,t),o=(n&&l(e,n))??new Map;if(r)return r.getVersions().map(t=>{let r=u(e,new Map([[n,t]]));return{rootVersion:t,versions:r}});if(0===o.size)return[{rootVersion:void 0,versions:new Map}];{let n=new Map;for(let[e,r]of o){if(r instanceof Map){let n=(0,i.QnV)(t),r=(0,i.QnV)(e);throw Error(`Unexpected error: Namespace ${n} version dependency to ${r} should be a picked version.`)}n.set(e,r)}return[{rootVersion:void 0,versions:u(e,n)}]}}[i,a,s,d]=m.then?(await m)():m;let M=new WeakMap;function p(e,t){return M.set(e,t),t}function c(e,t){let n=t.namespace;if(void 0===n)return[];let r=(0,a.HF)(e,n);return void 0===r?[]:[n,r]}function v(e,t){let n=M.get(t);if(n)return n;switch(t.kind){case"Namespace":var r=e,o=t;let i=(0,a.HF)(r,o);if(void 0!==i)return p(o,[o,i]);let s=o.namespace&&v(r,o.namespace)[1],d=(0,a.dL)(r,o);return s||d?p(o,[o,s]):p(o,[o,void 0]);case"Operation":case"Interface":case"Model":case"Union":case"Scalar":case"Enum":if(t.namespace)return p(t,v(e,t.namespace)||[]);if("Operation"===t.kind&&t.interface)return p(t,v(e,t.interface)||[]);return p(t,[]);case"ModelProperty":if(t.sourceProperty)return v(e,t.sourceProperty);if(t.model)return v(e,t.model);return p(t,[]);case"EnumMember":return p(t,v(e,t.enum)||[]);case"UnionVariant":return p(t,v(e,t.union)||[]);default:return p(t,[])}}function g(e,t){let[n,r]=v(e,t);if(void 0!==n)return(0,a.HF)(e,n)?.getVersions()}function y(e,t,n){return e.length||t.length?e.length&&(!t.length||e[0].index<t[0].index)?e:t.length&&(!e.length||t[0].index<e[0].index)?[n,...e]:e:[n]}!function(e){e.Unavailable="Unavailable",e.Added="Added",e.Available="Available",e.Removed="Removed"}(o||(o={}));function h(e,t){let n=t.enum,[,r]=c(e,n);return r?.getVersionForEnumMember(t)}r()}catch(e){r(e)}})}}]);