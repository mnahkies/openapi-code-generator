/** AUTOGENERATED - DO NOT EDIT **/
// @ts-nocheck
/* istanbul ignore file */
/* c8 ignore start */
"use strict";
module.exports = validate20;
module.exports.default = validate20;
const schema31 = {
	$id: "https://spec.openapis.org/oas/3.1/schema/2025-02-13",
	$schema: "https://json-schema.org/draft/2020-12/schema",
	description:
		"The description of OpenAPI v3.1.x Documents without Schema Object validation",
	type: "object",
	properties: {
		openapi: { type: "string", pattern: "^3\\.1\\.\\d+(-.+)?$" },
		info: { $ref: "#/$defs/info" },
		jsonSchemaDialect: {
			type: "string",
			format: "uri-reference",
			default: "https://spec.openapis.org/oas/3.1/dialect/2024-11-10",
		},
		servers: {
			type: "array",
			items: { $ref: "#/$defs/server" },
			default: [{ url: "/" }],
		},
		paths: { $ref: "#/$defs/paths" },
		webhooks: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/path-item" },
		},
		components: { $ref: "#/$defs/components" },
		security: {
			type: "array",
			items: { $ref: "#/$defs/security-requirement" },
		},
		tags: { type: "array", items: { $ref: "#/$defs/tag" } },
		externalDocs: { $ref: "#/$defs/external-documentation" },
	},
	required: ["openapi", "info"],
	anyOf: [
		{ required: ["paths"] },
		{ required: ["components"] },
		{ required: ["webhooks"] },
	],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
	$defs: {
		info: {
			$comment: "https://spec.openapis.org/oas/v3.1#info-object",
			type: "object",
			properties: {
				title: { type: "string" },
				summary: { type: "string" },
				description: { type: "string" },
				termsOfService: { type: "string", format: "uri-reference" },
				contact: { $ref: "#/$defs/contact" },
				license: { $ref: "#/$defs/license" },
				version: { type: "string" },
			},
			required: ["title", "version"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		contact: {
			$comment: "https://spec.openapis.org/oas/v3.1#contact-object",
			type: "object",
			properties: {
				name: { type: "string" },
				url: { type: "string", format: "uri-reference" },
				email: { type: "string", format: "email" },
			},
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		license: {
			$comment: "https://spec.openapis.org/oas/v3.1#license-object",
			type: "object",
			properties: {
				name: { type: "string" },
				identifier: { type: "string" },
				url: { type: "string", format: "uri-reference" },
			},
			required: ["name"],
			dependentSchemas: { identifier: { not: { required: ["url"] } } },
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		server: {
			$comment: "https://spec.openapis.org/oas/v3.1#server-object",
			type: "object",
			properties: {
				url: { type: "string" },
				description: { type: "string" },
				variables: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/server-variable" },
				},
			},
			required: ["url"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"server-variable": {
			$comment: "https://spec.openapis.org/oas/v3.1#server-variable-object",
			type: "object",
			properties: {
				enum: { type: "array", items: { type: "string" }, minItems: 1 },
				default: { type: "string" },
				description: { type: "string" },
			},
			required: ["default"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		components: {
			$comment: "https://spec.openapis.org/oas/v3.1#components-object",
			type: "object",
			properties: {
				schemas: {
					type: "object",
					additionalProperties: { $dynamicRef: "#meta" },
				},
				responses: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/response-or-reference" },
				},
				parameters: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/parameter-or-reference" },
				},
				examples: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/example-or-reference" },
				},
				requestBodies: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/request-body-or-reference" },
				},
				headers: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/header-or-reference" },
				},
				securitySchemes: {
					type: "object",
					additionalProperties: {
						$ref: "#/$defs/security-scheme-or-reference",
					},
				},
				links: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/link-or-reference" },
				},
				callbacks: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/callbacks-or-reference" },
				},
				pathItems: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/path-item" },
				},
			},
			patternProperties: {
				"^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$":
					{
						$comment:
							"Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
						propertyNames: { pattern: "^[a-zA-Z0-9._-]+$" },
					},
			},
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		paths: {
			$comment: "https://spec.openapis.org/oas/v3.1#paths-object",
			type: "object",
			patternProperties: { "^/": { $ref: "#/$defs/path-item" } },
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"path-item": {
			$comment: "https://spec.openapis.org/oas/v3.1#path-item-object",
			type: "object",
			properties: {
				$ref: { type: "string", format: "uri-reference" },
				summary: { type: "string" },
				description: { type: "string" },
				servers: { type: "array", items: { $ref: "#/$defs/server" } },
				parameters: {
					type: "array",
					items: { $ref: "#/$defs/parameter-or-reference" },
				},
				get: { $ref: "#/$defs/operation" },
				put: { $ref: "#/$defs/operation" },
				post: { $ref: "#/$defs/operation" },
				delete: { $ref: "#/$defs/operation" },
				options: { $ref: "#/$defs/operation" },
				head: { $ref: "#/$defs/operation" },
				patch: { $ref: "#/$defs/operation" },
				trace: { $ref: "#/$defs/operation" },
			},
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		operation: {
			$comment: "https://spec.openapis.org/oas/v3.1#operation-object",
			type: "object",
			properties: {
				tags: { type: "array", items: { type: "string" } },
				summary: { type: "string" },
				description: { type: "string" },
				externalDocs: { $ref: "#/$defs/external-documentation" },
				operationId: { type: "string" },
				parameters: {
					type: "array",
					items: { $ref: "#/$defs/parameter-or-reference" },
				},
				requestBody: { $ref: "#/$defs/request-body-or-reference" },
				responses: { $ref: "#/$defs/responses" },
				callbacks: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/callbacks-or-reference" },
				},
				deprecated: { default: false, type: "boolean" },
				security: {
					type: "array",
					items: { $ref: "#/$defs/security-requirement" },
				},
				servers: { type: "array", items: { $ref: "#/$defs/server" } },
			},
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"external-documentation": {
			$comment:
				"https://spec.openapis.org/oas/v3.1#external-documentation-object",
			type: "object",
			properties: {
				description: { type: "string" },
				url: { type: "string", format: "uri-reference" },
			},
			required: ["url"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		parameter: {
			$comment: "https://spec.openapis.org/oas/v3.1#parameter-object",
			type: "object",
			properties: {
				name: { type: "string" },
				in: { enum: ["query", "header", "path", "cookie"] },
				description: { type: "string" },
				required: { default: false, type: "boolean" },
				deprecated: { default: false, type: "boolean" },
				schema: { $dynamicRef: "#meta" },
				content: {
					$ref: "#/$defs/content",
					minProperties: 1,
					maxProperties: 1,
				},
			},
			required: ["name", "in"],
			oneOf: [{ required: ["schema"] }, { required: ["content"] }],
			if: { properties: { in: { const: "query" } }, required: ["in"] },
			then: {
				properties: { allowEmptyValue: { default: false, type: "boolean" } },
			},
			dependentSchemas: {
				schema: {
					properties: {
						style: { type: "string" },
						explode: { type: "boolean" },
					},
					allOf: [
						{ $ref: "#/$defs/examples" },
						{
							$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path",
						},
						{
							$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header",
						},
						{
							$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query",
						},
						{
							$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie",
						},
						{ $ref: "#/$defs/styles-for-form" },
					],
					$defs: {
						"styles-for-path": {
							if: { properties: { in: { const: "path" } }, required: ["in"] },
							then: {
								properties: {
									style: {
										default: "simple",
										enum: ["matrix", "label", "simple"],
									},
									required: { const: true },
								},
								required: ["required"],
							},
						},
						"styles-for-header": {
							if: { properties: { in: { const: "header" } }, required: ["in"] },
							then: {
								properties: { style: { default: "simple", const: "simple" } },
							},
						},
						"styles-for-query": {
							if: { properties: { in: { const: "query" } }, required: ["in"] },
							then: {
								properties: {
									style: {
										default: "form",
										enum: [
											"form",
											"spaceDelimited",
											"pipeDelimited",
											"deepObject",
										],
									},
									allowReserved: { default: false, type: "boolean" },
								},
							},
						},
						"styles-for-cookie": {
							if: { properties: { in: { const: "cookie" } }, required: ["in"] },
							then: {
								properties: { style: { default: "form", const: "form" } },
							},
						},
					},
				},
			},
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"parameter-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/parameter" },
		},
		"request-body": {
			$comment: "https://spec.openapis.org/oas/v3.1#request-body-object",
			type: "object",
			properties: {
				description: { type: "string" },
				content: { $ref: "#/$defs/content" },
				required: { default: false, type: "boolean" },
			},
			required: ["content"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"request-body-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/request-body" },
		},
		content: {
			$comment: "https://spec.openapis.org/oas/v3.1#fixed-fields-10",
			type: "object",
			additionalProperties: { $ref: "#/$defs/media-type" },
			propertyNames: { format: "media-range" },
		},
		"media-type": {
			$comment: "https://spec.openapis.org/oas/v3.1#media-type-object",
			type: "object",
			properties: {
				schema: { $dynamicRef: "#meta" },
				encoding: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/encoding" },
				},
			},
			allOf: [
				{ $ref: "#/$defs/specification-extensions" },
				{ $ref: "#/$defs/examples" },
			],
			unevaluatedProperties: false,
		},
		encoding: {
			$comment: "https://spec.openapis.org/oas/v3.1#encoding-object",
			type: "object",
			properties: {
				contentType: { type: "string", format: "media-range" },
				headers: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/header-or-reference" },
				},
				style: {
					default: "form",
					enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
				},
				explode: { type: "boolean" },
				allowReserved: { default: false, type: "boolean" },
			},
			allOf: [
				{ $ref: "#/$defs/specification-extensions" },
				{ $ref: "#/$defs/styles-for-form" },
			],
			unevaluatedProperties: false,
		},
		responses: {
			$comment: "https://spec.openapis.org/oas/v3.1#responses-object",
			type: "object",
			properties: { default: { $ref: "#/$defs/response-or-reference" } },
			patternProperties: {
				"^[1-5](?:[0-9]{2}|XX)$": { $ref: "#/$defs/response-or-reference" },
			},
			minProperties: 1,
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
			if: {
				$comment:
					"either default, or at least one response code property must exist",
				patternProperties: { "^[1-5](?:[0-9]{2}|XX)$": false },
			},
			then: { required: ["default"] },
		},
		response: {
			$comment: "https://spec.openapis.org/oas/v3.1#response-object",
			type: "object",
			properties: {
				description: { type: "string" },
				headers: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/header-or-reference" },
				},
				content: { $ref: "#/$defs/content" },
				links: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/link-or-reference" },
				},
			},
			required: ["description"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"response-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/response" },
		},
		callbacks: {
			$comment: "https://spec.openapis.org/oas/v3.1#callback-object",
			type: "object",
			$ref: "#/$defs/specification-extensions",
			additionalProperties: { $ref: "#/$defs/path-item" },
		},
		"callbacks-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/callbacks" },
		},
		example: {
			$comment: "https://spec.openapis.org/oas/v3.1#example-object",
			type: "object",
			properties: {
				summary: { type: "string" },
				description: { type: "string" },
				value: true,
				externalValue: { type: "string", format: "uri-reference" },
			},
			not: { required: ["value", "externalValue"] },
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"example-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/example" },
		},
		link: {
			$comment: "https://spec.openapis.org/oas/v3.1#link-object",
			type: "object",
			properties: {
				operationRef: { type: "string", format: "uri-reference" },
				operationId: { type: "string" },
				parameters: { $ref: "#/$defs/map-of-strings" },
				requestBody: true,
				description: { type: "string" },
				body: { $ref: "#/$defs/server" },
			},
			oneOf: [{ required: ["operationRef"] }, { required: ["operationId"] }],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"link-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/link" },
		},
		header: {
			$comment: "https://spec.openapis.org/oas/v3.1#header-object",
			type: "object",
			properties: {
				description: { type: "string" },
				required: { default: false, type: "boolean" },
				deprecated: { default: false, type: "boolean" },
				schema: { $dynamicRef: "#meta" },
				content: {
					$ref: "#/$defs/content",
					minProperties: 1,
					maxProperties: 1,
				},
			},
			oneOf: [{ required: ["schema"] }, { required: ["content"] }],
			dependentSchemas: {
				schema: {
					properties: {
						style: { default: "simple", const: "simple" },
						explode: { default: false, type: "boolean" },
					},
					$ref: "#/$defs/examples",
				},
			},
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"header-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/header" },
		},
		tag: {
			$comment: "https://spec.openapis.org/oas/v3.1#tag-object",
			type: "object",
			properties: {
				name: { type: "string" },
				description: { type: "string" },
				externalDocs: { $ref: "#/$defs/external-documentation" },
			},
			required: ["name"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		reference: {
			$comment: "https://spec.openapis.org/oas/v3.1#reference-object",
			type: "object",
			properties: {
				$ref: { type: "string", format: "uri-reference" },
				summary: { type: "string" },
				description: { type: "string" },
			},
		},
		schema: {
			$comment: "https://spec.openapis.org/oas/v3.1#schema-object",
			$dynamicAnchor: "meta",
			type: ["object", "boolean"],
		},
		"security-scheme": {
			$comment: "https://spec.openapis.org/oas/v3.1#security-scheme-object",
			type: "object",
			properties: {
				type: {
					enum: ["apiKey", "http", "mutualTLS", "oauth2", "openIdConnect"],
				},
				description: { type: "string" },
			},
			required: ["type"],
			allOf: [
				{ $ref: "#/$defs/specification-extensions" },
				{ $ref: "#/$defs/security-scheme/$defs/type-apikey" },
				{ $ref: "#/$defs/security-scheme/$defs/type-http" },
				{ $ref: "#/$defs/security-scheme/$defs/type-http-bearer" },
				{ $ref: "#/$defs/security-scheme/$defs/type-oauth2" },
				{ $ref: "#/$defs/security-scheme/$defs/type-oidc" },
			],
			unevaluatedProperties: false,
			$defs: {
				"type-apikey": {
					if: { properties: { type: { const: "apiKey" } }, required: ["type"] },
					then: {
						properties: {
							name: { type: "string" },
							in: { enum: ["query", "header", "cookie"] },
						},
						required: ["name", "in"],
					},
				},
				"type-http": {
					if: { properties: { type: { const: "http" } }, required: ["type"] },
					then: {
						properties: { scheme: { type: "string" } },
						required: ["scheme"],
					},
				},
				"type-http-bearer": {
					if: {
						properties: {
							type: { const: "http" },
							scheme: { type: "string", pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$" },
						},
						required: ["type", "scheme"],
					},
					then: { properties: { bearerFormat: { type: "string" } } },
				},
				"type-oauth2": {
					if: { properties: { type: { const: "oauth2" } }, required: ["type"] },
					then: {
						properties: { flows: { $ref: "#/$defs/oauth-flows" } },
						required: ["flows"],
					},
				},
				"type-oidc": {
					if: {
						properties: { type: { const: "openIdConnect" } },
						required: ["type"],
					},
					then: {
						properties: {
							openIdConnectUrl: { type: "string", format: "uri-reference" },
						},
						required: ["openIdConnectUrl"],
					},
				},
			},
		},
		"security-scheme-or-reference": {
			if: { type: "object", required: ["$ref"] },
			then: { $ref: "#/$defs/reference" },
			else: { $ref: "#/$defs/security-scheme" },
		},
		"oauth-flows": {
			type: "object",
			properties: {
				implicit: { $ref: "#/$defs/oauth-flows/$defs/implicit" },
				password: { $ref: "#/$defs/oauth-flows/$defs/password" },
				clientCredentials: {
					$ref: "#/$defs/oauth-flows/$defs/client-credentials",
				},
				authorizationCode: {
					$ref: "#/$defs/oauth-flows/$defs/authorization-code",
				},
			},
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
			$defs: {
				implicit: {
					type: "object",
					properties: {
						authorizationUrl: { type: "string", format: "uri-reference" },
						refreshUrl: { type: "string", format: "uri-reference" },
						scopes: { $ref: "#/$defs/map-of-strings" },
					},
					required: ["authorizationUrl", "scopes"],
					$ref: "#/$defs/specification-extensions",
					unevaluatedProperties: false,
				},
				password: {
					type: "object",
					properties: {
						tokenUrl: { type: "string", format: "uri-reference" },
						refreshUrl: { type: "string", format: "uri-reference" },
						scopes: { $ref: "#/$defs/map-of-strings" },
					},
					required: ["tokenUrl", "scopes"],
					$ref: "#/$defs/specification-extensions",
					unevaluatedProperties: false,
				},
				"client-credentials": {
					type: "object",
					properties: {
						tokenUrl: { type: "string", format: "uri-reference" },
						refreshUrl: { type: "string", format: "uri-reference" },
						scopes: { $ref: "#/$defs/map-of-strings" },
					},
					required: ["tokenUrl", "scopes"],
					$ref: "#/$defs/specification-extensions",
					unevaluatedProperties: false,
				},
				"authorization-code": {
					type: "object",
					properties: {
						authorizationUrl: { type: "string", format: "uri-reference" },
						tokenUrl: { type: "string", format: "uri-reference" },
						refreshUrl: { type: "string", format: "uri-reference" },
						scopes: { $ref: "#/$defs/map-of-strings" },
					},
					required: ["authorizationUrl", "tokenUrl", "scopes"],
					$ref: "#/$defs/specification-extensions",
					unevaluatedProperties: false,
				},
			},
		},
		"security-requirement": {
			$comment:
				"https://spec.openapis.org/oas/v3.1#security-requirement-object",
			type: "object",
			additionalProperties: { type: "array", items: { type: "string" } },
		},
		"specification-extensions": {
			$comment: "https://spec.openapis.org/oas/v3.1#specification-extensions",
			patternProperties: { "^x-": true },
		},
		examples: {
			properties: {
				example: true,
				examples: {
					type: "object",
					additionalProperties: { $ref: "#/$defs/example-or-reference" },
				},
			},
		},
		"map-of-strings": {
			type: "object",
			additionalProperties: { type: "string" },
		},
		"styles-for-form": {
			if: { properties: { style: { const: "form" } }, required: ["style"] },
			then: { properties: { explode: { default: true } } },
			else: { properties: { explode: { default: false } } },
		},
	},
};
const schema32 = {
	$comment: "https://spec.openapis.org/oas/v3.1#specification-extensions",
	patternProperties: { "^x-": true },
};
const schema88 = {
	$comment: "https://spec.openapis.org/oas/v3.1#security-requirement-object",
	type: "object",
	additionalProperties: { type: "array", items: { type: "string" } },
};
const pattern4 = new RegExp("^x-", "u");
const pattern5 = new RegExp("^3\\.1\\.\\d+(-.+)?$", "u");
const schema33 = {
	$comment: "https://spec.openapis.org/oas/v3.1#info-object",
	type: "object",
	properties: {
		title: { type: "string" },
		summary: { type: "string" },
		description: { type: "string" },
		termsOfService: { type: "string", format: "uri-reference" },
		contact: { $ref: "#/$defs/contact" },
		license: { $ref: "#/$defs/license" },
		version: { type: "string" },
	},
	required: ["title", "version"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const formats0 =
	/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
const schema35 = {
	$comment: "https://spec.openapis.org/oas/v3.1#contact-object",
	type: "object",
	properties: {
		name: { type: "string" },
		url: { type: "string", format: "uri-reference" },
		email: { type: "string", format: "email" },
	},
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const formats4 =
	/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
function validate22(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate22.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.name = true;
				props0.url = true;
				props0.email = true;
			}
			if (data.name !== undefined) {
				let data0 = data.name;
				const _errs4 = errors;
				if (typeof data0 !== "string") {
					validate22.errors = [
						{
							instancePath: instancePath + "/name",
							schemaPath: "#/properties/name/type",
							keyword: "type",
							params: { type: "string" },
							message: "must be string",
							schema: schema35.properties.name.type,
							parentSchema: schema35.properties.name,
							data: data0,
						},
					];
					return false;
				}
				var valid2 = _errs4 === errors;
			} else {
				var valid2 = true;
			}
			if (valid2) {
				if (data.url !== undefined) {
					let data1 = data.url;
					const _errs6 = errors;
					if (errors === _errs6) {
						if (errors === _errs6) {
							if (typeof data1 === "string") {
								if (!formats0.test(data1)) {
									validate22.errors = [
										{
											instancePath: instancePath + "/url",
											schemaPath: "#/properties/url/format",
											keyword: "format",
											params: { format: "uri-reference" },
											message: 'must match format "' + "uri-reference" + '"',
											schema: "uri-reference",
											parentSchema: schema35.properties.url,
											data: data1,
										},
									];
									return false;
								}
							} else {
								validate22.errors = [
									{
										instancePath: instancePath + "/url",
										schemaPath: "#/properties/url/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema35.properties.url.type,
										parentSchema: schema35.properties.url,
										data: data1,
									},
								];
								return false;
							}
						}
					}
					var valid2 = _errs6 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.email !== undefined) {
						let data2 = data.email;
						const _errs8 = errors;
						if (errors === _errs8) {
							if (errors === _errs8) {
								if (typeof data2 === "string") {
									if (!formats4.test(data2)) {
										validate22.errors = [
											{
												instancePath: instancePath + "/email",
												schemaPath: "#/properties/email/format",
												keyword: "format",
												params: { format: "email" },
												message: 'must match format "' + "email" + '"',
												schema: "email",
												parentSchema: schema35.properties.email,
												data: data2,
											},
										];
										return false;
									}
								} else {
									validate22.errors = [
										{
											instancePath: instancePath + "/email",
											schemaPath: "#/properties/email/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema35.properties.email.type,
											parentSchema: schema35.properties.email,
											data: data2,
										},
									];
									return false;
								}
							}
						}
						var valid2 = _errs8 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (props0 !== true) {
							for (const key1 in data) {
								if (!props0 || !props0[key1]) {
									validate22.errors = [
										{
											instancePath,
											schemaPath: "#/unevaluatedProperties",
											keyword: "unevaluatedProperties",
											params: { unevaluatedProperty: key1 },
											message: "must NOT have unevaluated properties",
											schema: false,
											parentSchema: schema35,
											data,
										},
									];
									return false;
									break;
								}
							}
						}
					}
				}
			}
		} else {
			validate22.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema35.type,
					parentSchema: schema35,
					data,
				},
			];
			return false;
		}
	}
	validate22.errors = vErrors;
	return errors === 0;
}
validate22.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema37 = {
	$comment: "https://spec.openapis.org/oas/v3.1#license-object",
	type: "object",
	properties: {
		name: { type: "string" },
		identifier: { type: "string" },
		url: { type: "string", format: "uri-reference" },
	},
	required: ["name"],
	dependentSchemas: { identifier: { not: { required: ["url"] } } },
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate24(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate24.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.name === undefined && (missing0 = "name")) {
				validate24.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema37.required,
						parentSchema: schema37,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.name = true;
					props0.identifier = true;
					props0.url = true;
				}
				if (data.name !== undefined) {
					let data0 = data.name;
					const _errs4 = errors;
					if (typeof data0 !== "string") {
						validate24.errors = [
							{
								instancePath: instancePath + "/name",
								schemaPath: "#/properties/name/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema37.properties.name.type,
								parentSchema: schema37.properties.name,
								data: data0,
							},
						];
						return false;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.identifier !== undefined) {
						let data1 = data.identifier;
						const _errs6 = errors;
						if (typeof data1 !== "string") {
							validate24.errors = [
								{
									instancePath: instancePath + "/identifier",
									schemaPath: "#/properties/identifier/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema37.properties.identifier.type,
									parentSchema: schema37.properties.identifier,
									data: data1,
								},
							];
							return false;
						}
						var valid2 = _errs6 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.url !== undefined) {
							let data2 = data.url;
							const _errs8 = errors;
							if (errors === _errs8) {
								if (errors === _errs8) {
									if (typeof data2 === "string") {
										if (!formats0.test(data2)) {
											validate24.errors = [
												{
													instancePath: instancePath + "/url",
													schemaPath: "#/properties/url/format",
													keyword: "format",
													params: { format: "uri-reference" },
													message:
														'must match format "' + "uri-reference" + '"',
													schema: "uri-reference",
													parentSchema: schema37.properties.url,
													data: data2,
												},
											];
											return false;
										}
									} else {
										validate24.errors = [
											{
												instancePath: instancePath + "/url",
												schemaPath: "#/properties/url/type",
												keyword: "type",
												params: { type: "string" },
												message: "must be string",
												schema: schema37.properties.url.type,
												parentSchema: schema37.properties.url,
												data: data2,
											},
										];
										return false;
									}
								}
							}
							var valid2 = _errs8 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (data.identifier !== undefined) {
								const _errs10 = errors;
								const _errs11 = errors;
								const _errs12 = errors;
								if (data && typeof data == "object" && !Array.isArray(data)) {
									let missing1;
									if (data.url === undefined && (missing1 = "url")) {
										const err0 = {};
										if (vErrors === null) {
											vErrors = [err0];
										} else {
											vErrors.push(err0);
										}
										errors++;
									}
								}
								var valid4 = _errs12 === errors;
								if (valid4) {
									validate24.errors = [
										{
											instancePath,
											schemaPath: "#/dependentSchemas/identifier/not",
											keyword: "not",
											params: {},
											message: "must NOT be valid",
											schema: schema37.dependentSchemas.identifier.not,
											parentSchema: schema37.dependentSchemas.identifier,
											data,
										},
									];
									return false;
								} else {
									errors = _errs11;
									if (vErrors !== null) {
										if (_errs11) {
											vErrors.length = _errs11;
										} else {
											vErrors = null;
										}
									}
								}
								var valid3 = _errs10 === errors;
							} else {
								var valid3 = true;
							}
							if (valid3) {
								if (props0 !== true) {
									for (const key1 in data) {
										if (!props0 || !props0[key1]) {
											validate24.errors = [
												{
													instancePath,
													schemaPath: "#/unevaluatedProperties",
													keyword: "unevaluatedProperties",
													params: { unevaluatedProperty: key1 },
													message: "must NOT have unevaluated properties",
													schema: false,
													parentSchema: schema37,
													data,
												},
											];
											return false;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate24.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema37.type,
					parentSchema: schema37,
					data,
				},
			];
			return false;
		}
	}
	validate24.errors = vErrors;
	return errors === 0;
}
validate24.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate21(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate21.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (
				(data.title === undefined && (missing0 = "title")) ||
				(data.version === undefined && (missing0 = "version"))
			) {
				validate21.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema33.required,
						parentSchema: schema33,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.title = true;
					props0.summary = true;
					props0.description = true;
					props0.termsOfService = true;
					props0.contact = true;
					props0.license = true;
					props0.version = true;
				}
				if (data.title !== undefined) {
					let data0 = data.title;
					const _errs4 = errors;
					if (typeof data0 !== "string") {
						validate21.errors = [
							{
								instancePath: instancePath + "/title",
								schemaPath: "#/properties/title/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema33.properties.title.type,
								parentSchema: schema33.properties.title,
								data: data0,
							},
						];
						return false;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.summary !== undefined) {
						let data1 = data.summary;
						const _errs6 = errors;
						if (typeof data1 !== "string") {
							validate21.errors = [
								{
									instancePath: instancePath + "/summary",
									schemaPath: "#/properties/summary/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema33.properties.summary.type,
									parentSchema: schema33.properties.summary,
									data: data1,
								},
							];
							return false;
						}
						var valid2 = _errs6 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.description !== undefined) {
							let data2 = data.description;
							const _errs8 = errors;
							if (typeof data2 !== "string") {
								validate21.errors = [
									{
										instancePath: instancePath + "/description",
										schemaPath: "#/properties/description/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema33.properties.description.type,
										parentSchema: schema33.properties.description,
										data: data2,
									},
								];
								return false;
							}
							var valid2 = _errs8 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (data.termsOfService !== undefined) {
								let data3 = data.termsOfService;
								const _errs10 = errors;
								if (errors === _errs10) {
									if (errors === _errs10) {
										if (typeof data3 === "string") {
											if (!formats0.test(data3)) {
												validate21.errors = [
													{
														instancePath: instancePath + "/termsOfService",
														schemaPath: "#/properties/termsOfService/format",
														keyword: "format",
														params: { format: "uri-reference" },
														message:
															'must match format "' + "uri-reference" + '"',
														schema: "uri-reference",
														parentSchema: schema33.properties.termsOfService,
														data: data3,
													},
												];
												return false;
											}
										} else {
											validate21.errors = [
												{
													instancePath: instancePath + "/termsOfService",
													schemaPath: "#/properties/termsOfService/type",
													keyword: "type",
													params: { type: "string" },
													message: "must be string",
													schema: schema33.properties.termsOfService.type,
													parentSchema: schema33.properties.termsOfService,
													data: data3,
												},
											];
											return false;
										}
									}
								}
								var valid2 = _errs10 === errors;
							} else {
								var valid2 = true;
							}
							if (valid2) {
								if (data.contact !== undefined) {
									const _errs12 = errors;
									if (
										!validate22(data.contact, {
											instancePath: instancePath + "/contact",
											parentData: data,
											parentDataProperty: "contact",
											rootData,
											dynamicAnchors,
										})
									) {
										vErrors =
											vErrors === null
												? validate22.errors
												: vErrors.concat(validate22.errors);
										errors = vErrors.length;
									}
									var valid2 = _errs12 === errors;
								} else {
									var valid2 = true;
								}
								if (valid2) {
									if (data.license !== undefined) {
										const _errs13 = errors;
										if (
											!validate24(data.license, {
												instancePath: instancePath + "/license",
												parentData: data,
												parentDataProperty: "license",
												rootData,
												dynamicAnchors,
											})
										) {
											vErrors =
												vErrors === null
													? validate24.errors
													: vErrors.concat(validate24.errors);
											errors = vErrors.length;
										}
										var valid2 = _errs13 === errors;
									} else {
										var valid2 = true;
									}
									if (valid2) {
										if (data.version !== undefined) {
											let data6 = data.version;
											const _errs14 = errors;
											if (typeof data6 !== "string") {
												validate21.errors = [
													{
														instancePath: instancePath + "/version",
														schemaPath: "#/properties/version/type",
														keyword: "type",
														params: { type: "string" },
														message: "must be string",
														schema: schema33.properties.version.type,
														parentSchema: schema33.properties.version,
														data: data6,
													},
												];
												return false;
											}
											var valid2 = _errs14 === errors;
										} else {
											var valid2 = true;
										}
										if (valid2) {
											if (props0 !== true) {
												for (const key1 in data) {
													if (!props0 || !props0[key1]) {
														validate21.errors = [
															{
																instancePath,
																schemaPath: "#/unevaluatedProperties",
																keyword: "unevaluatedProperties",
																params: { unevaluatedProperty: key1 },
																message: "must NOT have unevaluated properties",
																schema: false,
																parentSchema: schema33,
																data,
															},
														];
														return false;
														break;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate21.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema33.type,
					parentSchema: schema33,
					data,
				},
			];
			return false;
		}
	}
	validate21.errors = vErrors;
	return errors === 0;
}
validate21.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema39 = {
	$comment: "https://spec.openapis.org/oas/v3.1#server-object",
	type: "object",
	properties: {
		url: { type: "string" },
		description: { type: "string" },
		variables: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/server-variable" },
		},
	},
	required: ["url"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const schema41 = {
	$comment: "https://spec.openapis.org/oas/v3.1#server-variable-object",
	type: "object",
	properties: {
		enum: { type: "array", items: { type: "string" }, minItems: 1 },
		default: { type: "string" },
		description: { type: "string" },
	},
	required: ["default"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate28(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate28.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.default === undefined && (missing0 = "default")) {
				validate28.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema41.required,
						parentSchema: schema41,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.enum = true;
					props0.default = true;
					props0.description = true;
				}
				if (data.enum !== undefined) {
					let data0 = data.enum;
					const _errs4 = errors;
					if (errors === _errs4) {
						if (Array.isArray(data0)) {
							if (data0.length < 1) {
								validate28.errors = [
									{
										instancePath: instancePath + "/enum",
										schemaPath: "#/properties/enum/minItems",
										keyword: "minItems",
										params: { limit: 1 },
										message: "must NOT have fewer than 1 items",
										schema: 1,
										parentSchema: schema41.properties.enum,
										data: data0,
									},
								];
								return false;
							} else {
								var valid3 = true;
								const len0 = data0.length;
								for (let i0 = 0; i0 < len0; i0++) {
									let data1 = data0[i0];
									const _errs6 = errors;
									if (typeof data1 !== "string") {
										validate28.errors = [
											{
												instancePath: instancePath + "/enum/" + i0,
												schemaPath: "#/properties/enum/items/type",
												keyword: "type",
												params: { type: "string" },
												message: "must be string",
												schema: schema41.properties.enum.items.type,
												parentSchema: schema41.properties.enum.items,
												data: data1,
											},
										];
										return false;
									}
									var valid3 = _errs6 === errors;
									if (!valid3) {
										break;
									}
								}
							}
						} else {
							validate28.errors = [
								{
									instancePath: instancePath + "/enum",
									schemaPath: "#/properties/enum/type",
									keyword: "type",
									params: { type: "array" },
									message: "must be array",
									schema: schema41.properties.enum.type,
									parentSchema: schema41.properties.enum,
									data: data0,
								},
							];
							return false;
						}
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.default !== undefined) {
						let data2 = data.default;
						const _errs8 = errors;
						if (typeof data2 !== "string") {
							validate28.errors = [
								{
									instancePath: instancePath + "/default",
									schemaPath: "#/properties/default/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema41.properties.default.type,
									parentSchema: schema41.properties.default,
									data: data2,
								},
							];
							return false;
						}
						var valid2 = _errs8 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.description !== undefined) {
							let data3 = data.description;
							const _errs10 = errors;
							if (typeof data3 !== "string") {
								validate28.errors = [
									{
										instancePath: instancePath + "/description",
										schemaPath: "#/properties/description/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema41.properties.description.type,
										parentSchema: schema41.properties.description,
										data: data3,
									},
								];
								return false;
							}
							var valid2 = _errs10 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key1 in data) {
									if (!props0 || !props0[key1]) {
										validate28.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key1 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema41,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate28.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema41.type,
					parentSchema: schema41,
					data,
				},
			];
			return false;
		}
	}
	validate28.errors = vErrors;
	return errors === 0;
}
validate28.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate27(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate27.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.url === undefined && (missing0 = "url")) {
				validate27.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema39.required,
						parentSchema: schema39,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.url = true;
					props0.description = true;
					props0.variables = true;
				}
				if (data.url !== undefined) {
					let data0 = data.url;
					const _errs4 = errors;
					if (typeof data0 !== "string") {
						validate27.errors = [
							{
								instancePath: instancePath + "/url",
								schemaPath: "#/properties/url/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema39.properties.url.type,
								parentSchema: schema39.properties.url,
								data: data0,
							},
						];
						return false;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.description !== undefined) {
						let data1 = data.description;
						const _errs6 = errors;
						if (typeof data1 !== "string") {
							validate27.errors = [
								{
									instancePath: instancePath + "/description",
									schemaPath: "#/properties/description/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema39.properties.description.type,
									parentSchema: schema39.properties.description,
									data: data1,
								},
							];
							return false;
						}
						var valid2 = _errs6 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.variables !== undefined) {
							let data2 = data.variables;
							const _errs8 = errors;
							if (errors === _errs8) {
								if (
									data2 &&
									typeof data2 == "object" &&
									!Array.isArray(data2)
								) {
									for (const key1 in data2) {
										const _errs11 = errors;
										if (
											!validate28(data2[key1], {
												instancePath:
													instancePath +
													"/variables/" +
													key1.replace(/~/g, "~0").replace(/\//g, "~1"),
												parentData: data2,
												parentDataProperty: key1,
												rootData,
												dynamicAnchors,
											})
										) {
											vErrors =
												vErrors === null
													? validate28.errors
													: vErrors.concat(validate28.errors);
											errors = vErrors.length;
										}
										var valid3 = _errs11 === errors;
										if (!valid3) {
											break;
										}
									}
								} else {
									validate27.errors = [
										{
											instancePath: instancePath + "/variables",
											schemaPath: "#/properties/variables/type",
											keyword: "type",
											params: { type: "object" },
											message: "must be object",
											schema: schema39.properties.variables.type,
											parentSchema: schema39.properties.variables,
											data: data2,
										},
									];
									return false;
								}
							}
							var valid2 = _errs8 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key2 in data) {
									if (!props0 || !props0[key2]) {
										validate27.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key2 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema39,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate27.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema39.type,
					parentSchema: schema39,
					data,
				},
			];
			return false;
		}
	}
	validate27.errors = vErrors;
	return errors === 0;
}
validate27.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema43 = {
	$comment: "https://spec.openapis.org/oas/v3.1#paths-object",
	type: "object",
	patternProperties: { "^/": { $ref: "#/$defs/path-item" } },
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const pattern12 = new RegExp("^/", "u");
const schema45 = {
	$comment: "https://spec.openapis.org/oas/v3.1#path-item-object",
	type: "object",
	properties: {
		$ref: { type: "string", format: "uri-reference" },
		summary: { type: "string" },
		description: { type: "string" },
		servers: { type: "array", items: { $ref: "#/$defs/server" } },
		parameters: {
			type: "array",
			items: { $ref: "#/$defs/parameter-or-reference" },
		},
		get: { $ref: "#/$defs/operation" },
		put: { $ref: "#/$defs/operation" },
		post: { $ref: "#/$defs/operation" },
		delete: { $ref: "#/$defs/operation" },
		options: { $ref: "#/$defs/operation" },
		head: { $ref: "#/$defs/operation" },
		patch: { $ref: "#/$defs/operation" },
		trace: { $ref: "#/$defs/operation" },
	},
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const schema47 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/parameter" },
};
const schema48 = {
	$comment: "https://spec.openapis.org/oas/v3.1#reference-object",
	type: "object",
	properties: {
		$ref: { type: "string", format: "uri-reference" },
		summary: { type: "string" },
		description: { type: "string" },
	},
};
function validate35(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate35.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (data.$ref !== undefined) {
				let data0 = data.$ref;
				const _errs2 = errors;
				if (errors === _errs2) {
					if (errors === _errs2) {
						if (typeof data0 === "string") {
							if (!formats0.test(data0)) {
								validate35.errors = [
									{
										instancePath: instancePath + "/$ref",
										schemaPath: "#/properties/%24ref/format",
										keyword: "format",
										params: { format: "uri-reference" },
										message: 'must match format "' + "uri-reference" + '"',
										schema: "uri-reference",
										parentSchema: schema48.properties.$ref,
										data: data0,
									},
								];
								return false;
							}
						} else {
							validate35.errors = [
								{
									instancePath: instancePath + "/$ref",
									schemaPath: "#/properties/%24ref/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema48.properties.$ref.type,
									parentSchema: schema48.properties.$ref,
									data: data0,
								},
							];
							return false;
						}
					}
				}
				var valid0 = _errs2 === errors;
			} else {
				var valid0 = true;
			}
			if (valid0) {
				if (data.summary !== undefined) {
					let data1 = data.summary;
					const _errs4 = errors;
					if (typeof data1 !== "string") {
						validate35.errors = [
							{
								instancePath: instancePath + "/summary",
								schemaPath: "#/properties/summary/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema48.properties.summary.type,
								parentSchema: schema48.properties.summary,
								data: data1,
							},
						];
						return false;
					}
					var valid0 = _errs4 === errors;
				} else {
					var valid0 = true;
				}
				if (valid0) {
					if (data.description !== undefined) {
						let data2 = data.description;
						const _errs6 = errors;
						if (typeof data2 !== "string") {
							validate35.errors = [
								{
									instancePath: instancePath + "/description",
									schemaPath: "#/properties/description/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema48.properties.description.type,
									parentSchema: schema48.properties.description,
									data: data2,
								},
							];
							return false;
						}
						var valid0 = _errs6 === errors;
					} else {
						var valid0 = true;
					}
				}
			}
		} else {
			validate35.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema48.type,
					parentSchema: schema48,
					data,
				},
			];
			return false;
		}
	}
	validate35.errors = vErrors;
	return errors === 0;
}
validate35.evaluated = {
	props: { $ref: true, summary: true, description: true },
	dynamicProps: false,
	dynamicItems: false,
};
const schema49 = {
	$comment: "https://spec.openapis.org/oas/v3.1#parameter-object",
	type: "object",
	properties: {
		name: { type: "string" },
		in: { enum: ["query", "header", "path", "cookie"] },
		description: { type: "string" },
		required: { default: false, type: "boolean" },
		deprecated: { default: false, type: "boolean" },
		schema: { $dynamicRef: "#meta" },
		content: { $ref: "#/$defs/content", minProperties: 1, maxProperties: 1 },
	},
	required: ["name", "in"],
	oneOf: [{ required: ["schema"] }, { required: ["content"] }],
	if: { properties: { in: { const: "query" } }, required: ["in"] },
	then: {
		properties: { allowEmptyValue: { default: false, type: "boolean" } },
	},
	dependentSchemas: {
		schema: {
			properties: { style: { type: "string" }, explode: { type: "boolean" } },
			allOf: [
				{ $ref: "#/$defs/examples" },
				{
					$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path",
				},
				{
					$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header",
				},
				{
					$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query",
				},
				{
					$ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie",
				},
				{ $ref: "#/$defs/styles-for-form" },
			],
			$defs: {
				"styles-for-path": {
					if: { properties: { in: { const: "path" } }, required: ["in"] },
					then: {
						properties: {
							style: { default: "simple", enum: ["matrix", "label", "simple"] },
							required: { const: true },
						},
						required: ["required"],
					},
				},
				"styles-for-header": {
					if: { properties: { in: { const: "header" } }, required: ["in"] },
					then: {
						properties: { style: { default: "simple", const: "simple" } },
					},
				},
				"styles-for-query": {
					if: { properties: { in: { const: "query" } }, required: ["in"] },
					then: {
						properties: {
							style: {
								default: "form",
								enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
							},
							allowReserved: { default: false, type: "boolean" },
						},
					},
				},
				"styles-for-cookie": {
					if: { properties: { in: { const: "cookie" } }, required: ["in"] },
					then: { properties: { style: { default: "form", const: "form" } } },
				},
			},
		},
	},
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const schema64 = {
	if: { properties: { in: { const: "path" } }, required: ["in"] },
	then: {
		properties: {
			style: { default: "simple", enum: ["matrix", "label", "simple"] },
			required: { const: true },
		},
		required: ["required"],
	},
};
const schema65 = {
	if: { properties: { in: { const: "header" } }, required: ["in"] },
	then: { properties: { style: { default: "simple", const: "simple" } } },
};
const schema66 = {
	if: { properties: { in: { const: "query" } }, required: ["in"] },
	then: {
		properties: {
			style: {
				default: "form",
				enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
			},
			allowReserved: { default: false, type: "boolean" },
		},
	},
};
const schema67 = {
	if: { properties: { in: { const: "cookie" } }, required: ["in"] },
	then: { properties: { style: { default: "form", const: "form" } } },
};
const schema60 = {
	if: { properties: { style: { const: "form" } }, required: ["style"] },
	then: { properties: { explode: { default: true } } },
	else: { properties: { explode: { default: false } } },
};
const schema51 = {
	$comment: "https://spec.openapis.org/oas/v3.1#fixed-fields-10",
	type: "object",
	additionalProperties: { $ref: "#/$defs/media-type" },
	propertyNames: { format: "media-range" },
};
const schema52 = {
	$comment: "https://spec.openapis.org/oas/v3.1#media-type-object",
	type: "object",
	properties: {
		schema: { $dynamicRef: "#meta" },
		encoding: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/encoding" },
		},
	},
	allOf: [
		{ $ref: "#/$defs/specification-extensions" },
		{ $ref: "#/$defs/examples" },
	],
	unevaluatedProperties: false,
};
const schema54 = {
	properties: {
		example: true,
		examples: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/example-or-reference" },
		},
	},
};
const schema55 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/example" },
};
const schema56 = {
	$comment: "https://spec.openapis.org/oas/v3.1#example-object",
	type: "object",
	properties: {
		summary: { type: "string" },
		description: { type: "string" },
		value: true,
		externalValue: { type: "string", format: "uri-reference" },
	},
	not: { required: ["value", "externalValue"] },
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate43(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate43.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs1 === errors;
	if (valid0) {
		const _errs4 = errors;
		const _errs5 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (
				(data.value === undefined && (missing0 = "value")) ||
				(data.externalValue === undefined && (missing0 = "externalValue"))
			) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		}
		var valid2 = _errs5 === errors;
		if (valid2) {
			validate43.errors = [
				{
					instancePath,
					schemaPath: "#/not",
					keyword: "not",
					params: {},
					message: "must NOT be valid",
					schema: schema56.not,
					parentSchema: schema56,
					data,
				},
			];
			return false;
		} else {
			errors = _errs4;
			if (vErrors !== null) {
				if (_errs4) {
					vErrors.length = _errs4;
				} else {
					vErrors = null;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.summary = true;
				props0.description = true;
				props0.value = true;
				props0.externalValue = true;
			}
			if (data.summary !== undefined) {
				let data0 = data.summary;
				const _errs6 = errors;
				if (typeof data0 !== "string") {
					validate43.errors = [
						{
							instancePath: instancePath + "/summary",
							schemaPath: "#/properties/summary/type",
							keyword: "type",
							params: { type: "string" },
							message: "must be string",
							schema: schema56.properties.summary.type,
							parentSchema: schema56.properties.summary,
							data: data0,
						},
					];
					return false;
				}
				var valid3 = _errs6 === errors;
			} else {
				var valid3 = true;
			}
			if (valid3) {
				if (data.description !== undefined) {
					let data1 = data.description;
					const _errs8 = errors;
					if (typeof data1 !== "string") {
						validate43.errors = [
							{
								instancePath: instancePath + "/description",
								schemaPath: "#/properties/description/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema56.properties.description.type,
								parentSchema: schema56.properties.description,
								data: data1,
							},
						];
						return false;
					}
					var valid3 = _errs8 === errors;
				} else {
					var valid3 = true;
				}
				if (valid3) {
					if (data.externalValue !== undefined) {
						let data2 = data.externalValue;
						const _errs10 = errors;
						if (errors === _errs10) {
							if (errors === _errs10) {
								if (typeof data2 === "string") {
									if (!formats0.test(data2)) {
										validate43.errors = [
											{
												instancePath: instancePath + "/externalValue",
												schemaPath: "#/properties/externalValue/format",
												keyword: "format",
												params: { format: "uri-reference" },
												message: 'must match format "' + "uri-reference" + '"',
												schema: "uri-reference",
												parentSchema: schema56.properties.externalValue,
												data: data2,
											},
										];
										return false;
									}
								} else {
									validate43.errors = [
										{
											instancePath: instancePath + "/externalValue",
											schemaPath: "#/properties/externalValue/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema56.properties.externalValue.type,
											parentSchema: schema56.properties.externalValue,
											data: data2,
										},
									];
									return false;
								}
							}
						}
						var valid3 = _errs10 === errors;
					} else {
						var valid3 = true;
					}
					if (valid3) {
						if (props0 !== true) {
							for (const key1 in data) {
								if (!props0 || !props0[key1]) {
									validate43.errors = [
										{
											instancePath,
											schemaPath: "#/unevaluatedProperties",
											keyword: "unevaluatedProperties",
											params: { unevaluatedProperty: key1 },
											message: "must NOT have unevaluated properties",
											schema: false,
											parentSchema: schema56,
											data,
										},
									];
									return false;
									break;
								}
							}
						}
					}
				}
			}
		} else {
			validate43.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema56.type,
					parentSchema: schema56,
					data,
				},
			];
			return false;
		}
	}
	validate43.errors = vErrors;
	return errors === 0;
}
validate43.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate41(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate41.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate43(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate43.errors
					: vErrors.concat(validate43.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema55.if,
			parentSchema: schema55,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate41.errors = vErrors;
		return false;
	}
	validate41.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate41.evaluated = { dynamicProps: true, dynamicItems: false };
function validate40(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate40.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	if (data && typeof data == "object" && !Array.isArray(data)) {
		if (data.examples !== undefined) {
			let data0 = data.examples;
			const _errs0 = errors;
			if (errors === _errs0) {
				if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
					for (const key0 in data0) {
						const _errs3 = errors;
						if (
							!validate41(data0[key0], {
								instancePath:
									instancePath +
									"/examples/" +
									key0.replace(/~/g, "~0").replace(/\//g, "~1"),
								parentData: data0,
								parentDataProperty: key0,
								rootData,
								dynamicAnchors,
							})
						) {
							vErrors =
								vErrors === null
									? validate41.errors
									: vErrors.concat(validate41.errors);
							errors = vErrors.length;
						}
						var valid1 = _errs3 === errors;
						if (!valid1) {
							break;
						}
					}
				} else {
					validate40.errors = [
						{
							instancePath: instancePath + "/examples",
							schemaPath: "#/properties/examples/type",
							keyword: "type",
							params: { type: "object" },
							message: "must be object",
							schema: schema54.properties.examples.type,
							parentSchema: schema54.properties.examples,
							data: data0,
						},
					];
					return false;
				}
			}
		}
	}
	validate40.errors = vErrors;
	return errors === 0;
}
validate40.evaluated = {
	props: { example: true, examples: true },
	dynamicProps: false,
	dynamicItems: false,
};
const schema58 = {
	$comment: "https://spec.openapis.org/oas/v3.1#encoding-object",
	type: "object",
	properties: {
		contentType: { type: "string", format: "media-range" },
		headers: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/header-or-reference" },
		},
		style: {
			default: "form",
			enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
		},
		explode: { type: "boolean" },
		allowReserved: { default: false, type: "boolean" },
	},
	allOf: [
		{ $ref: "#/$defs/specification-extensions" },
		{ $ref: "#/$defs/styles-for-form" },
	],
	unevaluatedProperties: false,
};
const schema61 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/header" },
};
const schema62 = {
	$comment: "https://spec.openapis.org/oas/v3.1#header-object",
	type: "object",
	properties: {
		description: { type: "string" },
		required: { default: false, type: "boolean" },
		deprecated: { default: false, type: "boolean" },
		schema: { $dynamicRef: "#meta" },
		content: { $ref: "#/$defs/content", minProperties: 1, maxProperties: 1 },
	},
	oneOf: [{ required: ["schema"] }, { required: ["content"] }],
	dependentSchemas: {
		schema: {
			properties: {
				style: { default: "simple", const: "simple" },
				explode: { default: false, type: "boolean" },
			},
			$ref: "#/$defs/examples",
		},
	},
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const wrapper0 = { validate: validate38 };
function validate50(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate50.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs1 === errors;
	if (valid0) {
		const _errs4 = errors;
		let valid2 = false;
		let passing0 = null;
		const _errs5 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.schema === undefined && (missing0 = "schema")) {
				const err0 = {
					instancePath,
					schemaPath: "#/oneOf/0/required",
					keyword: "required",
					params: { missingProperty: missing0 },
					message: "must have required property '" + missing0 + "'",
					schema: schema62.oneOf[0].required,
					parentSchema: schema62.oneOf[0],
					data,
				};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		}
		var _valid0 = _errs5 === errors;
		if (_valid0) {
			valid2 = true;
			passing0 = 0;
		}
		const _errs6 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing1;
			if (data.content === undefined && (missing1 = "content")) {
				const err1 = {
					instancePath,
					schemaPath: "#/oneOf/1/required",
					keyword: "required",
					params: { missingProperty: missing1 },
					message: "must have required property '" + missing1 + "'",
					schema: schema62.oneOf[1].required,
					parentSchema: schema62.oneOf[1],
					data,
				};
				if (vErrors === null) {
					vErrors = [err1];
				} else {
					vErrors.push(err1);
				}
				errors++;
			}
		}
		var _valid0 = _errs6 === errors;
		if (_valid0 && valid2) {
			valid2 = false;
			passing0 = [passing0, 1];
		} else {
			if (_valid0) {
				valid2 = true;
				passing0 = 1;
			}
		}
		if (!valid2) {
			const err2 = {
				instancePath,
				schemaPath: "#/oneOf",
				keyword: "oneOf",
				params: { passingSchemas: passing0 },
				message: "must match exactly one schema in oneOf",
				schema: schema62.oneOf,
				parentSchema: schema62,
				data,
			};
			if (vErrors === null) {
				vErrors = [err2];
			} else {
				vErrors.push(err2);
			}
			errors++;
			validate50.errors = vErrors;
			return false;
		} else {
			errors = _errs4;
			if (vErrors !== null) {
				if (_errs4) {
					vErrors.length = _errs4;
				} else {
					vErrors = null;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.description = true;
				props0.required = true;
				props0.deprecated = true;
				props0.schema = true;
				props0.content = true;
			}
			if (data.description !== undefined) {
				let data0 = data.description;
				const _errs7 = errors;
				if (typeof data0 !== "string") {
					validate50.errors = [
						{
							instancePath: instancePath + "/description",
							schemaPath: "#/properties/description/type",
							keyword: "type",
							params: { type: "string" },
							message: "must be string",
							schema: schema62.properties.description.type,
							parentSchema: schema62.properties.description,
							data: data0,
						},
					];
					return false;
				}
				var valid3 = _errs7 === errors;
			} else {
				var valid3 = true;
			}
			if (valid3) {
				if (data.required !== undefined) {
					let data1 = data.required;
					const _errs9 = errors;
					if (typeof data1 !== "boolean") {
						validate50.errors = [
							{
								instancePath: instancePath + "/required",
								schemaPath: "#/properties/required/type",
								keyword: "type",
								params: { type: "boolean" },
								message: "must be boolean",
								schema: schema62.properties.required.type,
								parentSchema: schema62.properties.required,
								data: data1,
							},
						];
						return false;
					}
					var valid3 = _errs9 === errors;
				} else {
					var valid3 = true;
				}
				if (valid3) {
					if (data.deprecated !== undefined) {
						let data2 = data.deprecated;
						const _errs11 = errors;
						if (typeof data2 !== "boolean") {
							validate50.errors = [
								{
									instancePath: instancePath + "/deprecated",
									schemaPath: "#/properties/deprecated/type",
									keyword: "type",
									params: { type: "boolean" },
									message: "must be boolean",
									schema: schema62.properties.deprecated.type,
									parentSchema: schema62.properties.deprecated,
									data: data2,
								},
							];
							return false;
						}
						var valid3 = _errs11 === errors;
					} else {
						var valid3 = true;
					}
					if (valid3) {
						if (data.schema !== undefined) {
							const _errs13 = errors;
							if (
								!validate50(data.schema, {
									instancePath: instancePath + "/schema",
									parentData: data,
									parentDataProperty: "schema",
									rootData,
									dynamicAnchors,
								})
							) {
								vErrors =
									vErrors === null
										? validate50.errors
										: vErrors.concat(validate50.errors);
								errors = vErrors.length;
							}
							var valid3 = _errs13 === errors;
						} else {
							var valid3 = true;
						}
						if (valid3) {
							if (data.content !== undefined) {
								let data4 = data.content;
								const _errs14 = errors;
								if (
									!wrapper0.validate(data4, {
										instancePath: instancePath + "/content",
										parentData: data,
										parentDataProperty: "content",
										rootData,
										dynamicAnchors,
									})
								) {
									vErrors =
										vErrors === null
											? wrapper0.validate.errors
											: vErrors.concat(wrapper0.validate.errors);
									errors = vErrors.length;
								}
								if (errors === _errs14) {
									if (
										data4 &&
										typeof data4 == "object" &&
										!Array.isArray(data4)
									) {
										if (Object.keys(data4).length > 1) {
											validate50.errors = [
												{
													instancePath: instancePath + "/content",
													schemaPath: "#/properties/content/maxProperties",
													keyword: "maxProperties",
													params: { limit: 1 },
													message: "must NOT have more than 1 properties",
													schema: 1,
													parentSchema: schema62.properties.content,
													data: data4,
												},
											];
											return false;
										} else {
											if (Object.keys(data4).length < 1) {
												validate50.errors = [
													{
														instancePath: instancePath + "/content",
														schemaPath: "#/properties/content/minProperties",
														keyword: "minProperties",
														params: { limit: 1 },
														message: "must NOT have fewer than 1 properties",
														schema: 1,
														parentSchema: schema62.properties.content,
														data: data4,
													},
												];
												return false;
											}
										}
									}
								}
								var valid3 = _errs14 === errors;
							} else {
								var valid3 = true;
							}
							if (valid3) {
								if (data.schema !== undefined) {
									const _errs15 = errors;
									if (
										!validate40(data, {
											instancePath,
											parentData,
											parentDataProperty,
											rootData,
											dynamicAnchors,
										})
									) {
										vErrors =
											vErrors === null
												? validate40.errors
												: vErrors.concat(validate40.errors);
										errors = vErrors.length;
									}
									if (errors === _errs15) {
										if (
											data &&
											typeof data == "object" &&
											!Array.isArray(data)
										) {
											if (data.style !== undefined) {
												let data5 = data.style;
												const _errs16 = errors;
												if ("simple" !== data5) {
													validate50.errors = [
														{
															instancePath: instancePath + "/style",
															schemaPath:
																"#/dependentSchemas/schema/properties/style/const",
															keyword: "const",
															params: { allowedValue: "simple" },
															message: "must be equal to constant",
															schema: "simple",
															parentSchema:
																schema62.dependentSchemas.schema.properties
																	.style,
															data: data5,
														},
													];
													return false;
												}
												var valid6 = _errs16 === errors;
											} else {
												var valid6 = true;
											}
											if (valid6) {
												if (data.explode !== undefined) {
													let data6 = data.explode;
													const _errs17 = errors;
													if (typeof data6 !== "boolean") {
														validate50.errors = [
															{
																instancePath: instancePath + "/explode",
																schemaPath:
																	"#/dependentSchemas/schema/properties/explode/type",
																keyword: "type",
																params: { type: "boolean" },
																message: "must be boolean",
																schema:
																	schema62.dependentSchemas.schema.properties
																		.explode.type,
																parentSchema:
																	schema62.dependentSchemas.schema.properties
																		.explode,
																data: data6,
															},
														];
														return false;
													}
													var valid6 = _errs17 === errors;
												} else {
													var valid6 = true;
												}
											}
										}
									}
									var valid5 = _errs15 === errors;
									if (valid5) {
										if (props0 !== true) {
											props0 = props0 || {};
											props0.style = true;
											props0.explode = true;
											props0.example = true;
											props0.examples = true;
										}
									}
								} else {
									var valid5 = true;
								}
								if (valid5) {
									if (props0 !== true) {
										for (const key1 in data) {
											if (!props0 || !props0[key1]) {
												validate50.errors = [
													{
														instancePath,
														schemaPath: "#/unevaluatedProperties",
														keyword: "unevaluatedProperties",
														params: { unevaluatedProperty: key1 },
														message: "must NOT have unevaluated properties",
														schema: false,
														parentSchema: schema62,
														data,
													},
												];
												return false;
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate50.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema62.type,
					parentSchema: schema62,
					data,
				},
			];
			return false;
		}
	}
	validate50.errors = vErrors;
	return errors === 0;
}
validate50.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate48(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate48.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate50(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate50.errors
					: vErrors.concat(validate50.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema61.if,
			parentSchema: schema61,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate48.errors = vErrors;
		return false;
	}
	validate48.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate48.evaluated = { dynamicProps: true, dynamicItems: false };
function validate47(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate47.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs2 = errors;
	const _errs3 = errors;
	if (errors === _errs3) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs2 === errors;
	if (valid0) {
		const _errs5 = errors;
		const _errs7 = errors;
		let valid4 = true;
		const _errs8 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.style === undefined && (missing0 = "style")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			} else {
				if (data.style !== undefined) {
					if ("form" !== data.style) {
						const err1 = {};
						if (vErrors === null) {
							vErrors = [err1];
						} else {
							vErrors.push(err1);
						}
						errors++;
					}
				}
			}
		}
		var _valid0 = _errs8 === errors;
		errors = _errs7;
		if (vErrors !== null) {
			if (_errs7) {
				vErrors.length = _errs7;
			} else {
				vErrors = null;
			}
		}
		let ifClause0;
		if (_valid0) {
			const _errs10 = errors;
			var _valid0 = _errs10 === errors;
			valid4 = _valid0;
			if (valid4) {
				var props1 = {};
				props1.explode = true;
				props1.style = true;
			}
			ifClause0 = "then";
		} else {
			const _errs11 = errors;
			var _valid0 = _errs11 === errors;
			valid4 = _valid0;
			if (valid4) {
				if (props1 !== true) {
					props1 = props1 || {};
					props1.explode = true;
				}
			}
			ifClause0 = "else";
		}
		if (!valid4) {
			const err2 = {
				instancePath,
				schemaPath: "#/$defs/styles-for-form/if",
				keyword: "if",
				params: { failingKeyword: ifClause0 },
				message: 'must match "' + ifClause0 + '" schema',
				schema: schema60.if,
				parentSchema: schema60,
				data,
			};
			if (vErrors === null) {
				vErrors = [err2];
			} else {
				vErrors.push(err2);
			}
			errors++;
			validate47.errors = vErrors;
			return false;
		}
		var valid0 = _errs5 === errors;
		if (valid0) {
			if (props0 !== true && props1 !== undefined) {
				if (props1 === true) {
					props0 = true;
				} else {
					props0 = props0 || {};
					Object.assign(props0, props1);
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.contentType = true;
				props0.headers = true;
				props0.style = true;
				props0.explode = true;
				props0.allowReserved = true;
			}
			if (data.contentType !== undefined) {
				let data1 = data.contentType;
				const _errs12 = errors;
				if (errors === _errs12) {
					if (errors === _errs12) {
						if (!(typeof data1 === "string")) {
							validate47.errors = [
								{
									instancePath: instancePath + "/contentType",
									schemaPath: "#/properties/contentType/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema58.properties.contentType.type,
									parentSchema: schema58.properties.contentType,
									data: data1,
								},
							];
							return false;
						}
					}
				}
				var valid6 = _errs12 === errors;
			} else {
				var valid6 = true;
			}
			if (valid6) {
				if (data.headers !== undefined) {
					let data2 = data.headers;
					const _errs14 = errors;
					if (errors === _errs14) {
						if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
							for (const key1 in data2) {
								const _errs17 = errors;
								if (
									!validate48(data2[key1], {
										instancePath:
											instancePath +
											"/headers/" +
											key1.replace(/~/g, "~0").replace(/\//g, "~1"),
										parentData: data2,
										parentDataProperty: key1,
										rootData,
										dynamicAnchors,
									})
								) {
									vErrors =
										vErrors === null
											? validate48.errors
											: vErrors.concat(validate48.errors);
									errors = vErrors.length;
								}
								var valid7 = _errs17 === errors;
								if (!valid7) {
									break;
								}
							}
						} else {
							validate47.errors = [
								{
									instancePath: instancePath + "/headers",
									schemaPath: "#/properties/headers/type",
									keyword: "type",
									params: { type: "object" },
									message: "must be object",
									schema: schema58.properties.headers.type,
									parentSchema: schema58.properties.headers,
									data: data2,
								},
							];
							return false;
						}
					}
					var valid6 = _errs14 === errors;
				} else {
					var valid6 = true;
				}
				if (valid6) {
					if (data.style !== undefined) {
						let data4 = data.style;
						const _errs18 = errors;
						if (
							!(
								data4 === "form" ||
								data4 === "spaceDelimited" ||
								data4 === "pipeDelimited" ||
								data4 === "deepObject"
							)
						) {
							validate47.errors = [
								{
									instancePath: instancePath + "/style",
									schemaPath: "#/properties/style/enum",
									keyword: "enum",
									params: { allowedValues: schema58.properties.style.enum },
									message: "must be equal to one of the allowed values",
									schema: schema58.properties.style.enum,
									parentSchema: schema58.properties.style,
									data: data4,
								},
							];
							return false;
						}
						var valid6 = _errs18 === errors;
					} else {
						var valid6 = true;
					}
					if (valid6) {
						if (data.explode !== undefined) {
							let data5 = data.explode;
							const _errs19 = errors;
							if (typeof data5 !== "boolean") {
								validate47.errors = [
									{
										instancePath: instancePath + "/explode",
										schemaPath: "#/properties/explode/type",
										keyword: "type",
										params: { type: "boolean" },
										message: "must be boolean",
										schema: schema58.properties.explode.type,
										parentSchema: schema58.properties.explode,
										data: data5,
									},
								];
								return false;
							}
							var valid6 = _errs19 === errors;
						} else {
							var valid6 = true;
						}
						if (valid6) {
							if (data.allowReserved !== undefined) {
								let data6 = data.allowReserved;
								const _errs21 = errors;
								if (typeof data6 !== "boolean") {
									validate47.errors = [
										{
											instancePath: instancePath + "/allowReserved",
											schemaPath: "#/properties/allowReserved/type",
											keyword: "type",
											params: { type: "boolean" },
											message: "must be boolean",
											schema: schema58.properties.allowReserved.type,
											parentSchema: schema58.properties.allowReserved,
											data: data6,
										},
									];
									return false;
								}
								var valid6 = _errs21 === errors;
							} else {
								var valid6 = true;
							}
							if (valid6) {
								if (props0 !== true) {
									for (const key2 in data) {
										if (!props0 || !props0[key2]) {
											validate47.errors = [
												{
													instancePath,
													schemaPath: "#/unevaluatedProperties",
													keyword: "unevaluatedProperties",
													params: { unevaluatedProperty: key2 },
													message: "must NOT have unevaluated properties",
													schema: false,
													parentSchema: schema58,
													data,
												},
											];
											return false;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate47.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema58.type,
					parentSchema: schema58,
					data,
				},
			];
			return false;
		}
	}
	validate47.errors = vErrors;
	return errors === 0;
}
validate47.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate39(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate39.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs2 = errors;
	const _errs3 = errors;
	if (errors === _errs3) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs2 === errors;
	if (valid0) {
		const _errs5 = errors;
		if (
			!validate40(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate40.errors
					: vErrors.concat(validate40.errors);
			errors = vErrors.length;
		}
		var valid0 = _errs5 === errors;
		if (valid0) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.example = true;
				props0.examples = true;
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.schema = true;
				props0.encoding = true;
			}
			if (data.schema !== undefined) {
				const _errs6 = errors;
				if (
					!validate39(data.schema, {
						instancePath: instancePath + "/schema",
						parentData: data,
						parentDataProperty: "schema",
						rootData,
						dynamicAnchors,
					})
				) {
					vErrors =
						vErrors === null
							? validate39.errors
							: vErrors.concat(validate39.errors);
					errors = vErrors.length;
				}
				var valid3 = _errs6 === errors;
			} else {
				var valid3 = true;
			}
			if (valid3) {
				if (data.encoding !== undefined) {
					let data1 = data.encoding;
					const _errs7 = errors;
					if (errors === _errs7) {
						if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
							for (const key1 in data1) {
								const _errs10 = errors;
								if (
									!validate47(data1[key1], {
										instancePath:
											instancePath +
											"/encoding/" +
											key1.replace(/~/g, "~0").replace(/\//g, "~1"),
										parentData: data1,
										parentDataProperty: key1,
										rootData,
										dynamicAnchors,
									})
								) {
									vErrors =
										vErrors === null
											? validate47.errors
											: vErrors.concat(validate47.errors);
									errors = vErrors.length;
								}
								var valid5 = _errs10 === errors;
								if (!valid5) {
									break;
								}
							}
						} else {
							validate39.errors = [
								{
									instancePath: instancePath + "/encoding",
									schemaPath: "#/properties/encoding/type",
									keyword: "type",
									params: { type: "object" },
									message: "must be object",
									schema: schema52.properties.encoding.type,
									parentSchema: schema52.properties.encoding,
									data: data1,
								},
							];
							return false;
						}
					}
					var valid3 = _errs7 === errors;
				} else {
					var valid3 = true;
				}
				if (valid3) {
					if (props0 !== true) {
						for (const key2 in data) {
							if (!props0 || !props0[key2]) {
								validate39.errors = [
									{
										instancePath,
										schemaPath: "#/unevaluatedProperties",
										keyword: "unevaluatedProperties",
										params: { unevaluatedProperty: key2 },
										message: "must NOT have unevaluated properties",
										schema: false,
										parentSchema: schema52,
										data,
									},
								];
								return false;
								break;
							}
						}
					}
				}
			}
		} else {
			validate39.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema52.type,
					parentSchema: schema52,
					data,
				},
			];
			return false;
		}
	}
	validate39.errors = vErrors;
	return errors === 0;
}
validate39.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate38(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate38.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			for (const key0 in data) {
				const _errs2 = errors;
				var valid0 = _errs2 === errors;
				if (!valid0) {
					const err0 = {
						instancePath,
						schemaPath: "#/propertyNames",
						keyword: "propertyNames",
						params: { propertyName: key0 },
						message: "property name must be valid",
						schema: schema51.propertyNames,
						parentSchema: schema51,
						data,
					};
					if (vErrors === null) {
						vErrors = [err0];
					} else {
						vErrors.push(err0);
					}
					errors++;
					validate38.errors = vErrors;
					return false;
					break;
				}
			}
			if (valid0) {
				for (const key1 in data) {
					const _errs4 = errors;
					if (
						!validate39(data[key1], {
							instancePath:
								instancePath +
								"/" +
								key1.replace(/~/g, "~0").replace(/\//g, "~1"),
							parentData: data,
							parentDataProperty: key1,
							rootData,
							dynamicAnchors,
						})
					) {
						vErrors =
							vErrors === null
								? validate39.errors
								: vErrors.concat(validate39.errors);
						errors = vErrors.length;
					}
					var valid1 = _errs4 === errors;
					if (!valid1) {
						break;
					}
				}
			}
		} else {
			validate38.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema51.type,
					parentSchema: schema51,
					data,
				},
			];
			return false;
		}
	}
	validate38.errors = vErrors;
	return errors === 0;
}
validate38.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate37(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate37.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs1 === errors;
	if (valid0) {
		const _errs4 = errors;
		let valid2 = false;
		let passing0 = null;
		const _errs5 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.schema === undefined && (missing0 = "schema")) {
				const err0 = {
					instancePath,
					schemaPath: "#/oneOf/0/required",
					keyword: "required",
					params: { missingProperty: missing0 },
					message: "must have required property '" + missing0 + "'",
					schema: schema49.oneOf[0].required,
					parentSchema: schema49.oneOf[0],
					data,
				};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		}
		var _valid0 = _errs5 === errors;
		if (_valid0) {
			valid2 = true;
			passing0 = 0;
		}
		const _errs6 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing1;
			if (data.content === undefined && (missing1 = "content")) {
				const err1 = {
					instancePath,
					schemaPath: "#/oneOf/1/required",
					keyword: "required",
					params: { missingProperty: missing1 },
					message: "must have required property '" + missing1 + "'",
					schema: schema49.oneOf[1].required,
					parentSchema: schema49.oneOf[1],
					data,
				};
				if (vErrors === null) {
					vErrors = [err1];
				} else {
					vErrors.push(err1);
				}
				errors++;
			}
		}
		var _valid0 = _errs6 === errors;
		if (_valid0 && valid2) {
			valid2 = false;
			passing0 = [passing0, 1];
		} else {
			if (_valid0) {
				valid2 = true;
				passing0 = 1;
			}
		}
		if (!valid2) {
			const err2 = {
				instancePath,
				schemaPath: "#/oneOf",
				keyword: "oneOf",
				params: { passingSchemas: passing0 },
				message: "must match exactly one schema in oneOf",
				schema: schema49.oneOf,
				parentSchema: schema49,
				data,
			};
			if (vErrors === null) {
				vErrors = [err2];
			} else {
				vErrors.push(err2);
			}
			errors++;
			validate37.errors = vErrors;
			return false;
		} else {
			errors = _errs4;
			if (vErrors !== null) {
				if (_errs4) {
					vErrors.length = _errs4;
				} else {
					vErrors = null;
				}
			}
			const _errs7 = errors;
			let valid3 = true;
			const _errs8 = errors;
			if (data && typeof data == "object" && !Array.isArray(data)) {
				let missing2;
				if (data.in === undefined && (missing2 = "in")) {
					const err3 = {};
					if (vErrors === null) {
						vErrors = [err3];
					} else {
						vErrors.push(err3);
					}
					errors++;
				} else {
					if (data.in !== undefined) {
						if ("query" !== data.in) {
							const err4 = {};
							if (vErrors === null) {
								vErrors = [err4];
							} else {
								vErrors.push(err4);
							}
							errors++;
						}
					}
				}
			}
			var _valid1 = _errs8 === errors;
			if (props0 !== true) {
				props0 = props0 || {};
				props0.in = true;
			}
			errors = _errs7;
			if (vErrors !== null) {
				if (_errs7) {
					vErrors.length = _errs7;
				} else {
					vErrors = null;
				}
			}
			if (_valid1) {
				const _errs10 = errors;
				if (data && typeof data == "object" && !Array.isArray(data)) {
					if (data.allowEmptyValue !== undefined) {
						let data1 = data.allowEmptyValue;
						if (typeof data1 !== "boolean") {
							validate37.errors = [
								{
									instancePath: instancePath + "/allowEmptyValue",
									schemaPath: "#/then/properties/allowEmptyValue/type",
									keyword: "type",
									params: { type: "boolean" },
									message: "must be boolean",
									schema: schema49.then.properties.allowEmptyValue.type,
									parentSchema: schema49.then.properties.allowEmptyValue,
									data: data1,
								},
							];
							return false;
						}
					}
				}
				var _valid1 = _errs10 === errors;
				valid3 = _valid1;
				if (valid3) {
					if (props0 !== true) {
						props0 = props0 || {};
						props0.allowEmptyValue = true;
					}
				}
			}
			if (!valid3) {
				const err5 = {
					instancePath,
					schemaPath: "#/if",
					keyword: "if",
					params: { failingKeyword: "then" },
					message: 'must match "then" schema',
					schema: schema49.if,
					parentSchema: schema49,
					data,
				};
				if (vErrors === null) {
					vErrors = [err5];
				} else {
					vErrors.push(err5);
				}
				errors++;
				validate37.errors = vErrors;
				return false;
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing3;
			if (
				(data.name === undefined && (missing3 = "name")) ||
				(data.in === undefined && (missing3 = "in"))
			) {
				validate37.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing3 },
						message: "must have required property '" + missing3 + "'",
						schema: schema49.required,
						parentSchema: schema49,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.name = true;
					props0.in = true;
					props0.description = true;
					props0.required = true;
					props0.deprecated = true;
					props0.schema = true;
					props0.content = true;
				}
				if (data.name !== undefined) {
					let data2 = data.name;
					const _errs13 = errors;
					if (typeof data2 !== "string") {
						validate37.errors = [
							{
								instancePath: instancePath + "/name",
								schemaPath: "#/properties/name/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema49.properties.name.type,
								parentSchema: schema49.properties.name,
								data: data2,
							},
						];
						return false;
					}
					var valid6 = _errs13 === errors;
				} else {
					var valid6 = true;
				}
				if (valid6) {
					if (data.in !== undefined) {
						let data3 = data.in;
						const _errs15 = errors;
						if (
							!(
								data3 === "query" ||
								data3 === "header" ||
								data3 === "path" ||
								data3 === "cookie"
							)
						) {
							validate37.errors = [
								{
									instancePath: instancePath + "/in",
									schemaPath: "#/properties/in/enum",
									keyword: "enum",
									params: { allowedValues: schema49.properties.in.enum },
									message: "must be equal to one of the allowed values",
									schema: schema49.properties.in.enum,
									parentSchema: schema49.properties.in,
									data: data3,
								},
							];
							return false;
						}
						var valid6 = _errs15 === errors;
					} else {
						var valid6 = true;
					}
					if (valid6) {
						if (data.description !== undefined) {
							let data4 = data.description;
							const _errs16 = errors;
							if (typeof data4 !== "string") {
								validate37.errors = [
									{
										instancePath: instancePath + "/description",
										schemaPath: "#/properties/description/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema49.properties.description.type,
										parentSchema: schema49.properties.description,
										data: data4,
									},
								];
								return false;
							}
							var valid6 = _errs16 === errors;
						} else {
							var valid6 = true;
						}
						if (valid6) {
							if (data.required !== undefined) {
								let data5 = data.required;
								const _errs18 = errors;
								if (typeof data5 !== "boolean") {
									validate37.errors = [
										{
											instancePath: instancePath + "/required",
											schemaPath: "#/properties/required/type",
											keyword: "type",
											params: { type: "boolean" },
											message: "must be boolean",
											schema: schema49.properties.required.type,
											parentSchema: schema49.properties.required,
											data: data5,
										},
									];
									return false;
								}
								var valid6 = _errs18 === errors;
							} else {
								var valid6 = true;
							}
							if (valid6) {
								if (data.deprecated !== undefined) {
									let data6 = data.deprecated;
									const _errs20 = errors;
									if (typeof data6 !== "boolean") {
										validate37.errors = [
											{
												instancePath: instancePath + "/deprecated",
												schemaPath: "#/properties/deprecated/type",
												keyword: "type",
												params: { type: "boolean" },
												message: "must be boolean",
												schema: schema49.properties.deprecated.type,
												parentSchema: schema49.properties.deprecated,
												data: data6,
											},
										];
										return false;
									}
									var valid6 = _errs20 === errors;
								} else {
									var valid6 = true;
								}
								if (valid6) {
									if (data.schema !== undefined) {
										const _errs22 = errors;
										if (
											!validate37(data.schema, {
												instancePath: instancePath + "/schema",
												parentData: data,
												parentDataProperty: "schema",
												rootData,
												dynamicAnchors,
											})
										) {
											vErrors =
												vErrors === null
													? validate37.errors
													: vErrors.concat(validate37.errors);
											errors = vErrors.length;
										}
										var valid6 = _errs22 === errors;
									} else {
										var valid6 = true;
									}
									if (valid6) {
										if (data.content !== undefined) {
											let data8 = data.content;
											const _errs23 = errors;
											if (
												!validate38(data8, {
													instancePath: instancePath + "/content",
													parentData: data,
													parentDataProperty: "content",
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate38.errors
														: vErrors.concat(validate38.errors);
												errors = vErrors.length;
											}
											if (errors === _errs23) {
												if (
													data8 &&
													typeof data8 == "object" &&
													!Array.isArray(data8)
												) {
													if (Object.keys(data8).length > 1) {
														validate37.errors = [
															{
																instancePath: instancePath + "/content",
																schemaPath:
																	"#/properties/content/maxProperties",
																keyword: "maxProperties",
																params: { limit: 1 },
																message: "must NOT have more than 1 properties",
																schema: 1,
																parentSchema: schema49.properties.content,
																data: data8,
															},
														];
														return false;
													} else {
														if (Object.keys(data8).length < 1) {
															validate37.errors = [
																{
																	instancePath: instancePath + "/content",
																	schemaPath:
																		"#/properties/content/minProperties",
																	keyword: "minProperties",
																	params: { limit: 1 },
																	message:
																		"must NOT have fewer than 1 properties",
																	schema: 1,
																	parentSchema: schema49.properties.content,
																	data: data8,
																},
															];
															return false;
														}
													}
												}
											}
											var valid6 = _errs23 === errors;
										} else {
											var valid6 = true;
										}
										if (valid6) {
											if (data.schema !== undefined) {
												const _errs24 = errors;
												const _errs25 = errors;
												if (
													!validate40(data, {
														instancePath,
														parentData,
														parentDataProperty,
														rootData,
														dynamicAnchors,
													})
												) {
													vErrors =
														vErrors === null
															? validate40.errors
															: vErrors.concat(validate40.errors);
													errors = vErrors.length;
												}
												var valid9 = _errs25 === errors;
												if (valid9) {
													const _errs26 = errors;
													const _errs28 = errors;
													let valid11 = true;
													const _errs29 = errors;
													if (
														data &&
														typeof data == "object" &&
														!Array.isArray(data)
													) {
														let missing4;
														if (data.in === undefined && (missing4 = "in")) {
															const err6 = {};
															if (vErrors === null) {
																vErrors = [err6];
															} else {
																vErrors.push(err6);
															}
															errors++;
														} else {
															if (data.in !== undefined) {
																if ("path" !== data.in) {
																	const err7 = {};
																	if (vErrors === null) {
																		vErrors = [err7];
																	} else {
																		vErrors.push(err7);
																	}
																	errors++;
																}
															}
														}
													}
													var _valid2 = _errs29 === errors;
													errors = _errs28;
													if (vErrors !== null) {
														if (_errs28) {
															vErrors.length = _errs28;
														} else {
															vErrors = null;
														}
													}
													if (_valid2) {
														const _errs31 = errors;
														if (
															data &&
															typeof data == "object" &&
															!Array.isArray(data)
														) {
															let missing5;
															if (
																data.required === undefined &&
																(missing5 = "required")
															) {
																validate37.errors = [
																	{
																		instancePath,
																		schemaPath:
																			"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path/then/required",
																		keyword: "required",
																		params: { missingProperty: missing5 },
																		message:
																			"must have required property '" +
																			missing5 +
																			"'",
																		schema: schema64.then.required,
																		parentSchema: schema64.then,
																		data,
																	},
																];
																return false;
															} else {
																if (data.style !== undefined) {
																	let data10 = data.style;
																	const _errs32 = errors;
																	if (
																		!(
																			data10 === "matrix" ||
																			data10 === "label" ||
																			data10 === "simple"
																		)
																	) {
																		validate37.errors = [
																			{
																				instancePath: instancePath + "/style",
																				schemaPath:
																					"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path/then/properties/style/enum",
																				keyword: "enum",
																				params: {
																					allowedValues:
																						schema64.then.properties.style.enum,
																				},
																				message:
																					"must be equal to one of the allowed values",
																				schema:
																					schema64.then.properties.style.enum,
																				parentSchema:
																					schema64.then.properties.style,
																				data: data10,
																			},
																		];
																		return false;
																	}
																	var valid13 = _errs32 === errors;
																} else {
																	var valid13 = true;
																}
																if (valid13) {
																	if (data.required !== undefined) {
																		let data11 = data.required;
																		const _errs33 = errors;
																		if (true !== data11) {
																			validate37.errors = [
																				{
																					instancePath:
																						instancePath + "/required",
																					schemaPath:
																						"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path/then/properties/required/const",
																					keyword: "const",
																					params: { allowedValue: true },
																					message: "must be equal to constant",
																					schema: true,
																					parentSchema:
																						schema64.then.properties.required,
																					data: data11,
																				},
																			];
																			return false;
																		}
																		var valid13 = _errs33 === errors;
																	} else {
																		var valid13 = true;
																	}
																}
															}
														}
														var _valid2 = _errs31 === errors;
														valid11 = _valid2;
														if (valid11) {
															var props2 = {};
															props2.style = true;
															props2.required = true;
															props2.in = true;
														}
													}
													if (!valid11) {
														const err8 = {
															instancePath,
															schemaPath:
																"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path/if",
															keyword: "if",
															params: { failingKeyword: "then" },
															message: 'must match "then" schema',
															schema: schema64.if,
															parentSchema: schema64,
															data,
														};
														if (vErrors === null) {
															vErrors = [err8];
														} else {
															vErrors.push(err8);
														}
														errors++;
														validate37.errors = vErrors;
														return false;
													}
													var valid9 = _errs26 === errors;
													if (valid9) {
														if (props2 !== true) {
															props2 = props2 || {};
															props2.example = true;
															props2.examples = true;
														}
														const _errs34 = errors;
														const _errs36 = errors;
														let valid15 = true;
														const _errs37 = errors;
														if (
															data &&
															typeof data == "object" &&
															!Array.isArray(data)
														) {
															let missing6;
															if (data.in === undefined && (missing6 = "in")) {
																const err9 = {};
																if (vErrors === null) {
																	vErrors = [err9];
																} else {
																	vErrors.push(err9);
																}
																errors++;
															} else {
																if (data.in !== undefined) {
																	if ("header" !== data.in) {
																		const err10 = {};
																		if (vErrors === null) {
																			vErrors = [err10];
																		} else {
																			vErrors.push(err10);
																		}
																		errors++;
																	}
																}
															}
														}
														var _valid3 = _errs37 === errors;
														errors = _errs36;
														if (vErrors !== null) {
															if (_errs36) {
																vErrors.length = _errs36;
															} else {
																vErrors = null;
															}
														}
														if (_valid3) {
															const _errs39 = errors;
															if (
																data &&
																typeof data == "object" &&
																!Array.isArray(data)
															) {
																if (data.style !== undefined) {
																	let data13 = data.style;
																	if ("simple" !== data13) {
																		validate37.errors = [
																			{
																				instancePath: instancePath + "/style",
																				schemaPath:
																					"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header/then/properties/style/const",
																				keyword: "const",
																				params: { allowedValue: "simple" },
																				message: "must be equal to constant",
																				schema: "simple",
																				parentSchema:
																					schema65.then.properties.style,
																				data: data13,
																			},
																		];
																		return false;
																	}
																}
															}
															var _valid3 = _errs39 === errors;
															valid15 = _valid3;
															if (valid15) {
																var props3 = {};
																props3.style = true;
																props3.in = true;
															}
														}
														if (!valid15) {
															const err11 = {
																instancePath,
																schemaPath:
																	"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header/if",
																keyword: "if",
																params: { failingKeyword: "then" },
																message: 'must match "then" schema',
																schema: schema65.if,
																parentSchema: schema65,
																data,
															};
															if (vErrors === null) {
																vErrors = [err11];
															} else {
																vErrors.push(err11);
															}
															errors++;
															validate37.errors = vErrors;
															return false;
														}
														var valid9 = _errs34 === errors;
														if (valid9) {
															if (props2 !== true && props3 !== undefined) {
																if (props3 === true) {
																	props2 = true;
																} else {
																	props2 = props2 || {};
																	Object.assign(props2, props3);
																}
															}
															const _errs41 = errors;
															const _errs43 = errors;
															let valid19 = true;
															const _errs44 = errors;
															if (
																data &&
																typeof data == "object" &&
																!Array.isArray(data)
															) {
																let missing7;
																if (
																	data.in === undefined &&
																	(missing7 = "in")
																) {
																	const err12 = {};
																	if (vErrors === null) {
																		vErrors = [err12];
																	} else {
																		vErrors.push(err12);
																	}
																	errors++;
																} else {
																	if (data.in !== undefined) {
																		if ("query" !== data.in) {
																			const err13 = {};
																			if (vErrors === null) {
																				vErrors = [err13];
																			} else {
																				vErrors.push(err13);
																			}
																			errors++;
																		}
																	}
																}
															}
															var _valid4 = _errs44 === errors;
															errors = _errs43;
															if (vErrors !== null) {
																if (_errs43) {
																	vErrors.length = _errs43;
																} else {
																	vErrors = null;
																}
															}
															if (_valid4) {
																const _errs46 = errors;
																if (
																	data &&
																	typeof data == "object" &&
																	!Array.isArray(data)
																) {
																	if (data.style !== undefined) {
																		let data15 = data.style;
																		const _errs47 = errors;
																		if (
																			!(
																				data15 === "form" ||
																				data15 === "spaceDelimited" ||
																				data15 === "pipeDelimited" ||
																				data15 === "deepObject"
																			)
																		) {
																			validate37.errors = [
																				{
																					instancePath: instancePath + "/style",
																					schemaPath:
																						"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query/then/properties/style/enum",
																					keyword: "enum",
																					params: {
																						allowedValues:
																							schema66.then.properties.style
																								.enum,
																					},
																					message:
																						"must be equal to one of the allowed values",
																					schema:
																						schema66.then.properties.style.enum,
																					parentSchema:
																						schema66.then.properties.style,
																					data: data15,
																				},
																			];
																			return false;
																		}
																		var valid21 = _errs47 === errors;
																	} else {
																		var valid21 = true;
																	}
																	if (valid21) {
																		if (data.allowReserved !== undefined) {
																			let data16 = data.allowReserved;
																			const _errs48 = errors;
																			if (typeof data16 !== "boolean") {
																				validate37.errors = [
																					{
																						instancePath:
																							instancePath + "/allowReserved",
																						schemaPath:
																							"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query/then/properties/allowReserved/type",
																						keyword: "type",
																						params: { type: "boolean" },
																						message: "must be boolean",
																						schema:
																							schema66.then.properties
																								.allowReserved.type,
																						parentSchema:
																							schema66.then.properties
																								.allowReserved,
																						data: data16,
																					},
																				];
																				return false;
																			}
																			var valid21 = _errs48 === errors;
																		} else {
																			var valid21 = true;
																		}
																	}
																}
																var _valid4 = _errs46 === errors;
																valid19 = _valid4;
																if (valid19) {
																	var props4 = {};
																	props4.style = true;
																	props4.allowReserved = true;
																	props4.in = true;
																}
															}
															if (!valid19) {
																const err14 = {
																	instancePath,
																	schemaPath:
																		"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query/if",
																	keyword: "if",
																	params: { failingKeyword: "then" },
																	message: 'must match "then" schema',
																	schema: schema66.if,
																	parentSchema: schema66,
																	data,
																};
																if (vErrors === null) {
																	vErrors = [err14];
																} else {
																	vErrors.push(err14);
																}
																errors++;
																validate37.errors = vErrors;
																return false;
															}
															var valid9 = _errs41 === errors;
															if (valid9) {
																if (props2 !== true && props4 !== undefined) {
																	if (props4 === true) {
																		props2 = true;
																	} else {
																		props2 = props2 || {};
																		Object.assign(props2, props4);
																	}
																}
																const _errs50 = errors;
																const _errs52 = errors;
																let valid23 = true;
																const _errs53 = errors;
																if (
																	data &&
																	typeof data == "object" &&
																	!Array.isArray(data)
																) {
																	let missing8;
																	if (
																		data.in === undefined &&
																		(missing8 = "in")
																	) {
																		const err15 = {};
																		if (vErrors === null) {
																			vErrors = [err15];
																		} else {
																			vErrors.push(err15);
																		}
																		errors++;
																	} else {
																		if (data.in !== undefined) {
																			if ("cookie" !== data.in) {
																				const err16 = {};
																				if (vErrors === null) {
																					vErrors = [err16];
																				} else {
																					vErrors.push(err16);
																				}
																				errors++;
																			}
																		}
																	}
																}
																var _valid5 = _errs53 === errors;
																errors = _errs52;
																if (vErrors !== null) {
																	if (_errs52) {
																		vErrors.length = _errs52;
																	} else {
																		vErrors = null;
																	}
																}
																if (_valid5) {
																	const _errs55 = errors;
																	if (
																		data &&
																		typeof data == "object" &&
																		!Array.isArray(data)
																	) {
																		if (data.style !== undefined) {
																			let data18 = data.style;
																			if ("form" !== data18) {
																				validate37.errors = [
																					{
																						instancePath:
																							instancePath + "/style",
																						schemaPath:
																							"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie/then/properties/style/const",
																						keyword: "const",
																						params: { allowedValue: "form" },
																						message:
																							"must be equal to constant",
																						schema: "form",
																						parentSchema:
																							schema67.then.properties.style,
																						data: data18,
																					},
																				];
																				return false;
																			}
																		}
																	}
																	var _valid5 = _errs55 === errors;
																	valid23 = _valid5;
																	if (valid23) {
																		var props5 = {};
																		props5.style = true;
																		props5.in = true;
																	}
																}
																if (!valid23) {
																	const err17 = {
																		instancePath,
																		schemaPath:
																			"#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie/if",
																		keyword: "if",
																		params: { failingKeyword: "then" },
																		message: 'must match "then" schema',
																		schema: schema67.if,
																		parentSchema: schema67,
																		data,
																	};
																	if (vErrors === null) {
																		vErrors = [err17];
																	} else {
																		vErrors.push(err17);
																	}
																	errors++;
																	validate37.errors = vErrors;
																	return false;
																}
																var valid9 = _errs50 === errors;
																if (valid9) {
																	if (props2 !== true && props5 !== undefined) {
																		if (props5 === true) {
																			props2 = true;
																		} else {
																			props2 = props2 || {};
																			Object.assign(props2, props5);
																		}
																	}
																	const _errs57 = errors;
																	const _errs59 = errors;
																	let valid27 = true;
																	const _errs60 = errors;
																	if (
																		data &&
																		typeof data == "object" &&
																		!Array.isArray(data)
																	) {
																		let missing9;
																		if (
																			data.style === undefined &&
																			(missing9 = "style")
																		) {
																			const err18 = {};
																			if (vErrors === null) {
																				vErrors = [err18];
																			} else {
																				vErrors.push(err18);
																			}
																			errors++;
																		} else {
																			if (data.style !== undefined) {
																				if ("form" !== data.style) {
																					const err19 = {};
																					if (vErrors === null) {
																						vErrors = [err19];
																					} else {
																						vErrors.push(err19);
																					}
																					errors++;
																				}
																			}
																		}
																	}
																	var _valid6 = _errs60 === errors;
																	errors = _errs59;
																	if (vErrors !== null) {
																		if (_errs59) {
																			vErrors.length = _errs59;
																		} else {
																			vErrors = null;
																		}
																	}
																	let ifClause0;
																	if (_valid6) {
																		const _errs62 = errors;
																		var _valid6 = _errs62 === errors;
																		valid27 = _valid6;
																		if (valid27) {
																			var props6 = {};
																			props6.explode = true;
																			props6.style = true;
																		}
																		ifClause0 = "then";
																	} else {
																		const _errs63 = errors;
																		var _valid6 = _errs63 === errors;
																		valid27 = _valid6;
																		if (valid27) {
																			if (props6 !== true) {
																				props6 = props6 || {};
																				props6.explode = true;
																			}
																		}
																		ifClause0 = "else";
																	}
																	if (!valid27) {
																		const err20 = {
																			instancePath,
																			schemaPath: "#/$defs/styles-for-form/if",
																			keyword: "if",
																			params: { failingKeyword: ifClause0 },
																			message:
																				'must match "' + ifClause0 + '" schema',
																			schema: schema60.if,
																			parentSchema: schema60,
																			data,
																		};
																		if (vErrors === null) {
																			vErrors = [err20];
																		} else {
																			vErrors.push(err20);
																		}
																		errors++;
																		validate37.errors = vErrors;
																		return false;
																	}
																	var valid9 = _errs57 === errors;
																	if (valid9) {
																		if (
																			props2 !== true &&
																			props6 !== undefined
																		) {
																			if (props6 === true) {
																				props2 = true;
																			} else {
																				props2 = props2 || {};
																				Object.assign(props2, props6);
																			}
																		}
																	}
																}
															}
														}
													}
												}
												if (errors === _errs24) {
													if (
														data &&
														typeof data == "object" &&
														!Array.isArray(data)
													) {
														if (props2 !== true) {
															props2 = props2 || {};
															props2.style = true;
															props2.explode = true;
														}
														if (data.style !== undefined) {
															let data20 = data.style;
															const _errs64 = errors;
															if (typeof data20 !== "string") {
																validate37.errors = [
																	{
																		instancePath: instancePath + "/style",
																		schemaPath:
																			"#/dependentSchemas/schema/properties/style/type",
																		keyword: "type",
																		params: { type: "string" },
																		message: "must be string",
																		schema:
																			schema49.dependentSchemas.schema
																				.properties.style.type,
																		parentSchema:
																			schema49.dependentSchemas.schema
																				.properties.style,
																		data: data20,
																	},
																];
																return false;
															}
															var valid29 = _errs64 === errors;
														} else {
															var valid29 = true;
														}
														if (valid29) {
															if (data.explode !== undefined) {
																let data21 = data.explode;
																const _errs66 = errors;
																if (typeof data21 !== "boolean") {
																	validate37.errors = [
																		{
																			instancePath: instancePath + "/explode",
																			schemaPath:
																				"#/dependentSchemas/schema/properties/explode/type",
																			keyword: "type",
																			params: { type: "boolean" },
																			message: "must be boolean",
																			schema:
																				schema49.dependentSchemas.schema
																					.properties.explode.type,
																			parentSchema:
																				schema49.dependentSchemas.schema
																					.properties.explode,
																			data: data21,
																		},
																	];
																	return false;
																}
																var valid29 = _errs66 === errors;
															} else {
																var valid29 = true;
															}
														}
													}
												}
												var valid8 = _errs24 === errors;
												if (valid8) {
													if (props0 !== true && props2 !== undefined) {
														if (props2 === true) {
															props0 = true;
														} else {
															props0 = props0 || {};
															Object.assign(props0, props2);
														}
													}
												}
											} else {
												var valid8 = true;
											}
											if (valid8) {
												if (props0 !== true) {
													for (const key1 in data) {
														if (!props0 || !props0[key1]) {
															validate37.errors = [
																{
																	instancePath,
																	schemaPath: "#/unevaluatedProperties",
																	keyword: "unevaluatedProperties",
																	params: { unevaluatedProperty: key1 },
																	message:
																		"must NOT have unevaluated properties",
																	schema: false,
																	parentSchema: schema49,
																	data,
																},
															];
															return false;
															break;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate37.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema49.type,
					parentSchema: schema49,
					data,
				},
			];
			return false;
		}
	}
	validate37.errors = vErrors;
	return errors === 0;
}
validate37.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate34(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate34.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate37(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate37.errors
					: vErrors.concat(validate37.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema47.if,
			parentSchema: schema47,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate34.errors = vErrors;
		return false;
	}
	validate34.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate34.evaluated = { dynamicProps: true, dynamicItems: false };
const schema69 = {
	$comment: "https://spec.openapis.org/oas/v3.1#operation-object",
	type: "object",
	properties: {
		tags: { type: "array", items: { type: "string" } },
		summary: { type: "string" },
		description: { type: "string" },
		externalDocs: { $ref: "#/$defs/external-documentation" },
		operationId: { type: "string" },
		parameters: {
			type: "array",
			items: { $ref: "#/$defs/parameter-or-reference" },
		},
		requestBody: { $ref: "#/$defs/request-body-or-reference" },
		responses: { $ref: "#/$defs/responses" },
		callbacks: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/callbacks-or-reference" },
		},
		deprecated: { default: false, type: "boolean" },
		security: {
			type: "array",
			items: { $ref: "#/$defs/security-requirement" },
		},
		servers: { type: "array", items: { $ref: "#/$defs/server" } },
	},
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const schema71 = {
	$comment: "https://spec.openapis.org/oas/v3.1#external-documentation-object",
	type: "object",
	properties: {
		description: { type: "string" },
		url: { type: "string", format: "uri-reference" },
	},
	required: ["url"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate61(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate61.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.url === undefined && (missing0 = "url")) {
				validate61.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema71.required,
						parentSchema: schema71,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.description = true;
					props0.url = true;
				}
				if (data.description !== undefined) {
					let data0 = data.description;
					const _errs4 = errors;
					if (typeof data0 !== "string") {
						validate61.errors = [
							{
								instancePath: instancePath + "/description",
								schemaPath: "#/properties/description/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema71.properties.description.type,
								parentSchema: schema71.properties.description,
								data: data0,
							},
						];
						return false;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.url !== undefined) {
						let data1 = data.url;
						const _errs6 = errors;
						if (errors === _errs6) {
							if (errors === _errs6) {
								if (typeof data1 === "string") {
									if (!formats0.test(data1)) {
										validate61.errors = [
											{
												instancePath: instancePath + "/url",
												schemaPath: "#/properties/url/format",
												keyword: "format",
												params: { format: "uri-reference" },
												message: 'must match format "' + "uri-reference" + '"',
												schema: "uri-reference",
												parentSchema: schema71.properties.url,
												data: data1,
											},
										];
										return false;
									}
								} else {
									validate61.errors = [
										{
											instancePath: instancePath + "/url",
											schemaPath: "#/properties/url/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema71.properties.url.type,
											parentSchema: schema71.properties.url,
											data: data1,
										},
									];
									return false;
								}
							}
						}
						var valid2 = _errs6 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (props0 !== true) {
							for (const key1 in data) {
								if (!props0 || !props0[key1]) {
									validate61.errors = [
										{
											instancePath,
											schemaPath: "#/unevaluatedProperties",
											keyword: "unevaluatedProperties",
											params: { unevaluatedProperty: key1 },
											message: "must NOT have unevaluated properties",
											schema: false,
											parentSchema: schema71,
											data,
										},
									];
									return false;
									break;
								}
							}
						}
					}
				}
			}
		} else {
			validate61.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema71.type,
					parentSchema: schema71,
					data,
				},
			];
			return false;
		}
	}
	validate61.errors = vErrors;
	return errors === 0;
}
validate61.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema73 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/request-body" },
};
const schema74 = {
	$comment: "https://spec.openapis.org/oas/v3.1#request-body-object",
	type: "object",
	properties: {
		description: { type: "string" },
		content: { $ref: "#/$defs/content" },
		required: { default: false, type: "boolean" },
	},
	required: ["content"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate66(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate66.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.content === undefined && (missing0 = "content")) {
				validate66.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema74.required,
						parentSchema: schema74,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.description = true;
					props0.content = true;
					props0.required = true;
				}
				if (data.description !== undefined) {
					let data0 = data.description;
					const _errs4 = errors;
					if (typeof data0 !== "string") {
						validate66.errors = [
							{
								instancePath: instancePath + "/description",
								schemaPath: "#/properties/description/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema74.properties.description.type,
								parentSchema: schema74.properties.description,
								data: data0,
							},
						];
						return false;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.content !== undefined) {
						const _errs6 = errors;
						if (
							!validate38(data.content, {
								instancePath: instancePath + "/content",
								parentData: data,
								parentDataProperty: "content",
								rootData,
								dynamicAnchors,
							})
						) {
							vErrors =
								vErrors === null
									? validate38.errors
									: vErrors.concat(validate38.errors);
							errors = vErrors.length;
						}
						var valid2 = _errs6 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.required !== undefined) {
							let data2 = data.required;
							const _errs7 = errors;
							if (typeof data2 !== "boolean") {
								validate66.errors = [
									{
										instancePath: instancePath + "/required",
										schemaPath: "#/properties/required/type",
										keyword: "type",
										params: { type: "boolean" },
										message: "must be boolean",
										schema: schema74.properties.required.type,
										parentSchema: schema74.properties.required,
										data: data2,
									},
								];
								return false;
							}
							var valid2 = _errs7 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key1 in data) {
									if (!props0 || !props0[key1]) {
										validate66.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key1 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema74,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate66.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema74.type,
					parentSchema: schema74,
					data,
				},
			];
			return false;
		}
	}
	validate66.errors = vErrors;
	return errors === 0;
}
validate66.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate64(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate64.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate66(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate66.errors
					: vErrors.concat(validate66.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema73.if,
			parentSchema: schema73,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate64.errors = vErrors;
		return false;
	}
	validate64.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate64.evaluated = { dynamicProps: true, dynamicItems: false };
const schema76 = {
	$comment: "https://spec.openapis.org/oas/v3.1#responses-object",
	type: "object",
	properties: { default: { $ref: "#/$defs/response-or-reference" } },
	patternProperties: {
		"^[1-5](?:[0-9]{2}|XX)$": { $ref: "#/$defs/response-or-reference" },
	},
	minProperties: 1,
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
	if: {
		$comment:
			"either default, or at least one response code property must exist",
		patternProperties: { "^[1-5](?:[0-9]{2}|XX)$": false },
	},
	then: { required: ["default"] },
};
const pattern23 = new RegExp("^[1-5](?:[0-9]{2}|XX)$", "u");
const schema78 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/response" },
};
const schema79 = {
	$comment: "https://spec.openapis.org/oas/v3.1#response-object",
	type: "object",
	properties: {
		description: { type: "string" },
		headers: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/header-or-reference" },
		},
		content: { $ref: "#/$defs/content" },
		links: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/link-or-reference" },
		},
	},
	required: ["description"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const schema81 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/link" },
};
const schema82 = {
	$comment: "https://spec.openapis.org/oas/v3.1#link-object",
	type: "object",
	properties: {
		operationRef: { type: "string", format: "uri-reference" },
		operationId: { type: "string" },
		parameters: { $ref: "#/$defs/map-of-strings" },
		requestBody: true,
		description: { type: "string" },
		body: { $ref: "#/$defs/server" },
	},
	oneOf: [{ required: ["operationRef"] }, { required: ["operationId"] }],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const schema84 = { type: "object", additionalProperties: { type: "string" } };
function validate78(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate78.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs1 === errors;
	if (valid0) {
		const _errs4 = errors;
		let valid2 = false;
		let passing0 = null;
		const _errs5 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.operationRef === undefined && (missing0 = "operationRef")) {
				const err0 = {
					instancePath,
					schemaPath: "#/oneOf/0/required",
					keyword: "required",
					params: { missingProperty: missing0 },
					message: "must have required property '" + missing0 + "'",
					schema: schema82.oneOf[0].required,
					parentSchema: schema82.oneOf[0],
					data,
				};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		}
		var _valid0 = _errs5 === errors;
		if (_valid0) {
			valid2 = true;
			passing0 = 0;
		}
		const _errs6 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing1;
			if (data.operationId === undefined && (missing1 = "operationId")) {
				const err1 = {
					instancePath,
					schemaPath: "#/oneOf/1/required",
					keyword: "required",
					params: { missingProperty: missing1 },
					message: "must have required property '" + missing1 + "'",
					schema: schema82.oneOf[1].required,
					parentSchema: schema82.oneOf[1],
					data,
				};
				if (vErrors === null) {
					vErrors = [err1];
				} else {
					vErrors.push(err1);
				}
				errors++;
			}
		}
		var _valid0 = _errs6 === errors;
		if (_valid0 && valid2) {
			valid2 = false;
			passing0 = [passing0, 1];
		} else {
			if (_valid0) {
				valid2 = true;
				passing0 = 1;
			}
		}
		if (!valid2) {
			const err2 = {
				instancePath,
				schemaPath: "#/oneOf",
				keyword: "oneOf",
				params: { passingSchemas: passing0 },
				message: "must match exactly one schema in oneOf",
				schema: schema82.oneOf,
				parentSchema: schema82,
				data,
			};
			if (vErrors === null) {
				vErrors = [err2];
			} else {
				vErrors.push(err2);
			}
			errors++;
			validate78.errors = vErrors;
			return false;
		} else {
			errors = _errs4;
			if (vErrors !== null) {
				if (_errs4) {
					vErrors.length = _errs4;
				} else {
					vErrors = null;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.operationRef = true;
				props0.operationId = true;
				props0.parameters = true;
				props0.requestBody = true;
				props0.description = true;
				props0.body = true;
			}
			if (data.operationRef !== undefined) {
				let data0 = data.operationRef;
				const _errs7 = errors;
				if (errors === _errs7) {
					if (errors === _errs7) {
						if (typeof data0 === "string") {
							if (!formats0.test(data0)) {
								validate78.errors = [
									{
										instancePath: instancePath + "/operationRef",
										schemaPath: "#/properties/operationRef/format",
										keyword: "format",
										params: { format: "uri-reference" },
										message: 'must match format "' + "uri-reference" + '"',
										schema: "uri-reference",
										parentSchema: schema82.properties.operationRef,
										data: data0,
									},
								];
								return false;
							}
						} else {
							validate78.errors = [
								{
									instancePath: instancePath + "/operationRef",
									schemaPath: "#/properties/operationRef/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema82.properties.operationRef.type,
									parentSchema: schema82.properties.operationRef,
									data: data0,
								},
							];
							return false;
						}
					}
				}
				var valid3 = _errs7 === errors;
			} else {
				var valid3 = true;
			}
			if (valid3) {
				if (data.operationId !== undefined) {
					let data1 = data.operationId;
					const _errs9 = errors;
					if (typeof data1 !== "string") {
						validate78.errors = [
							{
								instancePath: instancePath + "/operationId",
								schemaPath: "#/properties/operationId/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema82.properties.operationId.type,
								parentSchema: schema82.properties.operationId,
								data: data1,
							},
						];
						return false;
					}
					var valid3 = _errs9 === errors;
				} else {
					var valid3 = true;
				}
				if (valid3) {
					if (data.parameters !== undefined) {
						let data2 = data.parameters;
						const _errs11 = errors;
						const _errs12 = errors;
						if (errors === _errs12) {
							if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
								for (const key1 in data2) {
									let data3 = data2[key1];
									const _errs15 = errors;
									if (typeof data3 !== "string") {
										validate78.errors = [
											{
												instancePath:
													instancePath +
													"/parameters/" +
													key1.replace(/~/g, "~0").replace(/\//g, "~1"),
												schemaPath:
													"#/$defs/map-of-strings/additionalProperties/type",
												keyword: "type",
												params: { type: "string" },
												message: "must be string",
												schema: schema84.additionalProperties.type,
												parentSchema: schema84.additionalProperties,
												data: data3,
											},
										];
										return false;
									}
									var valid5 = _errs15 === errors;
									if (!valid5) {
										break;
									}
								}
							} else {
								validate78.errors = [
									{
										instancePath: instancePath + "/parameters",
										schemaPath: "#/$defs/map-of-strings/type",
										keyword: "type",
										params: { type: "object" },
										message: "must be object",
										schema: schema84.type,
										parentSchema: schema84,
										data: data2,
									},
								];
								return false;
							}
						}
						var valid3 = _errs11 === errors;
					} else {
						var valid3 = true;
					}
					if (valid3) {
						if (data.description !== undefined) {
							let data4 = data.description;
							const _errs17 = errors;
							if (typeof data4 !== "string") {
								validate78.errors = [
									{
										instancePath: instancePath + "/description",
										schemaPath: "#/properties/description/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema82.properties.description.type,
										parentSchema: schema82.properties.description,
										data: data4,
									},
								];
								return false;
							}
							var valid3 = _errs17 === errors;
						} else {
							var valid3 = true;
						}
						if (valid3) {
							if (data.body !== undefined) {
								const _errs19 = errors;
								if (
									!validate27(data.body, {
										instancePath: instancePath + "/body",
										parentData: data,
										parentDataProperty: "body",
										rootData,
										dynamicAnchors,
									})
								) {
									vErrors =
										vErrors === null
											? validate27.errors
											: vErrors.concat(validate27.errors);
									errors = vErrors.length;
								}
								var valid3 = _errs19 === errors;
							} else {
								var valid3 = true;
							}
							if (valid3) {
								if (props0 !== true) {
									for (const key2 in data) {
										if (!props0 || !props0[key2]) {
											validate78.errors = [
												{
													instancePath,
													schemaPath: "#/unevaluatedProperties",
													keyword: "unevaluatedProperties",
													params: { unevaluatedProperty: key2 },
													message: "must NOT have unevaluated properties",
													schema: false,
													parentSchema: schema82,
													data,
												},
											];
											return false;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate78.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema82.type,
					parentSchema: schema82,
					data,
				},
			];
			return false;
		}
	}
	validate78.errors = vErrors;
	return errors === 0;
}
validate78.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate76(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate76.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate78(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate78.errors
					: vErrors.concat(validate78.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema81.if,
			parentSchema: schema81,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate76.errors = vErrors;
		return false;
	}
	validate76.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate76.evaluated = { dynamicProps: true, dynamicItems: false };
function validate73(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate73.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.description === undefined && (missing0 = "description")) {
				validate73.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema79.required,
						parentSchema: schema79,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.description = true;
					props0.headers = true;
					props0.content = true;
					props0.links = true;
				}
				if (data.description !== undefined) {
					let data0 = data.description;
					const _errs4 = errors;
					if (typeof data0 !== "string") {
						validate73.errors = [
							{
								instancePath: instancePath + "/description",
								schemaPath: "#/properties/description/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema79.properties.description.type,
								parentSchema: schema79.properties.description,
								data: data0,
							},
						];
						return false;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.headers !== undefined) {
						let data1 = data.headers;
						const _errs6 = errors;
						if (errors === _errs6) {
							if (data1 && typeof data1 == "object" && !Array.isArray(data1)) {
								for (const key1 in data1) {
									const _errs9 = errors;
									if (
										!validate48(data1[key1], {
											instancePath:
												instancePath +
												"/headers/" +
												key1.replace(/~/g, "~0").replace(/\//g, "~1"),
											parentData: data1,
											parentDataProperty: key1,
											rootData,
											dynamicAnchors,
										})
									) {
										vErrors =
											vErrors === null
												? validate48.errors
												: vErrors.concat(validate48.errors);
										errors = vErrors.length;
									}
									var valid3 = _errs9 === errors;
									if (!valid3) {
										break;
									}
								}
							} else {
								validate73.errors = [
									{
										instancePath: instancePath + "/headers",
										schemaPath: "#/properties/headers/type",
										keyword: "type",
										params: { type: "object" },
										message: "must be object",
										schema: schema79.properties.headers.type,
										parentSchema: schema79.properties.headers,
										data: data1,
									},
								];
								return false;
							}
						}
						var valid2 = _errs6 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.content !== undefined) {
							const _errs10 = errors;
							if (
								!validate38(data.content, {
									instancePath: instancePath + "/content",
									parentData: data,
									parentDataProperty: "content",
									rootData,
									dynamicAnchors,
								})
							) {
								vErrors =
									vErrors === null
										? validate38.errors
										: vErrors.concat(validate38.errors);
								errors = vErrors.length;
							}
							var valid2 = _errs10 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (data.links !== undefined) {
								let data4 = data.links;
								const _errs11 = errors;
								if (errors === _errs11) {
									if (
										data4 &&
										typeof data4 == "object" &&
										!Array.isArray(data4)
									) {
										for (const key2 in data4) {
											const _errs14 = errors;
											if (
												!validate76(data4[key2], {
													instancePath:
														instancePath +
														"/links/" +
														key2.replace(/~/g, "~0").replace(/\//g, "~1"),
													parentData: data4,
													parentDataProperty: key2,
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate76.errors
														: vErrors.concat(validate76.errors);
												errors = vErrors.length;
											}
											var valid4 = _errs14 === errors;
											if (!valid4) {
												break;
											}
										}
									} else {
										validate73.errors = [
											{
												instancePath: instancePath + "/links",
												schemaPath: "#/properties/links/type",
												keyword: "type",
												params: { type: "object" },
												message: "must be object",
												schema: schema79.properties.links.type,
												parentSchema: schema79.properties.links,
												data: data4,
											},
										];
										return false;
									}
								}
								var valid2 = _errs11 === errors;
							} else {
								var valid2 = true;
							}
							if (valid2) {
								if (props0 !== true) {
									for (const key3 in data) {
										if (!props0 || !props0[key3]) {
											validate73.errors = [
												{
													instancePath,
													schemaPath: "#/unevaluatedProperties",
													keyword: "unevaluatedProperties",
													params: { unevaluatedProperty: key3 },
													message: "must NOT have unevaluated properties",
													schema: false,
													parentSchema: schema79,
													data,
												},
											];
											return false;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate73.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema79.type,
					parentSchema: schema79,
					data,
				},
			];
			return false;
		}
	}
	validate73.errors = vErrors;
	return errors === 0;
}
validate73.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate71(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate71.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate73(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate73.errors
					: vErrors.concat(validate73.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema78.if,
			parentSchema: schema78,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate71.errors = vErrors;
		return false;
	}
	validate71.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate71.evaluated = { dynamicProps: true, dynamicItems: false };
function validate70(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate70.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs1 === errors;
	if (valid0) {
		const _errs4 = errors;
		let valid2 = true;
		const _errs5 = errors;
		if (errors === _errs5) {
			if (data && typeof data == "object" && !Array.isArray(data)) {
				var props1 = {};
				for (const key1 in data) {
					if (pattern23.test(key1)) {
						const err0 = {};
						if (vErrors === null) {
							vErrors = [err0];
						} else {
							vErrors.push(err0);
						}
						errors++;
						props1[key1] = true;
					}
				}
			}
		}
		var _valid0 = _errs5 === errors;
		if (props0 !== true && props1 !== undefined) {
			if (props1 === true) {
				props0 = true;
			} else {
				props0 = props0 || {};
				Object.assign(props0, props1);
			}
		}
		errors = _errs4;
		if (vErrors !== null) {
			if (_errs4) {
				vErrors.length = _errs4;
			} else {
				vErrors = null;
			}
		}
		if (_valid0) {
			const _errs7 = errors;
			if (data && typeof data == "object" && !Array.isArray(data)) {
				let missing0;
				if (data.default === undefined && (missing0 = "default")) {
					validate70.errors = [
						{
							instancePath,
							schemaPath: "#/then/required",
							keyword: "required",
							params: { missingProperty: missing0 },
							message: "must have required property '" + missing0 + "'",
							schema: schema76.then.required,
							parentSchema: schema76.then,
							data,
						},
					];
					return false;
				}
			}
			var _valid0 = _errs7 === errors;
			valid2 = _valid0;
		}
		if (!valid2) {
			const err1 = {
				instancePath,
				schemaPath: "#/if",
				keyword: "if",
				params: { failingKeyword: "then" },
				message: 'must match "then" schema',
				schema: schema76.if,
				parentSchema: schema76,
				data,
			};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
			validate70.errors = vErrors;
			return false;
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (Object.keys(data).length < 1) {
				validate70.errors = [
					{
						instancePath,
						schemaPath: "#/minProperties",
						keyword: "minProperties",
						params: { limit: 1 },
						message: "must NOT have fewer than 1 properties",
						schema: 1,
						parentSchema: schema76,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.default = true;
				}
				if (data.default !== undefined) {
					const _errs8 = errors;
					if (
						!validate71(data.default, {
							instancePath: instancePath + "/default",
							parentData: data,
							parentDataProperty: "default",
							rootData,
							dynamicAnchors,
						})
					) {
						vErrors =
							vErrors === null
								? validate71.errors
								: vErrors.concat(validate71.errors);
						errors = vErrors.length;
					}
					var valid4 = _errs8 === errors;
				} else {
					var valid4 = true;
				}
				if (valid4) {
					var valid5 = true;
					for (const key2 in data) {
						if (pattern23.test(key2)) {
							const _errs9 = errors;
							if (
								!validate71(data[key2], {
									instancePath:
										instancePath +
										"/" +
										key2.replace(/~/g, "~0").replace(/\//g, "~1"),
									parentData: data,
									parentDataProperty: key2,
									rootData,
									dynamicAnchors,
								})
							) {
								vErrors =
									vErrors === null
										? validate71.errors
										: vErrors.concat(validate71.errors);
								errors = vErrors.length;
							}
							var valid5 = _errs9 === errors;
							props0[key2] = true;
						}
					}
					if (valid5) {
						if (props0 !== true) {
							for (const key3 in data) {
								if (!props0 || !props0[key3]) {
									validate70.errors = [
										{
											instancePath,
											schemaPath: "#/unevaluatedProperties",
											keyword: "unevaluatedProperties",
											params: { unevaluatedProperty: key3 },
											message: "must NOT have unevaluated properties",
											schema: false,
											parentSchema: schema76,
											data,
										},
									];
									return false;
									break;
								}
							}
						}
					}
				}
			}
		} else {
			validate70.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema76.type,
					parentSchema: schema76,
					data,
				},
			];
			return false;
		}
	}
	validate70.errors = vErrors;
	return errors === 0;
}
validate70.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema85 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/callbacks" },
};
const schema86 = {
	$comment: "https://spec.openapis.org/oas/v3.1#callback-object",
	type: "object",
	$ref: "#/$defs/specification-extensions",
	additionalProperties: { $ref: "#/$defs/path-item" },
};
const wrapper1 = { validate: validate32 };
function validate88(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate88.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			for (const key1 in data) {
				const _errs5 = errors;
				if (
					!wrapper1.validate(data[key1], {
						instancePath:
							instancePath +
							"/" +
							key1.replace(/~/g, "~0").replace(/\//g, "~1"),
						parentData: data,
						parentDataProperty: key1,
						rootData,
						dynamicAnchors,
					})
				) {
					vErrors =
						vErrors === null
							? wrapper1.validate.errors
							: vErrors.concat(wrapper1.validate.errors);
					errors = vErrors.length;
				}
				var valid2 = _errs5 === errors;
				if (!valid2) {
					break;
				}
			}
		} else {
			validate88.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema86.type,
					parentSchema: schema86,
					data,
				},
			];
			return false;
		}
	}
	validate88.errors = vErrors;
	return errors === 0;
}
validate88.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate86(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate86.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate88(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate88.errors
					: vErrors.concat(validate88.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema85.if,
			parentSchema: schema85,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate86.errors = vErrors;
		return false;
	}
	validate86.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate86.evaluated = { dynamicProps: true, dynamicItems: false };
function validate60(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate60.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.tags = true;
				props0.summary = true;
				props0.description = true;
				props0.externalDocs = true;
				props0.operationId = true;
				props0.parameters = true;
				props0.requestBody = true;
				props0.responses = true;
				props0.callbacks = true;
				props0.deprecated = true;
				props0.security = true;
				props0.servers = true;
			}
			if (data.tags !== undefined) {
				let data0 = data.tags;
				const _errs4 = errors;
				if (errors === _errs4) {
					if (Array.isArray(data0)) {
						var valid3 = true;
						const len0 = data0.length;
						for (let i0 = 0; i0 < len0; i0++) {
							let data1 = data0[i0];
							const _errs6 = errors;
							if (typeof data1 !== "string") {
								validate60.errors = [
									{
										instancePath: instancePath + "/tags/" + i0,
										schemaPath: "#/properties/tags/items/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema69.properties.tags.items.type,
										parentSchema: schema69.properties.tags.items,
										data: data1,
									},
								];
								return false;
							}
							var valid3 = _errs6 === errors;
							if (!valid3) {
								break;
							}
						}
					} else {
						validate60.errors = [
							{
								instancePath: instancePath + "/tags",
								schemaPath: "#/properties/tags/type",
								keyword: "type",
								params: { type: "array" },
								message: "must be array",
								schema: schema69.properties.tags.type,
								parentSchema: schema69.properties.tags,
								data: data0,
							},
						];
						return false;
					}
				}
				var valid2 = _errs4 === errors;
			} else {
				var valid2 = true;
			}
			if (valid2) {
				if (data.summary !== undefined) {
					let data2 = data.summary;
					const _errs8 = errors;
					if (typeof data2 !== "string") {
						validate60.errors = [
							{
								instancePath: instancePath + "/summary",
								schemaPath: "#/properties/summary/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema69.properties.summary.type,
								parentSchema: schema69.properties.summary,
								data: data2,
							},
						];
						return false;
					}
					var valid2 = _errs8 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.description !== undefined) {
						let data3 = data.description;
						const _errs10 = errors;
						if (typeof data3 !== "string") {
							validate60.errors = [
								{
									instancePath: instancePath + "/description",
									schemaPath: "#/properties/description/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema69.properties.description.type,
									parentSchema: schema69.properties.description,
									data: data3,
								},
							];
							return false;
						}
						var valid2 = _errs10 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.externalDocs !== undefined) {
							const _errs12 = errors;
							if (
								!validate61(data.externalDocs, {
									instancePath: instancePath + "/externalDocs",
									parentData: data,
									parentDataProperty: "externalDocs",
									rootData,
									dynamicAnchors,
								})
							) {
								vErrors =
									vErrors === null
										? validate61.errors
										: vErrors.concat(validate61.errors);
								errors = vErrors.length;
							}
							var valid2 = _errs12 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (data.operationId !== undefined) {
								let data5 = data.operationId;
								const _errs13 = errors;
								if (typeof data5 !== "string") {
									validate60.errors = [
										{
											instancePath: instancePath + "/operationId",
											schemaPath: "#/properties/operationId/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema69.properties.operationId.type,
											parentSchema: schema69.properties.operationId,
											data: data5,
										},
									];
									return false;
								}
								var valid2 = _errs13 === errors;
							} else {
								var valid2 = true;
							}
							if (valid2) {
								if (data.parameters !== undefined) {
									let data6 = data.parameters;
									const _errs15 = errors;
									if (errors === _errs15) {
										if (Array.isArray(data6)) {
											var valid4 = true;
											const len1 = data6.length;
											for (let i1 = 0; i1 < len1; i1++) {
												const _errs17 = errors;
												if (
													!validate34(data6[i1], {
														instancePath: instancePath + "/parameters/" + i1,
														parentData: data6,
														parentDataProperty: i1,
														rootData,
														dynamicAnchors,
													})
												) {
													vErrors =
														vErrors === null
															? validate34.errors
															: vErrors.concat(validate34.errors);
													errors = vErrors.length;
												}
												var valid4 = _errs17 === errors;
												if (!valid4) {
													break;
												}
											}
										} else {
											validate60.errors = [
												{
													instancePath: instancePath + "/parameters",
													schemaPath: "#/properties/parameters/type",
													keyword: "type",
													params: { type: "array" },
													message: "must be array",
													schema: schema69.properties.parameters.type,
													parentSchema: schema69.properties.parameters,
													data: data6,
												},
											];
											return false;
										}
									}
									var valid2 = _errs15 === errors;
								} else {
									var valid2 = true;
								}
								if (valid2) {
									if (data.requestBody !== undefined) {
										const _errs18 = errors;
										if (
											!validate64(data.requestBody, {
												instancePath: instancePath + "/requestBody",
												parentData: data,
												parentDataProperty: "requestBody",
												rootData,
												dynamicAnchors,
											})
										) {
											vErrors =
												vErrors === null
													? validate64.errors
													: vErrors.concat(validate64.errors);
											errors = vErrors.length;
										}
										var valid2 = _errs18 === errors;
									} else {
										var valid2 = true;
									}
									if (valid2) {
										if (data.responses !== undefined) {
											const _errs19 = errors;
											if (
												!validate70(data.responses, {
													instancePath: instancePath + "/responses",
													parentData: data,
													parentDataProperty: "responses",
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate70.errors
														: vErrors.concat(validate70.errors);
												errors = vErrors.length;
											}
											var valid2 = _errs19 === errors;
										} else {
											var valid2 = true;
										}
										if (valid2) {
											if (data.callbacks !== undefined) {
												let data10 = data.callbacks;
												const _errs20 = errors;
												if (errors === _errs20) {
													if (
														data10 &&
														typeof data10 == "object" &&
														!Array.isArray(data10)
													) {
														for (const key1 in data10) {
															const _errs23 = errors;
															if (
																!validate86(data10[key1], {
																	instancePath:
																		instancePath +
																		"/callbacks/" +
																		key1
																			.replace(/~/g, "~0")
																			.replace(/\//g, "~1"),
																	parentData: data10,
																	parentDataProperty: key1,
																	rootData,
																	dynamicAnchors,
																})
															) {
																vErrors =
																	vErrors === null
																		? validate86.errors
																		: vErrors.concat(validate86.errors);
																errors = vErrors.length;
															}
															var valid5 = _errs23 === errors;
															if (!valid5) {
																break;
															}
														}
													} else {
														validate60.errors = [
															{
																instancePath: instancePath + "/callbacks",
																schemaPath: "#/properties/callbacks/type",
																keyword: "type",
																params: { type: "object" },
																message: "must be object",
																schema: schema69.properties.callbacks.type,
																parentSchema: schema69.properties.callbacks,
																data: data10,
															},
														];
														return false;
													}
												}
												var valid2 = _errs20 === errors;
											} else {
												var valid2 = true;
											}
											if (valid2) {
												if (data.deprecated !== undefined) {
													let data12 = data.deprecated;
													const _errs24 = errors;
													if (typeof data12 !== "boolean") {
														validate60.errors = [
															{
																instancePath: instancePath + "/deprecated",
																schemaPath: "#/properties/deprecated/type",
																keyword: "type",
																params: { type: "boolean" },
																message: "must be boolean",
																schema: schema69.properties.deprecated.type,
																parentSchema: schema69.properties.deprecated,
																data: data12,
															},
														];
														return false;
													}
													var valid2 = _errs24 === errors;
												} else {
													var valid2 = true;
												}
												if (valid2) {
													if (data.security !== undefined) {
														let data13 = data.security;
														const _errs26 = errors;
														if (errors === _errs26) {
															if (Array.isArray(data13)) {
																var valid6 = true;
																const len2 = data13.length;
																for (let i2 = 0; i2 < len2; i2++) {
																	let data14 = data13[i2];
																	const _errs28 = errors;
																	const _errs29 = errors;
																	if (errors === _errs29) {
																		if (
																			data14 &&
																			typeof data14 == "object" &&
																			!Array.isArray(data14)
																		) {
																			for (const key2 in data14) {
																				let data15 = data14[key2];
																				const _errs33 = errors;
																				if (errors === _errs33) {
																					if (Array.isArray(data15)) {
																						var valid9 = true;
																						const len3 = data15.length;
																						for (let i3 = 0; i3 < len3; i3++) {
																							let data16 = data15[i3];
																							const _errs35 = errors;
																							if (typeof data16 !== "string") {
																								validate60.errors = [
																									{
																										instancePath:
																											instancePath +
																											"/security/" +
																											i2 +
																											"/" +
																											key2
																												.replace(/~/g, "~0")
																												.replace(/\//g, "~1") +
																											"/" +
																											i3,
																										schemaPath:
																											"#/$defs/security-requirement/additionalProperties/items/type",
																										keyword: "type",
																										params: { type: "string" },
																										message: "must be string",
																										schema:
																											schema88
																												.additionalProperties
																												.items.type,
																										parentSchema:
																											schema88
																												.additionalProperties
																												.items,
																										data: data16,
																									},
																								];
																								return false;
																							}
																							var valid9 = _errs35 === errors;
																							if (!valid9) {
																								break;
																							}
																						}
																					} else {
																						validate60.errors = [
																							{
																								instancePath:
																									instancePath +
																									"/security/" +
																									i2 +
																									"/" +
																									key2
																										.replace(/~/g, "~0")
																										.replace(/\//g, "~1"),
																								schemaPath:
																									"#/$defs/security-requirement/additionalProperties/type",
																								keyword: "type",
																								params: { type: "array" },
																								message: "must be array",
																								schema:
																									schema88.additionalProperties
																										.type,
																								parentSchema:
																									schema88.additionalProperties,
																								data: data15,
																							},
																						];
																						return false;
																					}
																				}
																				var valid8 = _errs33 === errors;
																				if (!valid8) {
																					break;
																				}
																			}
																		} else {
																			validate60.errors = [
																				{
																					instancePath:
																						instancePath + "/security/" + i2,
																					schemaPath:
																						"#/$defs/security-requirement/type",
																					keyword: "type",
																					params: { type: "object" },
																					message: "must be object",
																					schema: schema88.type,
																					parentSchema: schema88,
																					data: data14,
																				},
																			];
																			return false;
																		}
																	}
																	var valid6 = _errs28 === errors;
																	if (!valid6) {
																		break;
																	}
																}
															} else {
																validate60.errors = [
																	{
																		instancePath: instancePath + "/security",
																		schemaPath: "#/properties/security/type",
																		keyword: "type",
																		params: { type: "array" },
																		message: "must be array",
																		schema: schema69.properties.security.type,
																		parentSchema: schema69.properties.security,
																		data: data13,
																	},
																];
																return false;
															}
														}
														var valid2 = _errs26 === errors;
													} else {
														var valid2 = true;
													}
													if (valid2) {
														if (data.servers !== undefined) {
															let data17 = data.servers;
															const _errs37 = errors;
															if (errors === _errs37) {
																if (Array.isArray(data17)) {
																	var valid10 = true;
																	const len4 = data17.length;
																	for (let i4 = 0; i4 < len4; i4++) {
																		const _errs39 = errors;
																		if (
																			!validate27(data17[i4], {
																				instancePath:
																					instancePath + "/servers/" + i4,
																				parentData: data17,
																				parentDataProperty: i4,
																				rootData,
																				dynamicAnchors,
																			})
																		) {
																			vErrors =
																				vErrors === null
																					? validate27.errors
																					: vErrors.concat(validate27.errors);
																			errors = vErrors.length;
																		}
																		var valid10 = _errs39 === errors;
																		if (!valid10) {
																			break;
																		}
																	}
																} else {
																	validate60.errors = [
																		{
																			instancePath: instancePath + "/servers",
																			schemaPath: "#/properties/servers/type",
																			keyword: "type",
																			params: { type: "array" },
																			message: "must be array",
																			schema: schema69.properties.servers.type,
																			parentSchema: schema69.properties.servers,
																			data: data17,
																		},
																	];
																	return false;
																}
															}
															var valid2 = _errs37 === errors;
														} else {
															var valid2 = true;
														}
														if (valid2) {
															if (props0 !== true) {
																for (const key3 in data) {
																	if (!props0 || !props0[key3]) {
																		validate60.errors = [
																			{
																				instancePath,
																				schemaPath: "#/unevaluatedProperties",
																				keyword: "unevaluatedProperties",
																				params: { unevaluatedProperty: key3 },
																				message:
																					"must NOT have unevaluated properties",
																				schema: false,
																				parentSchema: schema69,
																				data,
																			},
																		];
																		return false;
																		break;
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate60.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema69.type,
					parentSchema: schema69,
					data,
				},
			];
			return false;
		}
	}
	validate60.errors = vErrors;
	return errors === 0;
}
validate60.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate32(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate32.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.$ref = true;
				props0.summary = true;
				props0.description = true;
				props0.servers = true;
				props0.parameters = true;
				props0.get = true;
				props0.put = true;
				props0.post = true;
				props0.delete = true;
				props0.options = true;
				props0.head = true;
				props0.patch = true;
				props0.trace = true;
			}
			if (data.$ref !== undefined) {
				let data0 = data.$ref;
				const _errs4 = errors;
				if (errors === _errs4) {
					if (errors === _errs4) {
						if (typeof data0 === "string") {
							if (!formats0.test(data0)) {
								validate32.errors = [
									{
										instancePath: instancePath + "/$ref",
										schemaPath: "#/properties/%24ref/format",
										keyword: "format",
										params: { format: "uri-reference" },
										message: 'must match format "' + "uri-reference" + '"',
										schema: "uri-reference",
										parentSchema: schema45.properties.$ref,
										data: data0,
									},
								];
								return false;
							}
						} else {
							validate32.errors = [
								{
									instancePath: instancePath + "/$ref",
									schemaPath: "#/properties/%24ref/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema45.properties.$ref.type,
									parentSchema: schema45.properties.$ref,
									data: data0,
								},
							];
							return false;
						}
					}
				}
				var valid2 = _errs4 === errors;
			} else {
				var valid2 = true;
			}
			if (valid2) {
				if (data.summary !== undefined) {
					let data1 = data.summary;
					const _errs6 = errors;
					if (typeof data1 !== "string") {
						validate32.errors = [
							{
								instancePath: instancePath + "/summary",
								schemaPath: "#/properties/summary/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema45.properties.summary.type,
								parentSchema: schema45.properties.summary,
								data: data1,
							},
						];
						return false;
					}
					var valid2 = _errs6 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.description !== undefined) {
						let data2 = data.description;
						const _errs8 = errors;
						if (typeof data2 !== "string") {
							validate32.errors = [
								{
									instancePath: instancePath + "/description",
									schemaPath: "#/properties/description/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema45.properties.description.type,
									parentSchema: schema45.properties.description,
									data: data2,
								},
							];
							return false;
						}
						var valid2 = _errs8 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.servers !== undefined) {
							let data3 = data.servers;
							const _errs10 = errors;
							if (errors === _errs10) {
								if (Array.isArray(data3)) {
									var valid3 = true;
									const len0 = data3.length;
									for (let i0 = 0; i0 < len0; i0++) {
										const _errs12 = errors;
										if (
											!validate27(data3[i0], {
												instancePath: instancePath + "/servers/" + i0,
												parentData: data3,
												parentDataProperty: i0,
												rootData,
												dynamicAnchors,
											})
										) {
											vErrors =
												vErrors === null
													? validate27.errors
													: vErrors.concat(validate27.errors);
											errors = vErrors.length;
										}
										var valid3 = _errs12 === errors;
										if (!valid3) {
											break;
										}
									}
								} else {
									validate32.errors = [
										{
											instancePath: instancePath + "/servers",
											schemaPath: "#/properties/servers/type",
											keyword: "type",
											params: { type: "array" },
											message: "must be array",
											schema: schema45.properties.servers.type,
											parentSchema: schema45.properties.servers,
											data: data3,
										},
									];
									return false;
								}
							}
							var valid2 = _errs10 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (data.parameters !== undefined) {
								let data5 = data.parameters;
								const _errs13 = errors;
								if (errors === _errs13) {
									if (Array.isArray(data5)) {
										var valid4 = true;
										const len1 = data5.length;
										for (let i1 = 0; i1 < len1; i1++) {
											const _errs15 = errors;
											if (
												!validate34(data5[i1], {
													instancePath: instancePath + "/parameters/" + i1,
													parentData: data5,
													parentDataProperty: i1,
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate34.errors
														: vErrors.concat(validate34.errors);
												errors = vErrors.length;
											}
											var valid4 = _errs15 === errors;
											if (!valid4) {
												break;
											}
										}
									} else {
										validate32.errors = [
											{
												instancePath: instancePath + "/parameters",
												schemaPath: "#/properties/parameters/type",
												keyword: "type",
												params: { type: "array" },
												message: "must be array",
												schema: schema45.properties.parameters.type,
												parentSchema: schema45.properties.parameters,
												data: data5,
											},
										];
										return false;
									}
								}
								var valid2 = _errs13 === errors;
							} else {
								var valid2 = true;
							}
							if (valid2) {
								if (data.get !== undefined) {
									const _errs16 = errors;
									if (
										!validate60(data.get, {
											instancePath: instancePath + "/get",
											parentData: data,
											parentDataProperty: "get",
											rootData,
											dynamicAnchors,
										})
									) {
										vErrors =
											vErrors === null
												? validate60.errors
												: vErrors.concat(validate60.errors);
										errors = vErrors.length;
									}
									var valid2 = _errs16 === errors;
								} else {
									var valid2 = true;
								}
								if (valid2) {
									if (data.put !== undefined) {
										const _errs17 = errors;
										if (
											!validate60(data.put, {
												instancePath: instancePath + "/put",
												parentData: data,
												parentDataProperty: "put",
												rootData,
												dynamicAnchors,
											})
										) {
											vErrors =
												vErrors === null
													? validate60.errors
													: vErrors.concat(validate60.errors);
											errors = vErrors.length;
										}
										var valid2 = _errs17 === errors;
									} else {
										var valid2 = true;
									}
									if (valid2) {
										if (data.post !== undefined) {
											const _errs18 = errors;
											if (
												!validate60(data.post, {
													instancePath: instancePath + "/post",
													parentData: data,
													parentDataProperty: "post",
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate60.errors
														: vErrors.concat(validate60.errors);
												errors = vErrors.length;
											}
											var valid2 = _errs18 === errors;
										} else {
											var valid2 = true;
										}
										if (valid2) {
											if (data.delete !== undefined) {
												const _errs19 = errors;
												if (
													!validate60(data.delete, {
														instancePath: instancePath + "/delete",
														parentData: data,
														parentDataProperty: "delete",
														rootData,
														dynamicAnchors,
													})
												) {
													vErrors =
														vErrors === null
															? validate60.errors
															: vErrors.concat(validate60.errors);
													errors = vErrors.length;
												}
												var valid2 = _errs19 === errors;
											} else {
												var valid2 = true;
											}
											if (valid2) {
												if (data.options !== undefined) {
													const _errs20 = errors;
													if (
														!validate60(data.options, {
															instancePath: instancePath + "/options",
															parentData: data,
															parentDataProperty: "options",
															rootData,
															dynamicAnchors,
														})
													) {
														vErrors =
															vErrors === null
																? validate60.errors
																: vErrors.concat(validate60.errors);
														errors = vErrors.length;
													}
													var valid2 = _errs20 === errors;
												} else {
													var valid2 = true;
												}
												if (valid2) {
													if (data.head !== undefined) {
														const _errs21 = errors;
														if (
															!validate60(data.head, {
																instancePath: instancePath + "/head",
																parentData: data,
																parentDataProperty: "head",
																rootData,
																dynamicAnchors,
															})
														) {
															vErrors =
																vErrors === null
																	? validate60.errors
																	: vErrors.concat(validate60.errors);
															errors = vErrors.length;
														}
														var valid2 = _errs21 === errors;
													} else {
														var valid2 = true;
													}
													if (valid2) {
														if (data.patch !== undefined) {
															const _errs22 = errors;
															if (
																!validate60(data.patch, {
																	instancePath: instancePath + "/patch",
																	parentData: data,
																	parentDataProperty: "patch",
																	rootData,
																	dynamicAnchors,
																})
															) {
																vErrors =
																	vErrors === null
																		? validate60.errors
																		: vErrors.concat(validate60.errors);
																errors = vErrors.length;
															}
															var valid2 = _errs22 === errors;
														} else {
															var valid2 = true;
														}
														if (valid2) {
															if (data.trace !== undefined) {
																const _errs23 = errors;
																if (
																	!validate60(data.trace, {
																		instancePath: instancePath + "/trace",
																		parentData: data,
																		parentDataProperty: "trace",
																		rootData,
																		dynamicAnchors,
																	})
																) {
																	vErrors =
																		vErrors === null
																			? validate60.errors
																			: vErrors.concat(validate60.errors);
																	errors = vErrors.length;
																}
																var valid2 = _errs23 === errors;
															} else {
																var valid2 = true;
															}
															if (valid2) {
																if (props0 !== true) {
																	for (const key1 in data) {
																		if (!props0 || !props0[key1]) {
																			validate32.errors = [
																				{
																					instancePath,
																					schemaPath: "#/unevaluatedProperties",
																					keyword: "unevaluatedProperties",
																					params: { unevaluatedProperty: key1 },
																					message:
																						"must NOT have unevaluated properties",
																					schema: false,
																					parentSchema: schema45,
																					data,
																				},
																			];
																			return false;
																			break;
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate32.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema45.type,
					parentSchema: schema45,
					data,
				},
			];
			return false;
		}
	}
	validate32.errors = vErrors;
	return errors === 0;
}
validate32.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate31(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate31.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var valid2 = true;
			for (const key1 in data) {
				if (pattern12.test(key1)) {
					const _errs4 = errors;
					if (
						!validate32(data[key1], {
							instancePath:
								instancePath +
								"/" +
								key1.replace(/~/g, "~0").replace(/\//g, "~1"),
							parentData: data,
							parentDataProperty: key1,
							rootData,
							dynamicAnchors,
						})
					) {
						vErrors =
							vErrors === null
								? validate32.errors
								: vErrors.concat(validate32.errors);
						errors = vErrors.length;
					}
					var valid2 = _errs4 === errors;
					props0[key1] = true;
				}
			}
			if (valid2) {
				if (props0 !== true) {
					for (const key2 in data) {
						if (!props0 || !props0[key2]) {
							validate31.errors = [
								{
									instancePath,
									schemaPath: "#/unevaluatedProperties",
									keyword: "unevaluatedProperties",
									params: { unevaluatedProperty: key2 },
									message: "must NOT have unevaluated properties",
									schema: false,
									parentSchema: schema43,
									data,
								},
							];
							return false;
							break;
						}
					}
				}
			}
		} else {
			validate31.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema43.type,
					parentSchema: schema43,
					data,
				},
			];
			return false;
		}
	}
	validate31.errors = vErrors;
	return errors === 0;
}
validate31.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema89 = {
	$comment: "https://spec.openapis.org/oas/v3.1#components-object",
	type: "object",
	properties: {
		schemas: { type: "object", additionalProperties: { $dynamicRef: "#meta" } },
		responses: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/response-or-reference" },
		},
		parameters: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/parameter-or-reference" },
		},
		examples: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/example-or-reference" },
		},
		requestBodies: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/request-body-or-reference" },
		},
		headers: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/header-or-reference" },
		},
		securitySchemes: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/security-scheme-or-reference" },
		},
		links: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/link-or-reference" },
		},
		callbacks: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/callbacks-or-reference" },
		},
		pathItems: {
			type: "object",
			additionalProperties: { $ref: "#/$defs/path-item" },
		},
	},
	patternProperties: {
		"^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$":
			{
				$comment:
					"Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
				propertyNames: { pattern: "^[a-zA-Z0-9._-]+$" },
			},
	},
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
const pattern36 = new RegExp(
	"^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$",
	"u",
);
const pattern37 = new RegExp("^[a-zA-Z0-9._-]+$", "u");
const schema91 = {
	if: { type: "object", required: ["$ref"] },
	then: { $ref: "#/$defs/reference" },
	else: { $ref: "#/$defs/security-scheme" },
};
const schema92 = {
	$comment: "https://spec.openapis.org/oas/v3.1#security-scheme-object",
	type: "object",
	properties: {
		type: { enum: ["apiKey", "http", "mutualTLS", "oauth2", "openIdConnect"] },
		description: { type: "string" },
	},
	required: ["type"],
	allOf: [
		{ $ref: "#/$defs/specification-extensions" },
		{ $ref: "#/$defs/security-scheme/$defs/type-apikey" },
		{ $ref: "#/$defs/security-scheme/$defs/type-http" },
		{ $ref: "#/$defs/security-scheme/$defs/type-http-bearer" },
		{ $ref: "#/$defs/security-scheme/$defs/type-oauth2" },
		{ $ref: "#/$defs/security-scheme/$defs/type-oidc" },
	],
	unevaluatedProperties: false,
	$defs: {
		"type-apikey": {
			if: { properties: { type: { const: "apiKey" } }, required: ["type"] },
			then: {
				properties: {
					name: { type: "string" },
					in: { enum: ["query", "header", "cookie"] },
				},
				required: ["name", "in"],
			},
		},
		"type-http": {
			if: { properties: { type: { const: "http" } }, required: ["type"] },
			then: {
				properties: { scheme: { type: "string" } },
				required: ["scheme"],
			},
		},
		"type-http-bearer": {
			if: {
				properties: {
					type: { const: "http" },
					scheme: { type: "string", pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$" },
				},
				required: ["type", "scheme"],
			},
			then: { properties: { bearerFormat: { type: "string" } } },
		},
		"type-oauth2": {
			if: { properties: { type: { const: "oauth2" } }, required: ["type"] },
			then: {
				properties: { flows: { $ref: "#/$defs/oauth-flows" } },
				required: ["flows"],
			},
		},
		"type-oidc": {
			if: {
				properties: { type: { const: "openIdConnect" } },
				required: ["type"],
			},
			then: {
				properties: {
					openIdConnectUrl: { type: "string", format: "uri-reference" },
				},
				required: ["openIdConnectUrl"],
			},
		},
	},
};
const schema94 = {
	if: { properties: { type: { const: "apiKey" } }, required: ["type"] },
	then: {
		properties: {
			name: { type: "string" },
			in: { enum: ["query", "header", "cookie"] },
		},
		required: ["name", "in"],
	},
};
const schema95 = {
	if: { properties: { type: { const: "http" } }, required: ["type"] },
	then: { properties: { scheme: { type: "string" } }, required: ["scheme"] },
};
const schema96 = {
	if: {
		properties: {
			type: { const: "http" },
			scheme: { type: "string", pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$" },
		},
		required: ["type", "scheme"],
	},
	then: { properties: { bearerFormat: { type: "string" } } },
};
const schema112 = {
	if: { properties: { type: { const: "openIdConnect" } }, required: ["type"] },
	then: {
		properties: {
			openIdConnectUrl: { type: "string", format: "uri-reference" },
		},
		required: ["openIdConnectUrl"],
	},
};
const pattern30 = new RegExp("^[Bb][Ee][Aa][Rr][Ee][Rr]$", "u");
const schema97 = {
	if: { properties: { type: { const: "oauth2" } }, required: ["type"] },
	then: {
		properties: { flows: { $ref: "#/$defs/oauth-flows" } },
		required: ["flows"],
	},
};
const schema98 = {
	type: "object",
	properties: {
		implicit: { $ref: "#/$defs/oauth-flows/$defs/implicit" },
		password: { $ref: "#/$defs/oauth-flows/$defs/password" },
		clientCredentials: { $ref: "#/$defs/oauth-flows/$defs/client-credentials" },
		authorizationCode: { $ref: "#/$defs/oauth-flows/$defs/authorization-code" },
	},
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
	$defs: {
		implicit: {
			type: "object",
			properties: {
				authorizationUrl: { type: "string", format: "uri-reference" },
				refreshUrl: { type: "string", format: "uri-reference" },
				scopes: { $ref: "#/$defs/map-of-strings" },
			},
			required: ["authorizationUrl", "scopes"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		password: {
			type: "object",
			properties: {
				tokenUrl: { type: "string", format: "uri-reference" },
				refreshUrl: { type: "string", format: "uri-reference" },
				scopes: { $ref: "#/$defs/map-of-strings" },
			},
			required: ["tokenUrl", "scopes"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"client-credentials": {
			type: "object",
			properties: {
				tokenUrl: { type: "string", format: "uri-reference" },
				refreshUrl: { type: "string", format: "uri-reference" },
				scopes: { $ref: "#/$defs/map-of-strings" },
			},
			required: ["tokenUrl", "scopes"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
		"authorization-code": {
			type: "object",
			properties: {
				authorizationUrl: { type: "string", format: "uri-reference" },
				tokenUrl: { type: "string", format: "uri-reference" },
				refreshUrl: { type: "string", format: "uri-reference" },
				scopes: { $ref: "#/$defs/map-of-strings" },
			},
			required: ["authorizationUrl", "tokenUrl", "scopes"],
			$ref: "#/$defs/specification-extensions",
			unevaluatedProperties: false,
		},
	},
};
const schema100 = {
	type: "object",
	properties: {
		authorizationUrl: { type: "string", format: "uri-reference" },
		refreshUrl: { type: "string", format: "uri-reference" },
		scopes: { $ref: "#/$defs/map-of-strings" },
	},
	required: ["authorizationUrl", "scopes"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate114(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate114.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	if (errors === _errs0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (
				(data.authorizationUrl === undefined &&
					(missing0 = "authorizationUrl")) ||
				(data.scopes === undefined && (missing0 = "scopes"))
			) {
				validate114.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema100.required,
						parentSchema: schema100,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.authorizationUrl = true;
					props0.refreshUrl = true;
					props0.scopes = true;
				}
				if (data.authorizationUrl !== undefined) {
					let data0 = data.authorizationUrl;
					const _errs3 = errors;
					if (errors === _errs3) {
						if (errors === _errs3) {
							if (typeof data0 === "string") {
								if (!formats0.test(data0)) {
									validate114.errors = [
										{
											instancePath: instancePath + "/authorizationUrl",
											schemaPath: "#/properties/authorizationUrl/format",
											keyword: "format",
											params: { format: "uri-reference" },
											message: 'must match format "' + "uri-reference" + '"',
											schema: "uri-reference",
											parentSchema: schema100.properties.authorizationUrl,
											data: data0,
										},
									];
									return false;
								}
							} else {
								validate114.errors = [
									{
										instancePath: instancePath + "/authorizationUrl",
										schemaPath: "#/properties/authorizationUrl/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema100.properties.authorizationUrl.type,
										parentSchema: schema100.properties.authorizationUrl,
										data: data0,
									},
								];
								return false;
							}
						}
					}
					var valid2 = _errs3 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.refreshUrl !== undefined) {
						let data1 = data.refreshUrl;
						const _errs5 = errors;
						if (errors === _errs5) {
							if (errors === _errs5) {
								if (typeof data1 === "string") {
									if (!formats0.test(data1)) {
										validate114.errors = [
											{
												instancePath: instancePath + "/refreshUrl",
												schemaPath: "#/properties/refreshUrl/format",
												keyword: "format",
												params: { format: "uri-reference" },
												message: 'must match format "' + "uri-reference" + '"',
												schema: "uri-reference",
												parentSchema: schema100.properties.refreshUrl,
												data: data1,
											},
										];
										return false;
									}
								} else {
									validate114.errors = [
										{
											instancePath: instancePath + "/refreshUrl",
											schemaPath: "#/properties/refreshUrl/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema100.properties.refreshUrl.type,
											parentSchema: schema100.properties.refreshUrl,
											data: data1,
										},
									];
									return false;
								}
							}
						}
						var valid2 = _errs5 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.scopes !== undefined) {
							let data2 = data.scopes;
							const _errs7 = errors;
							const _errs8 = errors;
							if (errors === _errs8) {
								if (
									data2 &&
									typeof data2 == "object" &&
									!Array.isArray(data2)
								) {
									for (const key1 in data2) {
										let data3 = data2[key1];
										const _errs11 = errors;
										if (typeof data3 !== "string") {
											validate114.errors = [
												{
													instancePath:
														instancePath +
														"/scopes/" +
														key1.replace(/~/g, "~0").replace(/\//g, "~1"),
													schemaPath:
														"#/$defs/map-of-strings/additionalProperties/type",
													keyword: "type",
													params: { type: "string" },
													message: "must be string",
													schema: schema84.additionalProperties.type,
													parentSchema: schema84.additionalProperties,
													data: data3,
												},
											];
											return false;
										}
										var valid4 = _errs11 === errors;
										if (!valid4) {
											break;
										}
									}
								} else {
									validate114.errors = [
										{
											instancePath: instancePath + "/scopes",
											schemaPath: "#/$defs/map-of-strings/type",
											keyword: "type",
											params: { type: "object" },
											message: "must be object",
											schema: schema84.type,
											parentSchema: schema84,
											data: data2,
										},
									];
									return false;
								}
							}
							var valid2 = _errs7 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key2 in data) {
									if (!props0 || !props0[key2]) {
										validate114.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key2 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema100,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate114.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema100.type,
					parentSchema: schema100,
					data,
				},
			];
			return false;
		}
	}
	validate114.errors = vErrors;
	return errors === 0;
}
validate114.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema103 = {
	type: "object",
	properties: {
		tokenUrl: { type: "string", format: "uri-reference" },
		refreshUrl: { type: "string", format: "uri-reference" },
		scopes: { $ref: "#/$defs/map-of-strings" },
	},
	required: ["tokenUrl", "scopes"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate116(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate116.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	if (errors === _errs0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (
				(data.tokenUrl === undefined && (missing0 = "tokenUrl")) ||
				(data.scopes === undefined && (missing0 = "scopes"))
			) {
				validate116.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema103.required,
						parentSchema: schema103,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.tokenUrl = true;
					props0.refreshUrl = true;
					props0.scopes = true;
				}
				if (data.tokenUrl !== undefined) {
					let data0 = data.tokenUrl;
					const _errs3 = errors;
					if (errors === _errs3) {
						if (errors === _errs3) {
							if (typeof data0 === "string") {
								if (!formats0.test(data0)) {
									validate116.errors = [
										{
											instancePath: instancePath + "/tokenUrl",
											schemaPath: "#/properties/tokenUrl/format",
											keyword: "format",
											params: { format: "uri-reference" },
											message: 'must match format "' + "uri-reference" + '"',
											schema: "uri-reference",
											parentSchema: schema103.properties.tokenUrl,
											data: data0,
										},
									];
									return false;
								}
							} else {
								validate116.errors = [
									{
										instancePath: instancePath + "/tokenUrl",
										schemaPath: "#/properties/tokenUrl/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema103.properties.tokenUrl.type,
										parentSchema: schema103.properties.tokenUrl,
										data: data0,
									},
								];
								return false;
							}
						}
					}
					var valid2 = _errs3 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.refreshUrl !== undefined) {
						let data1 = data.refreshUrl;
						const _errs5 = errors;
						if (errors === _errs5) {
							if (errors === _errs5) {
								if (typeof data1 === "string") {
									if (!formats0.test(data1)) {
										validate116.errors = [
											{
												instancePath: instancePath + "/refreshUrl",
												schemaPath: "#/properties/refreshUrl/format",
												keyword: "format",
												params: { format: "uri-reference" },
												message: 'must match format "' + "uri-reference" + '"',
												schema: "uri-reference",
												parentSchema: schema103.properties.refreshUrl,
												data: data1,
											},
										];
										return false;
									}
								} else {
									validate116.errors = [
										{
											instancePath: instancePath + "/refreshUrl",
											schemaPath: "#/properties/refreshUrl/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema103.properties.refreshUrl.type,
											parentSchema: schema103.properties.refreshUrl,
											data: data1,
										},
									];
									return false;
								}
							}
						}
						var valid2 = _errs5 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.scopes !== undefined) {
							let data2 = data.scopes;
							const _errs7 = errors;
							const _errs8 = errors;
							if (errors === _errs8) {
								if (
									data2 &&
									typeof data2 == "object" &&
									!Array.isArray(data2)
								) {
									for (const key1 in data2) {
										let data3 = data2[key1];
										const _errs11 = errors;
										if (typeof data3 !== "string") {
											validate116.errors = [
												{
													instancePath:
														instancePath +
														"/scopes/" +
														key1.replace(/~/g, "~0").replace(/\//g, "~1"),
													schemaPath:
														"#/$defs/map-of-strings/additionalProperties/type",
													keyword: "type",
													params: { type: "string" },
													message: "must be string",
													schema: schema84.additionalProperties.type,
													parentSchema: schema84.additionalProperties,
													data: data3,
												},
											];
											return false;
										}
										var valid4 = _errs11 === errors;
										if (!valid4) {
											break;
										}
									}
								} else {
									validate116.errors = [
										{
											instancePath: instancePath + "/scopes",
											schemaPath: "#/$defs/map-of-strings/type",
											keyword: "type",
											params: { type: "object" },
											message: "must be object",
											schema: schema84.type,
											parentSchema: schema84,
											data: data2,
										},
									];
									return false;
								}
							}
							var valid2 = _errs7 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key2 in data) {
									if (!props0 || !props0[key2]) {
										validate116.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key2 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema103,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate116.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema103.type,
					parentSchema: schema103,
					data,
				},
			];
			return false;
		}
	}
	validate116.errors = vErrors;
	return errors === 0;
}
validate116.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema106 = {
	type: "object",
	properties: {
		tokenUrl: { type: "string", format: "uri-reference" },
		refreshUrl: { type: "string", format: "uri-reference" },
		scopes: { $ref: "#/$defs/map-of-strings" },
	},
	required: ["tokenUrl", "scopes"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate118(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate118.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	if (errors === _errs0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (
				(data.tokenUrl === undefined && (missing0 = "tokenUrl")) ||
				(data.scopes === undefined && (missing0 = "scopes"))
			) {
				validate118.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema106.required,
						parentSchema: schema106,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.tokenUrl = true;
					props0.refreshUrl = true;
					props0.scopes = true;
				}
				if (data.tokenUrl !== undefined) {
					let data0 = data.tokenUrl;
					const _errs3 = errors;
					if (errors === _errs3) {
						if (errors === _errs3) {
							if (typeof data0 === "string") {
								if (!formats0.test(data0)) {
									validate118.errors = [
										{
											instancePath: instancePath + "/tokenUrl",
											schemaPath: "#/properties/tokenUrl/format",
											keyword: "format",
											params: { format: "uri-reference" },
											message: 'must match format "' + "uri-reference" + '"',
											schema: "uri-reference",
											parentSchema: schema106.properties.tokenUrl,
											data: data0,
										},
									];
									return false;
								}
							} else {
								validate118.errors = [
									{
										instancePath: instancePath + "/tokenUrl",
										schemaPath: "#/properties/tokenUrl/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema106.properties.tokenUrl.type,
										parentSchema: schema106.properties.tokenUrl,
										data: data0,
									},
								];
								return false;
							}
						}
					}
					var valid2 = _errs3 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.refreshUrl !== undefined) {
						let data1 = data.refreshUrl;
						const _errs5 = errors;
						if (errors === _errs5) {
							if (errors === _errs5) {
								if (typeof data1 === "string") {
									if (!formats0.test(data1)) {
										validate118.errors = [
											{
												instancePath: instancePath + "/refreshUrl",
												schemaPath: "#/properties/refreshUrl/format",
												keyword: "format",
												params: { format: "uri-reference" },
												message: 'must match format "' + "uri-reference" + '"',
												schema: "uri-reference",
												parentSchema: schema106.properties.refreshUrl,
												data: data1,
											},
										];
										return false;
									}
								} else {
									validate118.errors = [
										{
											instancePath: instancePath + "/refreshUrl",
											schemaPath: "#/properties/refreshUrl/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema106.properties.refreshUrl.type,
											parentSchema: schema106.properties.refreshUrl,
											data: data1,
										},
									];
									return false;
								}
							}
						}
						var valid2 = _errs5 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.scopes !== undefined) {
							let data2 = data.scopes;
							const _errs7 = errors;
							const _errs8 = errors;
							if (errors === _errs8) {
								if (
									data2 &&
									typeof data2 == "object" &&
									!Array.isArray(data2)
								) {
									for (const key1 in data2) {
										let data3 = data2[key1];
										const _errs11 = errors;
										if (typeof data3 !== "string") {
											validate118.errors = [
												{
													instancePath:
														instancePath +
														"/scopes/" +
														key1.replace(/~/g, "~0").replace(/\//g, "~1"),
													schemaPath:
														"#/$defs/map-of-strings/additionalProperties/type",
													keyword: "type",
													params: { type: "string" },
													message: "must be string",
													schema: schema84.additionalProperties.type,
													parentSchema: schema84.additionalProperties,
													data: data3,
												},
											];
											return false;
										}
										var valid4 = _errs11 === errors;
										if (!valid4) {
											break;
										}
									}
								} else {
									validate118.errors = [
										{
											instancePath: instancePath + "/scopes",
											schemaPath: "#/$defs/map-of-strings/type",
											keyword: "type",
											params: { type: "object" },
											message: "must be object",
											schema: schema84.type,
											parentSchema: schema84,
											data: data2,
										},
									];
									return false;
								}
							}
							var valid2 = _errs7 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key2 in data) {
									if (!props0 || !props0[key2]) {
										validate118.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key2 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema106,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate118.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema106.type,
					parentSchema: schema106,
					data,
				},
			];
			return false;
		}
	}
	validate118.errors = vErrors;
	return errors === 0;
}
validate118.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema109 = {
	type: "object",
	properties: {
		authorizationUrl: { type: "string", format: "uri-reference" },
		tokenUrl: { type: "string", format: "uri-reference" },
		refreshUrl: { type: "string", format: "uri-reference" },
		scopes: { $ref: "#/$defs/map-of-strings" },
	},
	required: ["authorizationUrl", "tokenUrl", "scopes"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate120(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate120.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	if (errors === _errs0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (
				(data.authorizationUrl === undefined &&
					(missing0 = "authorizationUrl")) ||
				(data.tokenUrl === undefined && (missing0 = "tokenUrl")) ||
				(data.scopes === undefined && (missing0 = "scopes"))
			) {
				validate120.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema109.required,
						parentSchema: schema109,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.authorizationUrl = true;
					props0.tokenUrl = true;
					props0.refreshUrl = true;
					props0.scopes = true;
				}
				if (data.authorizationUrl !== undefined) {
					let data0 = data.authorizationUrl;
					const _errs3 = errors;
					if (errors === _errs3) {
						if (errors === _errs3) {
							if (typeof data0 === "string") {
								if (!formats0.test(data0)) {
									validate120.errors = [
										{
											instancePath: instancePath + "/authorizationUrl",
											schemaPath: "#/properties/authorizationUrl/format",
											keyword: "format",
											params: { format: "uri-reference" },
											message: 'must match format "' + "uri-reference" + '"',
											schema: "uri-reference",
											parentSchema: schema109.properties.authorizationUrl,
											data: data0,
										},
									];
									return false;
								}
							} else {
								validate120.errors = [
									{
										instancePath: instancePath + "/authorizationUrl",
										schemaPath: "#/properties/authorizationUrl/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema109.properties.authorizationUrl.type,
										parentSchema: schema109.properties.authorizationUrl,
										data: data0,
									},
								];
								return false;
							}
						}
					}
					var valid2 = _errs3 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.tokenUrl !== undefined) {
						let data1 = data.tokenUrl;
						const _errs5 = errors;
						if (errors === _errs5) {
							if (errors === _errs5) {
								if (typeof data1 === "string") {
									if (!formats0.test(data1)) {
										validate120.errors = [
											{
												instancePath: instancePath + "/tokenUrl",
												schemaPath: "#/properties/tokenUrl/format",
												keyword: "format",
												params: { format: "uri-reference" },
												message: 'must match format "' + "uri-reference" + '"',
												schema: "uri-reference",
												parentSchema: schema109.properties.tokenUrl,
												data: data1,
											},
										];
										return false;
									}
								} else {
									validate120.errors = [
										{
											instancePath: instancePath + "/tokenUrl",
											schemaPath: "#/properties/tokenUrl/type",
											keyword: "type",
											params: { type: "string" },
											message: "must be string",
											schema: schema109.properties.tokenUrl.type,
											parentSchema: schema109.properties.tokenUrl,
											data: data1,
										},
									];
									return false;
								}
							}
						}
						var valid2 = _errs5 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.refreshUrl !== undefined) {
							let data2 = data.refreshUrl;
							const _errs7 = errors;
							if (errors === _errs7) {
								if (errors === _errs7) {
									if (typeof data2 === "string") {
										if (!formats0.test(data2)) {
											validate120.errors = [
												{
													instancePath: instancePath + "/refreshUrl",
													schemaPath: "#/properties/refreshUrl/format",
													keyword: "format",
													params: { format: "uri-reference" },
													message:
														'must match format "' + "uri-reference" + '"',
													schema: "uri-reference",
													parentSchema: schema109.properties.refreshUrl,
													data: data2,
												},
											];
											return false;
										}
									} else {
										validate120.errors = [
											{
												instancePath: instancePath + "/refreshUrl",
												schemaPath: "#/properties/refreshUrl/type",
												keyword: "type",
												params: { type: "string" },
												message: "must be string",
												schema: schema109.properties.refreshUrl.type,
												parentSchema: schema109.properties.refreshUrl,
												data: data2,
											},
										];
										return false;
									}
								}
							}
							var valid2 = _errs7 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (data.scopes !== undefined) {
								let data3 = data.scopes;
								const _errs9 = errors;
								const _errs10 = errors;
								if (errors === _errs10) {
									if (
										data3 &&
										typeof data3 == "object" &&
										!Array.isArray(data3)
									) {
										for (const key1 in data3) {
											let data4 = data3[key1];
											const _errs13 = errors;
											if (typeof data4 !== "string") {
												validate120.errors = [
													{
														instancePath:
															instancePath +
															"/scopes/" +
															key1.replace(/~/g, "~0").replace(/\//g, "~1"),
														schemaPath:
															"#/$defs/map-of-strings/additionalProperties/type",
														keyword: "type",
														params: { type: "string" },
														message: "must be string",
														schema: schema84.additionalProperties.type,
														parentSchema: schema84.additionalProperties,
														data: data4,
													},
												];
												return false;
											}
											var valid4 = _errs13 === errors;
											if (!valid4) {
												break;
											}
										}
									} else {
										validate120.errors = [
											{
												instancePath: instancePath + "/scopes",
												schemaPath: "#/$defs/map-of-strings/type",
												keyword: "type",
												params: { type: "object" },
												message: "must be object",
												schema: schema84.type,
												parentSchema: schema84,
												data: data3,
											},
										];
										return false;
									}
								}
								var valid2 = _errs9 === errors;
							} else {
								var valid2 = true;
							}
							if (valid2) {
								if (props0 !== true) {
									for (const key2 in data) {
										if (!props0 || !props0[key2]) {
											validate120.errors = [
												{
													instancePath,
													schemaPath: "#/unevaluatedProperties",
													keyword: "unevaluatedProperties",
													params: { unevaluatedProperty: key2 },
													message: "must NOT have unevaluated properties",
													schema: false,
													parentSchema: schema109,
													data,
												},
											];
											return false;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate120.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema109.type,
					parentSchema: schema109,
					data,
				},
			];
			return false;
		}
	}
	validate120.errors = vErrors;
	return errors === 0;
}
validate120.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate113(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate113.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	if (errors === _errs0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.implicit = true;
				props0.password = true;
				props0.clientCredentials = true;
				props0.authorizationCode = true;
			}
			if (data.implicit !== undefined) {
				const _errs3 = errors;
				if (
					!validate114(data.implicit, {
						instancePath: instancePath + "/implicit",
						parentData: data,
						parentDataProperty: "implicit",
						rootData,
						dynamicAnchors,
					})
				) {
					vErrors =
						vErrors === null
							? validate114.errors
							: vErrors.concat(validate114.errors);
					errors = vErrors.length;
				}
				var valid2 = _errs3 === errors;
			} else {
				var valid2 = true;
			}
			if (valid2) {
				if (data.password !== undefined) {
					const _errs4 = errors;
					if (
						!validate116(data.password, {
							instancePath: instancePath + "/password",
							parentData: data,
							parentDataProperty: "password",
							rootData,
							dynamicAnchors,
						})
					) {
						vErrors =
							vErrors === null
								? validate116.errors
								: vErrors.concat(validate116.errors);
						errors = vErrors.length;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.clientCredentials !== undefined) {
						const _errs5 = errors;
						if (
							!validate118(data.clientCredentials, {
								instancePath: instancePath + "/clientCredentials",
								parentData: data,
								parentDataProperty: "clientCredentials",
								rootData,
								dynamicAnchors,
							})
						) {
							vErrors =
								vErrors === null
									? validate118.errors
									: vErrors.concat(validate118.errors);
							errors = vErrors.length;
						}
						var valid2 = _errs5 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.authorizationCode !== undefined) {
							const _errs6 = errors;
							if (
								!validate120(data.authorizationCode, {
									instancePath: instancePath + "/authorizationCode",
									parentData: data,
									parentDataProperty: "authorizationCode",
									rootData,
									dynamicAnchors,
								})
							) {
								vErrors =
									vErrors === null
										? validate120.errors
										: vErrors.concat(validate120.errors);
								errors = vErrors.length;
							}
							var valid2 = _errs6 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key1 in data) {
									if (!props0 || !props0[key1]) {
										validate113.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key1 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema98,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate113.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema98.type,
					parentSchema: schema98,
					data,
				},
			];
			return false;
		}
	}
	validate113.errors = vErrors;
	return errors === 0;
}
validate113.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate112(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate112.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (data && typeof data == "object" && !Array.isArray(data)) {
		let missing0;
		if (data.type === undefined && (missing0 = "type")) {
			const err0 = {};
			if (vErrors === null) {
				vErrors = [err0];
			} else {
				vErrors.push(err0);
			}
			errors++;
		} else {
			if (data.type !== undefined) {
				if ("oauth2" !== data.type) {
					const err1 = {};
					if (vErrors === null) {
						vErrors = [err1];
					} else {
						vErrors.push(err1);
					}
					errors++;
				}
			}
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	if (_valid0) {
		const _errs3 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing1;
			if (data.flows === undefined && (missing1 = "flows")) {
				validate112.errors = [
					{
						instancePath,
						schemaPath: "#/then/required",
						keyword: "required",
						params: { missingProperty: missing1 },
						message: "must have required property '" + missing1 + "'",
						schema: schema97.then.required,
						parentSchema: schema97.then,
						data,
					},
				];
				return false;
			} else {
				if (data.flows !== undefined) {
					if (
						!validate113(data.flows, {
							instancePath: instancePath + "/flows",
							parentData: data,
							parentDataProperty: "flows",
							rootData,
							dynamicAnchors,
						})
					) {
						vErrors =
							vErrors === null
								? validate113.errors
								: vErrors.concat(validate113.errors);
						errors = vErrors.length;
					}
				}
			}
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.flows = true;
			props0.type = true;
		}
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: "then" },
			message: 'must match "then" schema',
			schema: schema97.if,
			parentSchema: schema97,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate112.errors = vErrors;
		return false;
	}
	validate112.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate112.evaluated = { dynamicProps: true, dynamicItems: false };
function validate111(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate111.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs2 = errors;
	const _errs3 = errors;
	if (errors === _errs3) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs2 === errors;
	if (valid0) {
		const _errs5 = errors;
		const _errs7 = errors;
		let valid4 = true;
		const _errs8 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.type === undefined && (missing0 = "type")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			} else {
				if (data.type !== undefined) {
					if ("apiKey" !== data.type) {
						const err1 = {};
						if (vErrors === null) {
							vErrors = [err1];
						} else {
							vErrors.push(err1);
						}
						errors++;
					}
				}
			}
		}
		var _valid0 = _errs8 === errors;
		errors = _errs7;
		if (vErrors !== null) {
			if (_errs7) {
				vErrors.length = _errs7;
			} else {
				vErrors = null;
			}
		}
		if (_valid0) {
			const _errs10 = errors;
			if (data && typeof data == "object" && !Array.isArray(data)) {
				let missing1;
				if (
					(data.name === undefined && (missing1 = "name")) ||
					(data.in === undefined && (missing1 = "in"))
				) {
					validate111.errors = [
						{
							instancePath,
							schemaPath:
								"#/$defs/security-scheme/$defs/type-apikey/then/required",
							keyword: "required",
							params: { missingProperty: missing1 },
							message: "must have required property '" + missing1 + "'",
							schema: schema94.then.required,
							parentSchema: schema94.then,
							data,
						},
					];
					return false;
				} else {
					if (data.name !== undefined) {
						let data1 = data.name;
						const _errs11 = errors;
						if (typeof data1 !== "string") {
							validate111.errors = [
								{
									instancePath: instancePath + "/name",
									schemaPath:
										"#/$defs/security-scheme/$defs/type-apikey/then/properties/name/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema94.then.properties.name.type,
									parentSchema: schema94.then.properties.name,
									data: data1,
								},
							];
							return false;
						}
						var valid6 = _errs11 === errors;
					} else {
						var valid6 = true;
					}
					if (valid6) {
						if (data.in !== undefined) {
							let data2 = data.in;
							const _errs13 = errors;
							if (
								!(data2 === "query" || data2 === "header" || data2 === "cookie")
							) {
								validate111.errors = [
									{
										instancePath: instancePath + "/in",
										schemaPath:
											"#/$defs/security-scheme/$defs/type-apikey/then/properties/in/enum",
										keyword: "enum",
										params: { allowedValues: schema94.then.properties.in.enum },
										message: "must be equal to one of the allowed values",
										schema: schema94.then.properties.in.enum,
										parentSchema: schema94.then.properties.in,
										data: data2,
									},
								];
								return false;
							}
							var valid6 = _errs13 === errors;
						} else {
							var valid6 = true;
						}
					}
				}
			}
			var _valid0 = _errs10 === errors;
			valid4 = _valid0;
			if (valid4) {
				var props1 = {};
				props1.name = true;
				props1.in = true;
				props1.type = true;
			}
		}
		if (!valid4) {
			const err2 = {
				instancePath,
				schemaPath: "#/$defs/security-scheme/$defs/type-apikey/if",
				keyword: "if",
				params: { failingKeyword: "then" },
				message: 'must match "then" schema',
				schema: schema94.if,
				parentSchema: schema94,
				data,
			};
			if (vErrors === null) {
				vErrors = [err2];
			} else {
				vErrors.push(err2);
			}
			errors++;
			validate111.errors = vErrors;
			return false;
		}
		var valid0 = _errs5 === errors;
		if (valid0) {
			if (props0 !== true && props1 !== undefined) {
				if (props1 === true) {
					props0 = true;
				} else {
					props0 = props0 || {};
					Object.assign(props0, props1);
				}
			}
			const _errs14 = errors;
			const _errs16 = errors;
			let valid8 = true;
			const _errs17 = errors;
			if (data && typeof data == "object" && !Array.isArray(data)) {
				let missing2;
				if (data.type === undefined && (missing2 = "type")) {
					const err3 = {};
					if (vErrors === null) {
						vErrors = [err3];
					} else {
						vErrors.push(err3);
					}
					errors++;
				} else {
					if (data.type !== undefined) {
						if ("http" !== data.type) {
							const err4 = {};
							if (vErrors === null) {
								vErrors = [err4];
							} else {
								vErrors.push(err4);
							}
							errors++;
						}
					}
				}
			}
			var _valid1 = _errs17 === errors;
			errors = _errs16;
			if (vErrors !== null) {
				if (_errs16) {
					vErrors.length = _errs16;
				} else {
					vErrors = null;
				}
			}
			if (_valid1) {
				const _errs19 = errors;
				if (data && typeof data == "object" && !Array.isArray(data)) {
					let missing3;
					if (data.scheme === undefined && (missing3 = "scheme")) {
						validate111.errors = [
							{
								instancePath,
								schemaPath:
									"#/$defs/security-scheme/$defs/type-http/then/required",
								keyword: "required",
								params: { missingProperty: missing3 },
								message: "must have required property '" + missing3 + "'",
								schema: schema95.then.required,
								parentSchema: schema95.then,
								data,
							},
						];
						return false;
					} else {
						if (data.scheme !== undefined) {
							let data4 = data.scheme;
							if (typeof data4 !== "string") {
								validate111.errors = [
									{
										instancePath: instancePath + "/scheme",
										schemaPath:
											"#/$defs/security-scheme/$defs/type-http/then/properties/scheme/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema95.then.properties.scheme.type,
										parentSchema: schema95.then.properties.scheme,
										data: data4,
									},
								];
								return false;
							}
						}
					}
				}
				var _valid1 = _errs19 === errors;
				valid8 = _valid1;
				if (valid8) {
					var props2 = {};
					props2.scheme = true;
					props2.type = true;
				}
			}
			if (!valid8) {
				const err5 = {
					instancePath,
					schemaPath: "#/$defs/security-scheme/$defs/type-http/if",
					keyword: "if",
					params: { failingKeyword: "then" },
					message: 'must match "then" schema',
					schema: schema95.if,
					parentSchema: schema95,
					data,
				};
				if (vErrors === null) {
					vErrors = [err5];
				} else {
					vErrors.push(err5);
				}
				errors++;
				validate111.errors = vErrors;
				return false;
			}
			var valid0 = _errs14 === errors;
			if (valid0) {
				if (props0 !== true && props2 !== undefined) {
					if (props2 === true) {
						props0 = true;
					} else {
						props0 = props0 || {};
						Object.assign(props0, props2);
					}
				}
				const _errs22 = errors;
				const _errs24 = errors;
				let valid12 = true;
				const _errs25 = errors;
				if (data && typeof data == "object" && !Array.isArray(data)) {
					let missing4;
					if (
						(data.type === undefined && (missing4 = "type")) ||
						(data.scheme === undefined && (missing4 = "scheme"))
					) {
						const err6 = {};
						if (vErrors === null) {
							vErrors = [err6];
						} else {
							vErrors.push(err6);
						}
						errors++;
					} else {
						if (data.type !== undefined) {
							const _errs26 = errors;
							if ("http" !== data.type) {
								const err7 = {};
								if (vErrors === null) {
									vErrors = [err7];
								} else {
									vErrors.push(err7);
								}
								errors++;
							}
							var valid13 = _errs26 === errors;
						} else {
							var valid13 = true;
						}
						if (valid13) {
							if (data.scheme !== undefined) {
								let data6 = data.scheme;
								const _errs27 = errors;
								if (errors === _errs27) {
									if (typeof data6 === "string") {
										if (!pattern30.test(data6)) {
											const err8 = {};
											if (vErrors === null) {
												vErrors = [err8];
											} else {
												vErrors.push(err8);
											}
											errors++;
										}
									} else {
										const err9 = {};
										if (vErrors === null) {
											vErrors = [err9];
										} else {
											vErrors.push(err9);
										}
										errors++;
									}
								}
								var valid13 = _errs27 === errors;
							} else {
								var valid13 = true;
							}
						}
					}
				}
				var _valid2 = _errs25 === errors;
				errors = _errs24;
				if (vErrors !== null) {
					if (_errs24) {
						vErrors.length = _errs24;
					} else {
						vErrors = null;
					}
				}
				if (_valid2) {
					const _errs29 = errors;
					if (data && typeof data == "object" && !Array.isArray(data)) {
						if (data.bearerFormat !== undefined) {
							let data7 = data.bearerFormat;
							if (typeof data7 !== "string") {
								validate111.errors = [
									{
										instancePath: instancePath + "/bearerFormat",
										schemaPath:
											"#/$defs/security-scheme/$defs/type-http-bearer/then/properties/bearerFormat/type",
										keyword: "type",
										params: { type: "string" },
										message: "must be string",
										schema: schema96.then.properties.bearerFormat.type,
										parentSchema: schema96.then.properties.bearerFormat,
										data: data7,
									},
								];
								return false;
							}
						}
					}
					var _valid2 = _errs29 === errors;
					valid12 = _valid2;
					if (valid12) {
						var props3 = {};
						props3.bearerFormat = true;
						props3.type = true;
						props3.scheme = true;
					}
				}
				if (!valid12) {
					const err10 = {
						instancePath,
						schemaPath: "#/$defs/security-scheme/$defs/type-http-bearer/if",
						keyword: "if",
						params: { failingKeyword: "then" },
						message: 'must match "then" schema',
						schema: schema96.if,
						parentSchema: schema96,
						data,
					};
					if (vErrors === null) {
						vErrors = [err10];
					} else {
						vErrors.push(err10);
					}
					errors++;
					validate111.errors = vErrors;
					return false;
				}
				var valid0 = _errs22 === errors;
				if (valid0) {
					if (props0 !== true && props3 !== undefined) {
						if (props3 === true) {
							props0 = true;
						} else {
							props0 = props0 || {};
							Object.assign(props0, props3);
						}
					}
					const _errs32 = errors;
					if (
						!validate112(data, {
							instancePath,
							parentData,
							parentDataProperty,
							rootData,
							dynamicAnchors,
						})
					) {
						vErrors =
							vErrors === null
								? validate112.errors
								: vErrors.concat(validate112.errors);
						errors = vErrors.length;
					} else {
						var props4 = validate112.evaluated.props;
					}
					var valid0 = _errs32 === errors;
					if (valid0) {
						if (props0 !== true && props4 !== undefined) {
							if (props4 === true) {
								props0 = true;
							} else {
								props0 = props0 || {};
								Object.assign(props0, props4);
							}
						}
						const _errs33 = errors;
						const _errs35 = errors;
						let valid16 = true;
						const _errs36 = errors;
						if (data && typeof data == "object" && !Array.isArray(data)) {
							let missing5;
							if (data.type === undefined && (missing5 = "type")) {
								const err11 = {};
								if (vErrors === null) {
									vErrors = [err11];
								} else {
									vErrors.push(err11);
								}
								errors++;
							} else {
								if (data.type !== undefined) {
									if ("openIdConnect" !== data.type) {
										const err12 = {};
										if (vErrors === null) {
											vErrors = [err12];
										} else {
											vErrors.push(err12);
										}
										errors++;
									}
								}
							}
						}
						var _valid3 = _errs36 === errors;
						errors = _errs35;
						if (vErrors !== null) {
							if (_errs35) {
								vErrors.length = _errs35;
							} else {
								vErrors = null;
							}
						}
						if (_valid3) {
							const _errs38 = errors;
							if (data && typeof data == "object" && !Array.isArray(data)) {
								let missing6;
								if (
									data.openIdConnectUrl === undefined &&
									(missing6 = "openIdConnectUrl")
								) {
									validate111.errors = [
										{
											instancePath,
											schemaPath:
												"#/$defs/security-scheme/$defs/type-oidc/then/required",
											keyword: "required",
											params: { missingProperty: missing6 },
											message: "must have required property '" + missing6 + "'",
											schema: schema112.then.required,
											parentSchema: schema112.then,
											data,
										},
									];
									return false;
								} else {
									if (data.openIdConnectUrl !== undefined) {
										let data9 = data.openIdConnectUrl;
										const _errs39 = errors;
										if (errors === _errs39) {
											if (errors === _errs39) {
												if (typeof data9 === "string") {
													if (!formats0.test(data9)) {
														validate111.errors = [
															{
																instancePath:
																	instancePath + "/openIdConnectUrl",
																schemaPath:
																	"#/$defs/security-scheme/$defs/type-oidc/then/properties/openIdConnectUrl/format",
																keyword: "format",
																params: { format: "uri-reference" },
																message:
																	'must match format "' + "uri-reference" + '"',
																schema: "uri-reference",
																parentSchema:
																	schema112.then.properties.openIdConnectUrl,
																data: data9,
															},
														];
														return false;
													}
												} else {
													validate111.errors = [
														{
															instancePath: instancePath + "/openIdConnectUrl",
															schemaPath:
																"#/$defs/security-scheme/$defs/type-oidc/then/properties/openIdConnectUrl/type",
															keyword: "type",
															params: { type: "string" },
															message: "must be string",
															schema:
																schema112.then.properties.openIdConnectUrl.type,
															parentSchema:
																schema112.then.properties.openIdConnectUrl,
															data: data9,
														},
													];
													return false;
												}
											}
										}
									}
								}
							}
							var _valid3 = _errs38 === errors;
							valid16 = _valid3;
							if (valid16) {
								var props5 = {};
								props5.openIdConnectUrl = true;
								props5.type = true;
							}
						}
						if (!valid16) {
							const err13 = {
								instancePath,
								schemaPath: "#/$defs/security-scheme/$defs/type-oidc/if",
								keyword: "if",
								params: { failingKeyword: "then" },
								message: 'must match "then" schema',
								schema: schema112.if,
								parentSchema: schema112,
								data,
							};
							if (vErrors === null) {
								vErrors = [err13];
							} else {
								vErrors.push(err13);
							}
							errors++;
							validate111.errors = vErrors;
							return false;
						}
						var valid0 = _errs33 === errors;
						if (valid0) {
							if (props0 !== true && props5 !== undefined) {
								if (props5 === true) {
									props0 = true;
								} else {
									props0 = props0 || {};
									Object.assign(props0, props5);
								}
							}
						}
					}
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing7;
			if (data.type === undefined && (missing7 = "type")) {
				validate111.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing7 },
						message: "must have required property '" + missing7 + "'",
						schema: schema92.required,
						parentSchema: schema92,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.type = true;
					props0.description = true;
				}
				if (data.type !== undefined) {
					let data10 = data.type;
					const _errs41 = errors;
					if (
						!(
							data10 === "apiKey" ||
							data10 === "http" ||
							data10 === "mutualTLS" ||
							data10 === "oauth2" ||
							data10 === "openIdConnect"
						)
					) {
						validate111.errors = [
							{
								instancePath: instancePath + "/type",
								schemaPath: "#/properties/type/enum",
								keyword: "enum",
								params: { allowedValues: schema92.properties.type.enum },
								message: "must be equal to one of the allowed values",
								schema: schema92.properties.type.enum,
								parentSchema: schema92.properties.type,
								data: data10,
							},
						];
						return false;
					}
					var valid19 = _errs41 === errors;
				} else {
					var valid19 = true;
				}
				if (valid19) {
					if (data.description !== undefined) {
						let data11 = data.description;
						const _errs42 = errors;
						if (typeof data11 !== "string") {
							validate111.errors = [
								{
									instancePath: instancePath + "/description",
									schemaPath: "#/properties/description/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema92.properties.description.type,
									parentSchema: schema92.properties.description,
									data: data11,
								},
							];
							return false;
						}
						var valid19 = _errs42 === errors;
					} else {
						var valid19 = true;
					}
					if (valid19) {
						if (props0 !== true) {
							for (const key1 in data) {
								if (!props0 || !props0[key1]) {
									validate111.errors = [
										{
											instancePath,
											schemaPath: "#/unevaluatedProperties",
											keyword: "unevaluatedProperties",
											params: { unevaluatedProperty: key1 },
											message: "must NOT have unevaluated properties",
											schema: false,
											parentSchema: schema92,
											data,
										},
									];
									return false;
									break;
								}
							}
						}
					}
				}
			}
		} else {
			validate111.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema92.type,
					parentSchema: schema92,
					data,
				},
			];
			return false;
		}
	}
	validate111.errors = vErrors;
	return errors === 0;
}
validate111.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate109(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate109.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	let valid0 = true;
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.$ref === undefined && (missing0 = "$ref")) {
				const err0 = {};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		} else {
			const err1 = {};
			if (vErrors === null) {
				vErrors = [err1];
			} else {
				vErrors.push(err1);
			}
			errors++;
		}
	}
	var _valid0 = _errs1 === errors;
	errors = _errs0;
	if (vErrors !== null) {
		if (_errs0) {
			vErrors.length = _errs0;
		} else {
			vErrors = null;
		}
	}
	let ifClause0;
	if (_valid0) {
		const _errs3 = errors;
		if (
			!validate35(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate35.errors
					: vErrors.concat(validate35.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs3 === errors;
		valid0 = _valid0;
		if (valid0) {
			var props0 = {};
			props0.$ref = true;
			props0.summary = true;
			props0.description = true;
		}
		ifClause0 = "then";
	} else {
		const _errs4 = errors;
		if (
			!validate111(data, {
				instancePath,
				parentData,
				parentDataProperty,
				rootData,
				dynamicAnchors,
			})
		) {
			vErrors =
				vErrors === null
					? validate111.errors
					: vErrors.concat(validate111.errors);
			errors = vErrors.length;
		}
		var _valid0 = _errs4 === errors;
		valid0 = _valid0;
		if (valid0) {
			if (props0 !== true) {
				props0 = true;
			}
		}
		ifClause0 = "else";
	}
	if (!valid0) {
		const err2 = {
			instancePath,
			schemaPath: "#/if",
			keyword: "if",
			params: { failingKeyword: ifClause0 },
			message: 'must match "' + ifClause0 + '" schema',
			schema: schema91.if,
			parentSchema: schema91,
			data,
		};
		if (vErrors === null) {
			vErrors = [err2];
		} else {
			vErrors.push(err2);
		}
		errors++;
		validate109.errors = vErrors;
		return false;
	}
	validate109.errors = vErrors;
	evaluated0.props = props0;
	return errors === 0;
}
validate109.evaluated = { dynamicProps: true, dynamicItems: false };
function validate103(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate103.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			if (props0 !== true) {
				props0 = props0 || {};
				props0.schemas = true;
				props0.responses = true;
				props0.parameters = true;
				props0.examples = true;
				props0.requestBodies = true;
				props0.headers = true;
				props0.securitySchemes = true;
				props0.links = true;
				props0.callbacks = true;
				props0.pathItems = true;
			}
			if (data.schemas !== undefined) {
				let data0 = data.schemas;
				const _errs4 = errors;
				if (errors === _errs4) {
					if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
						for (const key1 in data0) {
							const _errs7 = errors;
							if (
								!validate103(data0[key1], {
									instancePath:
										instancePath +
										"/schemas/" +
										key1.replace(/~/g, "~0").replace(/\//g, "~1"),
									parentData: data0,
									parentDataProperty: key1,
									rootData,
									dynamicAnchors,
								})
							) {
								vErrors =
									vErrors === null
										? validate103.errors
										: vErrors.concat(validate103.errors);
								errors = vErrors.length;
							}
							var valid3 = _errs7 === errors;
							if (!valid3) {
								break;
							}
						}
					} else {
						validate103.errors = [
							{
								instancePath: instancePath + "/schemas",
								schemaPath: "#/properties/schemas/type",
								keyword: "type",
								params: { type: "object" },
								message: "must be object",
								schema: schema89.properties.schemas.type,
								parentSchema: schema89.properties.schemas,
								data: data0,
							},
						];
						return false;
					}
				}
				var valid2 = _errs4 === errors;
			} else {
				var valid2 = true;
			}
			if (valid2) {
				if (data.responses !== undefined) {
					let data2 = data.responses;
					const _errs8 = errors;
					if (errors === _errs8) {
						if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
							for (const key2 in data2) {
								const _errs11 = errors;
								if (
									!validate71(data2[key2], {
										instancePath:
											instancePath +
											"/responses/" +
											key2.replace(/~/g, "~0").replace(/\//g, "~1"),
										parentData: data2,
										parentDataProperty: key2,
										rootData,
										dynamicAnchors,
									})
								) {
									vErrors =
										vErrors === null
											? validate71.errors
											: vErrors.concat(validate71.errors);
									errors = vErrors.length;
								}
								var valid5 = _errs11 === errors;
								if (!valid5) {
									break;
								}
							}
						} else {
							validate103.errors = [
								{
									instancePath: instancePath + "/responses",
									schemaPath: "#/properties/responses/type",
									keyword: "type",
									params: { type: "object" },
									message: "must be object",
									schema: schema89.properties.responses.type,
									parentSchema: schema89.properties.responses,
									data: data2,
								},
							];
							return false;
						}
					}
					var valid2 = _errs8 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.parameters !== undefined) {
						let data4 = data.parameters;
						const _errs12 = errors;
						if (errors === _errs12) {
							if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
								for (const key3 in data4) {
									const _errs15 = errors;
									if (
										!validate34(data4[key3], {
											instancePath:
												instancePath +
												"/parameters/" +
												key3.replace(/~/g, "~0").replace(/\//g, "~1"),
											parentData: data4,
											parentDataProperty: key3,
											rootData,
											dynamicAnchors,
										})
									) {
										vErrors =
											vErrors === null
												? validate34.errors
												: vErrors.concat(validate34.errors);
										errors = vErrors.length;
									}
									var valid6 = _errs15 === errors;
									if (!valid6) {
										break;
									}
								}
							} else {
								validate103.errors = [
									{
										instancePath: instancePath + "/parameters",
										schemaPath: "#/properties/parameters/type",
										keyword: "type",
										params: { type: "object" },
										message: "must be object",
										schema: schema89.properties.parameters.type,
										parentSchema: schema89.properties.parameters,
										data: data4,
									},
								];
								return false;
							}
						}
						var valid2 = _errs12 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.examples !== undefined) {
							let data6 = data.examples;
							const _errs16 = errors;
							if (errors === _errs16) {
								if (
									data6 &&
									typeof data6 == "object" &&
									!Array.isArray(data6)
								) {
									for (const key4 in data6) {
										const _errs19 = errors;
										if (
											!validate41(data6[key4], {
												instancePath:
													instancePath +
													"/examples/" +
													key4.replace(/~/g, "~0").replace(/\//g, "~1"),
												parentData: data6,
												parentDataProperty: key4,
												rootData,
												dynamicAnchors,
											})
										) {
											vErrors =
												vErrors === null
													? validate41.errors
													: vErrors.concat(validate41.errors);
											errors = vErrors.length;
										}
										var valid7 = _errs19 === errors;
										if (!valid7) {
											break;
										}
									}
								} else {
									validate103.errors = [
										{
											instancePath: instancePath + "/examples",
											schemaPath: "#/properties/examples/type",
											keyword: "type",
											params: { type: "object" },
											message: "must be object",
											schema: schema89.properties.examples.type,
											parentSchema: schema89.properties.examples,
											data: data6,
										},
									];
									return false;
								}
							}
							var valid2 = _errs16 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (data.requestBodies !== undefined) {
								let data8 = data.requestBodies;
								const _errs20 = errors;
								if (errors === _errs20) {
									if (
										data8 &&
										typeof data8 == "object" &&
										!Array.isArray(data8)
									) {
										for (const key5 in data8) {
											const _errs23 = errors;
											if (
												!validate64(data8[key5], {
													instancePath:
														instancePath +
														"/requestBodies/" +
														key5.replace(/~/g, "~0").replace(/\//g, "~1"),
													parentData: data8,
													parentDataProperty: key5,
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate64.errors
														: vErrors.concat(validate64.errors);
												errors = vErrors.length;
											}
											var valid8 = _errs23 === errors;
											if (!valid8) {
												break;
											}
										}
									} else {
										validate103.errors = [
											{
												instancePath: instancePath + "/requestBodies",
												schemaPath: "#/properties/requestBodies/type",
												keyword: "type",
												params: { type: "object" },
												message: "must be object",
												schema: schema89.properties.requestBodies.type,
												parentSchema: schema89.properties.requestBodies,
												data: data8,
											},
										];
										return false;
									}
								}
								var valid2 = _errs20 === errors;
							} else {
								var valid2 = true;
							}
							if (valid2) {
								if (data.headers !== undefined) {
									let data10 = data.headers;
									const _errs24 = errors;
									if (errors === _errs24) {
										if (
											data10 &&
											typeof data10 == "object" &&
											!Array.isArray(data10)
										) {
											for (const key6 in data10) {
												const _errs27 = errors;
												if (
													!validate48(data10[key6], {
														instancePath:
															instancePath +
															"/headers/" +
															key6.replace(/~/g, "~0").replace(/\//g, "~1"),
														parentData: data10,
														parentDataProperty: key6,
														rootData,
														dynamicAnchors,
													})
												) {
													vErrors =
														vErrors === null
															? validate48.errors
															: vErrors.concat(validate48.errors);
													errors = vErrors.length;
												}
												var valid9 = _errs27 === errors;
												if (!valid9) {
													break;
												}
											}
										} else {
											validate103.errors = [
												{
													instancePath: instancePath + "/headers",
													schemaPath: "#/properties/headers/type",
													keyword: "type",
													params: { type: "object" },
													message: "must be object",
													schema: schema89.properties.headers.type,
													parentSchema: schema89.properties.headers,
													data: data10,
												},
											];
											return false;
										}
									}
									var valid2 = _errs24 === errors;
								} else {
									var valid2 = true;
								}
								if (valid2) {
									if (data.securitySchemes !== undefined) {
										let data12 = data.securitySchemes;
										const _errs28 = errors;
										if (errors === _errs28) {
											if (
												data12 &&
												typeof data12 == "object" &&
												!Array.isArray(data12)
											) {
												for (const key7 in data12) {
													const _errs31 = errors;
													if (
														!validate109(data12[key7], {
															instancePath:
																instancePath +
																"/securitySchemes/" +
																key7.replace(/~/g, "~0").replace(/\//g, "~1"),
															parentData: data12,
															parentDataProperty: key7,
															rootData,
															dynamicAnchors,
														})
													) {
														vErrors =
															vErrors === null
																? validate109.errors
																: vErrors.concat(validate109.errors);
														errors = vErrors.length;
													}
													var valid10 = _errs31 === errors;
													if (!valid10) {
														break;
													}
												}
											} else {
												validate103.errors = [
													{
														instancePath: instancePath + "/securitySchemes",
														schemaPath: "#/properties/securitySchemes/type",
														keyword: "type",
														params: { type: "object" },
														message: "must be object",
														schema: schema89.properties.securitySchemes.type,
														parentSchema: schema89.properties.securitySchemes,
														data: data12,
													},
												];
												return false;
											}
										}
										var valid2 = _errs28 === errors;
									} else {
										var valid2 = true;
									}
									if (valid2) {
										if (data.links !== undefined) {
											let data14 = data.links;
											const _errs32 = errors;
											if (errors === _errs32) {
												if (
													data14 &&
													typeof data14 == "object" &&
													!Array.isArray(data14)
												) {
													for (const key8 in data14) {
														const _errs35 = errors;
														if (
															!validate76(data14[key8], {
																instancePath:
																	instancePath +
																	"/links/" +
																	key8.replace(/~/g, "~0").replace(/\//g, "~1"),
																parentData: data14,
																parentDataProperty: key8,
																rootData,
																dynamicAnchors,
															})
														) {
															vErrors =
																vErrors === null
																	? validate76.errors
																	: vErrors.concat(validate76.errors);
															errors = vErrors.length;
														}
														var valid11 = _errs35 === errors;
														if (!valid11) {
															break;
														}
													}
												} else {
													validate103.errors = [
														{
															instancePath: instancePath + "/links",
															schemaPath: "#/properties/links/type",
															keyword: "type",
															params: { type: "object" },
															message: "must be object",
															schema: schema89.properties.links.type,
															parentSchema: schema89.properties.links,
															data: data14,
														},
													];
													return false;
												}
											}
											var valid2 = _errs32 === errors;
										} else {
											var valid2 = true;
										}
										if (valid2) {
											if (data.callbacks !== undefined) {
												let data16 = data.callbacks;
												const _errs36 = errors;
												if (errors === _errs36) {
													if (
														data16 &&
														typeof data16 == "object" &&
														!Array.isArray(data16)
													) {
														for (const key9 in data16) {
															const _errs39 = errors;
															if (
																!validate86(data16[key9], {
																	instancePath:
																		instancePath +
																		"/callbacks/" +
																		key9
																			.replace(/~/g, "~0")
																			.replace(/\//g, "~1"),
																	parentData: data16,
																	parentDataProperty: key9,
																	rootData,
																	dynamicAnchors,
																})
															) {
																vErrors =
																	vErrors === null
																		? validate86.errors
																		: vErrors.concat(validate86.errors);
																errors = vErrors.length;
															}
															var valid12 = _errs39 === errors;
															if (!valid12) {
																break;
															}
														}
													} else {
														validate103.errors = [
															{
																instancePath: instancePath + "/callbacks",
																schemaPath: "#/properties/callbacks/type",
																keyword: "type",
																params: { type: "object" },
																message: "must be object",
																schema: schema89.properties.callbacks.type,
																parentSchema: schema89.properties.callbacks,
																data: data16,
															},
														];
														return false;
													}
												}
												var valid2 = _errs36 === errors;
											} else {
												var valid2 = true;
											}
											if (valid2) {
												if (data.pathItems !== undefined) {
													let data18 = data.pathItems;
													const _errs40 = errors;
													if (errors === _errs40) {
														if (
															data18 &&
															typeof data18 == "object" &&
															!Array.isArray(data18)
														) {
															for (const key10 in data18) {
																const _errs43 = errors;
																if (
																	!validate32(data18[key10], {
																		instancePath:
																			instancePath +
																			"/pathItems/" +
																			key10
																				.replace(/~/g, "~0")
																				.replace(/\//g, "~1"),
																		parentData: data18,
																		parentDataProperty: key10,
																		rootData,
																		dynamicAnchors,
																	})
																) {
																	vErrors =
																		vErrors === null
																			? validate32.errors
																			: vErrors.concat(validate32.errors);
																	errors = vErrors.length;
																}
																var valid13 = _errs43 === errors;
																if (!valid13) {
																	break;
																}
															}
														} else {
															validate103.errors = [
																{
																	instancePath: instancePath + "/pathItems",
																	schemaPath: "#/properties/pathItems/type",
																	keyword: "type",
																	params: { type: "object" },
																	message: "must be object",
																	schema: schema89.properties.pathItems.type,
																	parentSchema: schema89.properties.pathItems,
																	data: data18,
																},
															];
															return false;
														}
													}
													var valid2 = _errs40 === errors;
												} else {
													var valid2 = true;
												}
												if (valid2) {
													var valid14 = true;
													for (const key11 in data) {
														if (pattern36.test(key11)) {
															let data20 = data[key11];
															const _errs44 = errors;
															if (errors === _errs44) {
																if (
																	data20 &&
																	typeof data20 == "object" &&
																	!Array.isArray(data20)
																) {
																	for (const key12 in data20) {
																		const _errs46 = errors;
																		if (typeof key12 === "string") {
																			if (!pattern37.test(key12)) {
																				const err0 = {
																					instancePath:
																						instancePath +
																						"/" +
																						key11
																							.replace(/~/g, "~0")
																							.replace(/\//g, "~1"),
																					schemaPath:
																						"#/patternProperties/%5E(schemas%7Cresponses%7Cparameters%7Cexamples%7CrequestBodies%7Cheaders%7CsecuritySchemes%7Clinks%7Ccallbacks%7CpathItems)%24/propertyNames/pattern",
																					keyword: "pattern",
																					params: {
																						pattern: "^[a-zA-Z0-9._-]+$",
																					},
																					message:
																						'must match pattern "' +
																						"^[a-zA-Z0-9._-]+$" +
																						'"',
																					schema: "^[a-zA-Z0-9._-]+$",
																					parentSchema:
																						schema89.patternProperties[
																							"^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$"
																						].propertyNames,
																					data: key12,
																					propertyName: key12,
																				};
																				if (vErrors === null) {
																					vErrors = [err0];
																				} else {
																					vErrors.push(err0);
																				}
																				errors++;
																			}
																		}
																		var valid15 = _errs46 === errors;
																		if (!valid15) {
																			const err1 = {
																				instancePath:
																					instancePath +
																					"/" +
																					key11
																						.replace(/~/g, "~0")
																						.replace(/\//g, "~1"),
																				schemaPath:
																					"#/patternProperties/%5E(schemas%7Cresponses%7Cparameters%7Cexamples%7CrequestBodies%7Cheaders%7CsecuritySchemes%7Clinks%7Ccallbacks%7CpathItems)%24/propertyNames",
																				keyword: "propertyNames",
																				params: { propertyName: key12 },
																				message: "property name must be valid",
																				schema:
																					schema89.patternProperties[
																						"^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$"
																					].propertyNames,
																				parentSchema:
																					schema89.patternProperties[
																						"^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$"
																					],
																				data: data20,
																			};
																			if (vErrors === null) {
																				vErrors = [err1];
																			} else {
																				vErrors.push(err1);
																			}
																			errors++;
																			validate103.errors = vErrors;
																			return false;
																			break;
																		}
																	}
																}
															}
															var valid14 = _errs44 === errors;
															props0[key11] = true;
														}
													}
													if (valid14) {
														if (props0 !== true) {
															for (const key13 in data) {
																if (!props0 || !props0[key13]) {
																	validate103.errors = [
																		{
																			instancePath,
																			schemaPath: "#/unevaluatedProperties",
																			keyword: "unevaluatedProperties",
																			params: { unevaluatedProperty: key13 },
																			message:
																				"must NOT have unevaluated properties",
																			schema: false,
																			parentSchema: schema89,
																			data,
																		},
																	];
																	return false;
																	break;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate103.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema89.type,
					parentSchema: schema89,
					data,
				},
			];
			return false;
		}
	}
	validate103.errors = vErrors;
	return errors === 0;
}
validate103.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
const schema114 = {
	$comment: "https://spec.openapis.org/oas/v3.1#tag-object",
	type: "object",
	properties: {
		name: { type: "string" },
		description: { type: "string" },
		externalDocs: { $ref: "#/$defs/external-documentation" },
	},
	required: ["name"],
	$ref: "#/$defs/specification-extensions",
	unevaluatedProperties: false,
};
function validate130(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate130.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs1 = errors;
	if (errors === _errs1) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.name === undefined && (missing0 = "name")) {
				validate130.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing0 },
						message: "must have required property '" + missing0 + "'",
						schema: schema114.required,
						parentSchema: schema114,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.name = true;
					props0.description = true;
					props0.externalDocs = true;
				}
				if (data.name !== undefined) {
					let data0 = data.name;
					const _errs4 = errors;
					if (typeof data0 !== "string") {
						validate130.errors = [
							{
								instancePath: instancePath + "/name",
								schemaPath: "#/properties/name/type",
								keyword: "type",
								params: { type: "string" },
								message: "must be string",
								schema: schema114.properties.name.type,
								parentSchema: schema114.properties.name,
								data: data0,
							},
						];
						return false;
					}
					var valid2 = _errs4 === errors;
				} else {
					var valid2 = true;
				}
				if (valid2) {
					if (data.description !== undefined) {
						let data1 = data.description;
						const _errs6 = errors;
						if (typeof data1 !== "string") {
							validate130.errors = [
								{
									instancePath: instancePath + "/description",
									schemaPath: "#/properties/description/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema114.properties.description.type,
									parentSchema: schema114.properties.description,
									data: data1,
								},
							];
							return false;
						}
						var valid2 = _errs6 === errors;
					} else {
						var valid2 = true;
					}
					if (valid2) {
						if (data.externalDocs !== undefined) {
							const _errs8 = errors;
							if (
								!validate61(data.externalDocs, {
									instancePath: instancePath + "/externalDocs",
									parentData: data,
									parentDataProperty: "externalDocs",
									rootData,
									dynamicAnchors,
								})
							) {
								vErrors =
									vErrors === null
										? validate61.errors
										: vErrors.concat(validate61.errors);
								errors = vErrors.length;
							}
							var valid2 = _errs8 === errors;
						} else {
							var valid2 = true;
						}
						if (valid2) {
							if (props0 !== true) {
								for (const key1 in data) {
									if (!props0 || !props0[key1]) {
										validate130.errors = [
											{
												instancePath,
												schemaPath: "#/unevaluatedProperties",
												keyword: "unevaluatedProperties",
												params: { unevaluatedProperty: key1 },
												message: "must NOT have unevaluated properties",
												schema: false,
												parentSchema: schema114,
												data,
											},
										];
										return false;
										break;
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate130.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema114.type,
					parentSchema: schema114,
					data,
				},
			];
			return false;
		}
	}
	validate130.errors = vErrors;
	return errors === 0;
}
validate130.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
function validate20(
	data,
	{
		instancePath = "",
		parentData,
		parentDataProperty,
		rootData = data,
		dynamicAnchors = {},
	} = {},
) {
	/*# sourceURL="https://spec.openapis.org/oas/3.1/schema/2025-02-13" */
	let vErrors = null;
	let errors = 0;
	const evaluated0 = validate20.evaluated;
	if (evaluated0.dynamicProps) {
		evaluated0.props = undefined;
	}
	if (evaluated0.dynamicItems) {
		evaluated0.items = undefined;
	}
	const _errs0 = errors;
	if (errors === _errs0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			var props0 = {};
			for (const key0 in data) {
				if (pattern4.test(key0)) {
					props0[key0] = true;
				}
			}
		}
	}
	var valid0 = _errs0 === errors;
	if (valid0) {
		const _errs3 = errors;
		let valid2 = false;
		const _errs4 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing0;
			if (data.paths === undefined && (missing0 = "paths")) {
				const err0 = {
					instancePath,
					schemaPath: "#/anyOf/0/required",
					keyword: "required",
					params: { missingProperty: missing0 },
					message: "must have required property '" + missing0 + "'",
					schema: schema31.anyOf[0].required,
					parentSchema: schema31.anyOf[0],
					data,
				};
				if (vErrors === null) {
					vErrors = [err0];
				} else {
					vErrors.push(err0);
				}
				errors++;
			}
		}
		var _valid0 = _errs4 === errors;
		valid2 = valid2 || _valid0;
		const _errs5 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing1;
			if (data.components === undefined && (missing1 = "components")) {
				const err1 = {
					instancePath,
					schemaPath: "#/anyOf/1/required",
					keyword: "required",
					params: { missingProperty: missing1 },
					message: "must have required property '" + missing1 + "'",
					schema: schema31.anyOf[1].required,
					parentSchema: schema31.anyOf[1],
					data,
				};
				if (vErrors === null) {
					vErrors = [err1];
				} else {
					vErrors.push(err1);
				}
				errors++;
			}
		}
		var _valid0 = _errs5 === errors;
		valid2 = valid2 || _valid0;
		const _errs6 = errors;
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing2;
			if (data.webhooks === undefined && (missing2 = "webhooks")) {
				const err2 = {
					instancePath,
					schemaPath: "#/anyOf/2/required",
					keyword: "required",
					params: { missingProperty: missing2 },
					message: "must have required property '" + missing2 + "'",
					schema: schema31.anyOf[2].required,
					parentSchema: schema31.anyOf[2],
					data,
				};
				if (vErrors === null) {
					vErrors = [err2];
				} else {
					vErrors.push(err2);
				}
				errors++;
			}
		}
		var _valid0 = _errs6 === errors;
		valid2 = valid2 || _valid0;
		if (!valid2) {
			const err3 = {
				instancePath,
				schemaPath: "#/anyOf",
				keyword: "anyOf",
				params: {},
				message: "must match a schema in anyOf",
				schema: schema31.anyOf,
				parentSchema: schema31,
				data,
			};
			if (vErrors === null) {
				vErrors = [err3];
			} else {
				vErrors.push(err3);
			}
			errors++;
			validate20.errors = vErrors;
			return false;
		} else {
			errors = _errs3;
			if (vErrors !== null) {
				if (_errs3) {
					vErrors.length = _errs3;
				} else {
					vErrors = null;
				}
			}
		}
	}
	if (errors === 0) {
		if (data && typeof data == "object" && !Array.isArray(data)) {
			let missing3;
			if (
				(data.openapi === undefined && (missing3 = "openapi")) ||
				(data.info === undefined && (missing3 = "info"))
			) {
				validate20.errors = [
					{
						instancePath,
						schemaPath: "#/required",
						keyword: "required",
						params: { missingProperty: missing3 },
						message: "must have required property '" + missing3 + "'",
						schema: schema31.required,
						parentSchema: schema31,
						data,
					},
				];
				return false;
			} else {
				if (props0 !== true) {
					props0 = props0 || {};
					props0.openapi = true;
					props0.info = true;
					props0.jsonSchemaDialect = true;
					props0.servers = true;
					props0.paths = true;
					props0.webhooks = true;
					props0.components = true;
					props0.security = true;
					props0.tags = true;
					props0.externalDocs = true;
				}
				if (data.openapi !== undefined) {
					let data0 = data.openapi;
					const _errs7 = errors;
					if (errors === _errs7) {
						if (typeof data0 === "string") {
							if (!pattern5.test(data0)) {
								validate20.errors = [
									{
										instancePath: instancePath + "/openapi",
										schemaPath: "#/properties/openapi/pattern",
										keyword: "pattern",
										params: { pattern: "^3\\.1\\.\\d+(-.+)?$" },
										message:
											'must match pattern "' + "^3\\.1\\.\\d+(-.+)?$" + '"',
										schema: "^3\\.1\\.\\d+(-.+)?$",
										parentSchema: schema31.properties.openapi,
										data: data0,
									},
								];
								return false;
							}
						} else {
							validate20.errors = [
								{
									instancePath: instancePath + "/openapi",
									schemaPath: "#/properties/openapi/type",
									keyword: "type",
									params: { type: "string" },
									message: "must be string",
									schema: schema31.properties.openapi.type,
									parentSchema: schema31.properties.openapi,
									data: data0,
								},
							];
							return false;
						}
					}
					var valid3 = _errs7 === errors;
				} else {
					var valid3 = true;
				}
				if (valid3) {
					if (data.info !== undefined) {
						const _errs9 = errors;
						if (
							!validate21(data.info, {
								instancePath: instancePath + "/info",
								parentData: data,
								parentDataProperty: "info",
								rootData,
								dynamicAnchors,
							})
						) {
							vErrors =
								vErrors === null
									? validate21.errors
									: vErrors.concat(validate21.errors);
							errors = vErrors.length;
						}
						var valid3 = _errs9 === errors;
					} else {
						var valid3 = true;
					}
					if (valid3) {
						if (data.jsonSchemaDialect !== undefined) {
							let data2 = data.jsonSchemaDialect;
							const _errs10 = errors;
							if (errors === _errs10) {
								if (errors === _errs10) {
									if (typeof data2 === "string") {
										if (!formats0.test(data2)) {
											validate20.errors = [
												{
													instancePath: instancePath + "/jsonSchemaDialect",
													schemaPath: "#/properties/jsonSchemaDialect/format",
													keyword: "format",
													params: { format: "uri-reference" },
													message:
														'must match format "' + "uri-reference" + '"',
													schema: "uri-reference",
													parentSchema: schema31.properties.jsonSchemaDialect,
													data: data2,
												},
											];
											return false;
										}
									} else {
										validate20.errors = [
											{
												instancePath: instancePath + "/jsonSchemaDialect",
												schemaPath: "#/properties/jsonSchemaDialect/type",
												keyword: "type",
												params: { type: "string" },
												message: "must be string",
												schema: schema31.properties.jsonSchemaDialect.type,
												parentSchema: schema31.properties.jsonSchemaDialect,
												data: data2,
											},
										];
										return false;
									}
								}
							}
							var valid3 = _errs10 === errors;
						} else {
							var valid3 = true;
						}
						if (valid3) {
							if (data.servers !== undefined) {
								let data3 = data.servers;
								const _errs12 = errors;
								if (errors === _errs12) {
									if (Array.isArray(data3)) {
										var valid4 = true;
										const len0 = data3.length;
										for (let i0 = 0; i0 < len0; i0++) {
											const _errs14 = errors;
											if (
												!validate27(data3[i0], {
													instancePath: instancePath + "/servers/" + i0,
													parentData: data3,
													parentDataProperty: i0,
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate27.errors
														: vErrors.concat(validate27.errors);
												errors = vErrors.length;
											}
											var valid4 = _errs14 === errors;
											if (!valid4) {
												break;
											}
										}
									} else {
										validate20.errors = [
											{
												instancePath: instancePath + "/servers",
												schemaPath: "#/properties/servers/type",
												keyword: "type",
												params: { type: "array" },
												message: "must be array",
												schema: schema31.properties.servers.type,
												parentSchema: schema31.properties.servers,
												data: data3,
											},
										];
										return false;
									}
								}
								var valid3 = _errs12 === errors;
							} else {
								var valid3 = true;
							}
							if (valid3) {
								if (data.paths !== undefined) {
									const _errs15 = errors;
									if (
										!validate31(data.paths, {
											instancePath: instancePath + "/paths",
											parentData: data,
											parentDataProperty: "paths",
											rootData,
											dynamicAnchors,
										})
									) {
										vErrors =
											vErrors === null
												? validate31.errors
												: vErrors.concat(validate31.errors);
										errors = vErrors.length;
									}
									var valid3 = _errs15 === errors;
								} else {
									var valid3 = true;
								}
								if (valid3) {
									if (data.webhooks !== undefined) {
										let data6 = data.webhooks;
										const _errs16 = errors;
										if (errors === _errs16) {
											if (
												data6 &&
												typeof data6 == "object" &&
												!Array.isArray(data6)
											) {
												for (const key1 in data6) {
													const _errs19 = errors;
													if (
														!validate32(data6[key1], {
															instancePath:
																instancePath +
																"/webhooks/" +
																key1.replace(/~/g, "~0").replace(/\//g, "~1"),
															parentData: data6,
															parentDataProperty: key1,
															rootData,
															dynamicAnchors,
														})
													) {
														vErrors =
															vErrors === null
																? validate32.errors
																: vErrors.concat(validate32.errors);
														errors = vErrors.length;
													}
													var valid5 = _errs19 === errors;
													if (!valid5) {
														break;
													}
												}
											} else {
												validate20.errors = [
													{
														instancePath: instancePath + "/webhooks",
														schemaPath: "#/properties/webhooks/type",
														keyword: "type",
														params: { type: "object" },
														message: "must be object",
														schema: schema31.properties.webhooks.type,
														parentSchema: schema31.properties.webhooks,
														data: data6,
													},
												];
												return false;
											}
										}
										var valid3 = _errs16 === errors;
									} else {
										var valid3 = true;
									}
									if (valid3) {
										if (data.components !== undefined) {
											const _errs20 = errors;
											if (
												!validate103(data.components, {
													instancePath: instancePath + "/components",
													parentData: data,
													parentDataProperty: "components",
													rootData,
													dynamicAnchors,
												})
											) {
												vErrors =
													vErrors === null
														? validate103.errors
														: vErrors.concat(validate103.errors);
												errors = vErrors.length;
											}
											var valid3 = _errs20 === errors;
										} else {
											var valid3 = true;
										}
										if (valid3) {
											if (data.security !== undefined) {
												let data9 = data.security;
												const _errs21 = errors;
												if (errors === _errs21) {
													if (Array.isArray(data9)) {
														var valid6 = true;
														const len1 = data9.length;
														for (let i1 = 0; i1 < len1; i1++) {
															let data10 = data9[i1];
															const _errs23 = errors;
															const _errs24 = errors;
															if (errors === _errs24) {
																if (
																	data10 &&
																	typeof data10 == "object" &&
																	!Array.isArray(data10)
																) {
																	for (const key2 in data10) {
																		let data11 = data10[key2];
																		const _errs28 = errors;
																		if (errors === _errs28) {
																			if (Array.isArray(data11)) {
																				var valid9 = true;
																				const len2 = data11.length;
																				for (let i2 = 0; i2 < len2; i2++) {
																					let data12 = data11[i2];
																					const _errs30 = errors;
																					if (typeof data12 !== "string") {
																						validate20.errors = [
																							{
																								instancePath:
																									instancePath +
																									"/security/" +
																									i1 +
																									"/" +
																									key2
																										.replace(/~/g, "~0")
																										.replace(/\//g, "~1") +
																									"/" +
																									i2,
																								schemaPath:
																									"#/$defs/security-requirement/additionalProperties/items/type",
																								keyword: "type",
																								params: { type: "string" },
																								message: "must be string",
																								schema:
																									schema88.additionalProperties
																										.items.type,
																								parentSchema:
																									schema88.additionalProperties
																										.items,
																								data: data12,
																							},
																						];
																						return false;
																					}
																					var valid9 = _errs30 === errors;
																					if (!valid9) {
																						break;
																					}
																				}
																			} else {
																				validate20.errors = [
																					{
																						instancePath:
																							instancePath +
																							"/security/" +
																							i1 +
																							"/" +
																							key2
																								.replace(/~/g, "~0")
																								.replace(/\//g, "~1"),
																						schemaPath:
																							"#/$defs/security-requirement/additionalProperties/type",
																						keyword: "type",
																						params: { type: "array" },
																						message: "must be array",
																						schema:
																							schema88.additionalProperties
																								.type,
																						parentSchema:
																							schema88.additionalProperties,
																						data: data11,
																					},
																				];
																				return false;
																			}
																		}
																		var valid8 = _errs28 === errors;
																		if (!valid8) {
																			break;
																		}
																	}
																} else {
																	validate20.errors = [
																		{
																			instancePath:
																				instancePath + "/security/" + i1,
																			schemaPath:
																				"#/$defs/security-requirement/type",
																			keyword: "type",
																			params: { type: "object" },
																			message: "must be object",
																			schema: schema88.type,
																			parentSchema: schema88,
																			data: data10,
																		},
																	];
																	return false;
																}
															}
															var valid6 = _errs23 === errors;
															if (!valid6) {
																break;
															}
														}
													} else {
														validate20.errors = [
															{
																instancePath: instancePath + "/security",
																schemaPath: "#/properties/security/type",
																keyword: "type",
																params: { type: "array" },
																message: "must be array",
																schema: schema31.properties.security.type,
																parentSchema: schema31.properties.security,
																data: data9,
															},
														];
														return false;
													}
												}
												var valid3 = _errs21 === errors;
											} else {
												var valid3 = true;
											}
											if (valid3) {
												if (data.tags !== undefined) {
													let data13 = data.tags;
													const _errs32 = errors;
													if (errors === _errs32) {
														if (Array.isArray(data13)) {
															var valid10 = true;
															const len3 = data13.length;
															for (let i3 = 0; i3 < len3; i3++) {
																const _errs34 = errors;
																if (
																	!validate130(data13[i3], {
																		instancePath: instancePath + "/tags/" + i3,
																		parentData: data13,
																		parentDataProperty: i3,
																		rootData,
																		dynamicAnchors,
																	})
																) {
																	vErrors =
																		vErrors === null
																			? validate130.errors
																			: vErrors.concat(validate130.errors);
																	errors = vErrors.length;
																}
																var valid10 = _errs34 === errors;
																if (!valid10) {
																	break;
																}
															}
														} else {
															validate20.errors = [
																{
																	instancePath: instancePath + "/tags",
																	schemaPath: "#/properties/tags/type",
																	keyword: "type",
																	params: { type: "array" },
																	message: "must be array",
																	schema: schema31.properties.tags.type,
																	parentSchema: schema31.properties.tags,
																	data: data13,
																},
															];
															return false;
														}
													}
													var valid3 = _errs32 === errors;
												} else {
													var valid3 = true;
												}
												if (valid3) {
													if (data.externalDocs !== undefined) {
														const _errs35 = errors;
														if (
															!validate61(data.externalDocs, {
																instancePath: instancePath + "/externalDocs",
																parentData: data,
																parentDataProperty: "externalDocs",
																rootData,
																dynamicAnchors,
															})
														) {
															vErrors =
																vErrors === null
																	? validate61.errors
																	: vErrors.concat(validate61.errors);
															errors = vErrors.length;
														}
														var valid3 = _errs35 === errors;
													} else {
														var valid3 = true;
													}
													if (valid3) {
														if (props0 !== true) {
															for (const key3 in data) {
																if (!props0 || !props0[key3]) {
																	validate20.errors = [
																		{
																			instancePath,
																			schemaPath: "#/unevaluatedProperties",
																			keyword: "unevaluatedProperties",
																			params: { unevaluatedProperty: key3 },
																			message:
																				"must NOT have unevaluated properties",
																			schema: false,
																			parentSchema: schema31,
																			data,
																		},
																	];
																	return false;
																	break;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			validate20.errors = [
				{
					instancePath,
					schemaPath: "#/type",
					keyword: "type",
					params: { type: "object" },
					message: "must be object",
					schema: schema31.type,
					parentSchema: schema31,
					data,
				},
			];
			return false;
		}
	}
	validate20.errors = vErrors;
	return errors === 0;
}
validate20.evaluated = {
	props: true,
	dynamicProps: false,
	dynamicItems: false,
};
/* c8 ignore end */
