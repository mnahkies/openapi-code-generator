/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {ExpressRuntimeError} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  SkipResponse,
  type StatusCode,
} from "@nahkies/typescript-express-runtime/server"
import {responseValidationFactory} from "@nahkies/typescript-express-runtime/zod-v4"
import {type NextFunction, type Request, type Response, Router} from "express"
import {z} from "zod/v4"

export type GetEscapeHatchesPlainTextResponder = {
  with200(): ExpressRuntimeResponse<string>
} & ExpressRuntimeResponder

export type GetEscapeHatchesPlainText = (
  params: Params<void, void, void, void>,
  respond: GetEscapeHatchesPlainTextResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type EscapeHatchesImplementation = {
  getEscapeHatchesPlainText: GetEscapeHatchesPlainText
}

export function createEscapeHatchesRouter(
  implementation: EscapeHatchesImplementation,
): Router {
  const router = Router()

  const getEscapeHatchesPlainTextResponseBodyValidator =
    responseValidationFactory([["200", z.string()]], undefined)

  // getEscapeHatchesPlainText
  router.get(
    `/escape-hatches/plain-text`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<string>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getEscapeHatchesPlainText(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getEscapeHatchesPlainTextResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export {createEscapeHatchesRouter as createRouter}
export type {EscapeHatchesImplementation as Implementation}
