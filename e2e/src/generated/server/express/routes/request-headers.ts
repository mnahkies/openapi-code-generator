/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import type {
  t_GetHeadersRequestRequestHeaderSchema,
  t_getHeadersRequestJson200Response,
  t_getHeadersUndeclaredJson200Response,
} from "../models"
import {
  PermissiveBoolean,
  s_getHeadersRequestJson200Response,
  s_getHeadersUndeclaredJson200Response,
} from "../schemas"
import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  SkipResponse,
  type StatusCode,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v4"
import {type NextFunction, type Request, type Response, Router} from "express"
import {z} from "zod/v4"

export type GetHeadersUndeclaredResponder = {
  with200(): ExpressRuntimeResponse<t_getHeadersUndeclaredJson200Response>
} & ExpressRuntimeResponder

export type GetHeadersUndeclared = (
  params: Params<void, void, void, void>,
  respond: GetHeadersUndeclaredResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetHeadersRequestResponder = {
  with200(): ExpressRuntimeResponse<t_getHeadersRequestJson200Response>
} & ExpressRuntimeResponder

export type GetHeadersRequest = (
  params: Params<void, void, void, t_GetHeadersRequestRequestHeaderSchema>,
  respond: GetHeadersRequestResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type RequestHeadersImplementation = {
  getHeadersUndeclared: GetHeadersUndeclared
  getHeadersRequest: GetHeadersRequest
}

export function createRequestHeadersRouter(
  implementation: RequestHeadersImplementation,
): Router {
  const router = Router()

  const getHeadersUndeclaredResponseBodyValidator = responseValidationFactory(
    [["200", s_getHeadersUndeclaredJson200Response]],
    undefined,
  )

  // getHeadersUndeclared
  router.get(
    `/headers/undeclared`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_getHeadersUndeclaredJson200Response>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getHeadersUndeclared(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getHeadersUndeclaredResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getHeadersRequestRequestHeaderSchema = z.object({
    "route-level-header": z.string().optional(),
    "number-header": z.coerce.number().optional(),
    "boolean-header": PermissiveBoolean.optional(),
    "second-boolean-header": PermissiveBoolean.optional(),
    authorization: z.string().optional(),
  })

  const getHeadersRequestResponseBodyValidator = responseValidationFactory(
    [["200", s_getHeadersRequestJson200Response]],
    undefined,
  )

  // getHeadersRequest
  router.get(
    `/headers/request`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            getHeadersRequestRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_getHeadersRequestJson200Response>(
              200,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getHeadersRequest(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getHeadersRequestResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export {createRequestHeadersRouter as createRouter}
export type {RequestHeadersImplementation as Implementation}
