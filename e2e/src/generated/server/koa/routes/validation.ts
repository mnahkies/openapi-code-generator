/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_Enumerations,
  t_GetValidationNumbersRandomNumberQuerySchema,
  t_PostValidationEnumsBodySchema,
  t_PostValidationOptionalBodyBodySchema,
  t_RandomNumber,
  t_postValidationOptionalBodyJson200Response,
} from "../models"
import {
  s_Enumerations,
  s_RandomNumber,
  s_postValidationOptionalBodyJson200Response,
  s_postValidationOptionalBodyJsonRequestBody,
} from "../schemas"
import KoaRouter, {RouterContext} from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  KoaRuntimeResponder,
  KoaRuntimeResponse,
  Params,
  Response,
  SkipResponse,
  StatusCode,
} from "@nahkies/typescript-koa-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod"
import {Next} from "koa"
import {z} from "zod"

export type GetValidationNumbersRandomNumberResponder = {
  with200(): KoaRuntimeResponse<t_RandomNumber>
} & KoaRuntimeResponder

export type GetValidationNumbersRandomNumber = (
  params: Params<
    void,
    t_GetValidationNumbersRandomNumberQuerySchema,
    void,
    void
  >,
  respond: GetValidationNumbersRandomNumberResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_RandomNumber>
  | typeof SkipResponse
>

export type PostValidationEnumsResponder = {
  with200(): KoaRuntimeResponse<t_Enumerations>
} & KoaRuntimeResponder

export type PostValidationEnums = (
  params: Params<void, void, t_PostValidationEnumsBodySchema, void>,
  respond: PostValidationEnumsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Enumerations>
  | typeof SkipResponse
>

export type PostValidationOptionalBodyResponder = {
  with200(): KoaRuntimeResponse<t_postValidationOptionalBodyJson200Response>
  with204(): KoaRuntimeResponse<void>
} & KoaRuntimeResponder

export type PostValidationOptionalBody = (
  params: Params<
    void,
    void,
    t_PostValidationOptionalBodyBodySchema | undefined,
    void
  >,
  respond: PostValidationOptionalBodyResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_postValidationOptionalBodyJson200Response>
  | Response<204, void>
  | typeof SkipResponse
>

export type GetResponses500Responder = {
  with500(): KoaRuntimeResponse<void>
} & KoaRuntimeResponder

export type GetResponses500 = (
  params: Params<void, void, void, void>,
  respond: GetResponses500Responder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<500, void> | typeof SkipResponse
>

export type GetResponsesEmptyResponder = {
  with204(): KoaRuntimeResponse<void>
} & KoaRuntimeResponder

export type GetResponsesEmpty = (
  params: Params<void, void, void, void>,
  respond: GetResponsesEmptyResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | typeof SkipResponse
>

export type ValidationImplementation = {
  getValidationNumbersRandomNumber: GetValidationNumbersRandomNumber
  postValidationEnums: PostValidationEnums
  postValidationOptionalBody: PostValidationOptionalBody
  getResponses500: GetResponses500
  getResponsesEmpty: GetResponsesEmpty
}

export function createValidationRouter(
  implementation: ValidationImplementation,
): KoaRouter {
  const router = new KoaRouter()

  const getValidationNumbersRandomNumberQuerySchema = z.object({
    max: z.coerce.number().min(1).optional().default(10),
    min: z.coerce.number().min(0).optional().default(0),
    forbidden: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.coerce.number()),
      )
      .optional(),
  })

  const getValidationNumbersRandomNumberResponseValidator =
    responseValidationFactory([["200", s_RandomNumber]], undefined)

  router.get(
    "getValidationNumbersRandomNumber",
    "/validation/numbers/random-number",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getValidationNumbersRandomNumberQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_RandomNumber>(200)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getValidationNumbersRandomNumber(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getValidationNumbersRandomNumberResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postValidationEnumsBodySchema = s_Enumerations

  const postValidationEnumsResponseValidator = responseValidationFactory(
    [["200", s_Enumerations]],
    undefined,
  )

  router.post("postValidationEnums", "/validation/enums", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postValidationEnumsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Enumerations>(200)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postValidationEnums(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postValidationEnumsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postValidationOptionalBodyBodySchema =
    s_postValidationOptionalBodyJsonRequestBody.optional()

  const postValidationOptionalBodyResponseValidator = responseValidationFactory(
    [
      ["200", s_postValidationOptionalBodyJson200Response],
      ["204", z.undefined()],
    ],
    undefined,
  )

  router.post(
    "postValidationOptionalBody",
    "/validation/optional-body",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postValidationOptionalBodyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_postValidationOptionalBodyJson200Response>(
            200,
          )
        },
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postValidationOptionalBody(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postValidationOptionalBodyResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getResponses500ResponseValidator = responseValidationFactory(
    [["500", z.undefined()]],
    undefined,
  )

  router.get("getResponses500", "/responses/500", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with500() {
        return new KoaRuntimeResponse<void>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getResponses500(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getResponses500ResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getResponsesEmptyResponseValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  router.get("getResponsesEmpty", "/responses/empty", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with204() {
        return new KoaRuntimeResponse<void>(204)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getResponsesEmpty(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getResponsesEmptyResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  return router
}

export {createValidationRouter as createRouter}
export type {ValidationImplementation as Implementation}
