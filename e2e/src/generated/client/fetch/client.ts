/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  AbstractFetchClient,
  type AbstractFetchClientConfig,
  type Res,
  type Server,
} from "@nahkies/typescript-fetch-runtime/main"
import {responseValidationFactory} from "@nahkies/typescript-fetch-runtime/zod-v4"
import {z} from "zod/v4"
import type {
  t_Enumerations,
  t_GetHeadersRequest200Response,
  t_GetHeadersUndeclared200Response,
  t_GetParamsDefaultObjectQuery200Response,
  t_GetParamsMixedQuery200Response,
  t_GetParamsSimpleQuery200Response,
  t_GetParamsUnexplodedObjectQuery200Response,
  t_PostValidationOptionalBody200Response,
  t_PostValidationOptionalBodyRequestBody,
  t_ProductOrder,
  t_RandomNumber,
  UnknownEnumStringValue,
} from "./models.ts"
import {
  s_Enumerations,
  s_GetHeadersRequest200Response,
  s_GetHeadersUndeclared200Response,
  s_GetParamsDefaultObjectQuery200Response,
  s_GetParamsMixedQuery200Response,
  s_GetParamsSimpleQuery200Response,
  s_GetParamsUnexplodedObjectQuery200Response,
  s_PostValidationOptionalBody200Response,
  s_ProductOrder,
  s_RandomNumber,
} from "./schemas.ts"

export class E2ETestClientServers {
  static default(): Server<"E2ETestClient"> {
    return E2ETestClientServers.server().build()
  }

  static server(
    url: "{protocol}://{host}:{port}" = "{protocol}://{host}:{port}",
  ): {
    build: (
      host?: string,
      protocol?: "http" | "https",
      port?: string,
    ) => Server<"E2ETestClient">
  } {
    switch (url) {
      case "{protocol}://{host}:{port}":
        return {
          build(
            host = "localhost",
            protocol: "http" | "https" = "http",
            port = "8080",
          ): Server<"E2ETestClient"> {
            return "{protocol}://{host}:{port}"
              .replace("{host}", host)
              .replace("{protocol}", protocol)
              .replace("{port}", port) as Server<"E2ETestClient">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export interface E2ETestClientConfig extends AbstractFetchClientConfig {
  basePath: Server<"E2ETestClient"> | string
}

export class E2ETestClient extends AbstractFetchClient {
  constructor(config: E2ETestClientConfig) {
    super(config)
  }

  async getHeadersUndeclared(
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_GetHeadersUndeclared200Response>> {
    const url = this.basePath + `/headers/undeclared`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    const res = this._fetch(url, {method: "GET", ...opts, headers}, timeout)

    return responseValidationFactory(
      [["200", s_GetHeadersUndeclared200Response]],
      undefined,
    )(res)
  }

  async getHeadersRequest(
    p: {
      routeLevelHeader?: string
      numberHeader?: number
      booleanHeader?: boolean
      secondBooleanHeader?: boolean
      authorization?: string
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_GetHeadersRequest200Response>> {
    const url = this.basePath + `/headers/request`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Route-Level-Header": p["routeLevelHeader"],
        "Number-Header": p["numberHeader"],
        "Boolean-Header": p["booleanHeader"],
        "Second-Boolean-Header": p["secondBooleanHeader"],
        Authorization: p["authorization"],
      },
      opts.headers,
    )

    const res = this._fetch(url, {method: "GET", ...opts, headers}, timeout)

    return responseValidationFactory(
      [["200", s_GetHeadersRequest200Response]],
      undefined,
    )(res)
  }

  async getParamsSimpleQuery(
    p: {
      orderBy: "asc" | "desc" | UnknownEnumStringValue
      limit: number
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_GetParamsSimpleQuery200Response>> {
    const url = this.basePath + `/params/simple-query`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({orderBy: p["orderBy"], limit: p["limit"]})

    const res = this._fetch(
      url + query,
      {method: "GET", ...opts, headers},
      timeout,
    )

    return responseValidationFactory(
      [["200", s_GetParamsSimpleQuery200Response]],
      undefined,
    )(res)
  }

  async getParamsDefaultObjectQuery(
    p: {
      filter: {
        age: number
        name: string
      }
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_GetParamsDefaultObjectQuery200Response>> {
    const url = this.basePath + `/params/default-object-query`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query(
      {filter: p["filter"]},
      {
        filter: {
          style: "form",
          explode: true,
        },
      },
    )

    const res = this._fetch(
      url + query,
      {method: "GET", ...opts, headers},
      timeout,
    )

    return responseValidationFactory(
      [["200", s_GetParamsDefaultObjectQuery200Response]],
      undefined,
    )(res)
  }

  async getParamsUnexplodedObjectQuery(
    p: {
      filter: {
        age: number
        name: string
      }
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_GetParamsUnexplodedObjectQuery200Response>> {
    const url = this.basePath + `/params/unexploded-object-query`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query(
      {filter: p["filter"]},
      {
        filter: {
          style: "form",
          explode: false,
        },
      },
    )

    const res = this._fetch(
      url + query,
      {method: "GET", ...opts, headers},
      timeout,
    )

    return responseValidationFactory(
      [["200", s_GetParamsUnexplodedObjectQuery200Response]],
      undefined,
    )(res)
  }

  async getParamsMixedQuery(
    p: {
      limit: number
      statuses: ("open" | "closed" | UnknownEnumStringValue)[]
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_GetParamsMixedQuery200Response>> {
    const url = this.basePath + `/params/mixed-query`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query(
      {limit: p["limit"], statuses: p["statuses"]},
      {
        statuses: {
          style: "form",
          explode: true,
        },
      },
    )

    const res = this._fetch(
      url + query,
      {method: "GET", ...opts, headers},
      timeout,
    )

    return responseValidationFactory(
      [["200", s_GetParamsMixedQuery200Response]],
      undefined,
    )(res)
  }

  async getValidationNumbersRandomNumber(
    p: {
      max?: number
      min?: number
      forbidden?: number[]
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_RandomNumber>> {
    const url = this.basePath + `/validation/numbers/random-number`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query(
      {max: p["max"], min: p["min"], forbidden: p["forbidden"]},
      {
        forbidden: {
          style: "form",
          explode: true,
        },
      },
    )

    const res = this._fetch(
      url + query,
      {method: "GET", ...opts, headers},
      timeout,
    )

    return responseValidationFactory([["200", s_RandomNumber]], undefined)(res)
  }

  async postValidationEnums(
    p: {
      requestBody: t_Enumerations
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_Enumerations>> {
    const url = this.basePath + `/validation/enums`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    const res = this._fetch(
      url,
      {method: "POST", body, ...opts, headers},
      timeout,
    )

    return responseValidationFactory([["200", s_Enumerations]], undefined)(res)
  }

  async postValidationOptionalBody(
    p: {
      requestBody?: t_PostValidationOptionalBodyRequestBody
    } = {},
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<
    Res<200, t_PostValidationOptionalBody200Response> | Res<204, void>
  > {
    const url = this.basePath + `/validation/optional-body`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : undefined,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    const res = this._fetch(
      url,
      {method: "POST", body, ...opts, headers},
      timeout,
    )

    return responseValidationFactory(
      [
        ["200", s_PostValidationOptionalBody200Response],
        ["204", z.any()],
      ],
      undefined,
    )(res)
  }

  async getResponses500(
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<500, void>> {
    const url = this.basePath + `/responses/500`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    const res = this._fetch(url, {method: "GET", ...opts, headers}, timeout)

    return responseValidationFactory([["500", z.any()]], undefined)(res)
  }

  async getResponsesEmpty(
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<204, void>> {
    const url = this.basePath + `/responses/empty`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    const res = this._fetch(url, {method: "GET", ...opts, headers}, timeout)

    return responseValidationFactory([["204", z.any()]], undefined)(res)
  }

  async postMediaTypesText(
    p: {
      requestBody: string
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, string>> {
    const url = this.basePath + `/media-types/text`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "text/plain"},
      opts.headers,
    )
    const body = p.requestBody

    const res = this._fetch(
      url,
      {method: "POST", body, ...opts, headers},
      timeout,
    )

    return responseValidationFactory([["200", z.string()]], undefined)(res)
  }

  async postMediaTypesXWwwFormUrlencoded(
    p: {
      requestBody: t_ProductOrder
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, t_ProductOrder>> {
    const url = this.basePath + `/media-types/x-www-form-urlencoded`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      opts.headers,
    )
    const body = this._requestBodyToUrlSearchParams(p.requestBody, {
      address: {style: "deepObject", explode: true},
    })

    const res = this._fetch(
      url,
      {method: "POST", body, ...opts, headers},
      timeout,
    )

    return responseValidationFactory([["200", s_ProductOrder]], undefined)(res)
  }

  async postMediaTypesOctetStream(
    p: {
      requestBody: Blob
    },
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, Blob>> {
    const url = this.basePath + `/media-types/octet-stream`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/octet-stream"},
      opts.headers,
    )
    const body = p.requestBody

    const res = this._fetch(
      url,
      {method: "POST", body, ...opts, headers},
      timeout,
    )

    return responseValidationFactory([["200", z.any()]], undefined)(res)
  }

  async getEscapeHatchesPlainText(
    timeout?: number,
    opts: RequestInit = {},
  ): Promise<Res<200, string>> {
    const url = this.basePath + `/escape-hatches/plain-text`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    const res = this._fetch(url, {method: "GET", ...opts, headers}, timeout)

    return responseValidationFactory([["200", z.string()]], undefined)(res)
  }
}

export {E2ETestClient as ApiClient}
export type {E2ETestClientConfig as ApiClientConfig}
