/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_Enumerations,
  t_RandomNumber,
  t_getHeadersRequestJson200Response,
  t_getHeadersUndeclaredJson200Response,
} from "./models"
import {
  s_Enumerations,
  s_RandomNumber,
  s_getHeadersRequestJson200Response,
  s_getHeadersUndeclaredJson200Response,
} from "./schemas"
import {
  AbstractAxiosClient,
  AbstractAxiosConfig,
  Server,
} from "@nahkies/typescript-axios-runtime/main"
import {AxiosRequestConfig, AxiosResponse} from "axios"
import {z} from "zod"

export class E2ETestClientServers {
  static default(): Server<"E2ETestClient"> {
    return E2ETestClientServers.server().build()
  }

  static server(
    url: "{protocol}://{host}:{port}" = "{protocol}://{host}:{port}",
  ): {
    build: (
      host?: string,
      protocol?: "http" | "https",
      port?: string,
    ) => Server<"E2ETestClient">
  } {
    switch (url) {
      case "{protocol}://{host}:{port}":
        return {
          build(
            host = "localhost",
            protocol: "http" | "https" = "http",
            port = "8080",
          ): Server<"E2ETestClient"> {
            return "{protocol}://{host}:{port}"
              .replace("{host}", host)
              .replace("{protocol}", protocol)
              .replace("{port}", port) as Server<"E2ETestClient">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export interface E2ETestClientConfig extends AbstractAxiosConfig {
  basePath: Server<"E2ETestClient"> | string
}

export class E2ETestClient extends AbstractAxiosClient {
  constructor(config: E2ETestClientConfig) {
    super(config)
  }

  async getHeadersUndeclared(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_getHeadersUndeclaredJson200Response>> {
    const url = `/headers/undeclared`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    const res = await this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })

    return {...res, data: s_getHeadersUndeclaredJson200Response.parse(res.data)}
  }

  async getHeadersRequest(
    p: {
      routeLevelHeader?: string
      numberHeader?: number
      booleanHeader?: boolean
      secondBooleanHeader?: boolean
      authorization?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_getHeadersRequestJson200Response>> {
    const url = `/headers/request`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Route-Level-Header": p["routeLevelHeader"],
        "Number-Header": p["numberHeader"],
        "Boolean-Header": p["booleanHeader"],
        "Second-Boolean-Header": p["secondBooleanHeader"],
        Authorization: p["authorization"],
      },
      opts.headers,
    )

    const res = await this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })

    return {...res, data: s_getHeadersRequestJson200Response.parse(res.data)}
  }

  async getValidationNumbersRandomNumber(
    p: {
      max?: number
      min?: number
      forbidden?: number[]
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_RandomNumber>> {
    const url = `/validation/numbers/random-number`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      max: p["max"],
      min: p["min"],
      forbidden: p["forbidden"],
    })

    const res = await this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })

    return {...res, data: s_RandomNumber.parse(res.data)}
  }

  async postValidationEnums(
    p: {
      requestBody: t_Enumerations
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Enumerations>> {
    const url = `/validation/enums`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    const res = await this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })

    return {...res, data: s_Enumerations.parse(res.data)}
  }

  async getResponses500(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/responses/500`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async getEscapeHatchesPlainText(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string>> {
    const url = `/escape-hatches/plain-text`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    const res = await this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })

    return {...res, data: z.string().parse(res.data)}
  }

  async getResponsesEmpty(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/responses/empty`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    const res = await this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })

    return {...res, data: z.any().parse(res.data)}
  }
}

export {E2ETestClient as ApiClient}
export type {E2ETestClientConfig as ApiClientConfig}
