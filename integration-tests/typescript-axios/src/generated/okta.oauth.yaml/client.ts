/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AcrValue,
  t_AmrValue,
  t_BackchannelAuthorizeRequest,
  t_BackchannelAuthorizeResponse,
  t_ChallengeRequest,
  t_ChallengeResponse,
  t_Client,
  t_CodeChallengeMethod,
  t_DeviceAuthorizeRequest,
  t_DeviceAuthorizeResponse,
  t_GlobalTokenRevocationRequest,
  t_IntrospectionRequest,
  t_IntrospectionResponse,
  t_LogoutWithPost,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OidcMetadata,
  t_OobAuthenticateRequest,
  t_OobAuthenticateResponse,
  t_ParRequest,
  t_ParResponse,
  t_Prompt,
  t_ResponseMode,
  t_ResponseTypesSupported,
  t_RevokeRequest,
  t_TokenRequest,
  t_TokenResponse,
  t_UserInfo,
} from "./models"
import {
  AbstractAxiosClient,
  AbstractAxiosConfig,
  Server,
} from "@nahkies/typescript-axios-runtime/main"
import { AxiosRequestConfig, AxiosResponse } from "axios"

export class OktaOpenIdConnectOAuth20Servers {
  static default(): Server<"OktaOpenIdConnectOAuth20"> {
    return OktaOpenIdConnectOAuth20Servers.server().build()
  }

  static server(url: "https://{yourOktaDomain}" = "https://{yourOktaDomain}"): {
    build: (yourOktaDomain?: string) => Server<"OktaOpenIdConnectOAuth20">
  } {
    switch (url) {
      case "https://{yourOktaDomain}":
        return {
          build(
            yourOktaDomain = "subdomain.okta.com",
          ): Server<"OktaOpenIdConnectOAuth20"> {
            return "https://{yourOktaDomain}".replace(
              "{yourOktaDomain}",
              yourOktaDomain,
            ) as Server<"OktaOpenIdConnectOAuth20">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export interface OktaOpenIdConnectOAuth20Config extends AbstractAxiosConfig {
  basePath: Server<"OktaOpenIdConnectOAuth20"> | string
}

export class OktaOpenIdConnectOAuth20 extends AbstractAxiosClient {
  constructor(config: OktaOpenIdConnectOAuth20Config) {
    super(config)
  }

  async getWellKnownOpenIdConfiguration(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_OidcMetadata>> {
    const url = `/.well-known/openid-configuration`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ client_id: p["clientId"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async authorize(
    p: {
      acrValues?: t_AcrValue
      clientId: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri: string
      responseType: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope: string
      sessionToken?: string
      state: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/authorize`
    const headers = this._headers({}, opts.headers)
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async bcAuthorize(
    p: {
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_BackchannelAuthorizeResponse>> {
    const url = `/oauth2/v1/bc/authorize`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async challenge(
    p: {
      requestBody: t_ChallengeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ChallengeResponse>> {
    const url = `/oauth2/v1/challenge`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async listClients(
    p: {
      after?: string
      limit?: number
      q?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Client[]>> {
    const url = `/oauth2/v1/clients`
    const headers = this._headers({}, opts.headers)
    const query = this._query({
      after: p["after"],
      limit: p["limit"],
      q: p["q"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async createClient(
    p: {
      requestBody: t_Client
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async getClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers({}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async replaceClient(
    p: {
      clientId: string
      requestBody: t_Client
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async deleteClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers({}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async generateNewClientSecret(
    p: {
      clientId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}/lifecycle/newSecret`
    const headers = this._headers({}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async deviceAuthorize(
    p: {
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_DeviceAuthorizeResponse>> {
    const url = `/oauth2/v1/device/authorize`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async globalTokenRevocation(
    p: {
      requestBody: t_GlobalTokenRevocationRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/global-token-revocation`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async introspect(
    p: {
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_IntrospectionResponse>> {
    const url = `/oauth2/v1/introspect`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async oauthKeys(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_OAuthKeys>> {
    const url = `/oauth2/v1/keys`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ client_id: p["clientId"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async logout(
    p: {
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/logout`
    const headers = this._headers({}, opts.headers)
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async logoutWithPost(
    p: {
      requestBody: t_LogoutWithPost
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/logout`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async oobAuthenticate(
    p: {
      requestBody: t_OobAuthenticateRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_OobAuthenticateResponse>> {
    const url = `/oauth2/v1/oob-authenticate`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async parOptions(
    p: {
      origin?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/par`
    const headers = this._headers({ Origin: p["origin"] }, opts.headers)

    return this._request({
      url: url,
      method: "OPTIONS",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async par(
    p: {
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ParResponse>> {
    const url = `/oauth2/v1/par`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async revoke(
    p: {
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/revoke`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async tokenOptions(
    p: {
      origin?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/token`
    const headers = this._headers({ Origin: p["origin"] }, opts.headers)

    return this._request({
      url: url,
      method: "OPTIONS",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async token(
    p: {
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_TokenResponse>> {
    const url = `/oauth2/v1/token`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async userinfo(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_UserInfo>> {
    const url = `/oauth2/v1/userinfo`
    const headers = this._headers({}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async getWellKnownOAuthConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_OAuthMetadata>> {
    const url = `/oauth2/${p["authorizationServerId"]}/.well-known/oauth-authorization-server`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ client_id: p["clientId"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async getWellKnownOpenIdConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_OidcMetadata>> {
    const url = `/oauth2/${p["authorizationServerId"]}/.well-known/openid-configuration`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ client_id: p["clientId"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async authorizeCustomAs(
    p: {
      authorizationServerId: string
      acrValues?: t_AcrValue
      clientId: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri: string
      responseType: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope: string
      sessionToken?: string
      state: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/authorize`
    const headers = this._headers({}, opts.headers)
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async bcAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_BackchannelAuthorizeResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/bc/authorize`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async challengeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_ChallengeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ChallengeResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/challenge`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async deviceAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_DeviceAuthorizeResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/device/authorize`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async introspectCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_IntrospectionResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/introspect`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async oauthKeysCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_OAuthKeys>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/keys`
    const headers = this._headers({}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async logoutCustomAs(
    p: {
      authorizationServerId: string
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/logout`
    const headers = this._headers({}, opts.headers)
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async logoutCustomAsWithPost(
    p: {
      authorizationServerId: string
      requestBody: t_LogoutWithPost
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/logout`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async oobAuthenticateCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_OobAuthenticateRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_OobAuthenticateResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/oob-authenticate`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async parOptionsCustomAs(
    p: {
      authorizationServerId: string
      origin?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/par`
    const headers = this._headers({ Origin: p["origin"] }, opts.headers)

    return this._request({
      url: url,
      method: "OPTIONS",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async parCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ParResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/par`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async revokeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/revoke`
    const headers = this._headers(
      { "Content-Type": "application/json" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async tokenOptionsCustomAs(
    p: {
      authorizationServerId: string
      origin?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/token`
    const headers = this._headers({ Origin: p["origin"] }, opts.headers)

    return this._request({
      url: url,
      method: "OPTIONS",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async tokenCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_TokenResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/token`
    const headers = this._headers(
      { "Content-Type": "application/x-www-form-urlencoded" },
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async userinfoCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_UserInfo>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/userinfo`
    const headers = this._headers({}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }
}

export { OktaOpenIdConnectOAuth20 as ApiClient }
export type { OktaOpenIdConnectOAuth20Config as ApiClientConfig }
