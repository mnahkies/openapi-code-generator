/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AcrValue,
  t_AmrValue,
  t_ApplicationType,
  t_BackchannelAuthorizeRequest,
  t_BackchannelAuthorizeResponse,
  t_Claim,
  t_Client,
  t_CodeChallengeMethod,
  t_DeviceAuthorizeRequest,
  t_DeviceAuthorizeResponse,
  t_EndpointAuthMethod,
  t_Error,
  t_GrantType,
  t_IntrospectionRequest,
  t_IntrospectionResponse,
  t_JsonWebKey,
  t_JsonWebKeyStatus,
  t_JsonWebKeyType,
  t_JsonWebKeyUse,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OidcMetadata,
  t_ParRequest,
  t_ParResponse,
  t_Prompt,
  t_ResponseMode,
  t_ResponseType,
  t_ResponseTypesSupported,
  t_RevokeRequest,
  t_Scope,
  t_SigningAlgorithm,
  t_SubjectType,
  t_TokenDeliveryMode,
  t_TokenRequest,
  t_TokenResponse,
  t_TokenResponseTokenType,
  t_TokenType,
  t_TokenTypeHintIntrospect,
  t_TokenTypeHintRevoke,
  t_UserInfo,
} from "./models"
import {
  s_ApplicationType,
  s_BackchannelAuthorizeResponse,
  s_Claim,
  s_Client,
  s_CodeChallengeMethod,
  s_DeviceAuthorizeResponse,
  s_EndpointAuthMethod,
  s_Error,
  s_GrantType,
  s_IntrospectionResponse,
  s_JsonWebKey,
  s_JsonWebKeyStatus,
  s_JsonWebKeyType,
  s_JsonWebKeyUse,
  s_OAuthError,
  s_OAuthKeys,
  s_OAuthMetadata,
  s_OidcMetadata,
  s_ParResponse,
  s_ResponseMode,
  s_ResponseType,
  s_ResponseTypesSupported,
  s_Scope,
  s_SigningAlgorithm,
  s_SubjectType,
  s_TokenDeliveryMode,
  s_TokenResponse,
  s_TokenResponseTokenType,
  s_TokenType,
  s_UserInfo,
} from "./schemas"
import {
  AbstractAxiosClient,
  AbstractAxiosConfig,
} from "@nahkies/typescript-axios-runtime/main"
import axios, { AxiosRequestConfig, AxiosResponse } from "axios"
import { z } from "zod"

export class ApiClient extends AbstractAxiosClient {
  constructor(config: AbstractAxiosConfig) {
    super(config)
  }

  async getWellKnownOpenIdConfiguration(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_OidcMetadata>> {
    const url = `/.well-known/openid-configuration`
    const query = this._query({ client_id: p["clientId"] })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_OidcMetadata.parse(res.data) }
  }

  async authorize(
    p: {
      acrValues?: t_AcrValue
      clientId?: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri?: string
      responseType?: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope?: string
      sessionToken?: string
      state?: string
    } = {},
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Error>> {
    const url = `/oauth2/v1/authorize`
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Error.parse(res.data) }
  }

  async bcAuthorize(
    p: {
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_BackchannelAuthorizeResponse>> {
    const url = `/oauth2/v1/bc/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_BackchannelAuthorizeResponse.parse(res.data) }
  }

  async listClients(
    p: {
      after?: string
      limit?: number
      q?: string
    } = {},
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Client[]>> {
    const url = `/oauth2/v1/clients`
    const query = this._query({
      after: p["after"],
      limit: p["limit"],
      q: p["q"],
    })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: z.array(s_Client).parse(res.data) }
  }

  async createClient(
    p: {
      requestBody: t_Client
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Client.parse(res.data) }
  }

  async getClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}`

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Client.parse(res.data) }
  }

  async replaceClient(
    p: {
      clientId: string
      requestBody: t_Client
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "PUT",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Client.parse(res.data) }
  }

  async deleteClient(
    p: {
      clientId: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}`

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "DELETE",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: z.undefined().parse(res.data) }
  }

  async generateNewClientSecret(
    p: {
      clientId: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Client>> {
    const url = `/oauth2/v1/clients/${p["clientId"]}/lifecycle/newSecret`

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Client.parse(res.data) }
  }

  async deviceAuthorize(
    p: {
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_DeviceAuthorizeResponse>> {
    const url = `/oauth2/v1/device/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_DeviceAuthorizeResponse.parse(res.data) }
  }

  async introspect(
    p: {
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_IntrospectionResponse>> {
    const url = `/oauth2/v1/introspect`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_IntrospectionResponse.parse(res.data) }
  }

  async oauthKeys(
    p: {
      clientId?: string
    } = {},
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_OAuthKeys>> {
    const url = `/oauth2/v1/keys`
    const query = this._query({ client_id: p["clientId"] })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_OAuthKeys.parse(res.data) }
  }

  async logout(
    p: {
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Error>> {
    const url = `/oauth2/v1/logout`
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Error.parse(res.data) }
  }

  async par(
    p: {
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_ParResponse>> {
    const url = `/oauth2/v1/par`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_ParResponse.parse(res.data) }
  }

  async revoke(
    p: {
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/v1/revoke`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: z.undefined().parse(res.data) }
  }

  async token(
    p: {
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_TokenResponse>> {
    const url = `/oauth2/v1/token`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_TokenResponse.parse(res.data) }
  }

  async userinfo(
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_UserInfo>> {
    const url = `/oauth2/v1/userinfo`

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_UserInfo.parse(res.data) }
  }

  async getWellKnownOAuthConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_OAuthMetadata>> {
    const url = `/oauth2/${p["authorizationServerId"]}/.well-known/oauth-authorization-server`
    const query = this._query({ client_id: p["clientId"] })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_OAuthMetadata.parse(res.data) }
  }

  async getWellKnownOpenIdConfigurationCustomAs(
    p: {
      authorizationServerId: string
      clientId?: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_OidcMetadata>> {
    const url = `/oauth2/${p["authorizationServerId"]}/.well-known/openid-configuration`
    const query = this._query({ client_id: p["clientId"] })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_OidcMetadata.parse(res.data) }
  }

  async authorizeCustomAs(
    p: {
      authorizationServerId: string
      acrValues?: t_AcrValue
      clientId?: string
      codeChallenge?: string
      codeChallengeMethod?: t_CodeChallengeMethod
      display?: string
      enrollAmrValues?: t_AmrValue
      idpScope?: string
      idp?: string
      loginHint?: string
      maxAge?: number
      nonce?: string
      prompt?: t_Prompt
      redirectUri?: string
      responseType?: t_ResponseTypesSupported
      responseMode?: t_ResponseMode
      requestUri?: string
      request?: string
      scope?: string
      sessionToken?: string
      state?: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Error>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/authorize`
    const query = this._query({
      acr_values: p["acrValues"],
      client_id: p["clientId"],
      code_challenge: p["codeChallenge"],
      code_challenge_method: p["codeChallengeMethod"],
      display: p["display"],
      enroll_amr_values: p["enrollAmrValues"],
      idp_scope: p["idpScope"],
      idp: p["idp"],
      login_hint: p["loginHint"],
      max_age: p["maxAge"],
      nonce: p["nonce"],
      prompt: p["prompt"],
      redirect_uri: p["redirectUri"],
      response_type: p["responseType"],
      response_mode: p["responseMode"],
      request_uri: p["requestUri"],
      request: p["request"],
      scope: p["scope"],
      sessionToken: p["sessionToken"],
      state: p["state"],
    })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Error.parse(res.data) }
  }

  async bcAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_BackchannelAuthorizeRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_BackchannelAuthorizeResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/bc/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_BackchannelAuthorizeResponse.parse(res.data) }
  }

  async deviceAuthorizeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_DeviceAuthorizeRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_DeviceAuthorizeResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/device/authorize`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_DeviceAuthorizeResponse.parse(res.data) }
  }

  async introspectCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_IntrospectionRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_IntrospectionResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/introspect`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_IntrospectionResponse.parse(res.data) }
  }

  async oauthKeysCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_OAuthKeys>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/keys`

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_OAuthKeys.parse(res.data) }
  }

  async logoutCustomAs(
    p: {
      authorizationServerId: string
      idTokenHint: string
      postLogoutRedirectUri?: string
      state?: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_Error>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/logout`
    const query = this._query({
      id_token_hint: p["idTokenHint"],
      post_logout_redirect_uri: p["postLogoutRedirectUri"],
      state: p["state"],
    })

    const res = await this.axios.request({
      url: url + query,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_Error.parse(res.data) }
  }

  async parCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_ParRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_ParResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/par`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_ParResponse.parse(res.data) }
  }

  async revokeCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_RevokeRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/revoke`
    const headers = this._headers({ "Content-Type": "application/json" })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: z.undefined().parse(res.data) }
  }

  async tokenCustomAs(
    p: {
      authorizationServerId: string
      requestBody: t_TokenRequest
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_TokenResponse>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/token`
    const headers = this._headers({
      "Content-Type": "application/x-www-form-urlencoded",
    })
    const body = JSON.stringify(p.requestBody)

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "POST",
      headers,
      data: body,
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_TokenResponse.parse(res.data) }
  }

  async userinfoCustomAs(
    p: {
      authorizationServerId: string
    },
    timeout?: number,
    opts?: AxiosRequestConfig,
  ): Promise<AxiosResponse<t_UserInfo>> {
    const url = `/oauth2/${p["authorizationServerId"]}/v1/userinfo`

    const res = await this.axios.request({
      url: url,
      baseURL: this.basePath,
      method: "GET",
      timeout,
      ...(opts ?? {}),
    })

    return { ...res, data: s_UserInfo.parse(res.data) }
  }
}
