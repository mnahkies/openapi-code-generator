/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_Azure_Core_Foundations_Error,
  t_Azure_Core_Foundations_OperationState,
  t_Azure_Core_uuid,
  t_Manufacturer,
  t_PagedManufacturer,
  t_PagedWidget,
  t_PagedWidgetPart,
  t_Widget,
  t_WidgetAnalytics,
  t_WidgetAnalyticsCreateOrUpdate,
  t_WidgetCreateOrUpdate,
  t_WidgetPart,
  t_WidgetPartReorderRequest,
  t_WidgetRepairRequest,
  t_WidgetRepairState,
} from "./models"
import {
  AbstractAxiosClient,
  AbstractAxiosConfig,
  Server,
} from "@nahkies/typescript-axios-runtime/main"
import { AxiosRequestConfig, AxiosResponse } from "axios"

export class ContosoWidgetManagerServers {
  static server(url: "{endpoint}/widget" = "{endpoint}/widget"): {
    build: (endpoint: string) => Server<"ContosoWidgetManager">
  } {
    switch (url) {
      case "{endpoint}/widget":
        return {
          build(endpoint): Server<"ContosoWidgetManager"> {
            return "{endpoint}/widget".replace(
              "{endpoint}",
              endpoint,
            ) as Server<"ContosoWidgetManager">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export interface ContosoWidgetManagerConfig extends AbstractAxiosConfig {
  basePath: Server<"ContosoWidgetManager"> | string
}

export class ContosoWidgetManager extends AbstractAxiosClient {
  constructor(config: ContosoWidgetManagerConfig) {
    super(config)
  }

  async getServiceStatus(
    p: {
      apiVersion: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      statusString: string
    }>
  > {
    const url = `/service-status`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus(
    p: {
      apiVersion: string
      widgetName: string
      operationId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<
      | {
          error?: t_Azure_Core_Foundations_Error | undefined
          id: string
          result?: t_Widget | undefined
          status: t_Azure_Core_Foundations_OperationState
        }
      | {
          error?: t_Azure_Core_Foundations_Error | undefined
          id: string
          status: t_Azure_Core_Foundations_OperationState
        }
    >
  > {
    const url = `/widgets/${p["widgetName"]}/operations/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsCreateOrUpdateWidget(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetCreateOrUpdate
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Widget>> {
    const url = `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        "Content-Type": "application/merge-patch+json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "PATCH",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsGetWidget(
    p: {
      apiVersion: string
      widgetName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Widget>> {
    const url = `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsDeleteWidget(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      error?: t_Azure_Core_Foundations_Error | undefined
      id: string
      status: t_Azure_Core_Foundations_OperationState
    }>
  > {
    const url = `/widgets/${p["widgetName"]}`
    const headers = this._headers(
      {
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "DELETE",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsListWidgets(
    p: {
      apiVersion: string
      top?: number
      skip?: number
      maxpagesize?: number
      select?: string[]
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_PagedWidget>> {
    const url = `/widgets`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({
      "api-version": p["apiVersion"],
      top: p["top"],
      skip: p["skip"],
      maxpagesize: p["maxpagesize"],
      select: p["select"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsGetAnalytics(
    p: {
      apiVersion: string
      widgetName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_WidgetAnalytics>> {
    const url = `/widgets/${p["widgetName"]}/analytics/current`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsUpdateAnalytics(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetAnalyticsCreateOrUpdate
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_WidgetAnalytics>> {
    const url = `/widgets/${p["widgetName"]}/analytics/current`
    const headers = this._headers(
      {
        "Content-Type": "application/merge-patch+json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "PATCH",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsGetRepairStatus(
    p: {
      apiVersion: string
      widgetId: string
      operationId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      error?: t_Azure_Core_Foundations_Error | undefined
      id: string
      result?: t_WidgetRepairRequest | undefined
      status: t_Azure_Core_Foundations_OperationState
    }>
  > {
    const url = `/widgets/${p["widgetId"]}/repairs/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetsScheduleRepairs(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetRepairRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      error?: t_Azure_Core_Foundations_Error | undefined
      id: string
      result?:
        | {
            completedDateTime: string
            createdDateTime: string
            requestState: t_WidgetRepairState
            scheduledDateTime: string
            updatedDateTime: string
          }
        | undefined
      status: t_Azure_Core_Foundations_OperationState
    }>
  > {
    const url = `/widgets/${p["widgetName"]}:scheduleRepairs`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetPartsGetWidgetPartOperationStatus(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      operationId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      error?: t_Azure_Core_Foundations_Error | undefined
      id: string
      result?: t_WidgetPart | undefined
      status: t_Azure_Core_Foundations_OperationState
    }>
  > {
    const url = `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}/operations/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetPartsCreateWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetPart
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/widgets/${p["widgetName"]}/parts`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetPartsListWidgetParts(
    p: {
      apiVersion: string
      widgetName: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_PagedWidgetPart>> {
    const url = `/widgets/${p["widgetName"]}/parts`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetPartsGetWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_WidgetPart>> {
    const url = `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetPartsDeleteWidgetPart(
    p: {
      apiVersion: string
      widgetName: string
      widgetPartName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/widgets/${p["widgetName"]}/parts/${p["widgetPartName"]}`
    const headers = this._headers(
      {
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "DELETE",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async widgetPartsReorderParts(
    p: {
      apiVersion: string
      widgetName: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_WidgetPartReorderRequest
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      error?: t_Azure_Core_Foundations_Error | undefined
      id: string
      status: t_Azure_Core_Foundations_OperationState
    }>
  > {
    const url = `/widgets/${p["widgetName"]}/parts:reorderParts`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "POST",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async manufacturersGetManufacturerOperationStatus(
    p: {
      apiVersion: string
      manufacturerId: string
      operationId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      error?: t_Azure_Core_Foundations_Error | undefined
      id: string
      result?: t_Manufacturer | undefined
      status: t_Azure_Core_Foundations_OperationState
    }>
  > {
    const url = `/manufacturers/${p["manufacturerId"]}/operations/${p["operationId"]}`
    const headers = this._headers({}, opts.headers)
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async manufacturersCreateOrReplaceManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
      requestBody: t_Manufacturer
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Manufacturer>> {
    const url = `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        "Content-Type": "application/json",
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "PUT",
      data: body,
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async manufacturersGetManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_Manufacturer>> {
    const url = `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async manufacturersDeleteManufacturer(
    p: {
      apiVersion: string
      manufacturerId: string
      repeatabilityRequestId?: string
      repeatabilityFirstSent?: string
      ifMatch?: string
      ifNoneMatch?: string
      ifUnmodifiedSince?: string
      ifModifiedSince?: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      error?: t_Azure_Core_Foundations_Error | undefined
      id: string
      status: t_Azure_Core_Foundations_OperationState
    }>
  > {
    const url = `/manufacturers/${p["manufacturerId"]}`
    const headers = this._headers(
      {
        "Repeatability-Request-ID": p["repeatabilityRequestId"],
        "Repeatability-First-Sent": p["repeatabilityFirstSent"],
        "If-Match": p["ifMatch"],
        "If-None-Match": p["ifNoneMatch"],
        "If-Unmodified-Since": p["ifUnmodifiedSince"],
        "If-Modified-Since": p["ifModifiedSince"],
        "x-ms-client-request-id": p["xMsClientRequestId"],
      },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "DELETE",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }

  async manufacturersListManufacturers(
    p: {
      apiVersion: string
      xMsClientRequestId?: t_Azure_Core_uuid
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_PagedManufacturer>> {
    const url = `/manufacturers`
    const headers = this._headers(
      { "x-ms-client-request-id": p["xMsClientRequestId"] },
      opts.headers,
    )
    const query = this._query({ "api-version": p["apiVersion"] })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? { timeout } : {}),
      ...opts,
      headers,
    })
  }
}

export { ContosoWidgetManager as ApiClient }
export type { ContosoWidgetManagerConfig as ApiClientConfig }
