/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  EmptyObject,
  UnknownEnumStringValue,
  t_actions_billing_usage,
  t_actions_cache_list,
  t_actions_cache_usage_by_repository,
  t_actions_cache_usage_org_enterprise,
  t_actions_enabled,
  t_actions_get_default_workflow_permissions,
  t_actions_hosted_runner,
  t_actions_hosted_runner_image,
  t_actions_hosted_runner_limits,
  t_actions_hosted_runner_machine_spec,
  t_actions_organization_permissions,
  t_actions_public_key,
  t_actions_repository_permissions,
  t_actions_secret,
  t_actions_set_default_workflow_permissions,
  t_actions_variable,
  t_actions_workflow_access_to_repository,
  t_activity,
  t_alert_number,
  t_allowed_actions,
  t_api_insights_route_stats,
  t_api_insights_subject_stats,
  t_api_insights_summary_stats,
  t_api_insights_time_stats,
  t_api_insights_user_stats,
  t_api_overview,
  t_app_permissions,
  t_artifact,
  t_authentication_token,
  t_authorization,
  t_autolink,
  t_base_gist,
  t_billing_usage_report,
  t_billing_usage_report_user,
  t_blob,
  t_branch_protection,
  t_branch_restriction_policy,
  t_branch_short,
  t_branch_with_protection,
  t_campaign_state,
  t_campaign_summary,
  t_check_annotation,
  t_check_automated_security_fixes,
  t_check_run,
  t_check_suite,
  t_check_suite_preference,
  t_classroom,
  t_classroom_accepted_assignment,
  t_classroom_assignment,
  t_classroom_assignment_grade,
  t_clone_traffic,
  t_code_frequency_stat,
  t_code_of_conduct,
  t_code_scanning_alert,
  t_code_scanning_alert_create_request,
  t_code_scanning_alert_dismissed_comment,
  t_code_scanning_alert_dismissed_reason,
  t_code_scanning_alert_instance,
  t_code_scanning_alert_items,
  t_code_scanning_alert_set_state,
  t_code_scanning_alert_severity,
  t_code_scanning_alert_state_query,
  t_code_scanning_analysis,
  t_code_scanning_analysis_commit_sha,
  t_code_scanning_analysis_deletion,
  t_code_scanning_analysis_sarif_file,
  t_code_scanning_analysis_sarif_id,
  t_code_scanning_analysis_tool_guid,
  t_code_scanning_analysis_tool_name,
  t_code_scanning_autofix,
  t_code_scanning_autofix_commits,
  t_code_scanning_autofix_commits_response,
  t_code_scanning_codeql_database,
  t_code_scanning_default_setup,
  t_code_scanning_default_setup_options,
  t_code_scanning_default_setup_update,
  t_code_scanning_default_setup_update_response,
  t_code_scanning_options,
  t_code_scanning_organization_alert_items,
  t_code_scanning_ref,
  t_code_scanning_ref_full,
  t_code_scanning_sarifs_receipt,
  t_code_scanning_sarifs_status,
  t_code_scanning_variant_analysis,
  t_code_scanning_variant_analysis_repo_task,
  t_code_search_result_item,
  t_code_security_configuration,
  t_code_security_configuration_for_repository,
  t_code_security_configuration_repositories,
  t_code_security_default_configurations,
  t_codeowners_errors,
  t_codespace,
  t_codespace_export_details,
  t_codespace_machine,
  t_codespace_with_full_repository,
  t_codespaces_org_secret,
  t_codespaces_permissions_check_for_devcontainer,
  t_codespaces_public_key,
  t_codespaces_secret,
  t_codespaces_user_public_key,
  t_collaborator,
  t_combined_billing_usage,
  t_combined_commit_status,
  t_commit,
  t_commit_activity,
  t_commit_comment,
  t_commit_comparison,
  t_commit_search_result_item,
  t_community_profile,
  t_content_directory,
  t_content_file,
  t_content_submodule,
  t_content_symlink,
  t_content_traffic,
  t_contributor,
  t_contributor_activity,
  t_copilot_organization_details,
  t_copilot_seat_details,
  t_copilot_usage_metrics_day,
  t_custom_deployment_rule_app,
  t_custom_property,
  t_custom_property_set_payload,
  t_custom_property_value,
  t_dependabot_alert,
  t_dependabot_alert_with_repository,
  t_dependabot_public_key,
  t_dependabot_repository_access_details,
  t_dependabot_secret,
  t_dependency_graph_diff,
  t_dependency_graph_spdx_sbom,
  t_deploy_key,
  t_deployment,
  t_deployment_branch_policy,
  t_deployment_branch_policy_name_pattern,
  t_deployment_branch_policy_name_pattern_with_type,
  t_deployment_branch_policy_settings,
  t_deployment_protection_rule,
  t_deployment_reviewer_type,
  t_deployment_status,
  t_diff_entry,
  t_email,
  t_empty_object,
  t_enabled_repositories,
  t_environment,
  t_environment_approvals,
  t_event,
  t_feed,
  t_file_commit,
  t_full_repository,
  t_gist_comment,
  t_gist_commit,
  t_gist_simple,
  t_git_commit,
  t_git_ref,
  t_git_tag,
  t_git_tree,
  t_gitignore_template,
  t_global_advisory,
  t_gpg_key,
  t_hook,
  t_hook_delivery,
  t_hook_delivery_item,
  t_hovercard,
  t_import,
  t_installation,
  t_installation_token,
  t_integration,
  t_integration_installation_request,
  t_interaction_limit,
  t_interaction_limit_response,
  t_issue,
  t_issue_comment,
  t_issue_event,
  t_issue_event_for_issue,
  t_issue_search_result_item,
  t_issue_type,
  t_job,
  t_key,
  t_key_simple,
  t_label,
  t_label_search_result_item,
  t_language,
  t_license,
  t_license_content,
  t_license_simple,
  t_marketplace_listing_plan,
  t_marketplace_purchase,
  t_merged_upstream,
  t_migration,
  t_milestone,
  t_minimal_repository,
  t_network_configuration,
  t_network_settings,
  t_oidc_custom_sub,
  t_oidc_custom_sub_repo,
  t_org_hook,
  t_org_membership,
  t_org_private_registry_configuration,
  t_org_private_registry_configuration_with_selected_repositories,
  t_org_repo_custom_property_values,
  t_org_rules,
  t_org_ruleset_conditions,
  t_organization_actions_secret,
  t_organization_actions_variable,
  t_organization_create_issue_type,
  t_organization_dependabot_secret,
  t_organization_full,
  t_organization_invitation,
  t_organization_programmatic_access_grant,
  t_organization_programmatic_access_grant_request,
  t_organization_role,
  t_organization_secret_scanning_alert,
  t_organization_simple,
  t_organization_update_issue_type,
  t_package,
  t_package_version,
  t_packages_billing_usage,
  t_page,
  t_page_build,
  t_page_build_status,
  t_page_deployment,
  t_pages_deployment_status,
  t_pages_health_check,
  t_participation_stats,
  t_pending_deployment,
  t_porter_author,
  t_porter_large_file,
  t_prevent_self_review,
  t_private_user,
  t_private_vulnerability_report_create,
  t_project,
  t_project_card,
  t_project_collaborator_permission,
  t_project_column,
  t_protected_branch,
  t_protected_branch_admin_enforced,
  t_protected_branch_pull_request_review,
  t_public_user,
  t_pull_request,
  t_pull_request_merge_result,
  t_pull_request_review,
  t_pull_request_review_comment,
  t_pull_request_review_request,
  t_pull_request_simple,
  t_rate_limit_overview,
  t_reaction,
  t_referrer_traffic,
  t_release,
  t_release_asset,
  t_release_notes_content,
  t_repo_codespaces_secret,
  t_repo_search_result_item,
  t_repository,
  t_repository_advisory,
  t_repository_advisory_create,
  t_repository_advisory_update,
  t_repository_collaborator_permission,
  t_repository_invitation,
  t_repository_rule,
  t_repository_rule_detailed,
  t_repository_rule_enforcement,
  t_repository_ruleset,
  t_repository_ruleset_bypass_actor,
  t_repository_ruleset_conditions,
  t_repository_subscription,
  t_review_comment,
  t_review_custom_gates_comment_required,
  t_review_custom_gates_state_required,
  t_root,
  t_rule_suite,
  t_rule_suites,
  t_ruleset_version,
  t_ruleset_version_with_state,
  t_runner,
  t_runner_application,
  t_runner_groups_org,
  t_runner_label,
  t_secret_scanning_alert,
  t_secret_scanning_alert_resolution,
  t_secret_scanning_alert_resolution_comment,
  t_secret_scanning_alert_state,
  t_secret_scanning_location,
  t_secret_scanning_push_protection_bypass,
  t_secret_scanning_push_protection_bypass_placeholder_id,
  t_secret_scanning_push_protection_bypass_reason,
  t_secret_scanning_scan_history,
  t_security_advisory_ecosystems,
  t_selected_actions,
  t_short_blob,
  t_short_branch,
  t_simple_classroom,
  t_simple_classroom_assignment,
  t_simple_user,
  t_snapshot,
  t_social_account,
  t_ssh_signing_key,
  t_stargazer,
  t_starred_repository,
  t_status,
  t_status_check_policy,
  t_tag,
  t_tag_protection,
  t_team,
  t_team_discussion,
  t_team_discussion_comment,
  t_team_full,
  t_team_membership,
  t_team_project,
  t_team_repository,
  t_team_role_assignment,
  t_team_simple,
  t_thread,
  t_thread_subscription,
  t_timeline_issue_events,
  t_topic,
  t_topic_search_result_item,
  t_user_marketplace_purchase,
  t_user_role_assignment,
  t_user_search_result_item,
  t_view_traffic,
  t_wait_timer,
  t_webhook_config,
  t_webhook_config_content_type,
  t_webhook_config_insecure_ssl,
  t_webhook_config_secret,
  t_webhook_config_url,
  t_workflow,
  t_workflow_run,
  t_workflow_run_usage,
  t_workflow_usage,
} from "./models"
import {
  AbstractAxiosClient,
  AbstractAxiosConfig,
  Server,
} from "@nahkies/typescript-axios-runtime/main"
import {AxiosRequestConfig, AxiosResponse} from "axios"

export class GitHubV3RestApiServersOperations {
  static reposUploadReleaseAsset(
    url: "https://uploads.github.com" = "https://uploads.github.com",
  ): {build: () => Server<"reposUploadReleaseAsset_GitHubV3RestApi">} {
    switch (url) {
      case "https://uploads.github.com":
        return {
          build(): Server<"reposUploadReleaseAsset_GitHubV3RestApi"> {
            return "https://uploads.github.com" as Server<"reposUploadReleaseAsset_GitHubV3RestApi">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }
}

export class GitHubV3RestApiServers {
  static default(): Server<"GitHubV3RestApi"> {
    return GitHubV3RestApiServers.server().build()
  }

  static server(url: "https://api.github.com" = "https://api.github.com"): {
    build: () => Server<"GitHubV3RestApi">
  } {
    switch (url) {
      case "https://api.github.com":
        return {
          build(): Server<"GitHubV3RestApi"> {
            return "https://api.github.com" as Server<"GitHubV3RestApi">
          },
        }

      default:
        throw new Error(`no matching server for url '${url}'`)
    }
  }

  static readonly operations = GitHubV3RestApiServersOperations
}

export interface GitHubV3RestApiConfig extends AbstractAxiosConfig {
  basePath: Server<"GitHubV3RestApi"> | string
}

export class GitHubV3RestApi extends AbstractAxiosClient {
  constructor(config: GitHubV3RestApiConfig) {
    super(config)
  }

  async metaRoot(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_root>> {
    const url = `/`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesListGlobalAdvisories(
    p: {
      ghsaId?: string
      type?: "reviewed" | "malware" | "unreviewed" | UnknownEnumStringValue
      cveId?: string
      ecosystem?: t_security_advisory_ecosystems
      severity?:
        | "unknown"
        | "low"
        | "medium"
        | "high"
        | "critical"
        | UnknownEnumStringValue
      cwes?: string | string[]
      isWithdrawn?: boolean
      affects?: string | string[]
      published?: string
      updated?: string
      modified?: string
      epssPercentage?: string
      epssPercentile?: string
      before?: string
      after?: string
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      sort?:
        | "updated"
        | "published"
        | "epss_percentage"
        | "epss_percentile"
        | UnknownEnumStringValue
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_global_advisory[]>> {
    const url = `/advisories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ghsa_id: p["ghsaId"],
      type: p["type"],
      cve_id: p["cveId"],
      ecosystem: p["ecosystem"],
      severity: p["severity"],
      cwes: p["cwes"],
      is_withdrawn: p["isWithdrawn"],
      affects: p["affects"],
      published: p["published"],
      updated: p["updated"],
      modified: p["modified"],
      epss_percentage: p["epssPercentage"],
      epss_percentile: p["epssPercentile"],
      before: p["before"],
      after: p["after"],
      direction: p["direction"],
      per_page: p["perPage"],
      sort: p["sort"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesGetGlobalAdvisory(
    p: {
      ghsaId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_global_advisory>> {
    const url = `/advisories/${p["ghsaId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetAuthenticated(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_integration>> {
    const url = `/app`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsCreateFromManifest(
    p: {
      code: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<
      t_integration & {
        client_id: string
        client_secret: string
        pem: string
        webhook_secret: string | null
        [key: string]: unknown | undefined
      }
    >
  > {
    const url = `/app-manifests/${p["code"]}/conversions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetWebhookConfigForApp(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_webhook_config>> {
    const url = `/app/hook/config`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsUpdateWebhookConfigForApp(
    p: {
      requestBody: {
        content_type?: t_webhook_config_content_type | undefined
        insecure_ssl?: t_webhook_config_insecure_ssl | undefined
        secret?: t_webhook_config_secret | undefined
        url?: t_webhook_config_url | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_webhook_config>> {
    const url = `/app/hook/config`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListWebhookDeliveries(
    p: {
      perPage?: number
      cursor?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook_delivery_item[]>> {
    const url = `/app/hook/deliveries`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], cursor: p["cursor"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetWebhookDelivery(
    p: {
      deliveryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook_delivery>> {
    const url = `/app/hook/deliveries/${p["deliveryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsRedeliverWebhookDelivery(
    p: {
      deliveryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/app/hook/deliveries/${p["deliveryId"]}/attempts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListInstallationRequestsForAuthenticatedApp(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_integration_installation_request[]>> {
    const url = `/app/installation-requests`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListInstallations(
    p: {
      perPage?: number
      page?: number
      since?: string
      outdated?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_installation[]>> {
    const url = `/app/installations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      since: p["since"],
      outdated: p["outdated"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_installation>> {
    const url = `/app/installations/${p["installationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsDeleteInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/app/installations/${p["installationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsCreateInstallationAccessToken(
    p: {
      installationId: number
      requestBody?: {
        permissions?: t_app_permissions | undefined
        repositories?: string[] | undefined
        repository_ids?: number[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_installation_token>> {
    const url = `/app/installations/${p["installationId"]}/access_tokens`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsSuspendInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/app/installations/${p["installationId"]}/suspended`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsUnsuspendInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/app/installations/${p["installationId"]}/suspended`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsDeleteAuthorization(
    p: {
      clientId: string
      requestBody: {
        access_token: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/applications/${p["clientId"]}/grant`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsCheckToken(
    p: {
      clientId: string
      requestBody: {
        access_token: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_authorization>> {
    const url = `/applications/${p["clientId"]}/token`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsResetToken(
    p: {
      clientId: string
      requestBody: {
        access_token: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_authorization>> {
    const url = `/applications/${p["clientId"]}/token`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsDeleteToken(
    p: {
      clientId: string
      requestBody: {
        access_token: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/applications/${p["clientId"]}/token`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsScopeToken(
    p: {
      clientId: string
      requestBody: {
        access_token: string
        permissions?: t_app_permissions | undefined
        repositories?: string[] | undefined
        repository_ids?: number[] | undefined
        target?: string | undefined
        target_id?: number | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_authorization>> {
    const url = `/applications/${p["clientId"]}/token/scoped`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetBySlug(
    p: {
      appSlug: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_integration>> {
    const url = `/apps/${p["appSlug"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async classroomGetAnAssignment(
    p: {
      assignmentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_classroom_assignment>> {
    const url = `/assignments/${p["assignmentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async classroomListAcceptedAssignmentsForAnAssignment(
    p: {
      assignmentId: number
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_classroom_accepted_assignment[]>> {
    const url = `/assignments/${p["assignmentId"]}/accepted_assignments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async classroomGetAssignmentGrades(
    p: {
      assignmentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_classroom_assignment_grade[]>> {
    const url = `/assignments/${p["assignmentId"]}/grades`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async classroomListClassrooms(
    p: {
      page?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_classroom[]>> {
    const url = `/classrooms`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async classroomGetAClassroom(
    p: {
      classroomId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_classroom>> {
    const url = `/classrooms/${p["classroomId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async classroomListAssignmentsForAClassroom(
    p: {
      classroomId: number
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_classroom_assignment[]>> {
    const url = `/classrooms/${p["classroomId"]}/assignments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codesOfConductGetAllCodesOfConduct(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_of_conduct[]>> {
    const url = `/codes_of_conduct`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codesOfConductGetConductCode(
    p: {
      key: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_of_conduct>> {
    const url = `/codes_of_conduct/${p["key"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async credentialsRevoke(
    p: {
      requestBody: {
        credentials: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/credentials/revoke`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async emojisGet(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: string | undefined
    }>
  > {
    const url = `/emojis`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetConfigurationsForEnterprise(
    p: {
      enterprise: string
      perPage?: number
      before?: string
      after?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration[]>> {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityCreateConfigurationForEnterprise(
    p: {
      enterprise: string
      requestBody: {
        advanced_security?:
          | (
              | "enabled"
              | "disabled"
              | "code_security"
              | "secret_protection"
              | UnknownEnumStringValue
            )
          | undefined
        code_scanning_default_setup?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_scanning_default_setup_options?:
          | t_code_scanning_default_setup_options
          | undefined
        code_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_scanning_options?: t_code_scanning_options | undefined
        code_security?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_alerts?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_security_updates?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action_options?:
          | {
              labeled_runners?: boolean | undefined
            }
          | undefined
        description: string
        enforcement?:
          | ("enforced" | "unenforced" | UnknownEnumStringValue)
          | undefined
        name: string
        private_vulnerability_reporting?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_generic_secrets?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_non_provider_patterns?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_push_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_validity_checks?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration>> {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetDefaultConfigurationsForEnterprise(
    p: {
      enterprise: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_default_configurations>> {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations/defaults`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetSingleConfigurationForEnterprise(
    p: {
      enterprise: string
      configurationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration>> {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations/${p["configurationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityUpdateEnterpriseConfiguration(
    p: {
      enterprise: string
      configurationId: number
      requestBody: {
        advanced_security?:
          | (
              | "enabled"
              | "disabled"
              | "code_security"
              | "secret_protection"
              | UnknownEnumStringValue
            )
          | undefined
        code_scanning_default_setup?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_scanning_default_setup_options?:
          | t_code_scanning_default_setup_options
          | undefined
        code_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_security?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_alerts?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_security_updates?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action_options?:
          | {
              labeled_runners?: boolean | undefined
            }
          | undefined
        description?: string | undefined
        enforcement?:
          | ("enforced" | "unenforced" | UnknownEnumStringValue)
          | undefined
        name?: string | undefined
        private_vulnerability_reporting?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_generic_secrets?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_non_provider_patterns?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_push_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_validity_checks?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration>> {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations/${p["configurationId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityDeleteConfigurationForEnterprise(
    p: {
      enterprise: string
      configurationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations/${p["configurationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityAttachEnterpriseConfiguration(
    p: {
      enterprise: string
      configurationId: number
      requestBody: {
        scope: "all" | "all_without_configurations" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations/${p["configurationId"]}/attach`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecuritySetConfigurationAsDefaultForEnterprise(
    p: {
      enterprise: string
      configurationId: number
      requestBody: {
        default_for_new_repos?:
          | (
              | "all"
              | "none"
              | "private_and_internal"
              | "public"
              | UnknownEnumStringValue
            )
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      configuration?: t_code_security_configuration | undefined
      default_for_new_repos?:
        | (
            | "all"
            | "none"
            | "private_and_internal"
            | "public"
            | UnknownEnumStringValue
          )
        | undefined
    }>
  > {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations/${p["configurationId"]}/defaults`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetRepositoriesForEnterpriseConfiguration(
    p: {
      enterprise: string
      configurationId: number
      perPage?: number
      before?: string
      after?: string
      status?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration_repositories[]>> {
    const url = `/enterprises/${p["enterprise"]}/code-security/configurations/${p["configurationId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      status: p["status"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotListAlertsForEnterprise(
    p: {
      enterprise: string
      state?: string
      severity?: string
      ecosystem?: string
      package?: string
      epssPercentage?: string
      has?: string | ("patch" | UnknownEnumStringValue)[]
      scope?: "development" | "runtime" | UnknownEnumStringValue
      sort?: "created" | "updated" | "epss_percentage" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      before?: string
      after?: string
      first?: number
      last?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_alert_with_repository[]>> {
    const url = `/enterprises/${p["enterprise"]}/dependabot/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      severity: p["severity"],
      ecosystem: p["ecosystem"],
      package: p["package"],
      epss_percentage: p["epssPercentage"],
      has: p["has"],
      scope: p["scope"],
      sort: p["sort"],
      direction: p["direction"],
      before: p["before"],
      after: p["after"],
      first: p["first"],
      last: p["last"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningListAlertsForEnterprise(
    p: {
      enterprise: string
      state?: "open" | "resolved" | UnknownEnumStringValue
      secretType?: string
      resolution?: string
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      before?: string
      after?: string
      validity?: string
      isPubliclyLeaked?: boolean
      isMultiRepo?: boolean
      hideSecret?: boolean
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_secret_scanning_alert[]>> {
    const url = `/enterprises/${p["enterprise"]}/secret-scanning/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      secret_type: p["secretType"],
      resolution: p["resolution"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      validity: p["validity"],
      is_publicly_leaked: p["isPubliclyLeaked"],
      is_multi_repo: p["isMultiRepo"],
      hide_secret: p["hideSecret"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListPublicEvents(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityGetFeeds(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_feed>> {
    const url = `/feeds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsList(
    p: {
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_base_gist[]>> {
    const url = `/gists`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsCreate(
    p: {
      requestBody: {
        description?: string | undefined
        files: {
          [key: string]:
            | {
                content: string
              }
            | undefined
        }
        public?:
          | (boolean | "true" | "false" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_simple>> {
    const url = `/gists`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsListPublic(
    p: {
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_base_gist[]>> {
    const url = `/gists/public`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsListStarred(
    p: {
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_base_gist[]>> {
    const url = `/gists/starred`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsGet(
    p: {
      gistId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_simple>> {
    const url = `/gists/${p["gistId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsUpdate(
    p: {
      gistId: string
      requestBody: {
        description?: string | undefined
        files?:
          | {
              [key: string]:
                | ({
                    content?: string | undefined
                    filename?: (string | null) | undefined
                  } | null)
                | undefined
            }
          | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_simple>> {
    const url = `/gists/${p["gistId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsDelete(
    p: {
      gistId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/gists/${p["gistId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsListComments(
    p: {
      gistId: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_comment[]>> {
    const url = `/gists/${p["gistId"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsCreateComment(
    p: {
      gistId: string
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_comment>> {
    const url = `/gists/${p["gistId"]}/comments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsGetComment(
    p: {
      gistId: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_comment>> {
    const url = `/gists/${p["gistId"]}/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsUpdateComment(
    p: {
      gistId: string
      commentId: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_comment>> {
    const url = `/gists/${p["gistId"]}/comments/${p["commentId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsDeleteComment(
    p: {
      gistId: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/gists/${p["gistId"]}/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsListCommits(
    p: {
      gistId: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_commit[]>> {
    const url = `/gists/${p["gistId"]}/commits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsListForks(
    p: {
      gistId: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_simple[]>> {
    const url = `/gists/${p["gistId"]}/forks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsFork(
    p: {
      gistId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_base_gist>> {
    const url = `/gists/${p["gistId"]}/forks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsCheckIsStarred(
    p: {
      gistId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/gists/${p["gistId"]}/star`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsStar(
    p: {
      gistId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/gists/${p["gistId"]}/star`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsUnstar(
    p: {
      gistId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/gists/${p["gistId"]}/star`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsGetRevision(
    p: {
      gistId: string
      sha: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gist_simple>> {
    const url = `/gists/${p["gistId"]}/${p["sha"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitignoreGetAllTemplates(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string[]>> {
    const url = `/gitignore/templates`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitignoreGetTemplate(
    p: {
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gitignore_template>> {
    const url = `/gitignore/templates/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListReposAccessibleToInstallation(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_repository[]
      repository_selection?: string | undefined
      total_count: number
    }>
  > {
    const url = `/installation/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsRevokeInstallationAccessToken(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/installation/token`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesList(
    p: {
      filter?:
        | "assigned"
        | "created"
        | "mentioned"
        | "subscribed"
        | "repos"
        | "all"
        | UnknownEnumStringValue
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      labels?: string
      sort?: "created" | "updated" | "comments" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      since?: string
      collab?: boolean
      orgs?: boolean
      owned?: boolean
      pulls?: boolean
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue[]>> {
    const url = `/issues`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      filter: p["filter"],
      state: p["state"],
      labels: p["labels"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      collab: p["collab"],
      orgs: p["orgs"],
      owned: p["owned"],
      pulls: p["pulls"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async licensesGetAllCommonlyUsed(
    p: {
      featured?: boolean
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_license_simple[]>> {
    const url = `/licenses`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      featured: p["featured"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async licensesGet(
    p: {
      license: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_license>> {
    const url = `/licenses/${p["license"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async markdownRender(
    p: {
      requestBody: {
        context?: string | undefined
        mode?: ("markdown" | "gfm" | UnknownEnumStringValue) | undefined
        text: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string>> {
    const url = `/markdown`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async markdownRenderRaw(
    p: {
      requestBody?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string>> {
    const url = `/markdown/raw`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type": p.requestBody !== undefined ? "text/plain" : false,
      },
      opts.headers,
    )
    const body = p.requestBody !== undefined ? p.requestBody : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetSubscriptionPlanForAccount(
    p: {
      accountId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_marketplace_purchase>> {
    const url = `/marketplace_listing/accounts/${p["accountId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListPlans(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_marketplace_listing_plan[]>> {
    const url = `/marketplace_listing/plans`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListAccountsForPlan(
    p: {
      planId: number
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_marketplace_purchase[]>> {
    const url = `/marketplace_listing/plans/${p["planId"]}/accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetSubscriptionPlanForAccountStubbed(
    p: {
      accountId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_marketplace_purchase>> {
    const url = `/marketplace_listing/stubbed/accounts/${p["accountId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListPlansStubbed(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_marketplace_listing_plan[]>> {
    const url = `/marketplace_listing/stubbed/plans`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListAccountsForPlanStubbed(
    p: {
      planId: number
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_marketplace_purchase[]>> {
    const url = `/marketplace_listing/stubbed/plans/${p["planId"]}/accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async metaGet(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_overview>> {
    const url = `/meta`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListPublicEventsForRepoNetwork(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/networks/${p["owner"]}/${p["repo"]}/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListNotificationsForAuthenticatedUser(
    p: {
      all?: boolean
      participating?: boolean
      since?: string
      before?: string
      page?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_thread[]>> {
    const url = `/notifications`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      all: p["all"],
      participating: p["participating"],
      since: p["since"],
      before: p["before"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityMarkNotificationsAsRead(
    p: {
      requestBody?: {
        last_read_at?: string | undefined
        read?: boolean | undefined
      }
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<{
        message?: string | undefined
      }>
    | AxiosResponse<void>
  > {
    const url = `/notifications`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityGetThread(
    p: {
      threadId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_thread>> {
    const url = `/notifications/threads/${p["threadId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityMarkThreadAsRead(
    p: {
      threadId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/notifications/threads/${p["threadId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PATCH",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityMarkThreadAsDone(
    p: {
      threadId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/notifications/threads/${p["threadId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityGetThreadSubscriptionForAuthenticatedUser(
    p: {
      threadId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_thread_subscription>> {
    const url = `/notifications/threads/${p["threadId"]}/subscription`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activitySetThreadSubscription(
    p: {
      threadId: number
      requestBody?: {
        ignored?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_thread_subscription>> {
    const url = `/notifications/threads/${p["threadId"]}/subscription`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityDeleteThreadSubscription(
    p: {
      threadId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/notifications/threads/${p["threadId"]}/subscription`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async metaGetOctocat(
    p: {
      s?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string>> {
    const url = `/octocat`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({s: p["s"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsList(
    p: {
      since?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_simple[]>> {
    const url = `/organizations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({since: p["since"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotRepositoryAccessForOrg(
    p: {
      org: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_repository_access_details>> {
    const url = `/organizations/${p["org"]}/dependabot/repository-access`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotUpdateRepositoryAccessForOrg(
    p: {
      org: string
      requestBody: {
        repository_ids_to_add?: number[] | undefined
        repository_ids_to_remove?: number[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/organizations/${p["org"]}/dependabot/repository-access`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotSetRepositoryAccessDefaultLevel(
    p: {
      org: string
      requestBody: {
        default_level: "public" | "internal" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/organizations/${p["org"]}/dependabot/repository-access/default-level`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetGithubBillingUsageReportOrg(
    p: {
      org: string
      year?: number
      month?: number
      day?: number
      hour?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_billing_usage_report>> {
    const url = `/organizations/${p["org"]}/settings/billing/usage`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      year: p["year"],
      month: p["month"],
      day: p["day"],
      hour: p["hour"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGet(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_full>> {
    const url = `/orgs/${p["org"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUpdate(
    p: {
      org: string
      requestBody?: {
        advanced_security_enabled_for_new_repositories?: boolean | undefined
        billing_email?: string | undefined
        blog?: string | undefined
        company?: string | undefined
        default_repository_permission?:
          | ("read" | "write" | "admin" | "none" | UnknownEnumStringValue)
          | undefined
        dependabot_alerts_enabled_for_new_repositories?: boolean | undefined
        dependabot_security_updates_enabled_for_new_repositories?:
          | boolean
          | undefined
        dependency_graph_enabled_for_new_repositories?: boolean | undefined
        deploy_keys_enabled_for_repositories?: boolean | undefined
        description?: string | undefined
        email?: string | undefined
        has_organization_projects?: boolean | undefined
        has_repository_projects?: boolean | undefined
        location?: string | undefined
        members_allowed_repository_creation_type?:
          | ("all" | "private" | "none" | UnknownEnumStringValue)
          | undefined
        members_can_create_internal_repositories?: boolean | undefined
        members_can_create_pages?: boolean | undefined
        members_can_create_private_pages?: boolean | undefined
        members_can_create_private_repositories?: boolean | undefined
        members_can_create_public_pages?: boolean | undefined
        members_can_create_public_repositories?: boolean | undefined
        members_can_create_repositories?: boolean | undefined
        members_can_fork_private_repositories?: boolean | undefined
        name?: string | undefined
        secret_scanning_enabled_for_new_repositories?: boolean | undefined
        secret_scanning_push_protection_custom_link?: string | undefined
        secret_scanning_push_protection_custom_link_enabled?:
          | boolean
          | undefined
        secret_scanning_push_protection_enabled_for_new_repositories?:
          | boolean
          | undefined
        twitter_username?: string | undefined
        web_commit_signoff_required?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_full>> {
    const url = `/orgs/${p["org"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsDelete(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetActionsCacheUsageForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_cache_usage_org_enterprise>> {
    const url = `/orgs/${p["org"]}/actions/cache/usage`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetActionsCacheUsageByRepoForOrg(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repository_cache_usages: t_actions_cache_usage_by_repository[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/cache/usage-by-repository`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListHostedRunnersForOrg(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      runners: t_actions_hosted_runner[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/hosted-runners`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateHostedRunnerForOrg(
    p: {
      org: string
      requestBody: {
        enable_static_ip?: boolean | undefined
        image: {
          id?: string | undefined
          source?:
            | ("github" | "partner" | "custom" | UnknownEnumStringValue)
            | undefined
        }
        maximum_runners?: number | undefined
        name: string
        runner_group_id: number
        size: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_hosted_runner>> {
    const url = `/orgs/${p["org"]}/actions/hosted-runners`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetHostedRunnersGithubOwnedImagesForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      images: t_actions_hosted_runner_image[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/images/github-owned`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetHostedRunnersPartnerImagesForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      images: t_actions_hosted_runner_image[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/images/partner`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetHostedRunnersLimitsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_hosted_runner_limits>> {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/limits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetHostedRunnersMachineSpecsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      machine_specs: t_actions_hosted_runner_machine_spec[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/machine-sizes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetHostedRunnersPlatformsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      platforms: string[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/platforms`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetHostedRunnerForOrg(
    p: {
      org: string
      hostedRunnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_hosted_runner>> {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/${p["hostedRunnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsUpdateHostedRunnerForOrg(
    p: {
      org: string
      hostedRunnerId: number
      requestBody: {
        enable_static_ip?: boolean | undefined
        maximum_runners?: number | undefined
        name?: string | undefined
        runner_group_id?: number | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_hosted_runner>> {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/${p["hostedRunnerId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteHostedRunnerForOrg(
    p: {
      org: string
      hostedRunnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_hosted_runner>> {
    const url = `/orgs/${p["org"]}/actions/hosted-runners/${p["hostedRunnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async oidcGetOidcCustomSubTemplateForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_oidc_custom_sub>> {
    const url = `/orgs/${p["org"]}/actions/oidc/customization/sub`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async oidcUpdateOidcCustomSubTemplateForOrg(
    p: {
      org: string
      requestBody: t_oidc_custom_sub
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/orgs/${p["org"]}/actions/oidc/customization/sub`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetGithubActionsPermissionsOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_organization_permissions>> {
    const url = `/orgs/${p["org"]}/actions/permissions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetGithubActionsPermissionsOrganization(
    p: {
      org: string
      requestBody: {
        allowed_actions?: t_allowed_actions | undefined
        enabled_repositories: t_enabled_repositories
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/permissions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_repository[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/permissions/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
    p: {
      org: string
      requestBody: {
        selected_repository_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/permissions/repositories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsEnableSelectedRepositoryGithubActionsOrganization(
    p: {
      org: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/permissions/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDisableSelectedRepositoryGithubActionsOrganization(
    p: {
      org: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/permissions/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetAllowedActionsOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_selected_actions>> {
    const url = `/orgs/${p["org"]}/actions/permissions/selected-actions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetAllowedActionsOrganization(
    p: {
      org: string
      requestBody?: t_selected_actions
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/permissions/selected-actions`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_get_default_workflow_permissions>> {
    const url = `/orgs/${p["org"]}/actions/permissions/workflow`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
    p: {
      org: string
      requestBody?: t_actions_set_default_workflow_permissions
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/permissions/workflow`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListSelfHostedRunnerGroupsForOrg(
    p: {
      org: string
      perPage?: number
      page?: number
      visibleToRepository?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      runner_groups: t_runner_groups_org[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runner-groups`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      visible_to_repository: p["visibleToRepository"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateSelfHostedRunnerGroupForOrg(
    p: {
      org: string
      requestBody: {
        allows_public_repositories?: boolean | undefined
        name: string
        network_configuration_id?: string | undefined
        restricted_to_workflows?: boolean | undefined
        runners?: number[] | undefined
        selected_repository_ids?: number[] | undefined
        selected_workflows?: string[] | undefined
        visibility?:
          | ("selected" | "all" | "private" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_runner_groups_org>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetSelfHostedRunnerGroupForOrg(
    p: {
      org: string
      runnerGroupId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_runner_groups_org>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsUpdateSelfHostedRunnerGroupForOrg(
    p: {
      org: string
      runnerGroupId: number
      requestBody: {
        allows_public_repositories?: boolean | undefined
        name: string
        network_configuration_id?: (string | null) | undefined
        restricted_to_workflows?: boolean | undefined
        selected_workflows?: string[] | undefined
        visibility?:
          | ("selected" | "all" | "private" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_runner_groups_org>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteSelfHostedRunnerGroupFromOrg(
    p: {
      org: string
      runnerGroupId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListGithubHostedRunnersInGroupForOrg(
    p: {
      org: string
      runnerGroupId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      runners: t_actions_hosted_runner[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/hosted-runners`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
    p: {
      org: string
      runnerGroupId: number
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_minimal_repository[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
    p: {
      org: string
      runnerGroupId: number
      requestBody: {
        selected_repository_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/repositories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsAddRepoAccessToSelfHostedRunnerGroupInOrg(
    p: {
      org: string
      runnerGroupId: number
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
    p: {
      org: string
      runnerGroupId: number
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListSelfHostedRunnersInGroupForOrg(
    p: {
      org: string
      runnerGroupId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      runners: t_runner[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/runners`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetSelfHostedRunnersInGroupForOrg(
    p: {
      org: string
      runnerGroupId: number
      requestBody: {
        runners: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/runners`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsAddSelfHostedRunnerToGroupForOrg(
    p: {
      org: string
      runnerGroupId: number
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/runners/${p["runnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveSelfHostedRunnerFromGroupForOrg(
    p: {
      org: string
      runnerGroupId: number
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runner-groups/${p["runnerGroupId"]}/runners/${p["runnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListSelfHostedRunnersForOrg(
    p: {
      name?: string
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      runners: t_runner[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runners`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      name: p["name"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRunnerApplicationsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_runner_application[]>> {
    const url = `/orgs/${p["org"]}/actions/runners/downloads`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGenerateRunnerJitconfigForOrg(
    p: {
      org: string
      requestBody: {
        labels: string[]
        name: string
        runner_group_id: number
        work_folder?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      encoded_jit_config: string
      runner: t_runner
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runners/generate-jitconfig`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateRegistrationTokenForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_authentication_token>> {
    const url = `/orgs/${p["org"]}/actions/runners/registration-token`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateRemoveTokenForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_authentication_token>> {
    const url = `/orgs/${p["org"]}/actions/runners/remove-token`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_runner>> {
    const url = `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteSelfHostedRunnerFromOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListLabelsForSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsAddCustomLabelsToSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
      requestBody: {
        labels: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetCustomLabelsForSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
      requestBody: {
        labels: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListOrgSecrets(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_organization_actions_secret[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetOrgPublicKey(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_public_key>> {
    const url = `/orgs/${p["org"]}/actions/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_actions_secret>> {
    const url = `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateOrUpdateOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: {
        encrypted_value: string
        key_id: string
        selected_repository_ids?: number[] | undefined
        visibility: "all" | "private" | "selected" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_minimal_repository[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: {
        selected_repository_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsAddSelectedRepoToOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveSelectedRepoFromOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListOrgVariables(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      total_count: number
      variables: t_organization_actions_variable[]
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/variables`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateOrgVariable(
    p: {
      org: string
      requestBody: {
        name: string
        selected_repository_ids?: number[] | undefined
        value: string
        visibility: "all" | "private" | "selected" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/orgs/${p["org"]}/actions/variables`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetOrgVariable(
    p: {
      org: string
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_actions_variable>> {
    const url = `/orgs/${p["org"]}/actions/variables/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsUpdateOrgVariable(
    p: {
      org: string
      name: string
      requestBody: {
        name?: string | undefined
        selected_repository_ids?: number[] | undefined
        value?: string | undefined
        visibility?:
          | ("all" | "private" | "selected" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/variables/${p["name"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteOrgVariable(
    p: {
      org: string
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/variables/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListSelectedReposForOrgVariable(
    p: {
      org: string
      name: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_minimal_repository[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetSelectedReposForOrgVariable(
    p: {
      org: string
      name: string
      requestBody: {
        selected_repository_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsAddSelectedRepoToOrgVariable(
    p: {
      org: string
      name: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveSelectedRepoFromOrgVariable(
    p: {
      org: string
      name: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListAttestationsBulk(
    p: {
      perPage?: number
      before?: string
      after?: string
      org: string
      requestBody: {
        predicate_type?: string | undefined
        subject_digests: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      attestations_subject_digests?:
        | {
            [key: string]:
              | (
                  | {
                      bundle?:
                        | {
                            dsseEnvelope?:
                              | {
                                  [key: string]: unknown | undefined
                                }
                              | undefined
                            mediaType?: string | undefined
                            verificationMaterial?:
                              | {
                                  [key: string]: unknown | undefined
                                }
                              | undefined
                          }
                        | undefined
                      bundle_url?: string | undefined
                      repository_id?: number | undefined
                    }[]
                  | null
                )
              | undefined
          }
        | undefined
      page_info?:
        | {
            has_next?: boolean | undefined
            has_previous?: boolean | undefined
            next?: string | undefined
            previous?: string | undefined
          }
        | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/attestations/bulk-list`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsDeleteAttestationsBulk(
    p: {
      org: string
      requestBody:
        | {
            subject_digests: string[]
          }
        | {
            attestation_ids: number[]
          }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/attestations/delete-request`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsDeleteAttestationsBySubjectDigest(
    p: {
      org: string
      subjectDigest: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/attestations/digest/${p["subjectDigest"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsDeleteAttestationsById(
    p: {
      org: string
      attestationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/attestations/${p["attestationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListAttestations(
    p: {
      perPage?: number
      before?: string
      after?: string
      org: string
      subjectDigest: string
      predicateType?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      attestations?:
        | {
            bundle?:
              | {
                  dsseEnvelope?:
                    | {
                        [key: string]: unknown | undefined
                      }
                    | undefined
                  mediaType?: string | undefined
                  verificationMaterial?:
                    | {
                        [key: string]: unknown | undefined
                      }
                    | undefined
                }
              | undefined
            bundle_url?: string | undefined
            repository_id?: number | undefined
          }[]
        | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/attestations/${p["subjectDigest"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      predicate_type: p["predicateType"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListBlockedUsers(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/orgs/${p["org"]}/blocks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCheckBlockedUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/blocks/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsBlockUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/blocks/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUnblockUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/blocks/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async campaignsListOrgCampaigns(
    p: {
      org: string
      page?: number
      perPage?: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      state?: t_campaign_state
      sort?:
        | "created"
        | "updated"
        | "ends_at"
        | "published"
        | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_campaign_summary[]>> {
    const url = `/orgs/${p["org"]}/campaigns`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      page: p["page"],
      per_page: p["perPage"],
      direction: p["direction"],
      state: p["state"],
      sort: p["sort"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async campaignsCreateCampaign(
    p: {
      org: string
      requestBody: {
        code_scanning_alerts: {
          alert_numbers: number[]
          repository_id: number
        }[]
        contact_link?: (string | null) | undefined
        description: string
        ends_at: string
        generate_issues?: boolean | undefined
        managers?: string[] | undefined
        name: string
        team_managers?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_campaign_summary>> {
    const url = `/orgs/${p["org"]}/campaigns`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async campaignsGetCampaignSummary(
    p: {
      org: string
      campaignNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_campaign_summary>> {
    const url = `/orgs/${p["org"]}/campaigns/${p["campaignNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async campaignsUpdateCampaign(
    p: {
      org: string
      campaignNumber: number
      requestBody: {
        contact_link?: (string | null) | undefined
        description?: string | undefined
        ends_at?: string | undefined
        managers?: string[] | undefined
        name?: string | undefined
        state?: t_campaign_state | undefined
        team_managers?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_campaign_summary>> {
    const url = `/orgs/${p["org"]}/campaigns/${p["campaignNumber"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async campaignsDeleteCampaign(
    p: {
      org: string
      campaignNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/campaigns/${p["campaignNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningListAlertsForOrg(
    p: {
      org: string
      toolName?: t_code_scanning_analysis_tool_name
      toolGuid?: t_code_scanning_analysis_tool_guid
      before?: string
      after?: string
      page?: number
      perPage?: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      state?: t_code_scanning_alert_state_query
      sort?: "created" | "updated" | UnknownEnumStringValue
      severity?: t_code_scanning_alert_severity
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_organization_alert_items[]>> {
    const url = `/orgs/${p["org"]}/code-scanning/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      tool_name: p["toolName"],
      tool_guid: p["toolGuid"],
      before: p["before"],
      after: p["after"],
      page: p["page"],
      per_page: p["perPage"],
      direction: p["direction"],
      state: p["state"],
      sort: p["sort"],
      severity: p["severity"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetConfigurationsForOrg(
    p: {
      org: string
      targetType?: "global" | "all" | UnknownEnumStringValue
      perPage?: number
      before?: string
      after?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration[]>> {
    const url = `/orgs/${p["org"]}/code-security/configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      target_type: p["targetType"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityCreateConfiguration(
    p: {
      org: string
      requestBody: {
        advanced_security?:
          | (
              | "enabled"
              | "disabled"
              | "code_security"
              | "secret_protection"
              | UnknownEnumStringValue
            )
          | undefined
        code_scanning_default_setup?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_scanning_default_setup_options?:
          | t_code_scanning_default_setup_options
          | undefined
        code_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_scanning_options?: t_code_scanning_options | undefined
        code_security?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_alerts?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_security_updates?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action_options?:
          | {
              labeled_runners?: boolean | undefined
            }
          | undefined
        description: string
        enforcement?:
          | ("enforced" | "unenforced" | UnknownEnumStringValue)
          | undefined
        name: string
        private_vulnerability_reporting?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_bypass?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_bypass_options?:
          | {
              reviewers?:
                | {
                    reviewer_id: number
                    reviewer_type: "TEAM" | "ROLE" | UnknownEnumStringValue
                  }[]
                | undefined
            }
          | undefined
        secret_scanning_generic_secrets?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_non_provider_patterns?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_push_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_validity_checks?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration>> {
    const url = `/orgs/${p["org"]}/code-security/configurations`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetDefaultConfigurations(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_default_configurations>> {
    const url = `/orgs/${p["org"]}/code-security/configurations/defaults`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityDetachConfiguration(
    p: {
      org: string
      requestBody: {
        selected_repository_ids?: number[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/code-security/configurations/detach`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetConfiguration(
    p: {
      org: string
      configurationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration>> {
    const url = `/orgs/${p["org"]}/code-security/configurations/${p["configurationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityUpdateConfiguration(
    p: {
      org: string
      configurationId: number
      requestBody: {
        advanced_security?:
          | (
              | "enabled"
              | "disabled"
              | "code_security"
              | "secret_protection"
              | UnknownEnumStringValue
            )
          | undefined
        code_scanning_default_setup?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_scanning_default_setup_options?:
          | t_code_scanning_default_setup_options
          | undefined
        code_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        code_security?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_alerts?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependabot_security_updates?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        dependency_graph_autosubmit_action_options?:
          | {
              labeled_runners?: boolean | undefined
            }
          | undefined
        description?: string | undefined
        enforcement?:
          | ("enforced" | "unenforced" | UnknownEnumStringValue)
          | undefined
        name?: string | undefined
        private_vulnerability_reporting?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_alert_dismissal?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_bypass?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_delegated_bypass_options?:
          | {
              reviewers?:
                | {
                    reviewer_id: number
                    reviewer_type: "TEAM" | "ROLE" | UnknownEnumStringValue
                  }[]
                | undefined
            }
          | undefined
        secret_scanning_generic_secrets?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_non_provider_patterns?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_push_protection?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
        secret_scanning_validity_checks?:
          | ("enabled" | "disabled" | "not_set" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<t_code_security_configuration> | AxiosResponse<void>
  > {
    const url = `/orgs/${p["org"]}/code-security/configurations/${p["configurationId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityDeleteConfiguration(
    p: {
      org: string
      configurationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/code-security/configurations/${p["configurationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityAttachConfiguration(
    p: {
      org: string
      configurationId: number
      requestBody: {
        scope:
          | "all"
          | "all_without_configurations"
          | "public"
          | "private_or_internal"
          | "selected"
          | UnknownEnumStringValue
        selected_repository_ids?: number[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/code-security/configurations/${p["configurationId"]}/attach`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecuritySetConfigurationAsDefault(
    p: {
      org: string
      configurationId: number
      requestBody: {
        default_for_new_repos?:
          | (
              | "all"
              | "none"
              | "private_and_internal"
              | "public"
              | UnknownEnumStringValue
            )
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      configuration?: t_code_security_configuration | undefined
      default_for_new_repos?:
        | (
            | "all"
            | "none"
            | "private_and_internal"
            | "public"
            | UnknownEnumStringValue
          )
        | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/code-security/configurations/${p["configurationId"]}/defaults`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetRepositoriesForConfiguration(
    p: {
      org: string
      configurationId: number
      perPage?: number
      before?: string
      after?: string
      status?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_security_configuration_repositories[]>> {
    const url = `/orgs/${p["org"]}/code-security/configurations/${p["configurationId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      status: p["status"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListInOrganization(
    p: {
      perPage?: number
      page?: number
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      codespaces: t_codespace[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/codespaces`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesSetCodespacesAccess(
    p: {
      org: string
      requestBody: {
        selected_usernames?: string[] | undefined
        visibility:
          | "disabled"
          | "selected_members"
          | "all_members"
          | "all_members_and_outside_collaborators"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/access`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesSetCodespacesAccessUsers(
    p: {
      org: string
      requestBody: {
        selected_usernames: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/access/selected_users`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesDeleteCodespacesAccessUsers(
    p: {
      org: string
      requestBody: {
        selected_usernames: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/access/selected_users`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListOrgSecrets(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_codespaces_org_secret[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/codespaces/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetOrgPublicKey(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespaces_public_key>> {
    const url = `/orgs/${p["org"]}/codespaces/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespaces_org_secret>> {
    const url = `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCreateOrUpdateOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: {
        encrypted_value?: string | undefined
        key_id?: string | undefined
        selected_repository_ids?: number[] | undefined
        visibility: "all" | "private" | "selected" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesDeleteOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_minimal_repository[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesSetSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: {
        selected_repository_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesAddSelectedRepoToOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesRemoveSelectedRepoFromOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotGetCopilotOrganizationDetails(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_copilot_organization_details>> {
    const url = `/orgs/${p["org"]}/copilot/billing`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotListCopilotSeats(
    p: {
      org: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      seats?: t_copilot_seat_details[] | undefined
      total_seats?: number | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/copilot/billing/seats`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotAddCopilotSeatsForTeams(
    p: {
      org: string
      requestBody: {
        selected_teams: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      seats_created: number
    }>
  > {
    const url = `/orgs/${p["org"]}/copilot/billing/selected_teams`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotCancelCopilotSeatAssignmentForTeams(
    p: {
      org: string
      requestBody: {
        selected_teams: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      seats_cancelled: number
    }>
  > {
    const url = `/orgs/${p["org"]}/copilot/billing/selected_teams`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotAddCopilotSeatsForUsers(
    p: {
      org: string
      requestBody: {
        selected_usernames: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      seats_created: number
    }>
  > {
    const url = `/orgs/${p["org"]}/copilot/billing/selected_users`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotCancelCopilotSeatAssignmentForUsers(
    p: {
      org: string
      requestBody: {
        selected_usernames: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      seats_cancelled: number
    }>
  > {
    const url = `/orgs/${p["org"]}/copilot/billing/selected_users`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotCopilotMetricsForOrganization(
    p: {
      org: string
      since?: string
      until?: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_copilot_usage_metrics_day[]>> {
    const url = `/orgs/${p["org"]}/copilot/metrics`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      since: p["since"],
      until: p["until"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotListAlertsForOrg(
    p: {
      org: string
      state?: string
      severity?: string
      ecosystem?: string
      package?: string
      epssPercentage?: string
      has?: string | ("patch" | UnknownEnumStringValue)[]
      scope?: "development" | "runtime" | UnknownEnumStringValue
      sort?: "created" | "updated" | "epss_percentage" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      before?: string
      after?: string
      first?: number
      last?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_alert_with_repository[]>> {
    const url = `/orgs/${p["org"]}/dependabot/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      severity: p["severity"],
      ecosystem: p["ecosystem"],
      package: p["package"],
      epss_percentage: p["epssPercentage"],
      has: p["has"],
      scope: p["scope"],
      sort: p["sort"],
      direction: p["direction"],
      before: p["before"],
      after: p["after"],
      first: p["first"],
      last: p["last"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotListOrgSecrets(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_organization_dependabot_secret[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/dependabot/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotGetOrgPublicKey(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_public_key>> {
    const url = `/orgs/${p["org"]}/dependabot/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotGetOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_dependabot_secret>> {
    const url = `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotCreateOrUpdateOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: {
        encrypted_value?: string | undefined
        key_id?: string | undefined
        selected_repository_ids?: string[] | undefined
        visibility: "all" | "private" | "selected" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotDeleteOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotListSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_minimal_repository[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotSetSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: {
        selected_repository_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotAddSelectedRepoToOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotRemoveSelectedRepoFromOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesListDockerMigrationConflictingPackagesForOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package[]>> {
    const url = `/orgs/${p["org"]}/docker/conflicts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListPublicOrgEvents(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/orgs/${p["org"]}/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListFailedInvitations(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_invitation[]>> {
    const url = `/orgs/${p["org"]}/failed_invitations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListWebhooks(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_hook[]>> {
    const url = `/orgs/${p["org"]}/hooks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCreateWebhook(
    p: {
      org: string
      requestBody: {
        active?: boolean | undefined
        config: {
          content_type?: t_webhook_config_content_type | undefined
          insecure_ssl?: t_webhook_config_insecure_ssl | undefined
          password?: string | undefined
          secret?: t_webhook_config_secret | undefined
          url: t_webhook_config_url
          username?: string | undefined
        }
        events?: string[] | undefined
        name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_hook>> {
    const url = `/orgs/${p["org"]}/hooks`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetWebhook(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_hook>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUpdateWebhook(
    p: {
      org: string
      hookId: number
      requestBody?: {
        active?: boolean | undefined
        config?:
          | {
              content_type?: t_webhook_config_content_type | undefined
              insecure_ssl?: t_webhook_config_insecure_ssl | undefined
              secret?: t_webhook_config_secret | undefined
              url: t_webhook_config_url
            }
          | undefined
        events?: string[] | undefined
        name?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_hook>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsDeleteWebhook(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetWebhookConfigForOrg(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_webhook_config>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}/config`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUpdateWebhookConfigForOrg(
    p: {
      org: string
      hookId: number
      requestBody?: {
        content_type?: t_webhook_config_content_type | undefined
        insecure_ssl?: t_webhook_config_insecure_ssl | undefined
        secret?: t_webhook_config_secret | undefined
        url?: t_webhook_config_url | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_webhook_config>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}/config`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListWebhookDeliveries(
    p: {
      org: string
      hookId: number
      perPage?: number
      cursor?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook_delivery_item[]>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], cursor: p["cursor"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetWebhookDelivery(
    p: {
      org: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook_delivery>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRedeliverWebhookDelivery(
    p: {
      org: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}/attempts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsPingWebhook(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/hooks/${p["hookId"]}/pings`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetRouteStatsByActor(
    p: {
      org: string
      actorType:
        | "installation"
        | "classic_pat"
        | "fine_grained_pat"
        | "oauth_app"
        | "github_app_user_to_server"
        | UnknownEnumStringValue
      actorId: number
      minTimestamp: string
      maxTimestamp?: string
      page?: number
      perPage?: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      sort?: (
        | "last_rate_limited_timestamp"
        | "last_request_timestamp"
        | "rate_limited_request_count"
        | "http_method"
        | "api_route"
        | "total_request_count"
        | UnknownEnumStringValue
      )[]
      apiRouteSubstring?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_route_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/route-stats/${p["actorType"]}/${p["actorId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
      page: p["page"],
      per_page: p["perPage"],
      direction: p["direction"],
      sort: p["sort"],
      api_route_substring: p["apiRouteSubstring"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetSubjectStats(
    p: {
      org: string
      minTimestamp: string
      maxTimestamp?: string
      page?: number
      perPage?: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      sort?: (
        | "last_rate_limited_timestamp"
        | "last_request_timestamp"
        | "rate_limited_request_count"
        | "subject_name"
        | "total_request_count"
        | UnknownEnumStringValue
      )[]
      subjectNameSubstring?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_subject_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/subject-stats`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
      page: p["page"],
      per_page: p["perPage"],
      direction: p["direction"],
      sort: p["sort"],
      subject_name_substring: p["subjectNameSubstring"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetSummaryStats(
    p: {
      org: string
      minTimestamp: string
      maxTimestamp?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_summary_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/summary-stats`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetSummaryStatsByUser(
    p: {
      org: string
      userId: string
      minTimestamp: string
      maxTimestamp?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_summary_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/summary-stats/users/${p["userId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetSummaryStatsByActor(
    p: {
      org: string
      minTimestamp: string
      maxTimestamp?: string
      actorType:
        | "installation"
        | "classic_pat"
        | "fine_grained_pat"
        | "oauth_app"
        | "github_app_user_to_server"
        | UnknownEnumStringValue
      actorId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_summary_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/summary-stats/${p["actorType"]}/${p["actorId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetTimeStats(
    p: {
      org: string
      minTimestamp: string
      maxTimestamp?: string
      timestampIncrement: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_time_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/time-stats`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
      timestamp_increment: p["timestampIncrement"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetTimeStatsByUser(
    p: {
      org: string
      userId: string
      minTimestamp: string
      maxTimestamp?: string
      timestampIncrement: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_time_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/time-stats/users/${p["userId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
      timestamp_increment: p["timestampIncrement"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetTimeStatsByActor(
    p: {
      org: string
      actorType:
        | "installation"
        | "classic_pat"
        | "fine_grained_pat"
        | "oauth_app"
        | "github_app_user_to_server"
        | UnknownEnumStringValue
      actorId: number
      minTimestamp: string
      maxTimestamp?: string
      timestampIncrement: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_time_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/time-stats/${p["actorType"]}/${p["actorId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
      timestamp_increment: p["timestampIncrement"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async apiInsightsGetUserStats(
    p: {
      org: string
      userId: string
      minTimestamp: string
      maxTimestamp?: string
      page?: number
      perPage?: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      sort?: (
        | "last_rate_limited_timestamp"
        | "last_request_timestamp"
        | "rate_limited_request_count"
        | "subject_name"
        | "total_request_count"
        | UnknownEnumStringValue
      )[]
      actorNameSubstring?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_api_insights_user_stats>> {
    const url = `/orgs/${p["org"]}/insights/api/user-stats/${p["userId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      min_timestamp: p["minTimestamp"],
      max_timestamp: p["maxTimestamp"],
      page: p["page"],
      per_page: p["perPage"],
      direction: p["direction"],
      sort: p["sort"],
      actor_name_substring: p["actorNameSubstring"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetOrgInstallation(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_installation>> {
    const url = `/orgs/${p["org"]}/installation`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListAppInstallations(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      installations: t_installation[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/installations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsGetRestrictionsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_interaction_limit_response | EmptyObject>> {
    const url = `/orgs/${p["org"]}/interaction-limits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsSetRestrictionsForOrg(
    p: {
      org: string
      requestBody: t_interaction_limit
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_interaction_limit_response>> {
    const url = `/orgs/${p["org"]}/interaction-limits`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsRemoveRestrictionsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/interaction-limits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListPendingInvitations(
    p: {
      org: string
      perPage?: number
      page?: number
      role?:
        | "all"
        | "admin"
        | "direct_member"
        | "billing_manager"
        | "hiring_manager"
        | UnknownEnumStringValue
      invitationSource?: "all" | "member" | "scim" | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_invitation[]>> {
    const url = `/orgs/${p["org"]}/invitations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      role: p["role"],
      invitation_source: p["invitationSource"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCreateInvitation(
    p: {
      org: string
      requestBody?: {
        email?: string | undefined
        invitee_id?: number | undefined
        role?:
          | (
              | "admin"
              | "direct_member"
              | "billing_manager"
              | "reinstate"
              | UnknownEnumStringValue
            )
          | undefined
        team_ids?: number[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_invitation>> {
    const url = `/orgs/${p["org"]}/invitations`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCancelInvitation(
    p: {
      org: string
      invitationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/invitations/${p["invitationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListInvitationTeams(
    p: {
      org: string
      invitationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/orgs/${p["org"]}/invitations/${p["invitationId"]}/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListIssueTypes(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_type[]>> {
    const url = `/orgs/${p["org"]}/issue-types`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCreateIssueType(
    p: {
      org: string
      requestBody: t_organization_create_issue_type
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_type>> {
    const url = `/orgs/${p["org"]}/issue-types`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUpdateIssueType(
    p: {
      org: string
      issueTypeId: number
      requestBody: t_organization_update_issue_type
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_type>> {
    const url = `/orgs/${p["org"]}/issue-types/${p["issueTypeId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsDeleteIssueType(
    p: {
      org: string
      issueTypeId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/issue-types/${p["issueTypeId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListForOrg(
    p: {
      org: string
      filter?:
        | "assigned"
        | "created"
        | "mentioned"
        | "subscribed"
        | "repos"
        | "all"
        | UnknownEnumStringValue
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      labels?: string
      type?: string
      sort?: "created" | "updated" | "comments" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue[]>> {
    const url = `/orgs/${p["org"]}/issues`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      filter: p["filter"],
      state: p["state"],
      labels: p["labels"],
      type: p["type"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListMembers(
    p: {
      org: string
      filter?: "2fa_disabled" | "2fa_insecure" | "all" | UnknownEnumStringValue
      role?: "all" | "admin" | "member" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/orgs/${p["org"]}/members`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      filter: p["filter"],
      role: p["role"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCheckMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRemoveMember(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetCodespacesForUserInOrg(
    p: {
      perPage?: number
      page?: number
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      codespaces: t_codespace[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/members/${p["username"]}/codespaces`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesDeleteFromOrganization(
    p: {
      org: string
      username: string
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/members/${p["username"]}/codespaces/${p["codespaceName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesStopInOrganization(
    p: {
      org: string
      username: string
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/orgs/${p["org"]}/members/${p["username"]}/codespaces/${p["codespaceName"]}/stop`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotGetCopilotSeatDetailsForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_copilot_seat_details>> {
    const url = `/orgs/${p["org"]}/members/${p["username"]}/copilot`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_membership>> {
    const url = `/orgs/${p["org"]}/memberships/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsSetMembershipForUser(
    p: {
      org: string
      username: string
      requestBody?: {
        role?: ("admin" | "member" | UnknownEnumStringValue) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_membership>> {
    const url = `/orgs/${p["org"]}/memberships/${p["username"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRemoveMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/memberships/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsListForOrg(
    p: {
      org: string
      perPage?: number
      page?: number
      exclude?: ("repositories" | UnknownEnumStringValue)[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_migration[]>> {
    const url = `/orgs/${p["org"]}/migrations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      exclude: p["exclude"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsStartForOrg(
    p: {
      org: string
      requestBody: {
        exclude?: ("repositories" | UnknownEnumStringValue)[] | undefined
        exclude_attachments?: boolean | undefined
        exclude_git_data?: boolean | undefined
        exclude_metadata?: boolean | undefined
        exclude_owner_projects?: boolean | undefined
        exclude_releases?: boolean | undefined
        lock_repositories?: boolean | undefined
        org_metadata_only?: boolean | undefined
        repositories: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_migration>> {
    const url = `/orgs/${p["org"]}/migrations`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsGetStatusForOrg(
    p: {
      org: string
      migrationId: number
      exclude?: ("repositories" | UnknownEnumStringValue)[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_migration>> {
    const url = `/orgs/${p["org"]}/migrations/${p["migrationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({exclude: p["exclude"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsDownloadArchiveForOrg(
    p: {
      org: string
      migrationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsDeleteArchiveForOrg(
    p: {
      org: string
      migrationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsUnlockRepoForOrg(
    p: {
      org: string
      migrationId: number
      repoName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsListReposForOrg(
    p: {
      org: string
      migrationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/orgs/${p["org"]}/migrations/${p["migrationId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListOrgRoles(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      roles?: t_organization_role[] | undefined
      total_count?: number | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/organization-roles`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRevokeAllOrgRolesTeam(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/organization-roles/teams/${p["teamSlug"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsAssignTeamToOrgRole(
    p: {
      org: string
      teamSlug: string
      roleId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/organization-roles/teams/${p["teamSlug"]}/${p["roleId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRevokeOrgRoleTeam(
    p: {
      org: string
      teamSlug: string
      roleId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/organization-roles/teams/${p["teamSlug"]}/${p["roleId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRevokeAllOrgRolesUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/organization-roles/users/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsAssignUserToOrgRole(
    p: {
      org: string
      username: string
      roleId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/organization-roles/users/${p["username"]}/${p["roleId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRevokeOrgRoleUser(
    p: {
      org: string
      username: string
      roleId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/organization-roles/users/${p["username"]}/${p["roleId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetOrgRole(
    p: {
      org: string
      roleId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_role>> {
    const url = `/orgs/${p["org"]}/organization-roles/${p["roleId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListOrgRoleTeams(
    p: {
      org: string
      roleId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_role_assignment[]>> {
    const url = `/orgs/${p["org"]}/organization-roles/${p["roleId"]}/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListOrgRoleUsers(
    p: {
      org: string
      roleId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_user_role_assignment[]>> {
    const url = `/orgs/${p["org"]}/organization-roles/${p["roleId"]}/users`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListOutsideCollaborators(
    p: {
      org: string
      filter?: "2fa_disabled" | "2fa_insecure" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/orgs/${p["org"]}/outside_collaborators`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsConvertMemberToOutsideCollaborator(
    p: {
      org: string
      username: string
      requestBody?: {
        async?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<EmptyObject> | AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRemoveOutsideCollaborator(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesListPackagesForOrganization(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      org: string
      visibility?: "public" | "private" | "internal" | UnknownEnumStringValue
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package[]>> {
    const url = `/orgs/${p["org"]}/packages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      package_type: p["packageType"],
      visibility: p["visibility"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetPackageForOrganization(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package>> {
    const url = `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesDeletePackageForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesRestorePackageForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      org: string
      token?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/restore`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({token: p["token"]})

    return this._request({
      url: url + query,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetAllPackageVersionsForPackageOwnedByOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      org: string
      page?: number
      perPage?: number
      state?: "active" | "deleted" | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package_version[]>> {
    const url = `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      page: p["page"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetPackageVersionForOrganization(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      org: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package_version>> {
    const url = `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesDeletePackageVersionForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      org: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesRestorePackageVersionForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      org: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListPatGrantRequests(
    p: {
      org: string
      perPage?: number
      page?: number
      sort?: "created_at" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      owner?: string[]
      repository?: string
      permission?: string
      lastUsedBefore?: string
      lastUsedAfter?: string
      tokenId?: string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<t_organization_programmatic_access_grant_request[]>
  > {
    const url = `/orgs/${p["org"]}/personal-access-token-requests`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      sort: p["sort"],
      direction: p["direction"],
      owner: p["owner"],
      repository: p["repository"],
      permission: p["permission"],
      last_used_before: p["lastUsedBefore"],
      last_used_after: p["lastUsedAfter"],
      token_id: p["tokenId"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsReviewPatGrantRequestsInBulk(
    p: {
      org: string
      requestBody: {
        action: "approve" | "deny" | UnknownEnumStringValue
        pat_request_ids?: number[] | undefined
        reason?: (string | null) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/personal-access-token-requests`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsReviewPatGrantRequest(
    p: {
      org: string
      patRequestId: number
      requestBody: {
        action: "approve" | "deny" | UnknownEnumStringValue
        reason?: (string | null) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/personal-access-token-requests/${p["patRequestId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListPatGrantRequestRepositories(
    p: {
      org: string
      patRequestId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/orgs/${p["org"]}/personal-access-token-requests/${p["patRequestId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListPatGrants(
    p: {
      org: string
      perPage?: number
      page?: number
      sort?: "created_at" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      owner?: string[]
      repository?: string
      permission?: string
      lastUsedBefore?: string
      lastUsedAfter?: string
      tokenId?: string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_programmatic_access_grant[]>> {
    const url = `/orgs/${p["org"]}/personal-access-tokens`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      sort: p["sort"],
      direction: p["direction"],
      owner: p["owner"],
      repository: p["repository"],
      permission: p["permission"],
      last_used_before: p["lastUsedBefore"],
      last_used_after: p["lastUsedAfter"],
      token_id: p["tokenId"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUpdatePatAccesses(
    p: {
      org: string
      requestBody: {
        action: "revoke" | UnknownEnumStringValue
        pat_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/orgs/${p["org"]}/personal-access-tokens`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUpdatePatAccess(
    p: {
      org: string
      patId: number
      requestBody: {
        action: "revoke" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/personal-access-tokens/${p["patId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListPatGrantRepositories(
    p: {
      org: string
      patId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/orgs/${p["org"]}/personal-access-tokens/${p["patId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async privateRegistriesListOrgPrivateRegistries(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      configurations: t_org_private_registry_configuration[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/private-registries`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async privateRegistriesCreateOrgPrivateRegistry(
    p: {
      org: string
      requestBody: {
        encrypted_value: string
        key_id: string
        registry_type:
          | "maven_repository"
          | "nuget_feed"
          | "goproxy_server"
          | "npm_registry"
          | "rubygems_server"
          | "cargo_registry"
          | "composer_repository"
          | "docker_registry"
          | "git_source"
          | "helm_registry"
          | "hex_organization"
          | "hex_repository"
          | "pub_repository"
          | "python_index"
          | "terraform_registry"
          | UnknownEnumStringValue
        selected_repository_ids?: number[] | undefined
        url: string
        username?: (string | null) | undefined
        visibility: "all" | "private" | "selected" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<t_org_private_registry_configuration_with_selected_repositories>
  > {
    const url = `/orgs/${p["org"]}/private-registries`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async privateRegistriesGetOrgPublicKey(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      key: string
      key_id: string
    }>
  > {
    const url = `/orgs/${p["org"]}/private-registries/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async privateRegistriesGetOrgPrivateRegistry(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_private_registry_configuration>> {
    const url = `/orgs/${p["org"]}/private-registries/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async privateRegistriesUpdateOrgPrivateRegistry(
    p: {
      org: string
      secretName: string
      requestBody: {
        encrypted_value?: string | undefined
        key_id?: string | undefined
        registry_type?:
          | (
              | "maven_repository"
              | "nuget_feed"
              | "goproxy_server"
              | "npm_registry"
              | "rubygems_server"
              | "cargo_registry"
              | "composer_repository"
              | "docker_registry"
              | "git_source"
              | "helm_registry"
              | "hex_organization"
              | "hex_repository"
              | "pub_repository"
              | "python_index"
              | "terraform_registry"
              | UnknownEnumStringValue
            )
          | undefined
        selected_repository_ids?: number[] | undefined
        url?: string | undefined
        username?: (string | null) | undefined
        visibility?:
          | ("all" | "private" | "selected" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/private-registries/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async privateRegistriesDeleteOrgPrivateRegistry(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/private-registries/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicListForOrg(
    p: {
      org: string
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project[]>> {
    const url = `/orgs/${p["org"]}/projects`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicCreateForOrg(
    p: {
      org: string
      requestBody: {
        body?: string | undefined
        name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project>> {
    const url = `/orgs/${p["org"]}/projects`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetAllCustomProperties(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_custom_property[]>> {
    const url = `/orgs/${p["org"]}/properties/schema`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCreateOrUpdateCustomProperties(
    p: {
      org: string
      requestBody: {
        properties: t_custom_property[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_custom_property[]>> {
    const url = `/orgs/${p["org"]}/properties/schema`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetCustomProperty(
    p: {
      org: string
      customPropertyName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_custom_property>> {
    const url = `/orgs/${p["org"]}/properties/schema/${p["customPropertyName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCreateOrUpdateCustomProperty(
    p: {
      org: string
      customPropertyName: string
      requestBody: t_custom_property_set_payload
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_custom_property>> {
    const url = `/orgs/${p["org"]}/properties/schema/${p["customPropertyName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRemoveCustomProperty(
    p: {
      org: string
      customPropertyName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/properties/schema/${p["customPropertyName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListCustomPropertiesValuesForRepos(
    p: {
      org: string
      perPage?: number
      page?: number
      repositoryQuery?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_repo_custom_property_values[]>> {
    const url = `/orgs/${p["org"]}/properties/values`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      repository_query: p["repositoryQuery"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCreateOrUpdateCustomPropertiesValuesForRepos(
    p: {
      org: string
      requestBody: {
        properties: t_custom_property_value[]
        repository_names: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/properties/values`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListPublicMembers(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/orgs/${p["org"]}/public_members`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsCheckPublicMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/public_members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsSetPublicMembershipForAuthenticatedUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/public_members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRemovePublicMembershipForAuthenticatedUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/public_members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListForOrg(
    p: {
      org: string
      type?:
        | "all"
        | "public"
        | "private"
        | "forks"
        | "sources"
        | "member"
        | UnknownEnumStringValue
      sort?:
        | "created"
        | "updated"
        | "pushed"
        | "full_name"
        | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/orgs/${p["org"]}/repos`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      type: p["type"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateInOrg(
    p: {
      org: string
      requestBody: {
        allow_auto_merge?: boolean | undefined
        allow_merge_commit?: boolean | undefined
        allow_rebase_merge?: boolean | undefined
        allow_squash_merge?: boolean | undefined
        auto_init?: boolean | undefined
        custom_properties?:
          | {
              [key: string]: unknown | undefined
            }
          | undefined
        delete_branch_on_merge?: boolean | undefined
        description?: string | undefined
        gitignore_template?: string | undefined
        has_downloads?: boolean | undefined
        has_issues?: boolean | undefined
        has_projects?: boolean | undefined
        has_wiki?: boolean | undefined
        homepage?: string | undefined
        is_template?: boolean | undefined
        license_template?: string | undefined
        merge_commit_message?:
          | ("PR_BODY" | "PR_TITLE" | "BLANK" | UnknownEnumStringValue)
          | undefined
        merge_commit_title?:
          | ("PR_TITLE" | "MERGE_MESSAGE" | UnknownEnumStringValue)
          | undefined
        name: string
        private?: boolean | undefined
        squash_merge_commit_message?:
          | ("PR_BODY" | "COMMIT_MESSAGES" | "BLANK" | UnknownEnumStringValue)
          | undefined
        squash_merge_commit_title?:
          | ("PR_TITLE" | "COMMIT_OR_PR_TITLE" | UnknownEnumStringValue)
          | undefined
        team_id?: number | undefined
        use_squash_pr_title_as_default?: boolean | undefined
        visibility?: ("public" | "private" | UnknownEnumStringValue) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_full_repository>> {
    const url = `/orgs/${p["org"]}/repos`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetOrgRulesets(
    p: {
      org: string
      perPage?: number
      page?: number
      targets?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset[]>> {
    const url = `/orgs/${p["org"]}/rulesets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      targets: p["targets"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateOrgRuleset(
    p: {
      org: string
      requestBody: {
        bypass_actors?: t_repository_ruleset_bypass_actor[] | undefined
        conditions?: t_org_ruleset_conditions | undefined
        enforcement: t_repository_rule_enforcement
        name: string
        rules?: t_org_rules[] | undefined
        target?:
          | ("branch" | "tag" | "push" | "repository" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset>> {
    const url = `/orgs/${p["org"]}/rulesets`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetOrgRuleSuites(
    p: {
      org: string
      ref?: string
      repositoryName?: string
      timePeriod?: "hour" | "day" | "week" | "month" | UnknownEnumStringValue
      actorName?: string
      ruleSuiteResult?:
        | "pass"
        | "fail"
        | "bypass"
        | "all"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_rule_suites>> {
    const url = `/orgs/${p["org"]}/rulesets/rule-suites`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ref: p["ref"],
      repository_name: p["repositoryName"],
      time_period: p["timePeriod"],
      actor_name: p["actorName"],
      rule_suite_result: p["ruleSuiteResult"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetOrgRuleSuite(
    p: {
      org: string
      ruleSuiteId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_rule_suite>> {
    const url = `/orgs/${p["org"]}/rulesets/rule-suites/${p["ruleSuiteId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetOrgRuleset(
    p: {
      org: string
      rulesetId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset>> {
    const url = `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateOrgRuleset(
    p: {
      org: string
      rulesetId: number
      requestBody?: {
        bypass_actors?: t_repository_ruleset_bypass_actor[] | undefined
        conditions?: t_org_ruleset_conditions | undefined
        enforcement?: t_repository_rule_enforcement | undefined
        name?: string | undefined
        rules?: t_org_rules[] | undefined
        target?:
          | ("branch" | "tag" | "push" | "repository" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset>> {
    const url = `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteOrgRuleset(
    p: {
      org: string
      rulesetId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetOrgRulesetHistory(
    p: {
      org: string
      perPage?: number
      page?: number
      rulesetId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ruleset_version[]>> {
    const url = `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}/history`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetOrgRulesetVersion(
    p: {
      org: string
      rulesetId: number
      versionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ruleset_version_with_state>> {
    const url = `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}/history/${p["versionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningListAlertsForOrg(
    p: {
      org: string
      state?: "open" | "resolved" | UnknownEnumStringValue
      secretType?: string
      resolution?: string
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      page?: number
      perPage?: number
      before?: string
      after?: string
      validity?: string
      isPubliclyLeaked?: boolean
      isMultiRepo?: boolean
      hideSecret?: boolean
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_secret_scanning_alert[]>> {
    const url = `/orgs/${p["org"]}/secret-scanning/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      secret_type: p["secretType"],
      resolution: p["resolution"],
      sort: p["sort"],
      direction: p["direction"],
      page: p["page"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      validity: p["validity"],
      is_publicly_leaked: p["isPubliclyLeaked"],
      is_multi_repo: p["isMultiRepo"],
      hide_secret: p["hideSecret"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesListOrgRepositoryAdvisories(
    p: {
      org: string
      direction?: "asc" | "desc" | UnknownEnumStringValue
      sort?: "created" | "updated" | "published" | UnknownEnumStringValue
      before?: string
      after?: string
      perPage?: number
      state?:
        | "triage"
        | "draft"
        | "published"
        | "closed"
        | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_advisory[]>> {
    const url = `/orgs/${p["org"]}/security-advisories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      direction: p["direction"],
      sort: p["sort"],
      before: p["before"],
      after: p["after"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListSecurityManagerTeams(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_simple[]>> {
    const url = `/orgs/${p["org"]}/security-managers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsAddSecurityManagerTeam(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/security-managers/teams/${p["teamSlug"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsRemoveSecurityManagerTeam(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/security-managers/teams/${p["teamSlug"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetGithubActionsBillingOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_billing_usage>> {
    const url = `/orgs/${p["org"]}/settings/billing/actions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetGithubPackagesBillingOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_packages_billing_usage>> {
    const url = `/orgs/${p["org"]}/settings/billing/packages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetSharedStorageBillingOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_combined_billing_usage>> {
    const url = `/orgs/${p["org"]}/settings/billing/shared-storage`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async hostedComputeListNetworkConfigurationsForOrg(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      network_configurations: t_network_configuration[]
      total_count: number
    }>
  > {
    const url = `/orgs/${p["org"]}/settings/network-configurations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async hostedComputeCreateNetworkConfigurationForOrg(
    p: {
      org: string
      requestBody: {
        compute_service?:
          | ("none" | "actions" | UnknownEnumStringValue)
          | undefined
        name: string
        network_settings_ids: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_network_configuration>> {
    const url = `/orgs/${p["org"]}/settings/network-configurations`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async hostedComputeGetNetworkConfigurationForOrg(
    p: {
      org: string
      networkConfigurationId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_network_configuration>> {
    const url = `/orgs/${p["org"]}/settings/network-configurations/${p["networkConfigurationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async hostedComputeUpdateNetworkConfigurationForOrg(
    p: {
      org: string
      networkConfigurationId: string
      requestBody: {
        compute_service?:
          | ("none" | "actions" | UnknownEnumStringValue)
          | undefined
        name?: string | undefined
        network_settings_ids?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_network_configuration>> {
    const url = `/orgs/${p["org"]}/settings/network-configurations/${p["networkConfigurationId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async hostedComputeDeleteNetworkConfigurationFromOrg(
    p: {
      org: string
      networkConfigurationId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/settings/network-configurations/${p["networkConfigurationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async hostedComputeGetNetworkSettingsForOrg(
    p: {
      org: string
      networkSettingsId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_network_settings>> {
    const url = `/orgs/${p["org"]}/settings/network-settings/${p["networkSettingsId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async copilotCopilotMetricsForTeam(
    p: {
      org: string
      teamSlug: string
      since?: string
      until?: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_copilot_usage_metrics_day[]>> {
    const url = `/orgs/${p["org"]}/team/${p["teamSlug"]}/copilot/metrics`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      since: p["since"],
      until: p["until"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsList(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/orgs/${p["org"]}/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCreate(
    p: {
      org: string
      requestBody: {
        description?: string | undefined
        maintainers?: string[] | undefined
        name: string
        notification_setting?:
          | (
              | "notifications_enabled"
              | "notifications_disabled"
              | UnknownEnumStringValue
            )
          | undefined
        parent_team_id?: number | undefined
        permission?: ("pull" | "push" | UnknownEnumStringValue) | undefined
        privacy?: ("secret" | "closed" | UnknownEnumStringValue) | undefined
        repo_names?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_full>> {
    const url = `/orgs/${p["org"]}/teams`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetByName(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_full>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsUpdateInOrg(
    p: {
      org: string
      teamSlug: string
      requestBody?: {
        description?: string | undefined
        name?: string | undefined
        notification_setting?:
          | (
              | "notifications_enabled"
              | "notifications_disabled"
              | UnknownEnumStringValue
            )
          | undefined
        parent_team_id?: (number | null) | undefined
        permission?:
          | ("pull" | "push" | "admin" | UnknownEnumStringValue)
          | undefined
        privacy?: ("secret" | "closed" | UnknownEnumStringValue) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_full>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsDeleteInOrg(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListDiscussionsInOrg(
    p: {
      org: string
      teamSlug: string
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
      pinned?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
      pinned: p["pinned"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCreateDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      requestBody: {
        body: string
        private?: boolean | undefined
        title: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsUpdateDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      requestBody?: {
        body?: string | undefined
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsDeleteDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListDiscussionCommentsInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCreateDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsUpdateDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsDeleteDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForTeamDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForTeamDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsDeleteForTeamDiscussionComment(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      reactionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions/${p["reactionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForTeamDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForTeamDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsDeleteForTeamDiscussion(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      reactionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions/${p["reactionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListPendingInvitationsInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_invitation[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/invitations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListMembersInOrg(
    p: {
      org: string
      teamSlug: string
      role?: "member" | "maintainer" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/members`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      role: p["role"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetMembershipForUserInOrg(
    p: {
      org: string
      teamSlug: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_membership>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsAddOrUpdateMembershipForUserInOrg(
    p: {
      org: string
      teamSlug: string
      username: string
      requestBody?: {
        role?: ("member" | "maintainer" | UnknownEnumStringValue) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_membership>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsRemoveMembershipForUserInOrg(
    p: {
      org: string
      teamSlug: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListProjectsInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_project[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCheckPermissionsForProjectInOrg(
    p: {
      org: string
      teamSlug: string
      projectId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_project>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsAddOrUpdateProjectPermissionsInOrg(
    p: {
      org: string
      teamSlug: string
      projectId: number
      requestBody?: {
        permission?:
          | ("read" | "write" | "admin" | UnknownEnumStringValue)
          | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsRemoveProjectInOrg(
    p: {
      org: string
      teamSlug: string
      projectId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListReposInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCheckPermissionsForRepoInOrg(
    p: {
      org: string
      teamSlug: string
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_repository> | AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsAddOrUpdateRepoPermissionsInOrg(
    p: {
      org: string
      teamSlug: string
      owner: string
      repo: string
      requestBody?: {
        permission?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsRemoveRepoInOrg(
    p: {
      org: string
      teamSlug: string
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListChildInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/orgs/${p["org"]}/teams/${p["teamSlug"]}/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsEnableOrDisableSecurityProductOnAllOrgRepos(
    p: {
      org: string
      securityProduct:
        | "dependency_graph"
        | "dependabot_alerts"
        | "dependabot_security_updates"
        | "advanced_security"
        | "code_scanning_default_setup"
        | "secret_scanning"
        | "secret_scanning_push_protection"
        | UnknownEnumStringValue
      enablement: "enable_all" | "disable_all" | UnknownEnumStringValue
      requestBody?: {
        query_suite?:
          | ("default" | "extended" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/orgs/${p["org"]}/${p["securityProduct"]}/${p["enablement"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicGetCard(
    p: {
      cardId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_card>> {
    const url = `/projects/columns/cards/${p["cardId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicUpdateCard(
    p: {
      cardId: number
      requestBody?: {
        archived?: boolean | undefined
        note?: (string | null) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_card>> {
    const url = `/projects/columns/cards/${p["cardId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicDeleteCard(
    p: {
      cardId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/projects/columns/cards/${p["cardId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicMoveCard(
    p: {
      cardId: number
      requestBody: {
        column_id?: number | undefined
        position: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<EmptyObject>> {
    const url = `/projects/columns/cards/${p["cardId"]}/moves`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicGetColumn(
    p: {
      columnId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_column>> {
    const url = `/projects/columns/${p["columnId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicUpdateColumn(
    p: {
      columnId: number
      requestBody: {
        name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_column>> {
    const url = `/projects/columns/${p["columnId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicDeleteColumn(
    p: {
      columnId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/projects/columns/${p["columnId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicListCards(
    p: {
      columnId: number
      archivedState?:
        | "all"
        | "archived"
        | "not_archived"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_card[]>> {
    const url = `/projects/columns/${p["columnId"]}/cards`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      archived_state: p["archivedState"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicCreateCard(
    p: {
      columnId: number
      requestBody:
        | {
            note: string | null
          }
        | {
            content_id: number
            content_type: string
          }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_card>> {
    const url = `/projects/columns/${p["columnId"]}/cards`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicMoveColumn(
    p: {
      columnId: number
      requestBody: {
        position: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<EmptyObject>> {
    const url = `/projects/columns/${p["columnId"]}/moves`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicGet(
    p: {
      projectId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project>> {
    const url = `/projects/${p["projectId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicUpdate(
    p: {
      projectId: number
      requestBody?: {
        body?: (string | null) | undefined
        name?: string | undefined
        organization_permission?:
          | ("read" | "write" | "admin" | "none" | UnknownEnumStringValue)
          | undefined
        private?: boolean | undefined
        state?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project>> {
    const url = `/projects/${p["projectId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicDelete(
    p: {
      projectId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/projects/${p["projectId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicListCollaborators(
    p: {
      projectId: number
      affiliation?: "outside" | "direct" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/projects/${p["projectId"]}/collaborators`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      affiliation: p["affiliation"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicAddCollaborator(
    p: {
      projectId: number
      username: string
      requestBody?: {
        permission?:
          | ("read" | "write" | "admin" | UnknownEnumStringValue)
          | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/projects/${p["projectId"]}/collaborators/${p["username"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicRemoveCollaborator(
    p: {
      projectId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/projects/${p["projectId"]}/collaborators/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicGetPermissionForUser(
    p: {
      projectId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_collaborator_permission>> {
    const url = `/projects/${p["projectId"]}/collaborators/${p["username"]}/permission`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicListColumns(
    p: {
      projectId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_column[]>> {
    const url = `/projects/${p["projectId"]}/columns`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicCreateColumn(
    p: {
      projectId: number
      requestBody: {
        name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project_column>> {
    const url = `/projects/${p["projectId"]}/columns`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async rateLimitGet(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_rate_limit_overview>> {
    const url = `/rate_limit`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGet(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_full_repository>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdate(
    p: {
      owner: string
      repo: string
      requestBody?: {
        allow_auto_merge?: boolean | undefined
        allow_forking?: boolean | undefined
        allow_merge_commit?: boolean | undefined
        allow_rebase_merge?: boolean | undefined
        allow_squash_merge?: boolean | undefined
        allow_update_branch?: boolean | undefined
        archived?: boolean | undefined
        default_branch?: string | undefined
        delete_branch_on_merge?: boolean | undefined
        description?: string | undefined
        has_issues?: boolean | undefined
        has_projects?: boolean | undefined
        has_wiki?: boolean | undefined
        homepage?: string | undefined
        is_template?: boolean | undefined
        merge_commit_message?:
          | ("PR_BODY" | "PR_TITLE" | "BLANK" | UnknownEnumStringValue)
          | undefined
        merge_commit_title?:
          | ("PR_TITLE" | "MERGE_MESSAGE" | UnknownEnumStringValue)
          | undefined
        name?: string | undefined
        private?: boolean | undefined
        security_and_analysis?:
          | ({
              advanced_security?:
                | {
                    status?: string | undefined
                  }
                | undefined
              code_security?:
                | {
                    status?: string | undefined
                  }
                | undefined
              secret_scanning?:
                | {
                    status?: string | undefined
                  }
                | undefined
              secret_scanning_ai_detection?:
                | {
                    status?: string | undefined
                  }
                | undefined
              secret_scanning_non_provider_patterns?:
                | {
                    status?: string | undefined
                  }
                | undefined
              secret_scanning_push_protection?:
                | {
                    status?: string | undefined
                  }
                | undefined
            } | null)
          | undefined
        squash_merge_commit_message?:
          | ("PR_BODY" | "COMMIT_MESSAGES" | "BLANK" | UnknownEnumStringValue)
          | undefined
        squash_merge_commit_title?:
          | ("PR_TITLE" | "COMMIT_OR_PR_TITLE" | UnknownEnumStringValue)
          | undefined
        use_squash_pr_title_as_default?: boolean | undefined
        visibility?: ("public" | "private" | UnknownEnumStringValue) | undefined
        web_commit_signoff_required?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_full_repository>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDelete(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListArtifactsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
      name?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      artifacts: t_artifact[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      name: p["name"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetArtifact(
    p: {
      owner: string
      repo: string
      artifactId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_artifact>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteArtifact(
    p: {
      owner: string
      repo: string
      artifactId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDownloadArtifact(
    p: {
      owner: string
      repo: string
      artifactId: number
      archiveFormat: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}/${p["archiveFormat"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetActionsCacheUsage(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_cache_usage_by_repository>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/cache/usage`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetActionsCacheList(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
      ref?: string
      key?: string
      sort?:
        | "created_at"
        | "last_accessed_at"
        | "size_in_bytes"
        | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_cache_list>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/caches`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      ref: p["ref"],
      key: p["key"],
      sort: p["sort"],
      direction: p["direction"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteActionsCacheByKey(
    p: {
      owner: string
      repo: string
      key: string
      ref?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_cache_list>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/caches`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({key: p["key"], ref: p["ref"]})

    return this._request({
      url: url + query,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteActionsCacheById(
    p: {
      owner: string
      repo: string
      cacheId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/caches/${p["cacheId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetJobForWorkflowRun(
    p: {
      owner: string
      repo: string
      jobId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_job>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDownloadJobLogsForWorkflowRun(
    p: {
      owner: string
      repo: string
      jobId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}/logs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsReRunJobForWorkflowRun(
    p: {
      owner: string
      repo: string
      jobId: number
      requestBody?: {
        enable_debug_logging?: boolean | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}/rerun`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetCustomOidcSubClaimForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_oidc_custom_sub_repo>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/oidc/customization/sub`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetCustomOidcSubClaimForRepo(
    p: {
      owner: string
      repo: string
      requestBody: {
        include_claim_keys?: string[] | undefined
        use_default: boolean
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/oidc/customization/sub`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRepoOrganizationSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_actions_secret[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/organization-secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRepoOrganizationVariables(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      total_count: number
      variables: t_actions_variable[]
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/organization-variables`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetGithubActionsPermissionsRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_repository_permissions>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetGithubActionsPermissionsRepository(
    p: {
      owner: string
      repo: string
      requestBody: {
        allowed_actions?: t_allowed_actions | undefined
        enabled: t_actions_enabled
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetWorkflowAccessToRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_workflow_access_to_repository>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/access`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetWorkflowAccessToRepository(
    p: {
      owner: string
      repo: string
      requestBody: t_actions_workflow_access_to_repository
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/access`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetAllowedActionsRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_selected_actions>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/selected-actions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetAllowedActionsRepository(
    p: {
      owner: string
      repo: string
      requestBody?: t_selected_actions
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/selected-actions`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_get_default_workflow_permissions>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/workflow`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
    p: {
      owner: string
      repo: string
      requestBody: t_actions_set_default_workflow_permissions
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/workflow`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListSelfHostedRunnersForRepo(
    p: {
      name?: string
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      runners: t_runner[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      name: p["name"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRunnerApplicationsForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_runner_application[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/downloads`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGenerateRunnerJitconfigForRepo(
    p: {
      owner: string
      repo: string
      requestBody: {
        labels: string[]
        name: string
        runner_group_id: number
        work_folder?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      encoded_jit_config: string
      runner: t_runner
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/generate-jitconfig`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateRegistrationTokenForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_authentication_token>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/registration-token`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateRemoveTokenForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_authentication_token>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/remove-token`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_runner>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteSelfHostedRunnerFromRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListLabelsForSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsAddCustomLabelsToSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
      requestBody: {
        labels: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsSetCustomLabelsForSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
      requestBody: {
        labels: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      labels: t_runner_label[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListWorkflowRunsForRepo(
    p: {
      owner: string
      repo: string
      actor?: string
      branch?: string
      event?: string
      status?:
        | "completed"
        | "action_required"
        | "cancelled"
        | "failure"
        | "neutral"
        | "skipped"
        | "stale"
        | "success"
        | "timed_out"
        | "in_progress"
        | "queued"
        | "requested"
        | "waiting"
        | "pending"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
      created?: string
      excludePullRequests?: boolean
      checkSuiteId?: number
      headSha?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      total_count: number
      workflow_runs: t_workflow_run[]
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      actor: p["actor"],
      branch: p["branch"],
      event: p["event"],
      status: p["status"],
      per_page: p["perPage"],
      page: p["page"],
      created: p["created"],
      exclude_pull_requests: p["excludePullRequests"],
      check_suite_id: p["checkSuiteId"],
      head_sha: p["headSha"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
      excludePullRequests?: boolean
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_workflow_run>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({exclude_pull_requests: p["excludePullRequests"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetReviewsForRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_environment_approvals[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/approvals`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsApproveWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/approve`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListWorkflowRunArtifacts(
    p: {
      owner: string
      repo: string
      runId: number
      perPage?: number
      page?: number
      name?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      artifacts: t_artifact[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/artifacts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      name: p["name"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetWorkflowRunAttempt(
    p: {
      owner: string
      repo: string
      runId: number
      attemptNumber: number
      excludePullRequests?: boolean
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_workflow_run>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/attempts/${p["attemptNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({exclude_pull_requests: p["excludePullRequests"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListJobsForWorkflowRunAttempt(
    p: {
      owner: string
      repo: string
      runId: number
      attemptNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      jobs: t_job[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/attempts/${p["attemptNumber"]}/jobs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDownloadWorkflowRunAttemptLogs(
    p: {
      owner: string
      repo: string
      runId: number
      attemptNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/attempts/${p["attemptNumber"]}/logs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCancelWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsReviewCustomGatesForRun(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody:
        | t_review_custom_gates_comment_required
        | t_review_custom_gates_state_required
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/deployment_protection_rule`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsForceCancelWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/force-cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListJobsForWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
      filter?: "latest" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      jobs: t_job[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/jobs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDownloadWorkflowRunLogs(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteWorkflowRunLogs(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetPendingDeploymentsForRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pending_deployment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/pending_deployments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsReviewPendingDeploymentsForRun(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody: {
        comment: string
        environment_ids: number[]
        state: "approved" | "rejected" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/pending_deployments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsReRunWorkflow(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody?: {
        enable_debug_logging?: boolean | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/rerun`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsReRunWorkflowFailedJobs(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody?: {
        enable_debug_logging?: boolean | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/rerun-failed-jobs`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetWorkflowRunUsage(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_workflow_run_usage>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/timing`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRepoSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_actions_secret[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetRepoPublicKey(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_public_key>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_secret>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateOrUpdateRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
      requestBody: {
        encrypted_value: string
        key_id: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRepoVariables(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      total_count: number
      variables: t_actions_variable[]
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/variables`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateRepoVariable(
    p: {
      owner: string
      repo: string
      requestBody: {
        name: string
        value: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/variables`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetRepoVariable(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_variable>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsUpdateRepoVariable(
    p: {
      owner: string
      repo: string
      name: string
      requestBody: {
        name?: string | undefined
        value?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteRepoVariable(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListRepoWorkflows(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      total_count: number
      workflows: t_workflow[]
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/workflows`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetWorkflow(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_workflow>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDisableWorkflow(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/disable`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateWorkflowDispatch(
    p: {
      owner: string
      repo: string
      workflowId: number | string
      requestBody: {
        inputs?:
          | {
              [key: string]: unknown | undefined
            }
          | undefined
        ref: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/dispatches`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsEnableWorkflow(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/enable`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListWorkflowRuns(
    p: {
      owner: string
      repo: string
      workflowId: number | string
      actor?: string
      branch?: string
      event?: string
      status?:
        | "completed"
        | "action_required"
        | "cancelled"
        | "failure"
        | "neutral"
        | "skipped"
        | "stale"
        | "success"
        | "timed_out"
        | "in_progress"
        | "queued"
        | "requested"
        | "waiting"
        | "pending"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
      created?: string
      excludePullRequests?: boolean
      checkSuiteId?: number
      headSha?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      total_count: number
      workflow_runs: t_workflow_run[]
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/runs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      actor: p["actor"],
      branch: p["branch"],
      event: p["event"],
      status: p["status"],
      per_page: p["perPage"],
      page: p["page"],
      created: p["created"],
      exclude_pull_requests: p["excludePullRequests"],
      check_suite_id: p["checkSuiteId"],
      head_sha: p["headSha"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetWorkflowUsage(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_workflow_usage>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/timing`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListActivities(
    p: {
      owner: string
      repo: string
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      before?: string
      after?: string
      ref?: string
      actor?: string
      timePeriod?:
        | "day"
        | "week"
        | "month"
        | "quarter"
        | "year"
        | UnknownEnumStringValue
      activityType?:
        | "push"
        | "force_push"
        | "branch_creation"
        | "branch_deletion"
        | "pr_merge"
        | "merge_queue_merge"
        | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_activity[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/activity`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      ref: p["ref"],
      actor: p["actor"],
      time_period: p["timePeriod"],
      activity_type: p["activityType"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListAssignees(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/assignees`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesCheckUserCanBeAssigned(
    p: {
      owner: string
      repo: string
      assignee: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/assignees/${p["assignee"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateAttestation(
    p: {
      owner: string
      repo: string
      requestBody: {
        bundle: {
          dsseEnvelope?:
            | {
                [key: string]: unknown | undefined
              }
            | undefined
          mediaType?: string | undefined
          verificationMaterial?:
            | {
                [key: string]: unknown | undefined
              }
            | undefined
        }
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      id?: number | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/attestations`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListAttestations(
    p: {
      owner: string
      repo: string
      perPage?: number
      before?: string
      after?: string
      subjectDigest: string
      predicateType?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      attestations?:
        | {
            bundle?:
              | {
                  dsseEnvelope?:
                    | {
                        [key: string]: unknown | undefined
                      }
                    | undefined
                  mediaType?: string | undefined
                  verificationMaterial?:
                    | {
                        [key: string]: unknown | undefined
                      }
                    | undefined
                }
              | undefined
            bundle_url?: string | undefined
            repository_id?: number | undefined
          }[]
        | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/attestations/${p["subjectDigest"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      predicate_type: p["predicateType"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListAutolinks(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_autolink[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/autolinks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateAutolink(
    p: {
      owner: string
      repo: string
      requestBody: {
        is_alphanumeric?: boolean | undefined
        key_prefix: string
        url_template: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_autolink>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/autolinks`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAutolink(
    p: {
      owner: string
      repo: string
      autolinkId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_autolink>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/autolinks/${p["autolinkId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteAutolink(
    p: {
      owner: string
      repo: string
      autolinkId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/autolinks/${p["autolinkId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCheckAutomatedSecurityFixes(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_automated_security_fixes>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposEnableAutomatedSecurityFixes(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDisableAutomatedSecurityFixes(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListBranches(
    p: {
      owner: string
      repo: string
      protected?: boolean
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_short_branch[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      protected: p["protected"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_branch_with_protection>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_branch_protection>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        allow_deletions?: boolean | undefined
        allow_force_pushes?: (boolean | null) | undefined
        allow_fork_syncing?: boolean | undefined
        block_creations?: boolean | undefined
        enforce_admins: boolean | null
        lock_branch?: boolean | undefined
        required_conversation_resolution?: boolean | undefined
        required_linear_history?: boolean | undefined
        required_pull_request_reviews: {
          bypass_pull_request_allowances?:
            | {
                apps?: string[] | undefined
                teams?: string[] | undefined
                users?: string[] | undefined
              }
            | undefined
          dismiss_stale_reviews?: boolean | undefined
          dismissal_restrictions?:
            | {
                apps?: string[] | undefined
                teams?: string[] | undefined
                users?: string[] | undefined
              }
            | undefined
          require_code_owner_reviews?: boolean | undefined
          require_last_push_approval?: boolean | undefined
          required_approving_review_count?: number | undefined
        } | null
        required_status_checks: {
          checks?:
            | {
                app_id?: number | undefined
                context: string
              }[]
            | undefined
          contexts: string[]
          strict: boolean
        } | null
        restrictions: {
          apps?: string[] | undefined
          teams: string[]
          users: string[]
        } | null
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_protected_branch>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAdminBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_protected_branch_admin_enforced>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposSetAdminBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_protected_branch_admin_enforced>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteAdminBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetPullRequestReviewProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_protected_branch_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdatePullRequestReviewProtection(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: {
        bypass_pull_request_allowances?:
          | {
              apps?: string[] | undefined
              teams?: string[] | undefined
              users?: string[] | undefined
            }
          | undefined
        dismiss_stale_reviews?: boolean | undefined
        dismissal_restrictions?:
          | {
              apps?: string[] | undefined
              teams?: string[] | undefined
              users?: string[] | undefined
            }
          | undefined
        require_code_owner_reviews?: boolean | undefined
        require_last_push_approval?: boolean | undefined
        required_approving_review_count?: number | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_protected_branch_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeletePullRequestReviewProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCommitSignatureProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_protected_branch_admin_enforced>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateCommitSignatureProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_protected_branch_admin_enforced>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteCommitSignatureProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetStatusChecksProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_status_check_policy>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateStatusCheckProtection(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: {
        checks?:
          | {
              app_id?: number | undefined
              context: string
            }[]
          | undefined
        contexts?: string[] | undefined
        strict?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_status_check_policy>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRemoveStatusCheckProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAllStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposAddStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?:
        | {
            contexts: string[]
          }
        | string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposSetStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?:
        | {
            contexts: string[]
          }
        | string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRemoveStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody:
        | {
            contexts: string[]
          }
        | string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_branch_restriction_policy>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAppsWithAccessToProtectedBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_integration[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposAddAppAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        apps: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_integration[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposSetAppAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        apps: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_integration[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRemoveAppAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        apps: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_integration[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetTeamsWithAccessToProtectedBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposAddTeamAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?:
        | {
            teams: string[]
          }
        | string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposSetTeamAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?:
        | {
            teams: string[]
          }
        | string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRemoveTeamAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody:
        | {
            teams: string[]
          }
        | string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetUsersWithAccessToProtectedBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposAddUserAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        users: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposSetUserAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        users: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRemoveUserAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        users: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRenameBranch(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: {
        new_name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_branch_with_protection>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/rename`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksCreate(
    p: {
      owner: string
      repo: string
      requestBody:
        | {
            status: EmptyObject
            [key: string]: unknown | undefined
          }
        | {
            status?: EmptyObject | undefined
            [key: string]: unknown | undefined
          }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_run>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-runs`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksGet(
    p: {
      owner: string
      repo: string
      checkRunId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_run>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksUpdate(
    p: {
      owner: string
      repo: string
      checkRunId: number
      requestBody: {
        actions?:
          | {
              description: string
              identifier: string
              label: string
            }[]
          | undefined
        completed_at?: string | undefined
        conclusion?:
          | (
              | "action_required"
              | "cancelled"
              | "failure"
              | "neutral"
              | "success"
              | "skipped"
              | "stale"
              | "timed_out"
              | UnknownEnumStringValue
            )
          | undefined
        details_url?: string | undefined
        external_id?: string | undefined
        name?: string | undefined
        output?:
          | {
              annotations?:
                | {
                    annotation_level:
                      | "notice"
                      | "warning"
                      | "failure"
                      | UnknownEnumStringValue
                    end_column?: number | undefined
                    end_line: number
                    message: string
                    path: string
                    raw_details?: string | undefined
                    start_column?: number | undefined
                    start_line: number
                    title?: string | undefined
                  }[]
                | undefined
              images?:
                | {
                    alt: string
                    caption?: string | undefined
                    image_url: string
                  }[]
                | undefined
              summary: string
              text?: string | undefined
              title?: string | undefined
            }
          | undefined
        started_at?: string | undefined
        status?:
          | (
              | "queued"
              | "in_progress"
              | "completed"
              | "waiting"
              | "requested"
              | "pending"
              | UnknownEnumStringValue
            )
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_run>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksListAnnotations(
    p: {
      owner: string
      repo: string
      checkRunId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_annotation[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}/annotations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksRerequestRun(
    p: {
      owner: string
      repo: string
      checkRunId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}/rerequest`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksCreateSuite(
    p: {
      owner: string
      repo: string
      requestBody: {
        head_sha: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_suite>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-suites`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksSetSuitesPreferences(
    p: {
      owner: string
      repo: string
      requestBody: {
        auto_trigger_checks?:
          | {
              app_id: number
              setting: boolean
            }[]
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_suite_preference>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-suites/preferences`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksGetSuite(
    p: {
      owner: string
      repo: string
      checkSuiteId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_check_suite>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksListForSuite(
    p: {
      owner: string
      repo: string
      checkSuiteId: number
      checkName?: string
      status?: "queued" | "in_progress" | "completed" | UnknownEnumStringValue
      filter?: "latest" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      check_runs: t_check_run[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}/check-runs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      check_name: p["checkName"],
      status: p["status"],
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksRerequestSuite(
    p: {
      owner: string
      repo: string
      checkSuiteId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}/rerequest`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningListAlertsForRepo(
    p: {
      owner: string
      repo: string
      toolName?: t_code_scanning_analysis_tool_name
      toolGuid?: t_code_scanning_analysis_tool_guid
      page?: number
      perPage?: number
      ref?: t_code_scanning_ref
      pr?: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      before?: string
      after?: string
      sort?: "created" | "updated" | UnknownEnumStringValue
      state?: t_code_scanning_alert_state_query
      severity?: t_code_scanning_alert_severity
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_alert_items[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      tool_name: p["toolName"],
      tool_guid: p["toolGuid"],
      page: p["page"],
      per_page: p["perPage"],
      ref: p["ref"],
      pr: p["pr"],
      direction: p["direction"],
      before: p["before"],
      after: p["after"],
      sort: p["sort"],
      state: p["state"],
      severity: p["severity"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_alert>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningUpdateAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      requestBody: {
        create_request?: t_code_scanning_alert_create_request | undefined
        dismissed_comment?: t_code_scanning_alert_dismissed_comment | undefined
        dismissed_reason?: t_code_scanning_alert_dismissed_reason | undefined
        state: t_code_scanning_alert_set_state
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_alert>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetAutofix(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_autofix>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}/autofix`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningCreateAutofix(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_autofix>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}/autofix`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningCommitAutofix(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      requestBody?: t_code_scanning_autofix_commits
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_autofix_commits_response>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}/autofix/commits`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningListAlertInstances(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      page?: number
      perPage?: number
      ref?: t_code_scanning_ref
      pr?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_alert_instance[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}/instances`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      page: p["page"],
      per_page: p["perPage"],
      ref: p["ref"],
      pr: p["pr"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningListRecentAnalyses(
    p: {
      owner: string
      repo: string
      toolName?: t_code_scanning_analysis_tool_name
      toolGuid?: t_code_scanning_analysis_tool_guid
      page?: number
      perPage?: number
      pr?: number
      ref?: t_code_scanning_ref
      sarifId?: t_code_scanning_analysis_sarif_id
      direction?: "asc" | "desc" | UnknownEnumStringValue
      sort?: "created" | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_analysis[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      tool_name: p["toolName"],
      tool_guid: p["toolGuid"],
      page: p["page"],
      per_page: p["perPage"],
      pr: p["pr"],
      ref: p["ref"],
      sarif_id: p["sarifId"],
      direction: p["direction"],
      sort: p["sort"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetAnalysis(
    p: {
      owner: string
      repo: string
      analysisId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses/${p["analysisId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningDeleteAnalysis(
    p: {
      owner: string
      repo: string
      analysisId: number
      confirmDelete?: string | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_analysis_deletion>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses/${p["analysisId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({confirm_delete: p["confirmDelete"]})

    return this._request({
      url: url + query,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningListCodeqlDatabases(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_codeql_database[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/databases`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetCodeqlDatabase(
    p: {
      owner: string
      repo: string
      language: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_codeql_database>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/databases/${p["language"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningDeleteCodeqlDatabase(
    p: {
      owner: string
      repo: string
      language: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/databases/${p["language"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningCreateVariantAnalysis(
    p: {
      owner: string
      repo: string
      requestBody: EmptyObject
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_variant_analysis>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/variant-analyses`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetVariantAnalysis(
    p: {
      owner: string
      repo: string
      codeqlVariantAnalysisId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_variant_analysis>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/variant-analyses/${p["codeqlVariantAnalysisId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetVariantAnalysisRepoTask(
    p: {
      owner: string
      repo: string
      codeqlVariantAnalysisId: number
      repoOwner: string
      repoName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_variant_analysis_repo_task>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/variant-analyses/${p["codeqlVariantAnalysisId"]}/repos/${p["repoOwner"]}/${p["repoName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetDefaultSetup(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_default_setup>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/default-setup`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningUpdateDefaultSetup(
    p: {
      owner: string
      repo: string
      requestBody: t_code_scanning_default_setup_update
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<t_empty_object>
    | AxiosResponse<t_code_scanning_default_setup_update_response>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/default-setup`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningUploadSarif(
    p: {
      owner: string
      repo: string
      requestBody: {
        checkout_uri?: string | undefined
        commit_sha: t_code_scanning_analysis_commit_sha
        ref: t_code_scanning_ref_full
        sarif: t_code_scanning_analysis_sarif_file
        started_at?: string | undefined
        tool_name?: string | undefined
        validate?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_sarifs_receipt>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/sarifs`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeScanningGetSarif(
    p: {
      owner: string
      repo: string
      sarifId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_scanning_sarifs_status>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-scanning/sarifs/${p["sarifId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codeSecurityGetConfigurationForRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<t_code_security_configuration_for_repository>
    | AxiosResponse<void>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/code-security-configuration`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCodeownersErrors(
    p: {
      owner: string
      repo: string
      ref?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codeowners_errors>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codeowners/errors`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({ref: p["ref"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListInRepositoryForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      codespaces: t_codespace[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCreateWithRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      requestBody: {
        client_ip?: string | undefined
        devcontainer_path?: string | undefined
        display_name?: string | undefined
        geo?:
          | (
              | "EuropeWest"
              | "SoutheastAsia"
              | "UsEast"
              | "UsWest"
              | UnknownEnumStringValue
            )
          | undefined
        idle_timeout_minutes?: number | undefined
        location?: string | undefined
        machine?: string | undefined
        multi_repo_permissions_opt_out?: boolean | undefined
        ref?: string | undefined
        retention_period_minutes?: number | undefined
        working_directory?: string | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListDevcontainersInRepositoryForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      devcontainers: {
        display_name?: string | undefined
        name?: string | undefined
        path: string
      }[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/devcontainers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesRepoMachinesForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      location?: string
      clientIp?: string
      ref?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      machines: t_codespace_machine[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/machines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      location: p["location"],
      client_ip: p["clientIp"],
      ref: p["ref"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesPreFlightWithRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      ref?: string
      clientIp?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      billable_owner?: t_simple_user | undefined
      defaults?:
        | {
            devcontainer_path: string | null
            location: string
          }
        | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/new`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({ref: p["ref"], client_ip: p["clientIp"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCheckPermissionsForDevcontainer(
    p: {
      owner: string
      repo: string
      ref: string
      devcontainerPath: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespaces_permissions_check_for_devcontainer>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/permissions_check`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ref: p["ref"],
      devcontainer_path: p["devcontainerPath"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListRepoSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_repo_codespaces_secret[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetRepoPublicKey(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespaces_public_key>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repo_codespaces_secret>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCreateOrUpdateRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
      requestBody: {
        encrypted_value?: string | undefined
        key_id?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesDeleteRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListCollaborators(
    p: {
      owner: string
      repo: string
      affiliation?: "outside" | "direct" | "all" | UnknownEnumStringValue
      permission?:
        | "pull"
        | "triage"
        | "push"
        | "maintain"
        | "admin"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_collaborator[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/collaborators`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      affiliation: p["affiliation"],
      permission: p["permission"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCheckCollaborator(
    p: {
      owner: string
      repo: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposAddCollaborator(
    p: {
      owner: string
      repo: string
      username: string
      requestBody?: {
        permission?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_invitation> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRemoveCollaborator(
    p: {
      owner: string
      repo: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCollaboratorPermissionLevel(
    p: {
      owner: string
      repo: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_collaborator_permission>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}/permission`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListCommitCommentsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit_comment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsDeleteForCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      reactionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions/${p["reactionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListCommits(
    p: {
      owner: string
      repo: string
      sha?: string
      path?: string
      author?: string
      committer?: string
      since?: string
      until?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sha: p["sha"],
      path: p["path"],
      author: p["author"],
      committer: p["committer"],
      since: p["since"],
      until: p["until"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListBranchesForHeadCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_branch_short[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/branches-where-head`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListCommentsForCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit_comment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateCommitComment(
    p: {
      owner: string
      repo: string
      commitSha: string
      requestBody: {
        body: string
        line?: number | undefined
        path?: string | undefined
        position?: number | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/comments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListPullRequestsAssociatedWithCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_simple[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/pulls`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCommit(
    p: {
      owner: string
      repo: string
      page?: number
      perPage?: number
      ref: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksListForRef(
    p: {
      owner: string
      repo: string
      ref: string
      checkName?: string
      status?: "queued" | "in_progress" | "completed" | UnknownEnumStringValue
      filter?: "latest" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
      appId?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      check_runs: t_check_run[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/check-runs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      check_name: p["checkName"],
      status: p["status"],
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
      app_id: p["appId"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async checksListSuitesForRef(
    p: {
      owner: string
      repo: string
      ref: string
      appId?: number
      checkName?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      check_suites: t_check_suite[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/check-suites`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      app_id: p["appId"],
      check_name: p["checkName"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCombinedStatusForRef(
    p: {
      owner: string
      repo: string
      ref: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_combined_commit_status>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/status`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListCommitStatusesForRef(
    p: {
      owner: string
      repo: string
      ref: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_status[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/statuses`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCommunityProfileMetrics(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_community_profile>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/community/profile`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCompareCommits(
    p: {
      owner: string
      repo: string
      page?: number
      perPage?: number
      basehead: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit_comparison>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/compare/${p["basehead"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetContent(
    p: {
      owner: string
      repo: string
      path: string
      ref?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<
      | t_content_directory
      | t_content_file
      | t_content_symlink
      | t_content_submodule
    >
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({ref: p["ref"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateOrUpdateFileContents(
    p: {
      owner: string
      repo: string
      path: string
      requestBody: {
        author?:
          | {
              date?: string | undefined
              email: string
              name: string
            }
          | undefined
        branch?: string | undefined
        committer?:
          | {
              date?: string | undefined
              email: string
              name: string
            }
          | undefined
        content: string
        message: string
        sha?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_file_commit>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteFile(
    p: {
      owner: string
      repo: string
      path: string
      requestBody: {
        author?:
          | {
              email?: string | undefined
              name?: string | undefined
            }
          | undefined
        branch?: string | undefined
        committer?:
          | {
              email?: string | undefined
              name?: string | undefined
            }
          | undefined
        message: string
        sha: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_file_commit>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListContributors(
    p: {
      owner: string
      repo: string
      anon?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_contributor[]> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/contributors`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      anon: p["anon"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotListAlertsForRepo(
    p: {
      owner: string
      repo: string
      state?: string
      severity?: string
      ecosystem?: string
      package?: string
      manifest?: string
      epssPercentage?: string
      has?: string | ("patch" | UnknownEnumStringValue)[]
      scope?: "development" | "runtime" | UnknownEnumStringValue
      sort?: "created" | "updated" | "epss_percentage" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      page?: number
      perPage?: number
      before?: string
      after?: string
      first?: number
      last?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_alert[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      severity: p["severity"],
      ecosystem: p["ecosystem"],
      package: p["package"],
      manifest: p["manifest"],
      epss_percentage: p["epssPercentage"],
      has: p["has"],
      scope: p["scope"],
      sort: p["sort"],
      direction: p["direction"],
      page: p["page"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      first: p["first"],
      last: p["last"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotGetAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_alert>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts/${p["alertNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotUpdateAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      requestBody: {
        dismissed_comment?: string | undefined
        dismissed_reason?:
          | (
              | "fix_started"
              | "inaccurate"
              | "no_bandwidth"
              | "not_used"
              | "tolerable_risk"
              | UnknownEnumStringValue
            )
          | undefined
        state: "dismissed" | "open" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_alert>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts/${p["alertNumber"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotListRepoSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_dependabot_secret[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotGetRepoPublicKey(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_public_key>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotGetRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependabot_secret>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotCreateOrUpdateRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
      requestBody: {
        encrypted_value?: string | undefined
        key_id?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependabotDeleteRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependencyGraphDiffRange(
    p: {
      owner: string
      repo: string
      basehead: string
      name?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependency_graph_diff>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/compare/${p["basehead"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({name: p["name"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependencyGraphExportSbom(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_dependency_graph_spdx_sbom>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/sbom`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async dependencyGraphCreateRepositorySnapshot(
    p: {
      owner: string
      repo: string
      requestBody: t_snapshot
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      created_at: string
      id: number
      message: string
      result: string
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/snapshots`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListDeployments(
    p: {
      owner: string
      repo: string
      sha?: string
      ref?: string
      task?: string
      environment?: string | null
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/deployments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sha: p["sha"],
      ref: p["ref"],
      task: p["task"],
      environment: p["environment"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateDeployment(
    p: {
      owner: string
      repo: string
      requestBody: {
        auto_merge?: boolean | undefined
        description?: (string | null) | undefined
        environment?: string | undefined
        payload?:
          | (
              | {
                  [key: string]: unknown | undefined
                }
              | string
            )
          | undefined
        production_environment?: boolean | undefined
        ref: string
        required_contexts?: string[] | undefined
        task?: string | undefined
        transient_environment?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<t_deployment>
    | AxiosResponse<{
        message?: string | undefined
      }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/deployments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetDeployment(
    p: {
      owner: string
      repo: string
      deploymentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteDeployment(
    p: {
      owner: string
      repo: string
      deploymentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListDeploymentStatuses(
    p: {
      owner: string
      repo: string
      deploymentId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_status[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateDeploymentStatus(
    p: {
      owner: string
      repo: string
      deploymentId: number
      requestBody: {
        auto_inactive?: boolean | undefined
        description?: string | undefined
        environment?: string | undefined
        environment_url?: string | undefined
        log_url?: string | undefined
        state:
          | "error"
          | "failure"
          | "inactive"
          | "in_progress"
          | "queued"
          | "pending"
          | "success"
          | UnknownEnumStringValue
        target_url?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_status>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetDeploymentStatus(
    p: {
      owner: string
      repo: string
      deploymentId: number
      statusId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_status>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses/${p["statusId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateDispatchEvent(
    p: {
      owner: string
      repo: string
      requestBody: {
        client_payload?:
          | {
              [key: string]: unknown | undefined
            }
          | undefined
        event_type: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/dispatches`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAllEnvironments(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      environments?: t_environment[] | undefined
      total_count?: number | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetEnvironment(
    p: {
      owner: string
      repo: string
      environmentName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_environment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateOrUpdateEnvironment(
    p: {
      owner: string
      repo: string
      environmentName: string
      requestBody?: {
        deployment_branch_policy?:
          | t_deployment_branch_policy_settings
          | undefined
        prevent_self_review?: t_prevent_self_review | undefined
        reviewers?:
          | (
              | {
                  id?: number | undefined
                  type?: t_deployment_reviewer_type | undefined
                }[]
              | null
            )
          | undefined
        wait_timer?: t_wait_timer | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_environment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteAnEnvironment(
    p: {
      owner: string
      repo: string
      environmentName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListDeploymentBranchPolicies(
    p: {
      owner: string
      repo: string
      environmentName: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      branch_policies: t_deployment_branch_policy[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      requestBody: t_deployment_branch_policy_name_pattern_with_type
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_branch_policy>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      branchPolicyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_branch_policy>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      branchPolicyId: number
      requestBody: t_deployment_branch_policy_name_pattern
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_branch_policy>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      branchPolicyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAllDeploymentProtectionRules(
    p: {
      environmentName: string
      repo: string
      owner: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      custom_deployment_protection_rules?:
        | t_deployment_protection_rule[]
        | undefined
      total_count?: number | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateDeploymentProtectionRule(
    p: {
      environmentName: string
      repo: string
      owner: string
      requestBody: {
        integration_id?: number | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_protection_rule>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListCustomDeploymentRuleIntegrations(
    p: {
      environmentName: string
      repo: string
      owner: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      available_custom_deployment_protection_rule_integrations?:
        | t_custom_deployment_rule_app[]
        | undefined
      total_count?: number | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules/apps`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCustomDeploymentProtectionRule(
    p: {
      owner: string
      repo: string
      environmentName: string
      protectionRuleId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deployment_protection_rule>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules/${p["protectionRuleId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDisableDeploymentProtectionRule(
    p: {
      environmentName: string
      repo: string
      owner: string
      protectionRuleId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules/${p["protectionRuleId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListEnvironmentSecrets(
    p: {
      owner: string
      repo: string
      environmentName: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_actions_secret[]
      total_count: number
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetEnvironmentPublicKey(
    p: {
      owner: string
      repo: string
      environmentName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_public_key>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetEnvironmentSecret(
    p: {
      owner: string
      repo: string
      environmentName: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_secret>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateOrUpdateEnvironmentSecret(
    p: {
      owner: string
      repo: string
      environmentName: string
      secretName: string
      requestBody: {
        encrypted_value: string
        key_id: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteEnvironmentSecret(
    p: {
      owner: string
      repo: string
      environmentName: string
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsListEnvironmentVariables(
    p: {
      owner: string
      repo: string
      environmentName: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      total_count: number
      variables: t_actions_variable[]
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsCreateEnvironmentVariable(
    p: {
      owner: string
      repo: string
      environmentName: string
      requestBody: {
        name: string
        value: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsGetEnvironmentVariable(
    p: {
      owner: string
      repo: string
      environmentName: string
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_variable>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsUpdateEnvironmentVariable(
    p: {
      owner: string
      repo: string
      name: string
      environmentName: string
      requestBody: {
        name?: string | undefined
        value?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables/${p["name"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async actionsDeleteEnvironmentVariable(
    p: {
      owner: string
      repo: string
      name: string
      environmentName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListRepoEvents(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListForks(
    p: {
      owner: string
      repo: string
      sort?:
        | "newest"
        | "oldest"
        | "stargazers"
        | "watchers"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/forks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateFork(
    p: {
      owner: string
      repo: string
      requestBody?: {
        default_branch_only?: boolean | undefined
        name?: string | undefined
        organization?: string | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_full_repository>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/forks`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitCreateBlob(
    p: {
      owner: string
      repo: string
      requestBody: {
        content: string
        encoding?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_short_blob>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/blobs`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitGetBlob(
    p: {
      owner: string
      repo: string
      fileSha: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_blob>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/blobs/${p["fileSha"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitCreateCommit(
    p: {
      owner: string
      repo: string
      requestBody: {
        author?:
          | {
              date?: string | undefined
              email: string
              name: string
            }
          | undefined
        committer?:
          | {
              date?: string | undefined
              email?: string | undefined
              name?: string | undefined
            }
          | undefined
        message: string
        parents?: string[] | undefined
        signature?: string | undefined
        tree: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_commit>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/commits`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitGetCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_commit>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/commits/${p["commitSha"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitListMatchingRefs(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_ref[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/matching-refs/${p["ref"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitGetRef(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_ref>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/ref/${p["ref"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitCreateRef(
    p: {
      owner: string
      repo: string
      requestBody: {
        ref: string
        sha: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_ref>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/refs`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitUpdateRef(
    p: {
      owner: string
      repo: string
      ref: string
      requestBody: {
        force?: boolean | undefined
        sha: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_ref>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitDeleteRef(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitCreateTag(
    p: {
      owner: string
      repo: string
      requestBody: {
        message: string
        object: string
        tag: string
        tagger?:
          | {
              date?: string | undefined
              email: string
              name: string
            }
          | undefined
        type: "commit" | "tree" | "blob" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_tag>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/tags`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitGetTag(
    p: {
      owner: string
      repo: string
      tagSha: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_tag>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/tags/${p["tagSha"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitCreateTree(
    p: {
      owner: string
      repo: string
      requestBody: {
        base_tree?: string | undefined
        tree: {
          content?: string | undefined
          mode?:
            | (
                | "100644"
                | "100755"
                | "040000"
                | "160000"
                | "120000"
                | UnknownEnumStringValue
              )
            | undefined
          path?: string | undefined
          sha?: (string | null) | undefined
          type?:
            | ("blob" | "tree" | "commit" | UnknownEnumStringValue)
            | undefined
        }[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_tree>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/trees`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gitGetTree(
    p: {
      owner: string
      repo: string
      treeSha: string
      recursive?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_git_tree>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/git/trees/${p["treeSha"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({recursive: p["recursive"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListWebhooks(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateWebhook(
    p: {
      owner: string
      repo: string
      requestBody?: {
        active?: boolean | undefined
        config?:
          | {
              content_type?: t_webhook_config_content_type | undefined
              insecure_ssl?: t_webhook_config_insecure_ssl | undefined
              secret?: t_webhook_config_secret | undefined
              url?: t_webhook_config_url | undefined
            }
          | undefined
        events?: string[] | undefined
        name?: string | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
      requestBody: {
        active?: boolean | undefined
        add_events?: string[] | undefined
        config?: t_webhook_config | undefined
        events?: string[] | undefined
        remove_events?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetWebhookConfigForRepo(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_webhook_config>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/config`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateWebhookConfigForRepo(
    p: {
      owner: string
      repo: string
      hookId: number
      requestBody?: {
        content_type?: t_webhook_config_content_type | undefined
        insecure_ssl?: t_webhook_config_insecure_ssl | undefined
        secret?: t_webhook_config_secret | undefined
        url?: t_webhook_config_url | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_webhook_config>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/config`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListWebhookDeliveries(
    p: {
      owner: string
      repo: string
      hookId: number
      perPage?: number
      cursor?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook_delivery_item[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], cursor: p["cursor"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetWebhookDelivery(
    p: {
      owner: string
      repo: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hook_delivery>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRedeliverWebhookDelivery(
    p: {
      owner: string
      repo: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}/attempts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposPingWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/pings`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposTestPushWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/tests`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsGetImportStatus(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_import>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsStartImport(
    p: {
      owner: string
      repo: string
      requestBody: {
        tfvc_project?: string | undefined
        vcs?:
          | (
              | "subversion"
              | "git"
              | "mercurial"
              | "tfvc"
              | UnknownEnumStringValue
            )
          | undefined
        vcs_password?: string | undefined
        vcs_url: string
        vcs_username?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_import>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsUpdateImport(
    p: {
      owner: string
      repo: string
      requestBody?: {
        tfvc_project?: string | undefined
        vcs?:
          | (
              | "subversion"
              | "tfvc"
              | "git"
              | "mercurial"
              | UnknownEnumStringValue
            )
          | undefined
        vcs_password?: string | undefined
        vcs_username?: string | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_import>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsCancelImport(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsGetCommitAuthors(
    p: {
      owner: string
      repo: string
      since?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_porter_author[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import/authors`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({since: p["since"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsMapCommitAuthor(
    p: {
      owner: string
      repo: string
      authorId: number
      requestBody?: {
        email?: string | undefined
        name?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_porter_author>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import/authors/${p["authorId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsGetLargeFiles(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_porter_large_file[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import/large_files`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsSetLfsPreference(
    p: {
      owner: string
      repo: string
      requestBody: {
        use_lfs: "opt_in" | "opt_out" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_import>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/import/lfs`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetRepoInstallation(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_installation>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/installation`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsGetRestrictionsForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_interaction_limit_response | EmptyObject>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsSetRestrictionsForRepo(
    p: {
      owner: string
      repo: string
      requestBody: t_interaction_limit
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_interaction_limit_response>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsRemoveRestrictionsForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListInvitations(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_invitation[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/invitations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateInvitation(
    p: {
      owner: string
      repo: string
      invitationId: number
      requestBody?: {
        permissions?:
          | (
              | "read"
              | "write"
              | "maintain"
              | "triage"
              | "admin"
              | UnknownEnumStringValue
            )
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_invitation>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteInvitation(
    p: {
      owner: string
      repo: string
      invitationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListForRepo(
    p: {
      owner: string
      repo: string
      milestone?: string
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      assignee?: string
      type?: string
      creator?: string
      mentioned?: string
      labels?: string
      sort?: "created" | "updated" | "comments" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      milestone: p["milestone"],
      state: p["state"],
      assignee: p["assignee"],
      type: p["type"],
      creator: p["creator"],
      mentioned: p["mentioned"],
      labels: p["labels"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesCreate(
    p: {
      owner: string
      repo: string
      requestBody: {
        assignee?: (string | null) | undefined
        assignees?: string[] | undefined
        body?: string | undefined
        labels?:
          | (
              | string
              | {
                  color?: (string | null) | undefined
                  description?: (string | null) | undefined
                  id?: number | undefined
                  name?: string | undefined
                }
            )[]
          | undefined
        milestone?: (string | number | null) | undefined
        title: string | number
        type?: (string | null) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListCommentsForRepo(
    p: {
      owner: string
      repo: string
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_comment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesGetComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesUpdateComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesDeleteComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForIssueComment(
    p: {
      owner: string
      repo: string
      commentId: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForIssueComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsDeleteForIssueComment(
    p: {
      owner: string
      repo: string
      commentId: number
      reactionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions/${p["reactionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListEventsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_event[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesGetEvent(
    p: {
      owner: string
      repo: string
      eventId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_event>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/events/${p["eventId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesGet(
    p: {
      owner: string
      repo: string
      issueNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesUpdate(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: {
        assignee?: (string | null) | undefined
        assignees?: string[] | undefined
        body?: (string | null) | undefined
        labels?:
          | (
              | string
              | {
                  color?: (string | null) | undefined
                  description?: (string | null) | undefined
                  id?: number | undefined
                  name?: string | undefined
                }
            )[]
          | undefined
        milestone?: (string | number | null) | undefined
        state?: ("open" | "closed" | UnknownEnumStringValue) | undefined
        state_reason?:
          | (
              | "completed"
              | "not_planned"
              | "duplicate"
              | "reopened"
              | UnknownEnumStringValue
              | null
            )
          | undefined
        title?: (string | number | null) | undefined
        type?: (string | null) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesAddAssignees(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: {
        assignees?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesRemoveAssignees(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: {
        assignees?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesCheckUserCanBeAssignedToIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      assignee: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees/${p["assignee"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListComments(
    p: {
      owner: string
      repo: string
      issueNumber: number
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_comment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesCreateComment(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/comments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListEvents(
    p: {
      owner: string
      repo: string
      issueNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue_event_for_issue[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListLabelsOnIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesAddLabels(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?:
        | {
            labels?: string[] | undefined
          }
        | string[]
        | {
            labels?:
              | {
                  name: string
                }[]
              | undefined
          }
        | {
            name: string
          }[]
        | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesSetLabels(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?:
        | {
            labels?: string[] | undefined
          }
        | string[]
        | {
            labels?:
              | {
                  name: string
                }[]
              | undefined
          }
        | {
            name: string
          }[]
        | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesRemoveAllLabels(
    p: {
      owner: string
      repo: string
      issueNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesRemoveLabel(
    p: {
      owner: string
      repo: string
      issueNumber: number
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesLock(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: {
        lock_reason?:
          | (
              | "off-topic"
              | "too heated"
              | "resolved"
              | "spam"
              | UnknownEnumStringValue
            )
          | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesUnlock(
    p: {
      owner: string
      repo: string
      issueNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsDeleteForIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      reactionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions/${p["reactionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesRemoveSubIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: {
        sub_issue_id: number
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/sub_issue`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListSubIssues(
    p: {
      owner: string
      repo: string
      issueNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/sub_issues`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesAddSubIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: {
        replace_parent?: boolean | undefined
        sub_issue_id: number
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/sub_issues`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesReprioritizeSubIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: {
        after_id?: number | undefined
        before_id?: number | undefined
        sub_issue_id: number
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/sub_issues/priority`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListEventsForTimeline(
    p: {
      owner: string
      repo: string
      issueNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_timeline_issue_events[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/timeline`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListDeployKeys(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deploy_key[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateDeployKey(
    p: {
      owner: string
      repo: string
      requestBody: {
        key: string
        read_only?: boolean | undefined
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deploy_key>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/keys`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetDeployKey(
    p: {
      owner: string
      repo: string
      keyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_deploy_key>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteDeployKey(
    p: {
      owner: string
      repo: string
      keyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListLabelsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesCreateLabel(
    p: {
      owner: string
      repo: string
      requestBody: {
        color?: string | undefined
        description?: string | undefined
        name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/labels`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesGetLabel(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesUpdateLabel(
    p: {
      owner: string
      repo: string
      name: string
      requestBody?: {
        color?: string | undefined
        description?: string | undefined
        new_name?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesDeleteLabel(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListLanguages(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_language>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/languages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async licensesGetForRepo(
    p: {
      owner: string
      repo: string
      ref?: t_code_scanning_ref
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_license_content>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/license`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({ref: p["ref"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposMergeUpstream(
    p: {
      owner: string
      repo: string
      requestBody: {
        branch: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_merged_upstream>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/merge-upstream`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposMerge(
    p: {
      owner: string
      repo: string
      requestBody: {
        base: string
        commit_message?: string | undefined
        head: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/merges`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListMilestones(
    p: {
      owner: string
      repo: string
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      sort?: "due_on" | "completeness" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_milestone[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/milestones`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesCreateMilestone(
    p: {
      owner: string
      repo: string
      requestBody: {
        description?: string | undefined
        due_on?: string | undefined
        state?: ("open" | "closed" | UnknownEnumStringValue) | undefined
        title: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_milestone>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/milestones`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesGetMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_milestone>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesUpdateMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
      requestBody?: {
        description?: string | undefined
        due_on?: string | undefined
        state?: ("open" | "closed" | UnknownEnumStringValue) | undefined
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_milestone>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesDeleteMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListLabelsForMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_label[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListRepoNotificationsForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      all?: boolean
      participating?: boolean
      since?: string
      before?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_thread[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/notifications`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      all: p["all"],
      participating: p["participating"],
      since: p["since"],
      before: p["before"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityMarkRepoNotificationsAsRead(
    p: {
      owner: string
      repo: string
      requestBody?: {
        last_read_at?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<{
        message?: string | undefined
        url?: string | undefined
      }>
    | AxiosResponse<void>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/notifications`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetPages(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_page>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreatePagesSite(
    p: {
      owner: string
      repo: string
      requestBody: {
        build_type?:
          | ("legacy" | "workflow" | UnknownEnumStringValue)
          | undefined
        source?:
          | {
              branch: string
              path?: ("/" | "/docs" | UnknownEnumStringValue) | undefined
            }
          | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_page>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateInformationAboutPagesSite(
    p: {
      owner: string
      repo: string
      requestBody: {
        build_type?:
          | ("legacy" | "workflow" | UnknownEnumStringValue)
          | undefined
        cname?: (string | null) | undefined
        https_enforced?: boolean | undefined
        source?:
          | (
              | "gh-pages"
              | "master"
              | "master /docs"
              | UnknownEnumStringValue
              | {
                  branch: string
                  path: "/" | "/docs" | UnknownEnumStringValue
                }
            )
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeletePagesSite(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListPagesBuilds(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_page_build[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/builds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposRequestPagesBuild(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_page_build_status>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/builds`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetLatestPagesBuild(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_page_build>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/builds/latest`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetPagesBuild(
    p: {
      owner: string
      repo: string
      buildId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_page_build>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/builds/${p["buildId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreatePagesDeployment(
    p: {
      owner: string
      repo: string
      requestBody: {
        artifact_id?: number | undefined
        artifact_url?: string | undefined
        environment?: string | undefined
        oidc_token: string
        pages_build_version: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_page_deployment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/deployments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetPagesDeployment(
    p: {
      owner: string
      repo: string
      pagesDeploymentId: number | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pages_deployment_status>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/deployments/${p["pagesDeploymentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCancelPagesDeployment(
    p: {
      owner: string
      repo: string
      pagesDeploymentId: number | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/deployments/${p["pagesDeploymentId"]}/cancel`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetPagesHealthCheck(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<t_pages_health_check> | AxiosResponse<t_empty_object>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pages/health`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCheckPrivateVulnerabilityReporting(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      enabled: boolean
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/private-vulnerability-reporting`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposEnablePrivateVulnerabilityReporting(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/private-vulnerability-reporting`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDisablePrivateVulnerabilityReporting(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/private-vulnerability-reporting`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicListForRepo(
    p: {
      owner: string
      repo: string
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/projects`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicCreateForRepo(
    p: {
      owner: string
      repo: string
      requestBody: {
        body?: string | undefined
        name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/projects`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCustomPropertiesValues(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_custom_property_value[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/properties/values`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateOrUpdateCustomPropertiesValues(
    p: {
      owner: string
      repo: string
      requestBody: {
        properties: t_custom_property_value[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/properties/values`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsList(
    p: {
      owner: string
      repo: string
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      head?: string
      base?: string
      sort?:
        | "created"
        | "updated"
        | "popularity"
        | "long-running"
        | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_simple[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      head: p["head"],
      base: p["base"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsCreate(
    p: {
      owner: string
      repo: string
      requestBody: {
        base: string
        body?: string | undefined
        draft?: boolean | undefined
        head: string
        head_repo?: string | undefined
        issue?: number | undefined
        maintainer_can_modify?: boolean | undefined
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsListReviewCommentsForRepo(
    p: {
      owner: string
      repo: string
      sort?: "created" | "updated" | "created_at" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review_comment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsGetReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsUpdateReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsDeleteReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForPullRequestReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForPullRequestReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsDeleteForPullRequestComment(
    p: {
      owner: string
      repo: string
      commentId: number
      reactionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions/${p["reactionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsGet(
    p: {
      owner: string
      repo: string
      pullNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsUpdate(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: {
        base?: string | undefined
        body?: string | undefined
        maintainer_can_modify?: boolean | undefined
        state?: ("open" | "closed" | UnknownEnumStringValue) | undefined
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCreateWithPrForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody: {
        client_ip?: string | undefined
        devcontainer_path?: string | undefined
        display_name?: string | undefined
        geo?:
          | (
              | "EuropeWest"
              | "SoutheastAsia"
              | "UsEast"
              | "UsWest"
              | UnknownEnumStringValue
            )
          | undefined
        idle_timeout_minutes?: number | undefined
        location?: string | undefined
        machine?: string | undefined
        multi_repo_permissions_opt_out?: boolean | undefined
        retention_period_minutes?: number | undefined
        working_directory?: string | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/codespaces`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsListReviewComments(
    p: {
      owner: string
      repo: string
      pullNumber: number
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review_comment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsCreateReviewComment(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody: {
        body: string
        commit_id: string
        in_reply_to?: number | undefined
        line?: number | undefined
        path: string
        position?: number | undefined
        side?: ("LEFT" | "RIGHT" | UnknownEnumStringValue) | undefined
        start_line?: number | undefined
        start_side?:
          | ("LEFT" | "RIGHT" | "side" | UnknownEnumStringValue)
          | undefined
        subject_type?: ("line" | "file" | UnknownEnumStringValue) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsCreateReplyForReviewComment(
    p: {
      owner: string
      repo: string
      pullNumber: number
      commentId: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review_comment>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments/${p["commentId"]}/replies`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsListCommits(
    p: {
      owner: string
      repo: string
      pullNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_commit[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/commits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsListFiles(
    p: {
      owner: string
      repo: string
      pullNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_diff_entry[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/files`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsCheckIfMerged(
    p: {
      owner: string
      repo: string
      pullNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsMerge(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: {
        commit_message?: string | undefined
        commit_title?: string | undefined
        merge_method?:
          | ("merge" | "squash" | "rebase" | UnknownEnumStringValue)
          | undefined
        sha?: string | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_merge_result>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsListRequestedReviewers(
    p: {
      owner: string
      repo: string
      pullNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review_request>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsRequestReviewers(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: {
        reviewers?: string[] | undefined
        team_reviewers?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_simple>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsRemoveRequestedReviewers(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody: {
        reviewers: string[]
        team_reviewers?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_simple>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsListReviews(
    p: {
      owner: string
      repo: string
      pullNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsCreateReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: {
        body?: string | undefined
        comments?:
          | {
              body: string
              line?: number | undefined
              path: string
              position?: number | undefined
              side?: string | undefined
              start_line?: number | undefined
              start_side?: string | undefined
            }[]
          | undefined
        commit_id?: string | undefined
        event?:
          | ("APPROVE" | "REQUEST_CHANGES" | "COMMENT" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsGetReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsUpdateReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsDeletePendingReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsListCommentsForReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_review_comment[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsDismissReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      requestBody: {
        event?: ("DISMISS" | UnknownEnumStringValue) | undefined
        message: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/dismissals`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsSubmitReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      requestBody: {
        body?: string | undefined
        event:
          | "APPROVE"
          | "REQUEST_CHANGES"
          | "COMMENT"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_pull_request_review>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/events`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async pullsUpdateBranch(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: {
        expected_head_sha?: string | undefined
      } | null
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      message?: string | undefined
      url?: string | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/update-branch`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetReadme(
    p: {
      owner: string
      repo: string
      ref?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_content_file>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/readme`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({ref: p["ref"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetReadmeInDirectory(
    p: {
      owner: string
      repo: string
      dir: string
      ref?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_content_file>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/readme/${p["dir"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({ref: p["ref"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListReleases(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateRelease(
    p: {
      owner: string
      repo: string
      requestBody: {
        body?: string | undefined
        discussion_category_name?: string | undefined
        draft?: boolean | undefined
        generate_release_notes?: boolean | undefined
        make_latest?:
          | ("true" | "false" | "legacy" | UnknownEnumStringValue)
          | undefined
        name?: string | undefined
        prerelease?: boolean | undefined
        tag_name: string
        target_commitish?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetReleaseAsset(
    p: {
      owner: string
      repo: string
      assetId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release_asset>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateReleaseAsset(
    p: {
      owner: string
      repo: string
      assetId: number
      requestBody?: {
        label?: string | undefined
        name?: string | undefined
        state?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release_asset>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteReleaseAsset(
    p: {
      owner: string
      repo: string
      assetId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGenerateReleaseNotes(
    p: {
      owner: string
      repo: string
      requestBody: {
        configuration_file_path?: string | undefined
        previous_tag_name?: string | undefined
        tag_name: string
        target_commitish?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release_notes_content>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/generate-notes`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetLatestRelease(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/latest`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetReleaseByTag(
    p: {
      owner: string
      repo: string
      tag: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/tags/${p["tag"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      requestBody?: {
        body?: string | undefined
        discussion_category_name?: string | undefined
        draft?: boolean | undefined
        make_latest?:
          | ("true" | "false" | "legacy" | UnknownEnumStringValue)
          | undefined
        name?: string | undefined
        prerelease?: boolean | undefined
        tag_name?: string | undefined
        target_commitish?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListReleaseAssets(
    p: {
      owner: string
      repo: string
      releaseId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release_asset[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/assets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUploadReleaseAsset(
    p: {
      owner: string
      repo: string
      releaseId: number
      name: string
      label?: string
      requestBody?: never
    },
    basePath:
      | Server<"reposUploadReleaseAsset_GitHubV3RestApi">
      | string = GitHubV3RestApiServers.operations
      .reposUploadReleaseAsset()
      .build(),
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_release_asset>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/assets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({name: p["name"], label: p["label"]})

    return this._request({
      url: url + query,
      method: "POST",
      // todo: request bodies with content-type 'application/octet-stream' not yet supported,
      baseURL: basePath,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      content?:
        | "+1"
        | "laugh"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      requestBody: {
        content:
          | "+1"
          | "laugh"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsDeleteForRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      reactionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions/${p["reactionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetBranchRules(
    p: {
      owner: string
      repo: string
      branch: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_rule_detailed[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rules/branches/${p["branch"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetRepoRulesets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
      includesParents?: boolean
      targets?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      includes_parents: p["includesParents"],
      targets: p["targets"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateRepoRuleset(
    p: {
      owner: string
      repo: string
      requestBody: {
        bypass_actors?: t_repository_ruleset_bypass_actor[] | undefined
        conditions?: t_repository_ruleset_conditions | undefined
        enforcement: t_repository_rule_enforcement
        name: string
        rules?: t_repository_rule[] | undefined
        target?:
          | ("branch" | "tag" | "push" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetRepoRuleSuites(
    p: {
      owner: string
      repo: string
      ref?: string
      timePeriod?: "hour" | "day" | "week" | "month" | UnknownEnumStringValue
      actorName?: string
      ruleSuiteResult?:
        | "pass"
        | "fail"
        | "bypass"
        | "all"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_rule_suites>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets/rule-suites`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      ref: p["ref"],
      time_period: p["timePeriod"],
      actor_name: p["actorName"],
      rule_suite_result: p["ruleSuiteResult"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetRepoRuleSuite(
    p: {
      owner: string
      repo: string
      ruleSuiteId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_rule_suite>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets/rule-suites/${p["ruleSuiteId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetRepoRuleset(
    p: {
      owner: string
      repo: string
      rulesetId: number
      includesParents?: boolean
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({includes_parents: p["includesParents"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposUpdateRepoRuleset(
    p: {
      owner: string
      repo: string
      rulesetId: number
      requestBody?: {
        bypass_actors?: t_repository_ruleset_bypass_actor[] | undefined
        conditions?: t_repository_ruleset_conditions | undefined
        enforcement?: t_repository_rule_enforcement | undefined
        name?: string | undefined
        rules?: t_repository_rule[] | undefined
        target?:
          | ("branch" | "tag" | "push" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_ruleset>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteRepoRuleset(
    p: {
      owner: string
      repo: string
      rulesetId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetRepoRulesetHistory(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
      rulesetId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ruleset_version[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}/history`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetRepoRulesetVersion(
    p: {
      owner: string
      repo: string
      rulesetId: number
      versionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ruleset_version_with_state>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}/history/${p["versionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningListAlertsForRepo(
    p: {
      owner: string
      repo: string
      state?: "open" | "resolved" | UnknownEnumStringValue
      secretType?: string
      resolution?: string
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      page?: number
      perPage?: number
      before?: string
      after?: string
      validity?: string
      isPubliclyLeaked?: boolean
      isMultiRepo?: boolean
      hideSecret?: boolean
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_secret_scanning_alert[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      secret_type: p["secretType"],
      resolution: p["resolution"],
      sort: p["sort"],
      direction: p["direction"],
      page: p["page"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      validity: p["validity"],
      is_publicly_leaked: p["isPubliclyLeaked"],
      is_multi_repo: p["isMultiRepo"],
      hide_secret: p["hideSecret"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningGetAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      hideSecret?: boolean
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_secret_scanning_alert>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({hide_secret: p["hideSecret"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningUpdateAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      requestBody: {
        resolution?: t_secret_scanning_alert_resolution | undefined
        resolution_comment?:
          | t_secret_scanning_alert_resolution_comment
          | undefined
        state: t_secret_scanning_alert_state
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_secret_scanning_alert>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningListLocationsForAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_secret_scanning_location[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}/locations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningCreatePushProtectionBypass(
    p: {
      owner: string
      repo: string
      requestBody: {
        placeholder_id: t_secret_scanning_push_protection_bypass_placeholder_id
        reason: t_secret_scanning_push_protection_bypass_reason
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_secret_scanning_push_protection_bypass>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/push-protection-bypasses`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async secretScanningGetScanHistory(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_secret_scanning_scan_history>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/scan-history`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesListRepositoryAdvisories(
    p: {
      owner: string
      repo: string
      direction?: "asc" | "desc" | UnknownEnumStringValue
      sort?: "created" | "updated" | "published" | UnknownEnumStringValue
      before?: string
      after?: string
      perPage?: number
      state?:
        | "triage"
        | "draft"
        | "published"
        | "closed"
        | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_advisory[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/security-advisories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      direction: p["direction"],
      sort: p["sort"],
      before: p["before"],
      after: p["after"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesCreateRepositoryAdvisory(
    p: {
      owner: string
      repo: string
      requestBody: t_repository_advisory_create
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_advisory>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/security-advisories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesCreatePrivateVulnerabilityReport(
    p: {
      owner: string
      repo: string
      requestBody: t_private_vulnerability_report_create
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_advisory>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/security-advisories/reports`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesGetRepositoryAdvisory(
    p: {
      owner: string
      repo: string
      ghsaId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_advisory>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesUpdateRepositoryAdvisory(
    p: {
      owner: string
      repo: string
      ghsaId: string
      requestBody: t_repository_advisory_update
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_advisory>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesCreateRepositoryAdvisoryCveRequest(
    p: {
      owner: string
      repo: string
      ghsaId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}/cve`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async securityAdvisoriesCreateFork(
    p: {
      owner: string
      repo: string
      ghsaId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_full_repository>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}/forks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListStargazersForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[] | t_stargazer[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/stargazers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCodeFrequencyStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<t_code_frequency_stat[]>
    | AxiosResponse<{
        [key: string]: unknown | undefined
      }>
    | AxiosResponse<void>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/stats/code_frequency`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetCommitActivityStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<t_commit_activity[]>
    | AxiosResponse<{
        [key: string]: unknown | undefined
      }>
    | AxiosResponse<void>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/stats/commit_activity`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetContributorsStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<t_contributor_activity[]>
    | AxiosResponse<{
        [key: string]: unknown | undefined
      }>
    | AxiosResponse<void>
  > {
    const url = `/repos/${p["owner"]}/${p["repo"]}/stats/contributors`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetParticipationStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_participation_stats>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/stats/participation`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetPunchCardStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_code_frequency_stat[]> | AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/stats/punch_card`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateCommitStatus(
    p: {
      owner: string
      repo: string
      sha: string
      requestBody: {
        context?: string | undefined
        description?: (string | null) | undefined
        state:
          | "error"
          | "failure"
          | "pending"
          | "success"
          | UnknownEnumStringValue
        target_url?: (string | null) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_status>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/statuses/${p["sha"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListWatchersForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/subscribers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityGetRepoSubscription(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_subscription>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/subscription`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activitySetRepoSubscription(
    p: {
      owner: string
      repo: string
      requestBody?: {
        ignored?: boolean | undefined
        subscribed?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_subscription>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/subscription`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityDeleteRepoSubscription(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/subscription`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListTags(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_tag[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/tags`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListTagProtection(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_tag_protection[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/tags/protection`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateTagProtection(
    p: {
      owner: string
      repo: string
      requestBody: {
        pattern: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_tag_protection>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/tags/protection`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeleteTagProtection(
    p: {
      owner: string
      repo: string
      tagProtectionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/tags/protection/${p["tagProtectionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDownloadTarballArchive(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/tarball/${p["ref"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListTeams(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetAllTopics(
    p: {
      owner: string
      repo: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_topic>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/topics`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposReplaceAllTopics(
    p: {
      owner: string
      repo: string
      requestBody: {
        names: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_topic>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/topics`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetClones(
    p: {
      owner: string
      repo: string
      per?: "day" | "week" | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_clone_traffic>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/traffic/clones`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per: p["per"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetTopPaths(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_content_traffic[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/paths`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetTopReferrers(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_referrer_traffic[]>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/referrers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposGetViews(
    p: {
      owner: string
      repo: string
      per?: "day" | "week" | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_view_traffic>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/traffic/views`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per: p["per"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposTransfer(
    p: {
      owner: string
      repo: string
      requestBody: {
        new_name?: string | undefined
        new_owner: string
        team_ids?: number[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/transfer`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCheckVulnerabilityAlerts(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposEnableVulnerabilityAlerts(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDisableVulnerabilityAlerts(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDownloadZipballArchive(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/repos/${p["owner"]}/${p["repo"]}/zipball/${p["ref"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateUsingTemplate(
    p: {
      templateOwner: string
      templateRepo: string
      requestBody: {
        description?: string | undefined
        include_all_branches?: boolean | undefined
        name: string
        owner?: string | undefined
        private?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_full_repository>> {
    const url = `/repos/${p["templateOwner"]}/${p["templateRepo"]}/generate`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListPublic(
    p: {
      since?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({since: p["since"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async searchCode(
    p: {
      q: string
      sort?: "indexed" | UnknownEnumStringValue
      order?: "desc" | "asc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      incomplete_results: boolean
      items: t_code_search_result_item[]
      total_count: number
    }>
  > {
    const url = `/search/code`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async searchCommits(
    p: {
      q: string
      sort?: "author-date" | "committer-date" | UnknownEnumStringValue
      order?: "desc" | "asc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      incomplete_results: boolean
      items: t_commit_search_result_item[]
      total_count: number
    }>
  > {
    const url = `/search/commits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async searchIssuesAndPullRequests(
    p: {
      q: string
      sort?:
        | "comments"
        | "reactions"
        | "reactions-+1"
        | "reactions--1"
        | "reactions-smile"
        | "reactions-thinking_face"
        | "reactions-heart"
        | "reactions-tada"
        | "interactions"
        | "created"
        | "updated"
        | UnknownEnumStringValue
      order?: "desc" | "asc" | UnknownEnumStringValue
      perPage?: number
      page?: number
      advancedSearch?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      incomplete_results: boolean
      items: t_issue_search_result_item[]
      total_count: number
    }>
  > {
    const url = `/search/issues`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
      advanced_search: p["advancedSearch"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async searchLabels(
    p: {
      repositoryId: number
      q: string
      sort?: "created" | "updated" | UnknownEnumStringValue
      order?: "desc" | "asc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      incomplete_results: boolean
      items: t_label_search_result_item[]
      total_count: number
    }>
  > {
    const url = `/search/labels`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      repository_id: p["repositoryId"],
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async searchRepos(
    p: {
      q: string
      sort?:
        | "stars"
        | "forks"
        | "help-wanted-issues"
        | "updated"
        | UnknownEnumStringValue
      order?: "desc" | "asc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      incomplete_results: boolean
      items: t_repo_search_result_item[]
      total_count: number
    }>
  > {
    const url = `/search/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async searchTopics(
    p: {
      q: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      incomplete_results: boolean
      items: t_topic_search_result_item[]
      total_count: number
    }>
  > {
    const url = `/search/topics`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      q: p["q"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async searchUsers(
    p: {
      q: string
      sort?: "followers" | "repositories" | "joined" | UnknownEnumStringValue
      order?: "desc" | "asc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      incomplete_results: boolean
      items: t_user_search_result_item[]
      total_count: number
    }>
  > {
    const url = `/search/users`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetLegacy(
    p: {
      teamId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_full>> {
    const url = `/teams/${p["teamId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsUpdateLegacy(
    p: {
      teamId: number
      requestBody: {
        description?: string | undefined
        name: string
        notification_setting?:
          | (
              | "notifications_enabled"
              | "notifications_disabled"
              | UnknownEnumStringValue
            )
          | undefined
        parent_team_id?: (number | null) | undefined
        permission?:
          | ("pull" | "push" | "admin" | UnknownEnumStringValue)
          | undefined
        privacy?: ("secret" | "closed" | UnknownEnumStringValue) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_full>> {
    const url = `/teams/${p["teamId"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsDeleteLegacy(
    p: {
      teamId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListDiscussionsLegacy(
    p: {
      teamId: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion[]>> {
    const url = `/teams/${p["teamId"]}/discussions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCreateDiscussionLegacy(
    p: {
      teamId: number
      requestBody: {
        body: string
        private?: boolean | undefined
        title: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion>> {
    const url = `/teams/${p["teamId"]}/discussions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsUpdateDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
      requestBody?: {
        body?: string | undefined
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsDeleteDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListDiscussionCommentsLegacy(
    p: {
      teamId: number
      discussionNumber: number
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment[]>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCreateDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsUpdateDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
      requestBody: {
        body: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_discussion_comment>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsDeleteDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForTeamDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForTeamDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsListForTeamDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
        | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction[]>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/reactions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reactionsCreateForTeamDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
      requestBody: {
        content:
          | "+1"
          | "-1"
          | "laugh"
          | "confused"
          | "heart"
          | "hooray"
          | "rocket"
          | "eyes"
          | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_reaction>> {
    const url = `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/reactions`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListPendingInvitationsLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_invitation[]>> {
    const url = `/teams/${p["teamId"]}/invitations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListMembersLegacy(
    p: {
      teamId: number
      role?: "member" | "maintainer" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/teams/${p["teamId"]}/members`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      role: p["role"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetMemberLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsAddMemberLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsRemoveMemberLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/members/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsGetMembershipForUserLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_membership>> {
    const url = `/teams/${p["teamId"]}/memberships/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsAddOrUpdateMembershipForUserLegacy(
    p: {
      teamId: number
      username: string
      requestBody?: {
        role?: ("member" | "maintainer" | UnknownEnumStringValue) | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_membership>> {
    const url = `/teams/${p["teamId"]}/memberships/${p["username"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsRemoveMembershipForUserLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/memberships/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListProjectsLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_project[]>> {
    const url = `/teams/${p["teamId"]}/projects`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCheckPermissionsForProjectLegacy(
    p: {
      teamId: number
      projectId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_project>> {
    const url = `/teams/${p["teamId"]}/projects/${p["projectId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsAddOrUpdateProjectPermissionsLegacy(
    p: {
      teamId: number
      projectId: number
      requestBody?: {
        permission?:
          | ("read" | "write" | "admin" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/projects/${p["projectId"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsRemoveProjectLegacy(
    p: {
      teamId: number
      projectId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/projects/${p["projectId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListReposLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/teams/${p["teamId"]}/repos`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsCheckPermissionsForRepoLegacy(
    p: {
      teamId: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_repository> | AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsAddOrUpdateRepoPermissionsLegacy(
    p: {
      teamId: number
      owner: string
      repo: string
      requestBody?: {
        permission?:
          | ("pull" | "push" | "admin" | UnknownEnumStringValue)
          | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsRemoveRepoLegacy(
    p: {
      teamId: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListChildLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team[]>> {
    const url = `/teams/${p["teamId"]}/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersGetAuthenticated(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_private_user | t_public_user>> {
    const url = `/user`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersUpdateAuthenticated(
    p: {
      requestBody?: {
        bio?: string | undefined
        blog?: string | undefined
        company?: string | undefined
        email?: string | undefined
        hireable?: boolean | undefined
        location?: string | undefined
        name?: string | undefined
        twitter_username?: (string | null) | undefined
      }
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_private_user>> {
    const url = `/user`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListBlockedByAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/user/blocks`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersCheckBlocked(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/blocks/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersBlock(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/blocks/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersUnblock(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/blocks/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
      repositoryId?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      codespaces: t_codespace[]
      total_count: number
    }>
  > {
    const url = `/user/codespaces`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      repository_id: p["repositoryId"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCreateForAuthenticatedUser(
    p: {
      requestBody:
        | {
            client_ip?: string | undefined
            devcontainer_path?: string | undefined
            display_name?: string | undefined
            geo?:
              | (
                  | "EuropeWest"
                  | "SoutheastAsia"
                  | "UsEast"
                  | "UsWest"
                  | UnknownEnumStringValue
                )
              | undefined
            idle_timeout_minutes?: number | undefined
            location?: string | undefined
            machine?: string | undefined
            multi_repo_permissions_opt_out?: boolean | undefined
            ref?: string | undefined
            repository_id: number
            retention_period_minutes?: number | undefined
            working_directory?: string | undefined
          }
        | {
            devcontainer_path?: string | undefined
            geo?:
              | (
                  | "EuropeWest"
                  | "SoutheastAsia"
                  | "UsEast"
                  | "UsWest"
                  | UnknownEnumStringValue
                )
              | undefined
            idle_timeout_minutes?: number | undefined
            location?: string | undefined
            machine?: string | undefined
            pull_request: {
              pull_request_number: number
              repository_id: number
            }
            working_directory?: string | undefined
          }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/user/codespaces`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListSecretsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      secrets: t_codespaces_secret[]
      total_count: number
    }>
  > {
    const url = `/user/codespaces/secrets`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetPublicKeyForAuthenticatedUser(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespaces_user_public_key>> {
    const url = `/user/codespaces/secrets/public-key`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetSecretForAuthenticatedUser(
    p: {
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespaces_secret>> {
    const url = `/user/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCreateOrUpdateSecretForAuthenticatedUser(
    p: {
      secretName: string
      requestBody: {
        encrypted_value?: string | undefined
        key_id: string
        selected_repository_ids?: (number | string)[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_empty_object> | AxiosResponse<void>> {
    const url = `/user/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesDeleteSecretForAuthenticatedUser(
    p: {
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesListRepositoriesForSecretForAuthenticatedUser(
    p: {
      secretName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_minimal_repository[]
      total_count: number
    }>
  > {
    const url = `/user/codespaces/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesSetRepositoriesForSecretForAuthenticatedUser(
    p: {
      secretName: string
      requestBody: {
        selected_repository_ids: number[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/codespaces/secrets/${p["secretName"]}/repositories`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesAddRepositoryForSecretForAuthenticatedUser(
    p: {
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesRemoveRepositoryForSecretForAuthenticatedUser(
    p: {
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/user/codespaces/${p["codespaceName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesUpdateForAuthenticatedUser(
    p: {
      codespaceName: string
      requestBody?: {
        display_name?: string | undefined
        machine?: string | undefined
        recent_folders?: string[] | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/user/codespaces/${p["codespaceName"]}`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesDeleteForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      [key: string]: unknown | undefined
    }>
  > {
    const url = `/user/codespaces/${p["codespaceName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesExportForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace_export_details>> {
    const url = `/user/codespaces/${p["codespaceName"]}/exports`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesGetExportDetailsForAuthenticatedUser(
    p: {
      codespaceName: string
      exportId: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace_export_details>> {
    const url = `/user/codespaces/${p["codespaceName"]}/exports/${p["exportId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesCodespaceMachinesForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      machines: t_codespace_machine[]
      total_count: number
    }>
  > {
    const url = `/user/codespaces/${p["codespaceName"]}/machines`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesPublishForAuthenticatedUser(
    p: {
      codespaceName: string
      requestBody: {
        name?: string | undefined
        private?: boolean | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace_with_full_repository>> {
    const url = `/user/codespaces/${p["codespaceName"]}/publish`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesStartForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/user/codespaces/${p["codespaceName"]}/start`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async codespacesStopForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_codespace>> {
    const url = `/user/codespaces/${p["codespaceName"]}/stop`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesListDockerMigrationConflictingPackagesForAuthenticatedUser(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package[]>> {
    const url = `/user/docker/conflicts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersSetPrimaryEmailVisibilityForAuthenticatedUser(
    p: {
      requestBody: {
        visibility: "public" | "private" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_email[]>> {
    const url = `/user/email/visibility`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListEmailsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_email[]>> {
    const url = `/user/emails`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersAddEmailForAuthenticatedUser(
    p: {
      requestBody?:
        | {
            emails: string[]
          }
        | string[]
        | string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_email[]>> {
    const url = `/user/emails`
    const headers = this._headers(
      {
        Accept: "application/json",
        "Content-Type":
          p.requestBody !== undefined ? "application/json" : false,
      },
      opts.headers,
    )
    const body =
      p.requestBody !== undefined ? JSON.stringify(p.requestBody) : null

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeleteEmailForAuthenticatedUser(
    p: {
      requestBody:
        | {
            emails: string[]
          }
        | string[]
        | string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/emails`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListFollowersForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/user/followers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListFollowedByAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/user/following`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersCheckPersonIsFollowedByAuthenticated(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/following/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersFollow(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/following/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersUnfollow(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/following/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListGpgKeysForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gpg_key[]>> {
    const url = `/user/gpg_keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersCreateGpgKeyForAuthenticatedUser(
    p: {
      requestBody: {
        armored_public_key: string
        name?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gpg_key>> {
    const url = `/user/gpg_keys`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersGetGpgKeyForAuthenticatedUser(
    p: {
      gpgKeyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gpg_key>> {
    const url = `/user/gpg_keys/${p["gpgKeyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeleteGpgKeyForAuthenticatedUser(
    p: {
      gpgKeyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/gpg_keys/${p["gpgKeyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListInstallationsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      installations: t_installation[]
      total_count: number
    }>
  > {
    const url = `/user/installations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListInstallationReposForAuthenticatedUser(
    p: {
      installationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      repositories: t_repository[]
      repository_selection?: string | undefined
      total_count: number
    }>
  > {
    const url = `/user/installations/${p["installationId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsAddRepoToInstallationForAuthenticatedUser(
    p: {
      installationId: number
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsRemoveRepoFromInstallationForAuthenticatedUser(
    p: {
      installationId: number
      repositoryId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsGetRestrictionsForAuthenticatedUser(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<t_interaction_limit_response | EmptyObject>
    | AxiosResponse<void>
  > {
    const url = `/user/interaction-limits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsSetRestrictionsForAuthenticatedUser(
    p: {
      requestBody: t_interaction_limit
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_interaction_limit_response>> {
    const url = `/user/interaction-limits`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PUT",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async interactionsRemoveRestrictionsForAuthenticatedUser(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/interaction-limits`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async issuesListForAuthenticatedUser(
    p: {
      filter?:
        | "assigned"
        | "created"
        | "mentioned"
        | "subscribed"
        | "repos"
        | "all"
        | UnknownEnumStringValue
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      labels?: string
      sort?: "created" | "updated" | "comments" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_issue[]>> {
    const url = `/user/issues`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      filter: p["filter"],
      state: p["state"],
      labels: p["labels"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListPublicSshKeysForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_key[]>> {
    const url = `/user/keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersCreatePublicSshKeyForAuthenticatedUser(
    p: {
      requestBody: {
        key: string
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_key>> {
    const url = `/user/keys`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersGetPublicSshKeyForAuthenticatedUser(
    p: {
      keyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_key>> {
    const url = `/user/keys/${p["keyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeletePublicSshKeyForAuthenticatedUser(
    p: {
      keyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/keys/${p["keyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListSubscriptionsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_user_marketplace_purchase[]>> {
    const url = `/user/marketplace_purchases`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsListSubscriptionsForAuthenticatedUserStubbed(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_user_marketplace_purchase[]>> {
    const url = `/user/marketplace_purchases/stubbed`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListMembershipsForAuthenticatedUser(
    p: {
      state?: "active" | "pending" | UnknownEnumStringValue
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_membership[]>> {
    const url = `/user/memberships/orgs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsGetMembershipForAuthenticatedUser(
    p: {
      org: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_membership>> {
    const url = `/user/memberships/orgs/${p["org"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsUpdateMembershipForAuthenticatedUser(
    p: {
      org: string
      requestBody: {
        state: "active" | UnknownEnumStringValue
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_org_membership>> {
    const url = `/user/memberships/orgs/${p["org"]}`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "PATCH",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_migration[]>> {
    const url = `/user/migrations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsStartForAuthenticatedUser(
    p: {
      requestBody: {
        exclude?: ("repositories" | UnknownEnumStringValue)[] | undefined
        exclude_attachments?: boolean | undefined
        exclude_git_data?: boolean | undefined
        exclude_metadata?: boolean | undefined
        exclude_owner_projects?: boolean | undefined
        exclude_releases?: boolean | undefined
        lock_repositories?: boolean | undefined
        org_metadata_only?: boolean | undefined
        repositories: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_migration>> {
    const url = `/user/migrations`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsGetStatusForAuthenticatedUser(
    p: {
      migrationId: number
      exclude?: string[]
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_migration>> {
    const url = `/user/migrations/${p["migrationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({exclude: p["exclude"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsGetArchiveForAuthenticatedUser(
    p: {
      migrationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/migrations/${p["migrationId"]}/archive`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsDeleteArchiveForAuthenticatedUser(
    p: {
      migrationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/migrations/${p["migrationId"]}/archive`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsUnlockRepoForAuthenticatedUser(
    p: {
      migrationId: number
      repoName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async migrationsListReposForAuthenticatedUser(
    p: {
      migrationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/user/migrations/${p["migrationId"]}/repositories`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_simple[]>> {
    const url = `/user/orgs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesListPackagesForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      visibility?: "public" | "private" | "internal" | UnknownEnumStringValue
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package[]>> {
    const url = `/user/packages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      package_type: p["packageType"],
      visibility: p["visibility"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetPackageForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package>> {
    const url = `/user/packages/${p["packageType"]}/${p["packageName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesDeletePackageForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/packages/${p["packageType"]}/${p["packageName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesRestorePackageForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      token?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/packages/${p["packageType"]}/${p["packageName"]}/restore`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({token: p["token"]})

    return this._request({
      url: url + query,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      page?: number
      perPage?: number
      state?: "active" | "deleted" | UnknownEnumStringValue
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package_version[]>> {
    const url = `/user/packages/${p["packageType"]}/${p["packageName"]}/versions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      page: p["page"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetPackageVersionForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package_version>> {
    const url = `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesDeletePackageVersionForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesRestorePackageVersionForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicCreateForAuthenticatedUser(
    p: {
      requestBody: {
        body?: (string | null) | undefined
        name: string
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project>> {
    const url = `/user/projects`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListPublicEmailsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_email[]>> {
    const url = `/user/public_emails`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListForAuthenticatedUser(
    p: {
      visibility?: "all" | "public" | "private" | UnknownEnumStringValue
      affiliation?: string
      type?:
        | "all"
        | "owner"
        | "public"
        | "private"
        | "member"
        | UnknownEnumStringValue
      sort?:
        | "created"
        | "updated"
        | "pushed"
        | "full_name"
        | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
      since?: string
      before?: string
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository[]>> {
    const url = `/user/repos`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      visibility: p["visibility"],
      affiliation: p["affiliation"],
      type: p["type"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
      since: p["since"],
      before: p["before"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposCreateForAuthenticatedUser(
    p: {
      requestBody: {
        allow_auto_merge?: boolean | undefined
        allow_merge_commit?: boolean | undefined
        allow_rebase_merge?: boolean | undefined
        allow_squash_merge?: boolean | undefined
        auto_init?: boolean | undefined
        delete_branch_on_merge?: boolean | undefined
        description?: string | undefined
        gitignore_template?: string | undefined
        has_discussions?: boolean | undefined
        has_downloads?: boolean | undefined
        has_issues?: boolean | undefined
        has_projects?: boolean | undefined
        has_wiki?: boolean | undefined
        homepage?: string | undefined
        is_template?: boolean | undefined
        license_template?: string | undefined
        merge_commit_message?:
          | ("PR_BODY" | "PR_TITLE" | "BLANK" | UnknownEnumStringValue)
          | undefined
        merge_commit_title?:
          | ("PR_TITLE" | "MERGE_MESSAGE" | UnknownEnumStringValue)
          | undefined
        name: string
        private?: boolean | undefined
        squash_merge_commit_message?:
          | ("PR_BODY" | "COMMIT_MESSAGES" | "BLANK" | UnknownEnumStringValue)
          | undefined
        squash_merge_commit_title?:
          | ("PR_TITLE" | "COMMIT_OR_PR_TITLE" | UnknownEnumStringValue)
          | undefined
        team_id?: number | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_full_repository>> {
    const url = `/user/repos`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListInvitationsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_repository_invitation[]>> {
    const url = `/user/repository_invitations`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposAcceptInvitationForAuthenticatedUser(
    p: {
      invitationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/repository_invitations/${p["invitationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PATCH",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposDeclineInvitationForAuthenticatedUser(
    p: {
      invitationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/repository_invitations/${p["invitationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListSocialAccountsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_social_account[]>> {
    const url = `/user/social_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersAddSocialAccountForAuthenticatedUser(
    p: {
      requestBody: {
        account_urls: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_social_account[]>> {
    const url = `/user/social_accounts`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeleteSocialAccountForAuthenticatedUser(
    p: {
      requestBody: {
        account_urls: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/social_accounts`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "DELETE",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListSshSigningKeysForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ssh_signing_key[]>> {
    const url = `/user/ssh_signing_keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersCreateSshSigningKeyForAuthenticatedUser(
    p: {
      requestBody: {
        key: string
        title?: string | undefined
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ssh_signing_key>> {
    const url = `/user/ssh_signing_keys`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersGetSshSigningKeyForAuthenticatedUser(
    p: {
      sshSigningKeyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ssh_signing_key>> {
    const url = `/user/ssh_signing_keys/${p["sshSigningKeyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeleteSshSigningKeyForAuthenticatedUser(
    p: {
      sshSigningKeyId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/ssh_signing_keys/${p["sshSigningKeyId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListReposStarredByAuthenticatedUser(
    p: {
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_starred_repository[]>> {
    const url = `/user/starred`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityCheckRepoIsStarredByAuthenticatedUser(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/starred/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityStarRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/starred/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "PUT",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityUnstarRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/user/starred/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListWatchedReposForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/user/subscriptions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async teamsListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_team_full[]>> {
    const url = `/user/teams`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersGetById(
    p: {
      accountId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_private_user | t_public_user>> {
    const url = `/user/${p["accountId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersList(
    p: {
      since?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/users`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({since: p["since"], per_page: p["perPage"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersGetByUsername(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_private_user | t_public_user>> {
    const url = `/users/${p["username"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListAttestationsBulk(
    p: {
      perPage?: number
      before?: string
      after?: string
      username: string
      requestBody: {
        predicate_type?: string | undefined
        subject_digests: string[]
      }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    AxiosResponse<{
      attestations_subject_digests?:
        | {
            [key: string]:
              | (
                  | {
                      bundle?:
                        | {
                            dsseEnvelope?:
                              | {
                                  [key: string]: unknown | undefined
                                }
                              | undefined
                            mediaType?: string | undefined
                            verificationMaterial?:
                              | {
                                  [key: string]: unknown | undefined
                                }
                              | undefined
                          }
                        | undefined
                      bundle_url?: string | undefined
                      repository_id?: number | undefined
                    }[]
                  | null
                )
              | undefined
          }
        | undefined
      page_info?:
        | {
            has_next?: boolean | undefined
            has_previous?: boolean | undefined
            next?: string | undefined
            previous?: string | undefined
          }
        | undefined
    }>
  > {
    const url = `/users/${p["username"]}/attestations/bulk-list`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
    })
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url + query,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeleteAttestationsBulk(
    p: {
      username: string
      requestBody:
        | {
            subject_digests: string[]
          }
        | {
            attestation_ids: number[]
          }
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/attestations/delete-request`
    const headers = this._headers(
      {Accept: "application/json", "Content-Type": "application/json"},
      opts.headers,
    )
    const body = JSON.stringify(p.requestBody)

    return this._request({
      url: url,
      method: "POST",
      data: body,
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeleteAttestationsBySubjectDigest(
    p: {
      username: string
      subjectDigest: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/attestations/digest/${p["subjectDigest"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersDeleteAttestationsById(
    p: {
      username: string
      attestationId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/attestations/${p["attestationId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListAttestations(
    p: {
      perPage?: number
      before?: string
      after?: string
      username: string
      subjectDigest: string
      predicateType?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<
    | AxiosResponse<{
        attestations?:
          | {
              bundle?:
                | {
                    dsseEnvelope?:
                      | {
                          [key: string]: unknown | undefined
                        }
                      | undefined
                    mediaType?: string | undefined
                    verificationMaterial?:
                      | {
                          [key: string]: unknown | undefined
                        }
                      | undefined
                  }
                | undefined
              bundle_url?: string | undefined
              repository_id?: number | undefined
            }[]
          | undefined
      }>
    | AxiosResponse<t_empty_object>
    | AxiosResponse<void>
  > {
    const url = `/users/${p["username"]}/attestations/${p["subjectDigest"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      predicate_type: p["predicateType"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesListDockerMigrationConflictingPackagesForUser(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package[]>> {
    const url = `/users/${p["username"]}/docker/conflicts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListEventsForAuthenticatedUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/users/${p["username"]}/events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListOrgEventsForAuthenticatedUser(
    p: {
      username: string
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/users/${p["username"]}/events/orgs/${p["org"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListPublicEventsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/users/${p["username"]}/events/public`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListFollowersForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/users/${p["username"]}/followers`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListFollowingForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_simple_user[]>> {
    const url = `/users/${p["username"]}/following`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersCheckFollowingForUser(
    p: {
      username: string
      targetUser: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/following/${p["targetUser"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async gistsListForUser(
    p: {
      username: string
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_base_gist[]>> {
    const url = `/users/${p["username"]}/gists`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListGpgKeysForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_gpg_key[]>> {
    const url = `/users/${p["username"]}/gpg_keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersGetContextForUser(
    p: {
      username: string
      subjectType?:
        | "organization"
        | "repository"
        | "issue"
        | "pull_request"
        | UnknownEnumStringValue
      subjectId?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_hovercard>> {
    const url = `/users/${p["username"]}/hovercard`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      subject_type: p["subjectType"],
      subject_id: p["subjectId"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async appsGetUserInstallation(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_installation>> {
    const url = `/users/${p["username"]}/installation`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListPublicKeysForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_key_simple[]>> {
    const url = `/users/${p["username"]}/keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async orgsListForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_organization_simple[]>> {
    const url = `/users/${p["username"]}/orgs`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesListPackagesForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      visibility?: "public" | "private" | "internal" | UnknownEnumStringValue
      username: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package[]>> {
    const url = `/users/${p["username"]}/packages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      package_type: p["packageType"],
      visibility: p["visibility"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetPackageForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package>> {
    const url = `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesDeletePackageForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesRestorePackageForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      username: string
      token?: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/restore`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({token: p["token"]})

    return this._request({
      url: url + query,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetAllPackageVersionsForPackageOwnedByUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package_version[]>> {
    const url = `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesGetPackageVersionForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      packageVersionId: number
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_package_version>> {
    const url = `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesDeletePackageVersionForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      username: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "DELETE",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async packagesRestorePackageVersionForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
        | UnknownEnumStringValue
      packageName: string
      username: string
      packageVersionId: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<void>> {
    const url = `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "POST",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async projectsClassicListForUser(
    p: {
      username: string
      state?: "open" | "closed" | "all" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_project[]>> {
    const url = `/users/${p["username"]}/projects`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListReceivedEventsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/users/${p["username"]}/received_events`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListReceivedPublicEventsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_event[]>> {
    const url = `/users/${p["username"]}/received_events/public`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async reposListForUser(
    p: {
      username: string
      type?: "all" | "owner" | "member" | UnknownEnumStringValue
      sort?:
        | "created"
        | "updated"
        | "pushed"
        | "full_name"
        | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/users/${p["username"]}/repos`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      type: p["type"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetGithubActionsBillingUser(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_actions_billing_usage>> {
    const url = `/users/${p["username"]}/settings/billing/actions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetGithubPackagesBillingUser(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_packages_billing_usage>> {
    const url = `/users/${p["username"]}/settings/billing/packages`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetSharedStorageBillingUser(
    p: {
      username: string
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_combined_billing_usage>> {
    const url = `/users/${p["username"]}/settings/billing/shared-storage`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async billingGetGithubBillingUsageReportUser(
    p: {
      username: string
      year?: number
      month?: number
      day?: number
      hour?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_billing_usage_report_user>> {
    const url = `/users/${p["username"]}/settings/billing/usage`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      year: p["year"],
      month: p["month"],
      day: p["day"],
      hour: p["hour"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListSocialAccountsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_social_account[]>> {
    const url = `/users/${p["username"]}/social_accounts`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async usersListSshSigningKeysForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_ssh_signing_key[]>> {
    const url = `/users/${p["username"]}/ssh_signing_keys`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListReposStarredByUser(
    p: {
      username: string
      sort?: "created" | "updated" | UnknownEnumStringValue
      direction?: "asc" | "desc" | UnknownEnumStringValue
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_starred_repository[] | t_repository[]>> {
    const url = `/users/${p["username"]}/starred`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async activityListReposWatchedByUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<t_minimal_repository[]>> {
    const url = `/users/${p["username"]}/subscriptions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._request({
      url: url + query,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async metaGetAllVersions(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string[]>> {
    const url = `/versions`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }

  async metaGetZen(
    timeout?: number,
    opts: AxiosRequestConfig = {},
  ): Promise<AxiosResponse<string>> {
    const url = `/zen`
    const headers = this._headers({Accept: "application/json"}, opts.headers)

    return this._request({
      url: url,
      method: "GET",
      ...(timeout ? {timeout} : {}),
      ...opts,
      headers,
    })
  }
}

export {GitHubV3RestApi as ApiClient}
export type {GitHubV3RestApiConfig as ApiClientConfig}
