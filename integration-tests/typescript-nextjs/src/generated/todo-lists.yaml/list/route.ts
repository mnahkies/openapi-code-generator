/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {t_GetTodoListsQuerySchema, t_TodoList} from "../models"
import {s_Statuses} from "../schemas"
import {
  OpenAPIRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-nextjs-runtime/errors"
import {
  OpenAPIRuntimeResponder,
  OpenAPIRuntimeResponse,
  Params,
  StatusCode,
} from "@nahkies/typescript-nextjs-runtime/server"
import {parseRequestInput} from "@nahkies/typescript-nextjs-runtime/zod"
import {NextRequest} from "next/server"
import {z} from "zod"

// /list
export type GetTodoListsResponder = {
  with200(): OpenAPIRuntimeResponse<t_TodoList[]>
} & OpenAPIRuntimeResponder

export type GetTodoLists = (
  params: Params<void, t_GetTodoListsQuerySchema, void, void>,
  respond: GetTodoListsResponder,
  request: NextRequest,
) => Promise<OpenAPIRuntimeResponse<unknown>>

const getTodoListsQuerySchema = z.object({
  created: z.string().datetime({offset: true}).optional(),
  statuses: z
    .preprocess(
      (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
      s_Statuses,
    )
    .optional(),
  tags: z
    .preprocess(
      (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
      z.array(z.string()),
    )
    .optional(),
})

export const _GET =
  (
    implementation: GetTodoLists,
    onError: (err: unknown) => Promise<Response>,
  ) =>
  async (request: NextRequest): Promise<Response> => {
    try {
      const input = {
        params: undefined,
        // TODO: this swallows repeated parameters
        query: parseRequestInput(
          getTodoListsQuerySchema,
          Object.fromEntries(request.nextUrl.searchParams.entries()),
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new OpenAPIRuntimeResponse<t_TodoList[]>(200)
        },
        withStatus(status: StatusCode) {
          return new OpenAPIRuntimeResponse(status)
        },
      }

      const {status, body} = await implementation(input, responder, request)
        .then((it) => it.unpack())
        .catch((err) => {
          throw OpenAPIRuntimeError.HandlerError(err)
        })

      return body !== undefined
        ? Response.json(body, {status})
        : new Response(undefined, {status})
    } catch (err) {
      return await onError(err)
    }
  }
