/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import KoaRouter, {type RouterContext} from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  type KoaRuntimeResponder,
  KoaRuntimeResponse,
  type Params,
  parseQueryParameters,
  type Response,
  type ServerConfig,
  SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod-v4"
import type {Next} from "koa"
import {z} from "zod/v4"
import type {
  t_Azure_Core_Foundations_Error,
  t_Azure_Core_Foundations_ErrorResponse,
  t_Azure_Core_Foundations_OperationState,
  t_GetServiceStatusQuerySchema,
  t_GetServiceStatusRequestHeaderSchema,
  t_Manufacturer,
  t_ManufacturersCreateOrReplaceManufacturerParamSchema,
  t_ManufacturersCreateOrReplaceManufacturerQuerySchema,
  t_ManufacturersCreateOrReplaceManufacturerRequestHeaderSchema,
  t_ManufacturersDeleteManufacturerParamSchema,
  t_ManufacturersDeleteManufacturerQuerySchema,
  t_ManufacturersDeleteManufacturerRequestHeaderSchema,
  t_ManufacturersGetManufacturerOperationStatusParamSchema,
  t_ManufacturersGetManufacturerOperationStatusQuerySchema,
  t_ManufacturersGetManufacturerParamSchema,
  t_ManufacturersGetManufacturerQuerySchema,
  t_ManufacturersGetManufacturerRequestHeaderSchema,
  t_ManufacturersListManufacturersQuerySchema,
  t_ManufacturersListManufacturersRequestHeaderSchema,
  t_PagedManufacturer,
  t_PagedWidget,
  t_PagedWidgetPart,
  t_Widget,
  t_WidgetAnalytics,
  t_WidgetAnalyticsCreateOrUpdate,
  t_WidgetCreateOrUpdate,
  t_WidgetPart,
  t_WidgetPartReorderRequest,
  t_WidgetPartsCreateWidgetPartParamSchema,
  t_WidgetPartsCreateWidgetPartQuerySchema,
  t_WidgetPartsCreateWidgetPartRequestHeaderSchema,
  t_WidgetPartsDeleteWidgetPartParamSchema,
  t_WidgetPartsDeleteWidgetPartQuerySchema,
  t_WidgetPartsDeleteWidgetPartRequestHeaderSchema,
  t_WidgetPartsGetWidgetPartOperationStatusParamSchema,
  t_WidgetPartsGetWidgetPartOperationStatusQuerySchema,
  t_WidgetPartsGetWidgetPartParamSchema,
  t_WidgetPartsGetWidgetPartQuerySchema,
  t_WidgetPartsGetWidgetPartRequestHeaderSchema,
  t_WidgetPartsListWidgetPartsParamSchema,
  t_WidgetPartsListWidgetPartsQuerySchema,
  t_WidgetPartsListWidgetPartsRequestHeaderSchema,
  t_WidgetPartsReorderPartsParamSchema,
  t_WidgetPartsReorderPartsQuerySchema,
  t_WidgetPartsReorderPartsRequestHeaderSchema,
  t_WidgetRepairRequest,
  t_WidgetRepairState,
  t_WidgetsCreateOrUpdateWidgetParamSchema,
  t_WidgetsCreateOrUpdateWidgetQuerySchema,
  t_WidgetsCreateOrUpdateWidgetRequestHeaderSchema,
  t_WidgetsDeleteWidgetParamSchema,
  t_WidgetsDeleteWidgetQuerySchema,
  t_WidgetsDeleteWidgetRequestHeaderSchema,
  t_WidgetsGetAnalyticsParamSchema,
  t_WidgetsGetAnalyticsQuerySchema,
  t_WidgetsGetAnalyticsRequestHeaderSchema,
  t_WidgetsGetRepairStatusParamSchema,
  t_WidgetsGetRepairStatusQuerySchema,
  t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema,
  t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema,
  t_WidgetsGetWidgetParamSchema,
  t_WidgetsGetWidgetQuerySchema,
  t_WidgetsGetWidgetRequestHeaderSchema,
  t_WidgetsListWidgetsQuerySchema,
  t_WidgetsListWidgetsRequestHeaderSchema,
  t_WidgetsScheduleRepairsParamSchema,
  t_WidgetsScheduleRepairsQuerySchema,
  t_WidgetsScheduleRepairsRequestHeaderSchema,
  t_WidgetsUpdateAnalyticsParamSchema,
  t_WidgetsUpdateAnalyticsQuerySchema,
  t_WidgetsUpdateAnalyticsRequestHeaderSchema,
} from "./models"
import {
  s_Azure_Core_Foundations_Error,
  s_Azure_Core_Foundations_ErrorResponse,
  s_Azure_Core_Foundations_OperationState,
  s_Azure_Core_uuid,
  s_Manufacturer,
  s_PagedManufacturer,
  s_PagedWidget,
  s_PagedWidgetPart,
  s_Widget,
  s_WidgetAnalytics,
  s_WidgetAnalyticsCreateOrUpdate,
  s_WidgetCreateOrUpdate,
  s_WidgetPart,
  s_WidgetPartReorderRequest,
  s_WidgetRepairRequest,
  s_WidgetRepairState,
} from "./schemas"

export type GetServiceStatusResponder = {
  with200(): KoaRuntimeResponse<{
    statusString: string
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type GetServiceStatus = (
  params: Params<
    void,
    t_GetServiceStatusQuerySchema,
    void,
    t_GetServiceStatusRequestHeaderSchema
  >,
  respond: GetServiceStatusResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        statusString: string
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponder =
  {
    with200(): KoaRuntimeResponse<
      | {
          error?: t_Azure_Core_Foundations_Error
          id: string
          result?: t_Widget
          status: t_Azure_Core_Foundations_OperationState
        }
      | {
          error?: t_Azure_Core_Foundations_Error
          id: string
          status: t_Azure_Core_Foundations_OperationState
        }
    >
    withDefault(
      status: StatusCode,
    ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
  } & KoaRuntimeResponder

export type WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus =
  (
    params: Params<
      t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema,
      t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema,
      void,
      void
    >,
    respond: WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponder,
    ctx: RouterContext,
    next: Next,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<
        200,
        | {
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_Widget
            status: t_Azure_Core_Foundations_OperationState
          }
        | {
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_Azure_Core_Foundations_OperationState
          }
      >
    | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
    | typeof SkipResponse
  >

export type WidgetsCreateOrUpdateWidgetResponder = {
  with200(): KoaRuntimeResponse<t_Widget>
  with201(): KoaRuntimeResponse<t_Widget>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsCreateOrUpdateWidget = (
  params: Params<
    t_WidgetsCreateOrUpdateWidgetParamSchema,
    t_WidgetsCreateOrUpdateWidgetQuerySchema,
    t_WidgetCreateOrUpdate,
    t_WidgetsCreateOrUpdateWidgetRequestHeaderSchema
  >,
  respond: WidgetsCreateOrUpdateWidgetResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Widget>
  | Response<201, t_Widget>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsGetWidgetResponder = {
  with200(): KoaRuntimeResponse<t_Widget>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsGetWidget = (
  params: Params<
    t_WidgetsGetWidgetParamSchema,
    t_WidgetsGetWidgetQuerySchema,
    void,
    t_WidgetsGetWidgetRequestHeaderSchema
  >,
  respond: WidgetsGetWidgetResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Widget>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsDeleteWidgetResponder = {
  with202(): KoaRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error
    id: string
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsDeleteWidget = (
  params: Params<
    t_WidgetsDeleteWidgetParamSchema,
    t_WidgetsDeleteWidgetQuerySchema,
    void,
    t_WidgetsDeleteWidgetRequestHeaderSchema
  >,
  respond: WidgetsDeleteWidgetResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        error?: t_Azure_Core_Foundations_Error
        id: string
        status: t_Azure_Core_Foundations_OperationState
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsListWidgetsResponder = {
  with200(): KoaRuntimeResponse<t_PagedWidget>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsListWidgets = (
  params: Params<
    void,
    t_WidgetsListWidgetsQuerySchema,
    void,
    t_WidgetsListWidgetsRequestHeaderSchema
  >,
  respond: WidgetsListWidgetsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_PagedWidget>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsGetAnalyticsResponder = {
  with200(): KoaRuntimeResponse<t_WidgetAnalytics>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsGetAnalytics = (
  params: Params<
    t_WidgetsGetAnalyticsParamSchema,
    t_WidgetsGetAnalyticsQuerySchema,
    void,
    t_WidgetsGetAnalyticsRequestHeaderSchema
  >,
  respond: WidgetsGetAnalyticsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_WidgetAnalytics>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsUpdateAnalyticsResponder = {
  with200(): KoaRuntimeResponse<t_WidgetAnalytics>
  with201(): KoaRuntimeResponse<t_WidgetAnalytics>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsUpdateAnalytics = (
  params: Params<
    t_WidgetsUpdateAnalyticsParamSchema,
    t_WidgetsUpdateAnalyticsQuerySchema,
    t_WidgetAnalyticsCreateOrUpdate,
    t_WidgetsUpdateAnalyticsRequestHeaderSchema
  >,
  respond: WidgetsUpdateAnalyticsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_WidgetAnalytics>
  | Response<201, t_WidgetAnalytics>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsGetRepairStatusResponder = {
  with200(): KoaRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error
    id: string
    result?: t_WidgetRepairRequest
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsGetRepairStatus = (
  params: Params<
    t_WidgetsGetRepairStatusParamSchema,
    t_WidgetsGetRepairStatusQuerySchema,
    void,
    void
  >,
  respond: WidgetsGetRepairStatusResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        error?: t_Azure_Core_Foundations_Error
        id: string
        result?: t_WidgetRepairRequest
        status: t_Azure_Core_Foundations_OperationState
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetsScheduleRepairsResponder = {
  with202(): KoaRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error
    id: string
    result?: {
      completedDateTime: string
      createdDateTime: string
      requestState: t_WidgetRepairState
      scheduledDateTime: string
      updatedDateTime: string
    }
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetsScheduleRepairs = (
  params: Params<
    t_WidgetsScheduleRepairsParamSchema,
    t_WidgetsScheduleRepairsQuerySchema,
    t_WidgetRepairRequest,
    t_WidgetsScheduleRepairsRequestHeaderSchema
  >,
  respond: WidgetsScheduleRepairsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        error?: t_Azure_Core_Foundations_Error
        id: string
        result?: {
          completedDateTime: string
          createdDateTime: string
          requestState: t_WidgetRepairState
          scheduledDateTime: string
          updatedDateTime: string
        }
        status: t_Azure_Core_Foundations_OperationState
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetPartsGetWidgetPartOperationStatusResponder = {
  with200(): KoaRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error
    id: string
    result?: t_WidgetPart
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetPartsGetWidgetPartOperationStatus = (
  params: Params<
    t_WidgetPartsGetWidgetPartOperationStatusParamSchema,
    t_WidgetPartsGetWidgetPartOperationStatusQuerySchema,
    void,
    void
  >,
  respond: WidgetPartsGetWidgetPartOperationStatusResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        error?: t_Azure_Core_Foundations_Error
        id: string
        result?: t_WidgetPart
        status: t_Azure_Core_Foundations_OperationState
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetPartsCreateWidgetPartResponder = {
  with201(): KoaRuntimeResponse<void>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetPartsCreateWidgetPart = (
  params: Params<
    t_WidgetPartsCreateWidgetPartParamSchema,
    t_WidgetPartsCreateWidgetPartQuerySchema,
    t_WidgetPart,
    t_WidgetPartsCreateWidgetPartRequestHeaderSchema
  >,
  respond: WidgetPartsCreateWidgetPartResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, void>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetPartsListWidgetPartsResponder = {
  with200(): KoaRuntimeResponse<t_PagedWidgetPart>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetPartsListWidgetParts = (
  params: Params<
    t_WidgetPartsListWidgetPartsParamSchema,
    t_WidgetPartsListWidgetPartsQuerySchema,
    void,
    t_WidgetPartsListWidgetPartsRequestHeaderSchema
  >,
  respond: WidgetPartsListWidgetPartsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_PagedWidgetPart>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetPartsGetWidgetPartResponder = {
  with200(): KoaRuntimeResponse<t_WidgetPart>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetPartsGetWidgetPart = (
  params: Params<
    t_WidgetPartsGetWidgetPartParamSchema,
    t_WidgetPartsGetWidgetPartQuerySchema,
    void,
    t_WidgetPartsGetWidgetPartRequestHeaderSchema
  >,
  respond: WidgetPartsGetWidgetPartResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_WidgetPart>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetPartsDeleteWidgetPartResponder = {
  with204(): KoaRuntimeResponse<void>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetPartsDeleteWidgetPart = (
  params: Params<
    t_WidgetPartsDeleteWidgetPartParamSchema,
    t_WidgetPartsDeleteWidgetPartQuerySchema,
    void,
    t_WidgetPartsDeleteWidgetPartRequestHeaderSchema
  >,
  respond: WidgetPartsDeleteWidgetPartResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type WidgetPartsReorderPartsResponder = {
  with202(): KoaRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error
    id: string
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type WidgetPartsReorderParts = (
  params: Params<
    t_WidgetPartsReorderPartsParamSchema,
    t_WidgetPartsReorderPartsQuerySchema,
    t_WidgetPartReorderRequest,
    t_WidgetPartsReorderPartsRequestHeaderSchema
  >,
  respond: WidgetPartsReorderPartsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        error?: t_Azure_Core_Foundations_Error
        id: string
        status: t_Azure_Core_Foundations_OperationState
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type ManufacturersGetManufacturerOperationStatusResponder = {
  with200(): KoaRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error
    id: string
    result?: t_Manufacturer
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type ManufacturersGetManufacturerOperationStatus = (
  params: Params<
    t_ManufacturersGetManufacturerOperationStatusParamSchema,
    t_ManufacturersGetManufacturerOperationStatusQuerySchema,
    void,
    void
  >,
  respond: ManufacturersGetManufacturerOperationStatusResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        error?: t_Azure_Core_Foundations_Error
        id: string
        result?: t_Manufacturer
        status: t_Azure_Core_Foundations_OperationState
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type ManufacturersCreateOrReplaceManufacturerResponder = {
  with200(): KoaRuntimeResponse<t_Manufacturer>
  with201(): KoaRuntimeResponse<t_Manufacturer>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type ManufacturersCreateOrReplaceManufacturer = (
  params: Params<
    t_ManufacturersCreateOrReplaceManufacturerParamSchema,
    t_ManufacturersCreateOrReplaceManufacturerQuerySchema,
    t_Manufacturer,
    t_ManufacturersCreateOrReplaceManufacturerRequestHeaderSchema
  >,
  respond: ManufacturersCreateOrReplaceManufacturerResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Manufacturer>
  | Response<201, t_Manufacturer>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type ManufacturersGetManufacturerResponder = {
  with200(): KoaRuntimeResponse<t_Manufacturer>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type ManufacturersGetManufacturer = (
  params: Params<
    t_ManufacturersGetManufacturerParamSchema,
    t_ManufacturersGetManufacturerQuerySchema,
    void,
    t_ManufacturersGetManufacturerRequestHeaderSchema
  >,
  respond: ManufacturersGetManufacturerResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Manufacturer>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type ManufacturersDeleteManufacturerResponder = {
  with202(): KoaRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error
    id: string
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type ManufacturersDeleteManufacturer = (
  params: Params<
    t_ManufacturersDeleteManufacturerParamSchema,
    t_ManufacturersDeleteManufacturerQuerySchema,
    void,
    t_ManufacturersDeleteManufacturerRequestHeaderSchema
  >,
  respond: ManufacturersDeleteManufacturerResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        error?: t_Azure_Core_Foundations_Error
        id: string
        status: t_Azure_Core_Foundations_OperationState
      }
    >
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type ManufacturersListManufacturersResponder = {
  with200(): KoaRuntimeResponse<t_PagedManufacturer>
  withDefault(
    status: StatusCode,
  ): KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & KoaRuntimeResponder

export type ManufacturersListManufacturers = (
  params: Params<
    void,
    t_ManufacturersListManufacturersQuerySchema,
    void,
    t_ManufacturersListManufacturersRequestHeaderSchema
  >,
  respond: ManufacturersListManufacturersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_PagedManufacturer>
  | Response<StatusCode, t_Azure_Core_Foundations_ErrorResponse>
  | typeof SkipResponse
>

export type Implementation = {
  getServiceStatus: GetServiceStatus
  widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus: WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus
  widgetsCreateOrUpdateWidget: WidgetsCreateOrUpdateWidget
  widgetsGetWidget: WidgetsGetWidget
  widgetsDeleteWidget: WidgetsDeleteWidget
  widgetsListWidgets: WidgetsListWidgets
  widgetsGetAnalytics: WidgetsGetAnalytics
  widgetsUpdateAnalytics: WidgetsUpdateAnalytics
  widgetsGetRepairStatus: WidgetsGetRepairStatus
  widgetsScheduleRepairs: WidgetsScheduleRepairs
  widgetPartsGetWidgetPartOperationStatus: WidgetPartsGetWidgetPartOperationStatus
  widgetPartsCreateWidgetPart: WidgetPartsCreateWidgetPart
  widgetPartsListWidgetParts: WidgetPartsListWidgetParts
  widgetPartsGetWidgetPart: WidgetPartsGetWidgetPart
  widgetPartsDeleteWidgetPart: WidgetPartsDeleteWidgetPart
  widgetPartsReorderParts: WidgetPartsReorderParts
  manufacturersGetManufacturerOperationStatus: ManufacturersGetManufacturerOperationStatus
  manufacturersCreateOrReplaceManufacturer: ManufacturersCreateOrReplaceManufacturer
  manufacturersGetManufacturer: ManufacturersGetManufacturer
  manufacturersDeleteManufacturer: ManufacturersDeleteManufacturer
  manufacturersListManufacturers: ManufacturersListManufacturers
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const getServiceStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const getServiceStatusRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const getServiceStatusResponseValidator = responseValidationFactory(
    [["200", z.object({statusString: z.string()})]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.get("getServiceStatus", "/service-status", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getServiceStatusQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: parseRequestInput(
        getServiceStatusRequestHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          statusString: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
          status,
        )
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getServiceStatus(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getServiceStatusResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema =
    z.object({widgetName: z.string(), operationId: z.string()})

  const widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema =
    z.object({"api-version": z.string().min(1)})

  const widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.object({
              id: z.string(),
              status: s_Azure_Core_Foundations_OperationState,
              error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
              result: s_Widget.optional(),
            }),
            z.object({
              id: z.string(),
              status: s_Azure_Core_Foundations_OperationState,
              error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
            }),
          ]),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.get(
    "widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus",
    "/widgets/:widgetName/operations/:operationId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            | {
                error?: t_Azure_Core_Foundations_Error
                id: string
                result?: t_Widget
                status: t_Azure_Core_Foundations_OperationState
              }
            | {
                error?: t_Azure_Core_Foundations_Error
                id: string
                status: t_Azure_Core_Foundations_OperationState
              }
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const widgetsCreateOrUpdateWidgetParamSchema = z.object({
    widgetName: z.string(),
  })

  const widgetsCreateOrUpdateWidgetQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsCreateOrUpdateWidgetRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsCreateOrUpdateWidgetResponseValidator =
    responseValidationFactory(
      [
        ["200", s_Widget],
        ["201", s_Widget],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.patch(
    "widgetsCreateOrUpdateWidget",
    "/widgets/:widgetName",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetsCreateOrUpdateWidgetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetsCreateOrUpdateWidgetQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          s_WidgetCreateOrUpdate,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: parseRequestInput(
          widgetsCreateOrUpdateWidgetRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Widget>(200)
        },
        with201() {
          return new KoaRuntimeResponse<t_Widget>(201)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetsCreateOrUpdateWidget(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetsCreateOrUpdateWidgetResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetsGetWidgetParamSchema = z.object({widgetName: z.string()})

  const widgetsGetWidgetQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsGetWidgetRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsGetWidgetResponseValidator = responseValidationFactory(
    [["200", s_Widget]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.get("widgetsGetWidget", "/widgets/:widgetName", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        widgetsGetWidgetParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        widgetsGetWidgetQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: parseRequestInput(
        widgetsGetWidgetRequestHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Widget>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
          status,
        )
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .widgetsGetWidget(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = widgetsGetWidgetResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const widgetsDeleteWidgetParamSchema = z.object({widgetName: z.string()})

  const widgetsDeleteWidgetQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsDeleteWidgetRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsDeleteWidgetResponseValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({
          id: z.string(),
          status: s_Azure_Core_Foundations_OperationState,
          error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
        }),
      ],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.delete(
    "widgetsDeleteWidget",
    "/widgets/:widgetName",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetsDeleteWidgetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetsDeleteWidgetQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          widgetsDeleteWidgetRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with202() {
          return new KoaRuntimeResponse<{
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_Azure_Core_Foundations_OperationState
          }>(202)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetsDeleteWidget(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetsDeleteWidgetResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetsListWidgetsQuerySchema = z.object({
    "api-version": z.string().min(1),
    top: z.coerce.number().optional(),
    skip: z.coerce.number().optional().default(0),
    maxpagesize: z.coerce.number().optional(),
    select: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()),
      )
      .optional(),
  })

  const widgetsListWidgetsRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsListWidgetsResponseValidator = responseValidationFactory(
    [["200", s_PagedWidget]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.get("widgetsListWidgets", "/widgets", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        widgetsListWidgetsQuerySchema,
        parseQueryParameters(ctx.querystring, [
          {
            name: "api-version",
            explode: false,
            style: "form",
            schema: {type: "string"},
          },
          {
            name: "top",
            explode: false,
            style: "form",
            schema: {type: "number"},
          },
          {
            name: "skip",
            explode: false,
            style: "form",
            schema: {type: "number"},
          },
          {
            name: "maxpagesize",
            explode: false,
            style: "form",
            schema: {type: "number"},
          },
          {
            name: "select",
            explode: true,
            style: "form",
            schema: {type: "array", items: {type: "string"}},
          },
        ]),
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: parseRequestInput(
        widgetsListWidgetsRequestHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_PagedWidget>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
          status,
        )
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .widgetsListWidgets(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = widgetsListWidgetsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const widgetsGetAnalyticsParamSchema = z.object({widgetName: z.string()})

  const widgetsGetAnalyticsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsGetAnalyticsRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsGetAnalyticsResponseValidator = responseValidationFactory(
    [["200", s_WidgetAnalytics]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.get(
    "widgetsGetAnalytics",
    "/widgets/:widgetName/analytics/current",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetsGetAnalyticsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetsGetAnalyticsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          widgetsGetAnalyticsRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_WidgetAnalytics>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetsGetAnalytics(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetsGetAnalyticsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetsUpdateAnalyticsParamSchema = z.object({widgetName: z.string()})

  const widgetsUpdateAnalyticsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsUpdateAnalyticsRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsUpdateAnalyticsResponseValidator = responseValidationFactory(
    [
      ["200", s_WidgetAnalytics],
      ["201", s_WidgetAnalytics],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.patch(
    "widgetsUpdateAnalytics",
    "/widgets/:widgetName/analytics/current",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetsUpdateAnalyticsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetsUpdateAnalyticsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          s_WidgetAnalyticsCreateOrUpdate,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: parseRequestInput(
          widgetsUpdateAnalyticsRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_WidgetAnalytics>(200)
        },
        with201() {
          return new KoaRuntimeResponse<t_WidgetAnalytics>(201)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetsUpdateAnalytics(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetsUpdateAnalyticsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetsGetRepairStatusParamSchema = z.object({
    widgetId: z.string(),
    operationId: z.string(),
  })

  const widgetsGetRepairStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsGetRepairStatusResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          id: z.string(),
          status: s_Azure_Core_Foundations_OperationState,
          error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
          result: s_WidgetRepairRequest.optional(),
        }),
      ],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.get(
    "widgetsGetRepairStatus",
    "/widgets/:widgetId/repairs/:operationId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetsGetRepairStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetsGetRepairStatusQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_WidgetRepairRequest
            status: t_Azure_Core_Foundations_OperationState
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetsGetRepairStatus(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetsGetRepairStatusResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetsScheduleRepairsParamSchema = z.object({widgetName: z.string()})

  const widgetsScheduleRepairsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsScheduleRepairsRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsScheduleRepairsResponseValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({
          id: z.string(),
          status: s_Azure_Core_Foundations_OperationState,
          error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
          result: z
            .object({
              requestState: s_WidgetRepairState,
              scheduledDateTime: z.iso.datetime({offset: true}),
              createdDateTime: z.iso.datetime({offset: true}),
              updatedDateTime: z.iso.datetime({offset: true}),
              completedDateTime: z.iso.datetime({offset: true}),
            })
            .optional(),
        }),
      ],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.post(
    "widgetsScheduleRepairs",
    "/widgets/:widgetName:scheduleRepairs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetsScheduleRepairsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetsScheduleRepairsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          s_WidgetRepairRequest,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: parseRequestInput(
          widgetsScheduleRepairsRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with202() {
          return new KoaRuntimeResponse<{
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: {
              completedDateTime: string
              createdDateTime: string
              requestState: t_WidgetRepairState
              scheduledDateTime: string
              updatedDateTime: string
            }
            status: t_Azure_Core_Foundations_OperationState
          }>(202)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetsScheduleRepairs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetsScheduleRepairsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetPartsGetWidgetPartOperationStatusParamSchema = z.object({
    widgetName: z.string(),
    widgetPartName: z.string(),
    operationId: z.string(),
  })

  const widgetPartsGetWidgetPartOperationStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsGetWidgetPartOperationStatusResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            id: z.string(),
            status: s_Azure_Core_Foundations_OperationState,
            error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
            result: s_WidgetPart.optional(),
          }),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.get(
    "widgetPartsGetWidgetPartOperationStatus",
    "/widgets/:widgetName/parts/:widgetPartName/operations/:operationId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetPartsGetWidgetPartOperationStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetPartsGetWidgetPartOperationStatusQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_WidgetPart
            status: t_Azure_Core_Foundations_OperationState
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetPartsGetWidgetPartOperationStatus(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetPartsGetWidgetPartOperationStatusResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const widgetPartsCreateWidgetPartParamSchema = z.object({
    widgetName: z.string(),
  })

  const widgetPartsCreateWidgetPartQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsCreateWidgetPartRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsCreateWidgetPartResponseValidator =
    responseValidationFactory(
      [["201", z.undefined()]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.post(
    "widgetPartsCreateWidgetPart",
    "/widgets/:widgetName/parts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetPartsCreateWidgetPartParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetPartsCreateWidgetPartQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          s_WidgetPart,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: parseRequestInput(
          widgetPartsCreateWidgetPartRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with201() {
          return new KoaRuntimeResponse<void>(201)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetPartsCreateWidgetPart(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetPartsCreateWidgetPartResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetPartsListWidgetPartsParamSchema = z.object({
    widgetName: z.string(),
  })

  const widgetPartsListWidgetPartsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsListWidgetPartsRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsListWidgetPartsResponseValidator = responseValidationFactory(
    [["200", s_PagedWidgetPart]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.get(
    "widgetPartsListWidgetParts",
    "/widgets/:widgetName/parts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetPartsListWidgetPartsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetPartsListWidgetPartsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          widgetPartsListWidgetPartsRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_PagedWidgetPart>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetPartsListWidgetParts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetPartsListWidgetPartsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetPartsGetWidgetPartParamSchema = z.object({
    widgetName: z.string(),
    widgetPartName: z.string(),
  })

  const widgetPartsGetWidgetPartQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsGetWidgetPartRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsGetWidgetPartResponseValidator = responseValidationFactory(
    [["200", s_WidgetPart]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.get(
    "widgetPartsGetWidgetPart",
    "/widgets/:widgetName/parts/:widgetPartName",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetPartsGetWidgetPartParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetPartsGetWidgetPartQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          widgetPartsGetWidgetPartRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_WidgetPart>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetPartsGetWidgetPart(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetPartsGetWidgetPartResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetPartsDeleteWidgetPartParamSchema = z.object({
    widgetName: z.string(),
    widgetPartName: z.string(),
  })

  const widgetPartsDeleteWidgetPartQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsDeleteWidgetPartRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsDeleteWidgetPartResponseValidator =
    responseValidationFactory(
      [["204", z.undefined()]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.delete(
    "widgetPartsDeleteWidgetPart",
    "/widgets/:widgetName/parts/:widgetPartName",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetPartsDeleteWidgetPartParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetPartsDeleteWidgetPartQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          widgetPartsDeleteWidgetPartRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetPartsDeleteWidgetPart(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetPartsDeleteWidgetPartResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const widgetPartsReorderPartsParamSchema = z.object({widgetName: z.string()})

  const widgetPartsReorderPartsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsReorderPartsRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsReorderPartsResponseValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({
          id: z.string(),
          status: s_Azure_Core_Foundations_OperationState,
          error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
        }),
      ],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  router.post(
    "widgetPartsReorderParts",
    "/widgets/:widgetName/parts:reorderParts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          widgetPartsReorderPartsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          widgetPartsReorderPartsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          s_WidgetPartReorderRequest,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: parseRequestInput(
          widgetPartsReorderPartsRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with202() {
          return new KoaRuntimeResponse<{
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_Azure_Core_Foundations_OperationState
          }>(202)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .widgetPartsReorderParts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = widgetPartsReorderPartsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const manufacturersGetManufacturerOperationStatusParamSchema = z.object({
    manufacturerId: z.string(),
    operationId: z.string(),
  })

  const manufacturersGetManufacturerOperationStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersGetManufacturerOperationStatusResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            id: z.string(),
            status: s_Azure_Core_Foundations_OperationState,
            error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
            result: s_Manufacturer.optional(),
          }),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.get(
    "manufacturersGetManufacturerOperationStatus",
    "/manufacturers/:manufacturerId/operations/:operationId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          manufacturersGetManufacturerOperationStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          manufacturersGetManufacturerOperationStatusQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            error?: t_Azure_Core_Foundations_Error
            id: string
            result?: t_Manufacturer
            status: t_Azure_Core_Foundations_OperationState
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .manufacturersGetManufacturerOperationStatus(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = manufacturersGetManufacturerOperationStatusResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const manufacturersCreateOrReplaceManufacturerParamSchema = z.object({
    manufacturerId: z.string(),
  })

  const manufacturersCreateOrReplaceManufacturerQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersCreateOrReplaceManufacturerRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersCreateOrReplaceManufacturerResponseValidator =
    responseValidationFactory(
      [
        ["200", s_Manufacturer],
        ["201", s_Manufacturer],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.put(
    "manufacturersCreateOrReplaceManufacturer",
    "/manufacturers/:manufacturerId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          manufacturersCreateOrReplaceManufacturerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          manufacturersCreateOrReplaceManufacturerQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          s_Manufacturer,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: parseRequestInput(
          manufacturersCreateOrReplaceManufacturerRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Manufacturer>(200)
        },
        with201() {
          return new KoaRuntimeResponse<t_Manufacturer>(201)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .manufacturersCreateOrReplaceManufacturer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = manufacturersCreateOrReplaceManufacturerResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const manufacturersGetManufacturerParamSchema = z.object({
    manufacturerId: z.string(),
  })

  const manufacturersGetManufacturerQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersGetManufacturerRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersGetManufacturerResponseValidator =
    responseValidationFactory(
      [["200", s_Manufacturer]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.get(
    "manufacturersGetManufacturer",
    "/manufacturers/:manufacturerId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          manufacturersGetManufacturerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          manufacturersGetManufacturerQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          manufacturersGetManufacturerRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Manufacturer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .manufacturersGetManufacturer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = manufacturersGetManufacturerResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const manufacturersDeleteManufacturerParamSchema = z.object({
    manufacturerId: z.string(),
  })

  const manufacturersDeleteManufacturerQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersDeleteManufacturerRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersDeleteManufacturerResponseValidator =
    responseValidationFactory(
      [
        [
          "202",
          z.object({
            id: z.string(),
            status: s_Azure_Core_Foundations_OperationState,
            error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
          }),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.delete(
    "manufacturersDeleteManufacturer",
    "/manufacturers/:manufacturerId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          manufacturersDeleteManufacturerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          manufacturersDeleteManufacturerQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          manufacturersDeleteManufacturerRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with202() {
          return new KoaRuntimeResponse<{
            error?: t_Azure_Core_Foundations_Error
            id: string
            status: t_Azure_Core_Foundations_OperationState
          }>(202)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .manufacturersDeleteManufacturer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = manufacturersDeleteManufacturerResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const manufacturersListManufacturersQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersListManufacturersRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersListManufacturersResponseValidator =
    responseValidationFactory(
      [["200", s_PagedManufacturer]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  router.get(
    "manufacturersListManufacturers",
    "/manufacturers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          manufacturersListManufacturersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: parseRequestInput(
          manufacturersListManufacturersRequestHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_PagedManufacturer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
            status,
          )
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .manufacturersListManufacturers(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = manufacturersListManufacturersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Contoso Widget Manager
  return startServer(config)
}
