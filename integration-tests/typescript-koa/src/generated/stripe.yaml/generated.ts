/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_DeleteAccountsAccountBankAccountsIdBodySchema,
  t_DeleteAccountsAccountBankAccountsIdParamSchema,
  t_DeleteAccountsAccountBodySchema,
  t_DeleteAccountsAccountExternalAccountsIdBodySchema,
  t_DeleteAccountsAccountExternalAccountsIdParamSchema,
  t_DeleteAccountsAccountParamSchema,
  t_DeleteAccountsAccountPeoplePersonBodySchema,
  t_DeleteAccountsAccountPeoplePersonParamSchema,
  t_DeleteAccountsAccountPersonsPersonBodySchema,
  t_DeleteAccountsAccountPersonsPersonParamSchema,
  t_DeleteApplePayDomainsDomainBodySchema,
  t_DeleteApplePayDomainsDomainParamSchema,
  t_DeleteCouponsCouponBodySchema,
  t_DeleteCouponsCouponParamSchema,
  t_DeleteCustomersCustomerBankAccountsIdBodySchema,
  t_DeleteCustomersCustomerBankAccountsIdParamSchema,
  t_DeleteCustomersCustomerBodySchema,
  t_DeleteCustomersCustomerCardsIdBodySchema,
  t_DeleteCustomersCustomerCardsIdParamSchema,
  t_DeleteCustomersCustomerDiscountBodySchema,
  t_DeleteCustomersCustomerDiscountParamSchema,
  t_DeleteCustomersCustomerParamSchema,
  t_DeleteCustomersCustomerSourcesIdBodySchema,
  t_DeleteCustomersCustomerSourcesIdParamSchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_DeleteCustomersCustomerTaxIdsIdBodySchema,
  t_DeleteCustomersCustomerTaxIdsIdParamSchema,
  t_DeleteEphemeralKeysKeyBodySchema,
  t_DeleteEphemeralKeysKeyParamSchema,
  t_DeleteInvoiceitemsInvoiceitemBodySchema,
  t_DeleteInvoiceitemsInvoiceitemParamSchema,
  t_DeleteInvoicesInvoiceBodySchema,
  t_DeleteInvoicesInvoiceParamSchema,
  t_DeletePlansPlanBodySchema,
  t_DeletePlansPlanParamSchema,
  t_DeleteProductsIdBodySchema,
  t_DeleteProductsIdParamSchema,
  t_DeleteProductsProductFeaturesIdBodySchema,
  t_DeleteProductsProductFeaturesIdParamSchema,
  t_DeleteRadarValueListItemsItemBodySchema,
  t_DeleteRadarValueListItemsItemParamSchema,
  t_DeleteRadarValueListsValueListBodySchema,
  t_DeleteRadarValueListsValueListParamSchema,
  t_DeleteSubscriptionItemsItemBodySchema,
  t_DeleteSubscriptionItemsItemParamSchema,
  t_DeleteSubscriptionsSubscriptionExposedIdBodySchema,
  t_DeleteSubscriptionsSubscriptionExposedIdDiscountBodySchema,
  t_DeleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_DeleteSubscriptionsSubscriptionExposedIdParamSchema,
  t_DeleteTaxIdsIdBodySchema,
  t_DeleteTaxIdsIdParamSchema,
  t_DeleteTerminalConfigurationsConfigurationBodySchema,
  t_DeleteTerminalConfigurationsConfigurationParamSchema,
  t_DeleteTerminalLocationsLocationBodySchema,
  t_DeleteTerminalLocationsLocationParamSchema,
  t_DeleteTerminalReadersReaderBodySchema,
  t_DeleteTerminalReadersReaderParamSchema,
  t_DeleteTestHelpersTestClocksTestClockBodySchema,
  t_DeleteTestHelpersTestClocksTestClockParamSchema,
  t_DeleteWebhookEndpointsWebhookEndpointBodySchema,
  t_DeleteWebhookEndpointsWebhookEndpointParamSchema,
  t_GetAccountBodySchema,
  t_GetAccountQuerySchema,
  t_GetAccountsAccountBankAccountsIdBodySchema,
  t_GetAccountsAccountBankAccountsIdParamSchema,
  t_GetAccountsAccountBankAccountsIdQuerySchema,
  t_GetAccountsAccountBodySchema,
  t_GetAccountsAccountCapabilitiesBodySchema,
  t_GetAccountsAccountCapabilitiesCapabilityBodySchema,
  t_GetAccountsAccountCapabilitiesCapabilityParamSchema,
  t_GetAccountsAccountCapabilitiesCapabilityQuerySchema,
  t_GetAccountsAccountCapabilitiesParamSchema,
  t_GetAccountsAccountCapabilitiesQuerySchema,
  t_GetAccountsAccountExternalAccountsBodySchema,
  t_GetAccountsAccountExternalAccountsIdBodySchema,
  t_GetAccountsAccountExternalAccountsIdParamSchema,
  t_GetAccountsAccountExternalAccountsIdQuerySchema,
  t_GetAccountsAccountExternalAccountsParamSchema,
  t_GetAccountsAccountExternalAccountsQuerySchema,
  t_GetAccountsAccountParamSchema,
  t_GetAccountsAccountPeopleBodySchema,
  t_GetAccountsAccountPeopleParamSchema,
  t_GetAccountsAccountPeoplePersonBodySchema,
  t_GetAccountsAccountPeoplePersonParamSchema,
  t_GetAccountsAccountPeoplePersonQuerySchema,
  t_GetAccountsAccountPeopleQuerySchema,
  t_GetAccountsAccountPersonsBodySchema,
  t_GetAccountsAccountPersonsParamSchema,
  t_GetAccountsAccountPersonsPersonBodySchema,
  t_GetAccountsAccountPersonsPersonParamSchema,
  t_GetAccountsAccountPersonsPersonQuerySchema,
  t_GetAccountsAccountPersonsQuerySchema,
  t_GetAccountsAccountQuerySchema,
  t_GetAccountsBodySchema,
  t_GetAccountsQuerySchema,
  t_GetApplePayDomainsBodySchema,
  t_GetApplePayDomainsDomainBodySchema,
  t_GetApplePayDomainsDomainParamSchema,
  t_GetApplePayDomainsDomainQuerySchema,
  t_GetApplePayDomainsQuerySchema,
  t_GetApplicationFeesBodySchema,
  t_GetApplicationFeesFeeRefundsIdBodySchema,
  t_GetApplicationFeesFeeRefundsIdParamSchema,
  t_GetApplicationFeesFeeRefundsIdQuerySchema,
  t_GetApplicationFeesIdBodySchema,
  t_GetApplicationFeesIdParamSchema,
  t_GetApplicationFeesIdQuerySchema,
  t_GetApplicationFeesIdRefundsBodySchema,
  t_GetApplicationFeesIdRefundsParamSchema,
  t_GetApplicationFeesIdRefundsQuerySchema,
  t_GetApplicationFeesQuerySchema,
  t_GetAppsSecretsBodySchema,
  t_GetAppsSecretsFindBodySchema,
  t_GetAppsSecretsFindQuerySchema,
  t_GetAppsSecretsQuerySchema,
  t_GetBalanceBodySchema,
  t_GetBalanceHistoryBodySchema,
  t_GetBalanceHistoryIdBodySchema,
  t_GetBalanceHistoryIdParamSchema,
  t_GetBalanceHistoryIdQuerySchema,
  t_GetBalanceHistoryQuerySchema,
  t_GetBalanceQuerySchema,
  t_GetBalanceTransactionsBodySchema,
  t_GetBalanceTransactionsIdBodySchema,
  t_GetBalanceTransactionsIdParamSchema,
  t_GetBalanceTransactionsIdQuerySchema,
  t_GetBalanceTransactionsQuerySchema,
  t_GetBillingAlertsBodySchema,
  t_GetBillingAlertsIdBodySchema,
  t_GetBillingAlertsIdParamSchema,
  t_GetBillingAlertsIdQuerySchema,
  t_GetBillingAlertsQuerySchema,
  t_GetBillingCreditBalanceSummaryBodySchema,
  t_GetBillingCreditBalanceSummaryQuerySchema,
  t_GetBillingCreditBalanceTransactionsBodySchema,
  t_GetBillingCreditBalanceTransactionsIdBodySchema,
  t_GetBillingCreditBalanceTransactionsIdParamSchema,
  t_GetBillingCreditBalanceTransactionsIdQuerySchema,
  t_GetBillingCreditBalanceTransactionsQuerySchema,
  t_GetBillingCreditGrantsBodySchema,
  t_GetBillingCreditGrantsIdBodySchema,
  t_GetBillingCreditGrantsIdParamSchema,
  t_GetBillingCreditGrantsIdQuerySchema,
  t_GetBillingCreditGrantsQuerySchema,
  t_GetBillingMetersBodySchema,
  t_GetBillingMetersIdBodySchema,
  t_GetBillingMetersIdEventSummariesBodySchema,
  t_GetBillingMetersIdEventSummariesParamSchema,
  t_GetBillingMetersIdEventSummariesQuerySchema,
  t_GetBillingMetersIdParamSchema,
  t_GetBillingMetersIdQuerySchema,
  t_GetBillingMetersQuerySchema,
  t_GetBillingPortalConfigurationsBodySchema,
  t_GetBillingPortalConfigurationsConfigurationBodySchema,
  t_GetBillingPortalConfigurationsConfigurationParamSchema,
  t_GetBillingPortalConfigurationsConfigurationQuerySchema,
  t_GetBillingPortalConfigurationsQuerySchema,
  t_GetChargesBodySchema,
  t_GetChargesChargeBodySchema,
  t_GetChargesChargeDisputeBodySchema,
  t_GetChargesChargeDisputeParamSchema,
  t_GetChargesChargeDisputeQuerySchema,
  t_GetChargesChargeParamSchema,
  t_GetChargesChargeQuerySchema,
  t_GetChargesChargeRefundsBodySchema,
  t_GetChargesChargeRefundsParamSchema,
  t_GetChargesChargeRefundsQuerySchema,
  t_GetChargesChargeRefundsRefundBodySchema,
  t_GetChargesChargeRefundsRefundParamSchema,
  t_GetChargesChargeRefundsRefundQuerySchema,
  t_GetChargesQuerySchema,
  t_GetChargesSearchBodySchema,
  t_GetChargesSearchQuerySchema,
  t_GetCheckoutSessionsBodySchema,
  t_GetCheckoutSessionsQuerySchema,
  t_GetCheckoutSessionsSessionBodySchema,
  t_GetCheckoutSessionsSessionLineItemsBodySchema,
  t_GetCheckoutSessionsSessionLineItemsParamSchema,
  t_GetCheckoutSessionsSessionLineItemsQuerySchema,
  t_GetCheckoutSessionsSessionParamSchema,
  t_GetCheckoutSessionsSessionQuerySchema,
  t_GetClimateOrdersBodySchema,
  t_GetClimateOrdersOrderBodySchema,
  t_GetClimateOrdersOrderParamSchema,
  t_GetClimateOrdersOrderQuerySchema,
  t_GetClimateOrdersQuerySchema,
  t_GetClimateProductsBodySchema,
  t_GetClimateProductsProductBodySchema,
  t_GetClimateProductsProductParamSchema,
  t_GetClimateProductsProductQuerySchema,
  t_GetClimateProductsQuerySchema,
  t_GetClimateSuppliersBodySchema,
  t_GetClimateSuppliersQuerySchema,
  t_GetClimateSuppliersSupplierBodySchema,
  t_GetClimateSuppliersSupplierParamSchema,
  t_GetClimateSuppliersSupplierQuerySchema,
  t_GetConfirmationTokensConfirmationTokenBodySchema,
  t_GetConfirmationTokensConfirmationTokenParamSchema,
  t_GetConfirmationTokensConfirmationTokenQuerySchema,
  t_GetCountrySpecsBodySchema,
  t_GetCountrySpecsCountryBodySchema,
  t_GetCountrySpecsCountryParamSchema,
  t_GetCountrySpecsCountryQuerySchema,
  t_GetCountrySpecsQuerySchema,
  t_GetCouponsBodySchema,
  t_GetCouponsCouponBodySchema,
  t_GetCouponsCouponParamSchema,
  t_GetCouponsCouponQuerySchema,
  t_GetCouponsQuerySchema,
  t_GetCreditNotesBodySchema,
  t_GetCreditNotesCreditNoteLinesBodySchema,
  t_GetCreditNotesCreditNoteLinesParamSchema,
  t_GetCreditNotesCreditNoteLinesQuerySchema,
  t_GetCreditNotesIdBodySchema,
  t_GetCreditNotesIdParamSchema,
  t_GetCreditNotesIdQuerySchema,
  t_GetCreditNotesPreviewBodySchema,
  t_GetCreditNotesPreviewLinesBodySchema,
  t_GetCreditNotesPreviewLinesQuerySchema,
  t_GetCreditNotesPreviewQuerySchema,
  t_GetCreditNotesQuerySchema,
  t_GetCustomersBodySchema,
  t_GetCustomersCustomerBalanceTransactionsBodySchema,
  t_GetCustomersCustomerBalanceTransactionsParamSchema,
  t_GetCustomersCustomerBalanceTransactionsQuerySchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionBodySchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionParamSchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionQuerySchema,
  t_GetCustomersCustomerBankAccountsBodySchema,
  t_GetCustomersCustomerBankAccountsIdBodySchema,
  t_GetCustomersCustomerBankAccountsIdParamSchema,
  t_GetCustomersCustomerBankAccountsIdQuerySchema,
  t_GetCustomersCustomerBankAccountsParamSchema,
  t_GetCustomersCustomerBankAccountsQuerySchema,
  t_GetCustomersCustomerBodySchema,
  t_GetCustomersCustomerCardsBodySchema,
  t_GetCustomersCustomerCardsIdBodySchema,
  t_GetCustomersCustomerCardsIdParamSchema,
  t_GetCustomersCustomerCardsIdQuerySchema,
  t_GetCustomersCustomerCardsParamSchema,
  t_GetCustomersCustomerCardsQuerySchema,
  t_GetCustomersCustomerCashBalanceBodySchema,
  t_GetCustomersCustomerCashBalanceParamSchema,
  t_GetCustomersCustomerCashBalanceQuerySchema,
  t_GetCustomersCustomerCashBalanceTransactionsBodySchema,
  t_GetCustomersCustomerCashBalanceTransactionsParamSchema,
  t_GetCustomersCustomerCashBalanceTransactionsQuerySchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionBodySchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
  t_GetCustomersCustomerDiscountBodySchema,
  t_GetCustomersCustomerDiscountParamSchema,
  t_GetCustomersCustomerDiscountQuerySchema,
  t_GetCustomersCustomerParamSchema,
  t_GetCustomersCustomerPaymentMethodsBodySchema,
  t_GetCustomersCustomerPaymentMethodsParamSchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodBodySchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
  t_GetCustomersCustomerPaymentMethodsQuerySchema,
  t_GetCustomersCustomerQuerySchema,
  t_GetCustomersCustomerSourcesBodySchema,
  t_GetCustomersCustomerSourcesIdBodySchema,
  t_GetCustomersCustomerSourcesIdParamSchema,
  t_GetCustomersCustomerSourcesIdQuerySchema,
  t_GetCustomersCustomerSourcesParamSchema,
  t_GetCustomersCustomerSourcesQuerySchema,
  t_GetCustomersCustomerSubscriptionsBodySchema,
  t_GetCustomersCustomerSubscriptionsParamSchema,
  t_GetCustomersCustomerSubscriptionsQuerySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
  t_GetCustomersCustomerTaxIdsBodySchema,
  t_GetCustomersCustomerTaxIdsIdBodySchema,
  t_GetCustomersCustomerTaxIdsIdParamSchema,
  t_GetCustomersCustomerTaxIdsIdQuerySchema,
  t_GetCustomersCustomerTaxIdsParamSchema,
  t_GetCustomersCustomerTaxIdsQuerySchema,
  t_GetCustomersQuerySchema,
  t_GetCustomersSearchBodySchema,
  t_GetCustomersSearchQuerySchema,
  t_GetDisputesBodySchema,
  t_GetDisputesDisputeBodySchema,
  t_GetDisputesDisputeParamSchema,
  t_GetDisputesDisputeQuerySchema,
  t_GetDisputesQuerySchema,
  t_GetEntitlementsActiveEntitlementsBodySchema,
  t_GetEntitlementsActiveEntitlementsIdBodySchema,
  t_GetEntitlementsActiveEntitlementsIdParamSchema,
  t_GetEntitlementsActiveEntitlementsIdQuerySchema,
  t_GetEntitlementsActiveEntitlementsQuerySchema,
  t_GetEntitlementsFeaturesBodySchema,
  t_GetEntitlementsFeaturesIdBodySchema,
  t_GetEntitlementsFeaturesIdParamSchema,
  t_GetEntitlementsFeaturesIdQuerySchema,
  t_GetEntitlementsFeaturesQuerySchema,
  t_GetEventsBodySchema,
  t_GetEventsIdBodySchema,
  t_GetEventsIdParamSchema,
  t_GetEventsIdQuerySchema,
  t_GetEventsQuerySchema,
  t_GetExchangeRatesBodySchema,
  t_GetExchangeRatesQuerySchema,
  t_GetExchangeRatesRateIdBodySchema,
  t_GetExchangeRatesRateIdParamSchema,
  t_GetExchangeRatesRateIdQuerySchema,
  t_GetFileLinksBodySchema,
  t_GetFileLinksLinkBodySchema,
  t_GetFileLinksLinkParamSchema,
  t_GetFileLinksLinkQuerySchema,
  t_GetFileLinksQuerySchema,
  t_GetFilesBodySchema,
  t_GetFilesFileBodySchema,
  t_GetFilesFileParamSchema,
  t_GetFilesFileQuerySchema,
  t_GetFilesQuerySchema,
  t_GetFinancialConnectionsAccountsAccountBodySchema,
  t_GetFinancialConnectionsAccountsAccountOwnersBodySchema,
  t_GetFinancialConnectionsAccountsAccountOwnersParamSchema,
  t_GetFinancialConnectionsAccountsAccountOwnersQuerySchema,
  t_GetFinancialConnectionsAccountsAccountParamSchema,
  t_GetFinancialConnectionsAccountsAccountQuerySchema,
  t_GetFinancialConnectionsAccountsBodySchema,
  t_GetFinancialConnectionsAccountsQuerySchema,
  t_GetFinancialConnectionsSessionsSessionBodySchema,
  t_GetFinancialConnectionsSessionsSessionParamSchema,
  t_GetFinancialConnectionsSessionsSessionQuerySchema,
  t_GetFinancialConnectionsTransactionsBodySchema,
  t_GetFinancialConnectionsTransactionsQuerySchema,
  t_GetFinancialConnectionsTransactionsTransactionBodySchema,
  t_GetFinancialConnectionsTransactionsTransactionParamSchema,
  t_GetFinancialConnectionsTransactionsTransactionQuerySchema,
  t_GetForwardingRequestsBodySchema,
  t_GetForwardingRequestsIdBodySchema,
  t_GetForwardingRequestsIdParamSchema,
  t_GetForwardingRequestsIdQuerySchema,
  t_GetForwardingRequestsQuerySchema,
  t_GetIdentityVerificationReportsBodySchema,
  t_GetIdentityVerificationReportsQuerySchema,
  t_GetIdentityVerificationReportsReportBodySchema,
  t_GetIdentityVerificationReportsReportParamSchema,
  t_GetIdentityVerificationReportsReportQuerySchema,
  t_GetIdentityVerificationSessionsBodySchema,
  t_GetIdentityVerificationSessionsQuerySchema,
  t_GetIdentityVerificationSessionsSessionBodySchema,
  t_GetIdentityVerificationSessionsSessionParamSchema,
  t_GetIdentityVerificationSessionsSessionQuerySchema,
  t_GetInvoicePaymentsBodySchema,
  t_GetInvoicePaymentsInvoicePaymentBodySchema,
  t_GetInvoicePaymentsInvoicePaymentParamSchema,
  t_GetInvoicePaymentsInvoicePaymentQuerySchema,
  t_GetInvoicePaymentsQuerySchema,
  t_GetInvoiceRenderingTemplatesBodySchema,
  t_GetInvoiceRenderingTemplatesQuerySchema,
  t_GetInvoiceRenderingTemplatesTemplateBodySchema,
  t_GetInvoiceRenderingTemplatesTemplateParamSchema,
  t_GetInvoiceRenderingTemplatesTemplateQuerySchema,
  t_GetInvoiceitemsBodySchema,
  t_GetInvoiceitemsInvoiceitemBodySchema,
  t_GetInvoiceitemsInvoiceitemParamSchema,
  t_GetInvoiceitemsInvoiceitemQuerySchema,
  t_GetInvoiceitemsQuerySchema,
  t_GetInvoicesBodySchema,
  t_GetInvoicesInvoiceBodySchema,
  t_GetInvoicesInvoiceLinesBodySchema,
  t_GetInvoicesInvoiceLinesParamSchema,
  t_GetInvoicesInvoiceLinesQuerySchema,
  t_GetInvoicesInvoiceParamSchema,
  t_GetInvoicesInvoiceQuerySchema,
  t_GetInvoicesQuerySchema,
  t_GetInvoicesSearchBodySchema,
  t_GetInvoicesSearchQuerySchema,
  t_GetIssuingAuthorizationsAuthorizationBodySchema,
  t_GetIssuingAuthorizationsAuthorizationParamSchema,
  t_GetIssuingAuthorizationsAuthorizationQuerySchema,
  t_GetIssuingAuthorizationsBodySchema,
  t_GetIssuingAuthorizationsQuerySchema,
  t_GetIssuingCardholdersBodySchema,
  t_GetIssuingCardholdersCardholderBodySchema,
  t_GetIssuingCardholdersCardholderParamSchema,
  t_GetIssuingCardholdersCardholderQuerySchema,
  t_GetIssuingCardholdersQuerySchema,
  t_GetIssuingCardsBodySchema,
  t_GetIssuingCardsCardBodySchema,
  t_GetIssuingCardsCardParamSchema,
  t_GetIssuingCardsCardQuerySchema,
  t_GetIssuingCardsQuerySchema,
  t_GetIssuingDisputesBodySchema,
  t_GetIssuingDisputesDisputeBodySchema,
  t_GetIssuingDisputesDisputeParamSchema,
  t_GetIssuingDisputesDisputeQuerySchema,
  t_GetIssuingDisputesQuerySchema,
  t_GetIssuingPersonalizationDesignsBodySchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
  t_GetIssuingPersonalizationDesignsQuerySchema,
  t_GetIssuingPhysicalBundlesBodySchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleBodySchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleParamSchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleQuerySchema,
  t_GetIssuingPhysicalBundlesQuerySchema,
  t_GetIssuingSettlementsSettlementBodySchema,
  t_GetIssuingSettlementsSettlementParamSchema,
  t_GetIssuingSettlementsSettlementQuerySchema,
  t_GetIssuingTokensBodySchema,
  t_GetIssuingTokensQuerySchema,
  t_GetIssuingTokensTokenBodySchema,
  t_GetIssuingTokensTokenParamSchema,
  t_GetIssuingTokensTokenQuerySchema,
  t_GetIssuingTransactionsBodySchema,
  t_GetIssuingTransactionsQuerySchema,
  t_GetIssuingTransactionsTransactionBodySchema,
  t_GetIssuingTransactionsTransactionParamSchema,
  t_GetIssuingTransactionsTransactionQuerySchema,
  t_GetLinkAccountSessionsSessionBodySchema,
  t_GetLinkAccountSessionsSessionParamSchema,
  t_GetLinkAccountSessionsSessionQuerySchema,
  t_GetLinkedAccountsAccountBodySchema,
  t_GetLinkedAccountsAccountOwnersBodySchema,
  t_GetLinkedAccountsAccountOwnersParamSchema,
  t_GetLinkedAccountsAccountOwnersQuerySchema,
  t_GetLinkedAccountsAccountParamSchema,
  t_GetLinkedAccountsAccountQuerySchema,
  t_GetLinkedAccountsBodySchema,
  t_GetLinkedAccountsQuerySchema,
  t_GetMandatesMandateBodySchema,
  t_GetMandatesMandateParamSchema,
  t_GetMandatesMandateQuerySchema,
  t_GetPaymentIntentsBodySchema,
  t_GetPaymentIntentsIntentBodySchema,
  t_GetPaymentIntentsIntentParamSchema,
  t_GetPaymentIntentsIntentQuerySchema,
  t_GetPaymentIntentsQuerySchema,
  t_GetPaymentIntentsSearchBodySchema,
  t_GetPaymentIntentsSearchQuerySchema,
  t_GetPaymentLinksBodySchema,
  t_GetPaymentLinksPaymentLinkBodySchema,
  t_GetPaymentLinksPaymentLinkLineItemsBodySchema,
  t_GetPaymentLinksPaymentLinkLineItemsParamSchema,
  t_GetPaymentLinksPaymentLinkLineItemsQuerySchema,
  t_GetPaymentLinksPaymentLinkParamSchema,
  t_GetPaymentLinksPaymentLinkQuerySchema,
  t_GetPaymentLinksQuerySchema,
  t_GetPaymentMethodConfigurationsBodySchema,
  t_GetPaymentMethodConfigurationsConfigurationBodySchema,
  t_GetPaymentMethodConfigurationsConfigurationParamSchema,
  t_GetPaymentMethodConfigurationsConfigurationQuerySchema,
  t_GetPaymentMethodConfigurationsQuerySchema,
  t_GetPaymentMethodDomainsBodySchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainBodySchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainParamSchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainQuerySchema,
  t_GetPaymentMethodDomainsQuerySchema,
  t_GetPaymentMethodsBodySchema,
  t_GetPaymentMethodsPaymentMethodBodySchema,
  t_GetPaymentMethodsPaymentMethodParamSchema,
  t_GetPaymentMethodsPaymentMethodQuerySchema,
  t_GetPaymentMethodsQuerySchema,
  t_GetPayoutsBodySchema,
  t_GetPayoutsPayoutBodySchema,
  t_GetPayoutsPayoutParamSchema,
  t_GetPayoutsPayoutQuerySchema,
  t_GetPayoutsQuerySchema,
  t_GetPlansBodySchema,
  t_GetPlansPlanBodySchema,
  t_GetPlansPlanParamSchema,
  t_GetPlansPlanQuerySchema,
  t_GetPlansQuerySchema,
  t_GetPricesBodySchema,
  t_GetPricesPriceBodySchema,
  t_GetPricesPriceParamSchema,
  t_GetPricesPriceQuerySchema,
  t_GetPricesQuerySchema,
  t_GetPricesSearchBodySchema,
  t_GetPricesSearchQuerySchema,
  t_GetProductsBodySchema,
  t_GetProductsIdBodySchema,
  t_GetProductsIdParamSchema,
  t_GetProductsIdQuerySchema,
  t_GetProductsProductFeaturesBodySchema,
  t_GetProductsProductFeaturesIdBodySchema,
  t_GetProductsProductFeaturesIdParamSchema,
  t_GetProductsProductFeaturesIdQuerySchema,
  t_GetProductsProductFeaturesParamSchema,
  t_GetProductsProductFeaturesQuerySchema,
  t_GetProductsQuerySchema,
  t_GetProductsSearchBodySchema,
  t_GetProductsSearchQuerySchema,
  t_GetPromotionCodesBodySchema,
  t_GetPromotionCodesPromotionCodeBodySchema,
  t_GetPromotionCodesPromotionCodeParamSchema,
  t_GetPromotionCodesPromotionCodeQuerySchema,
  t_GetPromotionCodesQuerySchema,
  t_GetQuotesBodySchema,
  t_GetQuotesQuerySchema,
  t_GetQuotesQuoteBodySchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsBodySchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsParamSchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsQuerySchema,
  t_GetQuotesQuoteLineItemsBodySchema,
  t_GetQuotesQuoteLineItemsParamSchema,
  t_GetQuotesQuoteLineItemsQuerySchema,
  t_GetQuotesQuoteParamSchema,
  t_GetQuotesQuotePdfBodySchema,
  t_GetQuotesQuotePdfParamSchema,
  t_GetQuotesQuotePdfQuerySchema,
  t_GetQuotesQuoteQuerySchema,
  t_GetRadarEarlyFraudWarningsBodySchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningBodySchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
  t_GetRadarEarlyFraudWarningsQuerySchema,
  t_GetRadarValueListItemsBodySchema,
  t_GetRadarValueListItemsItemBodySchema,
  t_GetRadarValueListItemsItemParamSchema,
  t_GetRadarValueListItemsItemQuerySchema,
  t_GetRadarValueListItemsQuerySchema,
  t_GetRadarValueListsBodySchema,
  t_GetRadarValueListsQuerySchema,
  t_GetRadarValueListsValueListBodySchema,
  t_GetRadarValueListsValueListParamSchema,
  t_GetRadarValueListsValueListQuerySchema,
  t_GetRefundsBodySchema,
  t_GetRefundsQuerySchema,
  t_GetRefundsRefundBodySchema,
  t_GetRefundsRefundParamSchema,
  t_GetRefundsRefundQuerySchema,
  t_GetReportingReportRunsBodySchema,
  t_GetReportingReportRunsQuerySchema,
  t_GetReportingReportRunsReportRunBodySchema,
  t_GetReportingReportRunsReportRunParamSchema,
  t_GetReportingReportRunsReportRunQuerySchema,
  t_GetReportingReportTypesBodySchema,
  t_GetReportingReportTypesQuerySchema,
  t_GetReportingReportTypesReportTypeBodySchema,
  t_GetReportingReportTypesReportTypeParamSchema,
  t_GetReportingReportTypesReportTypeQuerySchema,
  t_GetReviewsBodySchema,
  t_GetReviewsQuerySchema,
  t_GetReviewsReviewBodySchema,
  t_GetReviewsReviewParamSchema,
  t_GetReviewsReviewQuerySchema,
  t_GetSetupAttemptsBodySchema,
  t_GetSetupAttemptsQuerySchema,
  t_GetSetupIntentsBodySchema,
  t_GetSetupIntentsIntentBodySchema,
  t_GetSetupIntentsIntentParamSchema,
  t_GetSetupIntentsIntentQuerySchema,
  t_GetSetupIntentsQuerySchema,
  t_GetShippingRatesBodySchema,
  t_GetShippingRatesQuerySchema,
  t_GetShippingRatesShippingRateTokenBodySchema,
  t_GetShippingRatesShippingRateTokenParamSchema,
  t_GetShippingRatesShippingRateTokenQuerySchema,
  t_GetSigmaScheduledQueryRunsBodySchema,
  t_GetSigmaScheduledQueryRunsQuerySchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunBodySchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
  t_GetSourcesSourceBodySchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationBodySchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationParamSchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
  t_GetSourcesSourceParamSchema,
  t_GetSourcesSourceQuerySchema,
  t_GetSourcesSourceSourceTransactionsBodySchema,
  t_GetSourcesSourceSourceTransactionsParamSchema,
  t_GetSourcesSourceSourceTransactionsQuerySchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionBodySchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionParamSchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
  t_GetSubscriptionItemsBodySchema,
  t_GetSubscriptionItemsItemBodySchema,
  t_GetSubscriptionItemsItemParamSchema,
  t_GetSubscriptionItemsItemQuerySchema,
  t_GetSubscriptionItemsQuerySchema,
  t_GetSubscriptionSchedulesBodySchema,
  t_GetSubscriptionSchedulesQuerySchema,
  t_GetSubscriptionSchedulesScheduleBodySchema,
  t_GetSubscriptionSchedulesScheduleParamSchema,
  t_GetSubscriptionSchedulesScheduleQuerySchema,
  t_GetSubscriptionsBodySchema,
  t_GetSubscriptionsQuerySchema,
  t_GetSubscriptionsSearchBodySchema,
  t_GetSubscriptionsSearchQuerySchema,
  t_GetSubscriptionsSubscriptionExposedIdBodySchema,
  t_GetSubscriptionsSubscriptionExposedIdParamSchema,
  t_GetSubscriptionsSubscriptionExposedIdQuerySchema,
  t_GetTaxCalculationsCalculationBodySchema,
  t_GetTaxCalculationsCalculationLineItemsBodySchema,
  t_GetTaxCalculationsCalculationLineItemsParamSchema,
  t_GetTaxCalculationsCalculationLineItemsQuerySchema,
  t_GetTaxCalculationsCalculationParamSchema,
  t_GetTaxCalculationsCalculationQuerySchema,
  t_GetTaxCodesBodySchema,
  t_GetTaxCodesIdBodySchema,
  t_GetTaxCodesIdParamSchema,
  t_GetTaxCodesIdQuerySchema,
  t_GetTaxCodesQuerySchema,
  t_GetTaxIdsBodySchema,
  t_GetTaxIdsIdBodySchema,
  t_GetTaxIdsIdParamSchema,
  t_GetTaxIdsIdQuerySchema,
  t_GetTaxIdsQuerySchema,
  t_GetTaxRatesBodySchema,
  t_GetTaxRatesQuerySchema,
  t_GetTaxRatesTaxRateBodySchema,
  t_GetTaxRatesTaxRateParamSchema,
  t_GetTaxRatesTaxRateQuerySchema,
  t_GetTaxRegistrationsBodySchema,
  t_GetTaxRegistrationsIdBodySchema,
  t_GetTaxRegistrationsIdParamSchema,
  t_GetTaxRegistrationsIdQuerySchema,
  t_GetTaxRegistrationsQuerySchema,
  t_GetTaxSettingsBodySchema,
  t_GetTaxSettingsQuerySchema,
  t_GetTaxTransactionsTransactionBodySchema,
  t_GetTaxTransactionsTransactionLineItemsBodySchema,
  t_GetTaxTransactionsTransactionLineItemsParamSchema,
  t_GetTaxTransactionsTransactionLineItemsQuerySchema,
  t_GetTaxTransactionsTransactionParamSchema,
  t_GetTaxTransactionsTransactionQuerySchema,
  t_GetTerminalConfigurationsBodySchema,
  t_GetTerminalConfigurationsConfigurationBodySchema,
  t_GetTerminalConfigurationsConfigurationParamSchema,
  t_GetTerminalConfigurationsConfigurationQuerySchema,
  t_GetTerminalConfigurationsQuerySchema,
  t_GetTerminalLocationsBodySchema,
  t_GetTerminalLocationsLocationBodySchema,
  t_GetTerminalLocationsLocationParamSchema,
  t_GetTerminalLocationsLocationQuerySchema,
  t_GetTerminalLocationsQuerySchema,
  t_GetTerminalReadersBodySchema,
  t_GetTerminalReadersQuerySchema,
  t_GetTerminalReadersReaderBodySchema,
  t_GetTerminalReadersReaderParamSchema,
  t_GetTerminalReadersReaderQuerySchema,
  t_GetTestHelpersTestClocksBodySchema,
  t_GetTestHelpersTestClocksQuerySchema,
  t_GetTestHelpersTestClocksTestClockBodySchema,
  t_GetTestHelpersTestClocksTestClockParamSchema,
  t_GetTestHelpersTestClocksTestClockQuerySchema,
  t_GetTokensTokenBodySchema,
  t_GetTokensTokenParamSchema,
  t_GetTokensTokenQuerySchema,
  t_GetTopupsBodySchema,
  t_GetTopupsQuerySchema,
  t_GetTopupsTopupBodySchema,
  t_GetTopupsTopupParamSchema,
  t_GetTopupsTopupQuerySchema,
  t_GetTransfersBodySchema,
  t_GetTransfersIdReversalsBodySchema,
  t_GetTransfersIdReversalsParamSchema,
  t_GetTransfersIdReversalsQuerySchema,
  t_GetTransfersQuerySchema,
  t_GetTransfersTransferBodySchema,
  t_GetTransfersTransferParamSchema,
  t_GetTransfersTransferQuerySchema,
  t_GetTransfersTransferReversalsIdBodySchema,
  t_GetTransfersTransferReversalsIdParamSchema,
  t_GetTransfersTransferReversalsIdQuerySchema,
  t_GetTreasuryCreditReversalsBodySchema,
  t_GetTreasuryCreditReversalsCreditReversalBodySchema,
  t_GetTreasuryCreditReversalsCreditReversalParamSchema,
  t_GetTreasuryCreditReversalsCreditReversalQuerySchema,
  t_GetTreasuryCreditReversalsQuerySchema,
  t_GetTreasuryDebitReversalsBodySchema,
  t_GetTreasuryDebitReversalsDebitReversalBodySchema,
  t_GetTreasuryDebitReversalsDebitReversalParamSchema,
  t_GetTreasuryDebitReversalsDebitReversalQuerySchema,
  t_GetTreasuryDebitReversalsQuerySchema,
  t_GetTreasuryFinancialAccountsBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountParamSchema,
  t_GetTreasuryFinancialAccountsFinancialAccountQuerySchema,
  t_GetTreasuryFinancialAccountsQuerySchema,
  t_GetTreasuryInboundTransfersBodySchema,
  t_GetTreasuryInboundTransfersIdBodySchema,
  t_GetTreasuryInboundTransfersIdParamSchema,
  t_GetTreasuryInboundTransfersIdQuerySchema,
  t_GetTreasuryInboundTransfersQuerySchema,
  t_GetTreasuryOutboundPaymentsBodySchema,
  t_GetTreasuryOutboundPaymentsIdBodySchema,
  t_GetTreasuryOutboundPaymentsIdParamSchema,
  t_GetTreasuryOutboundPaymentsIdQuerySchema,
  t_GetTreasuryOutboundPaymentsQuerySchema,
  t_GetTreasuryOutboundTransfersBodySchema,
  t_GetTreasuryOutboundTransfersOutboundTransferBodySchema,
  t_GetTreasuryOutboundTransfersOutboundTransferParamSchema,
  t_GetTreasuryOutboundTransfersOutboundTransferQuerySchema,
  t_GetTreasuryOutboundTransfersQuerySchema,
  t_GetTreasuryReceivedCreditsBodySchema,
  t_GetTreasuryReceivedCreditsIdBodySchema,
  t_GetTreasuryReceivedCreditsIdParamSchema,
  t_GetTreasuryReceivedCreditsIdQuerySchema,
  t_GetTreasuryReceivedCreditsQuerySchema,
  t_GetTreasuryReceivedDebitsBodySchema,
  t_GetTreasuryReceivedDebitsIdBodySchema,
  t_GetTreasuryReceivedDebitsIdParamSchema,
  t_GetTreasuryReceivedDebitsIdQuerySchema,
  t_GetTreasuryReceivedDebitsQuerySchema,
  t_GetTreasuryTransactionEntriesBodySchema,
  t_GetTreasuryTransactionEntriesIdBodySchema,
  t_GetTreasuryTransactionEntriesIdParamSchema,
  t_GetTreasuryTransactionEntriesIdQuerySchema,
  t_GetTreasuryTransactionEntriesQuerySchema,
  t_GetTreasuryTransactionsBodySchema,
  t_GetTreasuryTransactionsIdBodySchema,
  t_GetTreasuryTransactionsIdParamSchema,
  t_GetTreasuryTransactionsIdQuerySchema,
  t_GetTreasuryTransactionsQuerySchema,
  t_GetWebhookEndpointsBodySchema,
  t_GetWebhookEndpointsQuerySchema,
  t_GetWebhookEndpointsWebhookEndpointBodySchema,
  t_GetWebhookEndpointsWebhookEndpointParamSchema,
  t_GetWebhookEndpointsWebhookEndpointQuerySchema,
  t_PostAccountLinksBodySchema,
  t_PostAccountSessionsBodySchema,
  t_PostAccountsAccountBankAccountsBodySchema,
  t_PostAccountsAccountBankAccountsIdBodySchema,
  t_PostAccountsAccountBankAccountsIdParamSchema,
  t_PostAccountsAccountBankAccountsParamSchema,
  t_PostAccountsAccountBodySchema,
  t_PostAccountsAccountCapabilitiesCapabilityBodySchema,
  t_PostAccountsAccountCapabilitiesCapabilityParamSchema,
  t_PostAccountsAccountExternalAccountsBodySchema,
  t_PostAccountsAccountExternalAccountsIdBodySchema,
  t_PostAccountsAccountExternalAccountsIdParamSchema,
  t_PostAccountsAccountExternalAccountsParamSchema,
  t_PostAccountsAccountLoginLinksBodySchema,
  t_PostAccountsAccountLoginLinksParamSchema,
  t_PostAccountsAccountParamSchema,
  t_PostAccountsAccountPeopleBodySchema,
  t_PostAccountsAccountPeopleParamSchema,
  t_PostAccountsAccountPeoplePersonBodySchema,
  t_PostAccountsAccountPeoplePersonParamSchema,
  t_PostAccountsAccountPersonsBodySchema,
  t_PostAccountsAccountPersonsParamSchema,
  t_PostAccountsAccountPersonsPersonBodySchema,
  t_PostAccountsAccountPersonsPersonParamSchema,
  t_PostAccountsAccountRejectBodySchema,
  t_PostAccountsAccountRejectParamSchema,
  t_PostAccountsBodySchema,
  t_PostApplePayDomainsBodySchema,
  t_PostApplicationFeesFeeRefundsIdBodySchema,
  t_PostApplicationFeesFeeRefundsIdParamSchema,
  t_PostApplicationFeesIdRefundBodySchema,
  t_PostApplicationFeesIdRefundParamSchema,
  t_PostApplicationFeesIdRefundsBodySchema,
  t_PostApplicationFeesIdRefundsParamSchema,
  t_PostAppsSecretsBodySchema,
  t_PostAppsSecretsDeleteBodySchema,
  t_PostBillingAlertsBodySchema,
  t_PostBillingAlertsIdActivateBodySchema,
  t_PostBillingAlertsIdActivateParamSchema,
  t_PostBillingAlertsIdArchiveBodySchema,
  t_PostBillingAlertsIdArchiveParamSchema,
  t_PostBillingAlertsIdDeactivateBodySchema,
  t_PostBillingAlertsIdDeactivateParamSchema,
  t_PostBillingCreditGrantsBodySchema,
  t_PostBillingCreditGrantsIdBodySchema,
  t_PostBillingCreditGrantsIdExpireBodySchema,
  t_PostBillingCreditGrantsIdExpireParamSchema,
  t_PostBillingCreditGrantsIdParamSchema,
  t_PostBillingCreditGrantsIdVoidBodySchema,
  t_PostBillingCreditGrantsIdVoidParamSchema,
  t_PostBillingMeterEventAdjustmentsBodySchema,
  t_PostBillingMeterEventsBodySchema,
  t_PostBillingMetersBodySchema,
  t_PostBillingMetersIdBodySchema,
  t_PostBillingMetersIdDeactivateBodySchema,
  t_PostBillingMetersIdDeactivateParamSchema,
  t_PostBillingMetersIdParamSchema,
  t_PostBillingMetersIdReactivateBodySchema,
  t_PostBillingMetersIdReactivateParamSchema,
  t_PostBillingPortalConfigurationsBodySchema,
  t_PostBillingPortalConfigurationsConfigurationBodySchema,
  t_PostBillingPortalConfigurationsConfigurationParamSchema,
  t_PostBillingPortalSessionsBodySchema,
  t_PostChargesBodySchema,
  t_PostChargesChargeBodySchema,
  t_PostChargesChargeCaptureBodySchema,
  t_PostChargesChargeCaptureParamSchema,
  t_PostChargesChargeDisputeBodySchema,
  t_PostChargesChargeDisputeCloseBodySchema,
  t_PostChargesChargeDisputeCloseParamSchema,
  t_PostChargesChargeDisputeParamSchema,
  t_PostChargesChargeParamSchema,
  t_PostChargesChargeRefundBodySchema,
  t_PostChargesChargeRefundParamSchema,
  t_PostChargesChargeRefundsBodySchema,
  t_PostChargesChargeRefundsParamSchema,
  t_PostChargesChargeRefundsRefundBodySchema,
  t_PostChargesChargeRefundsRefundParamSchema,
  t_PostCheckoutSessionsBodySchema,
  t_PostCheckoutSessionsSessionBodySchema,
  t_PostCheckoutSessionsSessionExpireBodySchema,
  t_PostCheckoutSessionsSessionExpireParamSchema,
  t_PostCheckoutSessionsSessionParamSchema,
  t_PostClimateOrdersBodySchema,
  t_PostClimateOrdersOrderBodySchema,
  t_PostClimateOrdersOrderCancelBodySchema,
  t_PostClimateOrdersOrderCancelParamSchema,
  t_PostClimateOrdersOrderParamSchema,
  t_PostCouponsBodySchema,
  t_PostCouponsCouponBodySchema,
  t_PostCouponsCouponParamSchema,
  t_PostCreditNotesBodySchema,
  t_PostCreditNotesIdBodySchema,
  t_PostCreditNotesIdParamSchema,
  t_PostCreditNotesIdVoidBodySchema,
  t_PostCreditNotesIdVoidParamSchema,
  t_PostCustomerSessionsBodySchema,
  t_PostCustomersBodySchema,
  t_PostCustomersCustomerBalanceTransactionsBodySchema,
  t_PostCustomersCustomerBalanceTransactionsParamSchema,
  t_PostCustomersCustomerBalanceTransactionsTransactionBodySchema,
  t_PostCustomersCustomerBalanceTransactionsTransactionParamSchema,
  t_PostCustomersCustomerBankAccountsBodySchema,
  t_PostCustomersCustomerBankAccountsIdBodySchema,
  t_PostCustomersCustomerBankAccountsIdParamSchema,
  t_PostCustomersCustomerBankAccountsIdVerifyBodySchema,
  t_PostCustomersCustomerBankAccountsIdVerifyParamSchema,
  t_PostCustomersCustomerBankAccountsParamSchema,
  t_PostCustomersCustomerBodySchema,
  t_PostCustomersCustomerCardsBodySchema,
  t_PostCustomersCustomerCardsIdBodySchema,
  t_PostCustomersCustomerCardsIdParamSchema,
  t_PostCustomersCustomerCardsParamSchema,
  t_PostCustomersCustomerCashBalanceBodySchema,
  t_PostCustomersCustomerCashBalanceParamSchema,
  t_PostCustomersCustomerFundingInstructionsBodySchema,
  t_PostCustomersCustomerFundingInstructionsParamSchema,
  t_PostCustomersCustomerParamSchema,
  t_PostCustomersCustomerSourcesBodySchema,
  t_PostCustomersCustomerSourcesIdBodySchema,
  t_PostCustomersCustomerSourcesIdParamSchema,
  t_PostCustomersCustomerSourcesIdVerifyBodySchema,
  t_PostCustomersCustomerSourcesIdVerifyParamSchema,
  t_PostCustomersCustomerSourcesParamSchema,
  t_PostCustomersCustomerSubscriptionsBodySchema,
  t_PostCustomersCustomerSubscriptionsParamSchema,
  t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
  t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_PostCustomersCustomerTaxIdsBodySchema,
  t_PostCustomersCustomerTaxIdsParamSchema,
  t_PostDisputesDisputeBodySchema,
  t_PostDisputesDisputeCloseBodySchema,
  t_PostDisputesDisputeCloseParamSchema,
  t_PostDisputesDisputeParamSchema,
  t_PostEntitlementsFeaturesBodySchema,
  t_PostEntitlementsFeaturesIdBodySchema,
  t_PostEntitlementsFeaturesIdParamSchema,
  t_PostEphemeralKeysBodySchema,
  t_PostExternalAccountsIdBodySchema,
  t_PostExternalAccountsIdParamSchema,
  t_PostFileLinksBodySchema,
  t_PostFileLinksLinkBodySchema,
  t_PostFileLinksLinkParamSchema,
  t_PostFilesBodySchema,
  t_PostFinancialConnectionsAccountsAccountDisconnectBodySchema,
  t_PostFinancialConnectionsAccountsAccountDisconnectParamSchema,
  t_PostFinancialConnectionsAccountsAccountRefreshBodySchema,
  t_PostFinancialConnectionsAccountsAccountRefreshParamSchema,
  t_PostFinancialConnectionsAccountsAccountSubscribeBodySchema,
  t_PostFinancialConnectionsAccountsAccountSubscribeParamSchema,
  t_PostFinancialConnectionsAccountsAccountUnsubscribeBodySchema,
  t_PostFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
  t_PostFinancialConnectionsSessionsBodySchema,
  t_PostForwardingRequestsBodySchema,
  t_PostIdentityVerificationSessionsBodySchema,
  t_PostIdentityVerificationSessionsSessionBodySchema,
  t_PostIdentityVerificationSessionsSessionCancelBodySchema,
  t_PostIdentityVerificationSessionsSessionCancelParamSchema,
  t_PostIdentityVerificationSessionsSessionParamSchema,
  t_PostIdentityVerificationSessionsSessionRedactBodySchema,
  t_PostIdentityVerificationSessionsSessionRedactParamSchema,
  t_PostInvoiceRenderingTemplatesTemplateArchiveBodySchema,
  t_PostInvoiceRenderingTemplatesTemplateArchiveParamSchema,
  t_PostInvoiceRenderingTemplatesTemplateUnarchiveBodySchema,
  t_PostInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
  t_PostInvoiceitemsBodySchema,
  t_PostInvoiceitemsInvoiceitemBodySchema,
  t_PostInvoiceitemsInvoiceitemParamSchema,
  t_PostInvoicesBodySchema,
  t_PostInvoicesCreatePreviewBodySchema,
  t_PostInvoicesInvoiceAddLinesBodySchema,
  t_PostInvoicesInvoiceAddLinesParamSchema,
  t_PostInvoicesInvoiceAttachPaymentBodySchema,
  t_PostInvoicesInvoiceAttachPaymentParamSchema,
  t_PostInvoicesInvoiceBodySchema,
  t_PostInvoicesInvoiceFinalizeBodySchema,
  t_PostInvoicesInvoiceFinalizeParamSchema,
  t_PostInvoicesInvoiceLinesLineItemIdBodySchema,
  t_PostInvoicesInvoiceLinesLineItemIdParamSchema,
  t_PostInvoicesInvoiceMarkUncollectibleBodySchema,
  t_PostInvoicesInvoiceMarkUncollectibleParamSchema,
  t_PostInvoicesInvoiceParamSchema,
  t_PostInvoicesInvoicePayBodySchema,
  t_PostInvoicesInvoicePayParamSchema,
  t_PostInvoicesInvoiceRemoveLinesBodySchema,
  t_PostInvoicesInvoiceRemoveLinesParamSchema,
  t_PostInvoicesInvoiceSendBodySchema,
  t_PostInvoicesInvoiceSendParamSchema,
  t_PostInvoicesInvoiceUpdateLinesBodySchema,
  t_PostInvoicesInvoiceUpdateLinesParamSchema,
  t_PostInvoicesInvoiceVoidBodySchema,
  t_PostInvoicesInvoiceVoidParamSchema,
  t_PostIssuingAuthorizationsAuthorizationApproveBodySchema,
  t_PostIssuingAuthorizationsAuthorizationApproveParamSchema,
  t_PostIssuingAuthorizationsAuthorizationBodySchema,
  t_PostIssuingAuthorizationsAuthorizationDeclineBodySchema,
  t_PostIssuingAuthorizationsAuthorizationDeclineParamSchema,
  t_PostIssuingAuthorizationsAuthorizationParamSchema,
  t_PostIssuingCardholdersBodySchema,
  t_PostIssuingCardholdersCardholderBodySchema,
  t_PostIssuingCardholdersCardholderParamSchema,
  t_PostIssuingCardsBodySchema,
  t_PostIssuingCardsCardBodySchema,
  t_PostIssuingCardsCardParamSchema,
  t_PostIssuingDisputesBodySchema,
  t_PostIssuingDisputesDisputeBodySchema,
  t_PostIssuingDisputesDisputeParamSchema,
  t_PostIssuingDisputesDisputeSubmitBodySchema,
  t_PostIssuingDisputesDisputeSubmitParamSchema,
  t_PostIssuingPersonalizationDesignsBodySchema,
  t_PostIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
  t_PostIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
  t_PostIssuingSettlementsSettlementBodySchema,
  t_PostIssuingSettlementsSettlementParamSchema,
  t_PostIssuingTokensTokenBodySchema,
  t_PostIssuingTokensTokenParamSchema,
  t_PostIssuingTransactionsTransactionBodySchema,
  t_PostIssuingTransactionsTransactionParamSchema,
  t_PostLinkAccountSessionsBodySchema,
  t_PostLinkedAccountsAccountDisconnectBodySchema,
  t_PostLinkedAccountsAccountDisconnectParamSchema,
  t_PostLinkedAccountsAccountRefreshBodySchema,
  t_PostLinkedAccountsAccountRefreshParamSchema,
  t_PostPaymentIntentsBodySchema,
  t_PostPaymentIntentsIntentApplyCustomerBalanceBodySchema,
  t_PostPaymentIntentsIntentApplyCustomerBalanceParamSchema,
  t_PostPaymentIntentsIntentBodySchema,
  t_PostPaymentIntentsIntentCancelBodySchema,
  t_PostPaymentIntentsIntentCancelParamSchema,
  t_PostPaymentIntentsIntentCaptureBodySchema,
  t_PostPaymentIntentsIntentCaptureParamSchema,
  t_PostPaymentIntentsIntentConfirmBodySchema,
  t_PostPaymentIntentsIntentConfirmParamSchema,
  t_PostPaymentIntentsIntentIncrementAuthorizationBodySchema,
  t_PostPaymentIntentsIntentIncrementAuthorizationParamSchema,
  t_PostPaymentIntentsIntentParamSchema,
  t_PostPaymentIntentsIntentVerifyMicrodepositsBodySchema,
  t_PostPaymentIntentsIntentVerifyMicrodepositsParamSchema,
  t_PostPaymentLinksBodySchema,
  t_PostPaymentLinksPaymentLinkBodySchema,
  t_PostPaymentLinksPaymentLinkParamSchema,
  t_PostPaymentMethodConfigurationsBodySchema,
  t_PostPaymentMethodConfigurationsConfigurationBodySchema,
  t_PostPaymentMethodConfigurationsConfigurationParamSchema,
  t_PostPaymentMethodDomainsBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainParamSchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainValidateBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
  t_PostPaymentMethodsBodySchema,
  t_PostPaymentMethodsPaymentMethodAttachBodySchema,
  t_PostPaymentMethodsPaymentMethodAttachParamSchema,
  t_PostPaymentMethodsPaymentMethodBodySchema,
  t_PostPaymentMethodsPaymentMethodDetachBodySchema,
  t_PostPaymentMethodsPaymentMethodDetachParamSchema,
  t_PostPaymentMethodsPaymentMethodParamSchema,
  t_PostPayoutsBodySchema,
  t_PostPayoutsPayoutBodySchema,
  t_PostPayoutsPayoutCancelBodySchema,
  t_PostPayoutsPayoutCancelParamSchema,
  t_PostPayoutsPayoutParamSchema,
  t_PostPayoutsPayoutReverseBodySchema,
  t_PostPayoutsPayoutReverseParamSchema,
  t_PostPlansBodySchema,
  t_PostPlansPlanBodySchema,
  t_PostPlansPlanParamSchema,
  t_PostPricesBodySchema,
  t_PostPricesPriceBodySchema,
  t_PostPricesPriceParamSchema,
  t_PostProductsBodySchema,
  t_PostProductsIdBodySchema,
  t_PostProductsIdParamSchema,
  t_PostProductsProductFeaturesBodySchema,
  t_PostProductsProductFeaturesParamSchema,
  t_PostPromotionCodesBodySchema,
  t_PostPromotionCodesPromotionCodeBodySchema,
  t_PostPromotionCodesPromotionCodeParamSchema,
  t_PostQuotesBodySchema,
  t_PostQuotesQuoteAcceptBodySchema,
  t_PostQuotesQuoteAcceptParamSchema,
  t_PostQuotesQuoteBodySchema,
  t_PostQuotesQuoteCancelBodySchema,
  t_PostQuotesQuoteCancelParamSchema,
  t_PostQuotesQuoteFinalizeBodySchema,
  t_PostQuotesQuoteFinalizeParamSchema,
  t_PostQuotesQuoteParamSchema,
  t_PostRadarValueListItemsBodySchema,
  t_PostRadarValueListsBodySchema,
  t_PostRadarValueListsValueListBodySchema,
  t_PostRadarValueListsValueListParamSchema,
  t_PostRefundsBodySchema,
  t_PostRefundsRefundBodySchema,
  t_PostRefundsRefundCancelBodySchema,
  t_PostRefundsRefundCancelParamSchema,
  t_PostRefundsRefundParamSchema,
  t_PostReportingReportRunsBodySchema,
  t_PostReviewsReviewApproveBodySchema,
  t_PostReviewsReviewApproveParamSchema,
  t_PostSetupIntentsBodySchema,
  t_PostSetupIntentsIntentBodySchema,
  t_PostSetupIntentsIntentCancelBodySchema,
  t_PostSetupIntentsIntentCancelParamSchema,
  t_PostSetupIntentsIntentConfirmBodySchema,
  t_PostSetupIntentsIntentConfirmParamSchema,
  t_PostSetupIntentsIntentParamSchema,
  t_PostSetupIntentsIntentVerifyMicrodepositsBodySchema,
  t_PostSetupIntentsIntentVerifyMicrodepositsParamSchema,
  t_PostShippingRatesBodySchema,
  t_PostShippingRatesShippingRateTokenBodySchema,
  t_PostShippingRatesShippingRateTokenParamSchema,
  t_PostSigmaSavedQueriesIdBodySchema,
  t_PostSigmaSavedQueriesIdParamSchema,
  t_PostSourcesBodySchema,
  t_PostSourcesSourceBodySchema,
  t_PostSourcesSourceParamSchema,
  t_PostSourcesSourceVerifyBodySchema,
  t_PostSourcesSourceVerifyParamSchema,
  t_PostSubscriptionItemsBodySchema,
  t_PostSubscriptionItemsItemBodySchema,
  t_PostSubscriptionItemsItemParamSchema,
  t_PostSubscriptionSchedulesBodySchema,
  t_PostSubscriptionSchedulesScheduleBodySchema,
  t_PostSubscriptionSchedulesScheduleCancelBodySchema,
  t_PostSubscriptionSchedulesScheduleCancelParamSchema,
  t_PostSubscriptionSchedulesScheduleParamSchema,
  t_PostSubscriptionSchedulesScheduleReleaseBodySchema,
  t_PostSubscriptionSchedulesScheduleReleaseParamSchema,
  t_PostSubscriptionsBodySchema,
  t_PostSubscriptionsSubscriptionExposedIdBodySchema,
  t_PostSubscriptionsSubscriptionExposedIdParamSchema,
  t_PostSubscriptionsSubscriptionMigrateBodySchema,
  t_PostSubscriptionsSubscriptionMigrateParamSchema,
  t_PostSubscriptionsSubscriptionResumeBodySchema,
  t_PostSubscriptionsSubscriptionResumeParamSchema,
  t_PostTaxCalculationsBodySchema,
  t_PostTaxIdsBodySchema,
  t_PostTaxRatesBodySchema,
  t_PostTaxRatesTaxRateBodySchema,
  t_PostTaxRatesTaxRateParamSchema,
  t_PostTaxRegistrationsBodySchema,
  t_PostTaxRegistrationsIdBodySchema,
  t_PostTaxRegistrationsIdParamSchema,
  t_PostTaxSettingsBodySchema,
  t_PostTaxTransactionsCreateFromCalculationBodySchema,
  t_PostTaxTransactionsCreateReversalBodySchema,
  t_PostTerminalConfigurationsBodySchema,
  t_PostTerminalConfigurationsConfigurationBodySchema,
  t_PostTerminalConfigurationsConfigurationParamSchema,
  t_PostTerminalConnectionTokensBodySchema,
  t_PostTerminalLocationsBodySchema,
  t_PostTerminalLocationsLocationBodySchema,
  t_PostTerminalLocationsLocationParamSchema,
  t_PostTerminalReadersBodySchema,
  t_PostTerminalReadersReaderBodySchema,
  t_PostTerminalReadersReaderCancelActionBodySchema,
  t_PostTerminalReadersReaderCancelActionParamSchema,
  t_PostTerminalReadersReaderCollectInputsBodySchema,
  t_PostTerminalReadersReaderCollectInputsParamSchema,
  t_PostTerminalReadersReaderCollectPaymentMethodBodySchema,
  t_PostTerminalReadersReaderCollectPaymentMethodParamSchema,
  t_PostTerminalReadersReaderConfirmPaymentIntentBodySchema,
  t_PostTerminalReadersReaderConfirmPaymentIntentParamSchema,
  t_PostTerminalReadersReaderParamSchema,
  t_PostTerminalReadersReaderProcessPaymentIntentBodySchema,
  t_PostTerminalReadersReaderProcessPaymentIntentParamSchema,
  t_PostTerminalReadersReaderProcessSetupIntentBodySchema,
  t_PostTerminalReadersReaderProcessSetupIntentParamSchema,
  t_PostTerminalReadersReaderRefundPaymentBodySchema,
  t_PostTerminalReadersReaderRefundPaymentParamSchema,
  t_PostTerminalReadersReaderSetReaderDisplayBodySchema,
  t_PostTerminalReadersReaderSetReaderDisplayParamSchema,
  t_PostTestHelpersConfirmationTokensBodySchema,
  t_PostTestHelpersCustomersCustomerFundCashBalanceBodySchema,
  t_PostTestHelpersCustomersCustomerFundCashBalanceParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
  t_PostTestHelpersIssuingAuthorizationsBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingDeliverBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingDeliverParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingFailBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingFailParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingReturnBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingReturnParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingShipBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingShipParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingSubmitBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingSubmitParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
  t_PostTestHelpersIssuingSettlementsBodySchema,
  t_PostTestHelpersIssuingSettlementsSettlementCompleteBodySchema,
  t_PostTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
  t_PostTestHelpersIssuingTransactionsCreateForceCaptureBodySchema,
  t_PostTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema,
  t_PostTestHelpersIssuingTransactionsTransactionRefundBodySchema,
  t_PostTestHelpersIssuingTransactionsTransactionRefundParamSchema,
  t_PostTestHelpersRefundsRefundExpireBodySchema,
  t_PostTestHelpersRefundsRefundExpireParamSchema,
  t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema,
  t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
  t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionBodySchema,
  t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema,
  t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionBodySchema,
  t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema,
  t_PostTestHelpersTestClocksBodySchema,
  t_PostTestHelpersTestClocksTestClockAdvanceBodySchema,
  t_PostTestHelpersTestClocksTestClockAdvanceParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdFailBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdFailParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdReturnBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdSucceedBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdFailBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdPostBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
  t_PostTestHelpersTreasuryReceivedCreditsBodySchema,
  t_PostTestHelpersTreasuryReceivedDebitsBodySchema,
  t_PostTokensBodySchema,
  t_PostTopupsBodySchema,
  t_PostTopupsTopupBodySchema,
  t_PostTopupsTopupCancelBodySchema,
  t_PostTopupsTopupCancelParamSchema,
  t_PostTopupsTopupParamSchema,
  t_PostTransfersBodySchema,
  t_PostTransfersIdReversalsBodySchema,
  t_PostTransfersIdReversalsParamSchema,
  t_PostTransfersTransferBodySchema,
  t_PostTransfersTransferParamSchema,
  t_PostTransfersTransferReversalsIdBodySchema,
  t_PostTransfersTransferReversalsIdParamSchema,
  t_PostTreasuryCreditReversalsBodySchema,
  t_PostTreasuryDebitReversalsBodySchema,
  t_PostTreasuryFinancialAccountsBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountCloseBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
  t_PostTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
  t_PostTreasuryFinancialAccountsFinancialAccountParamSchema,
  t_PostTreasuryInboundTransfersBodySchema,
  t_PostTreasuryInboundTransfersInboundTransferCancelBodySchema,
  t_PostTreasuryInboundTransfersInboundTransferCancelParamSchema,
  t_PostTreasuryOutboundPaymentsBodySchema,
  t_PostTreasuryOutboundPaymentsIdCancelBodySchema,
  t_PostTreasuryOutboundPaymentsIdCancelParamSchema,
  t_PostTreasuryOutboundTransfersBodySchema,
  t_PostTreasuryOutboundTransfersOutboundTransferCancelBodySchema,
  t_PostTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
  t_PostWebhookEndpointsBodySchema,
  t_PostWebhookEndpointsWebhookEndpointBodySchema,
  t_PostWebhookEndpointsWebhookEndpointParamSchema,
  t_account,
  t_account_link,
  t_account_session,
  t_apple_pay_domain,
  t_application_fee,
  t_apps_secret,
  t_balance,
  t_balance_transaction,
  t_bank_account,
  t_billing_alert,
  t_billing_credit_balance_summary,
  t_billing_credit_balance_transaction,
  t_billing_credit_grant,
  t_billing_meter,
  t_billing_meter_event,
  t_billing_meter_event_adjustment,
  t_billing_meter_event_summary,
  t_billing_portal_configuration,
  t_billing_portal_session,
  t_capability,
  t_card,
  t_cash_balance,
  t_charge,
  t_checkout_session,
  t_climate_order,
  t_climate_product,
  t_climate_supplier,
  t_confirmation_token,
  t_country_spec,
  t_coupon,
  t_credit_note,
  t_credit_note_line_item,
  t_customer,
  t_customer_balance_transaction,
  t_customer_cash_balance_transaction,
  t_customer_session,
  t_deleted_account,
  t_deleted_apple_pay_domain,
  t_deleted_coupon,
  t_deleted_customer,
  t_deleted_discount,
  t_deleted_external_account,
  t_deleted_invoice,
  t_deleted_invoiceitem,
  t_deleted_payment_source,
  t_deleted_person,
  t_deleted_plan,
  t_deleted_product,
  t_deleted_product_feature,
  t_deleted_radar_value_list,
  t_deleted_radar_value_list_item,
  t_deleted_subscription_item,
  t_deleted_tax_id,
  t_deleted_terminal_configuration,
  t_deleted_terminal_location,
  t_deleted_terminal_reader,
  t_deleted_test_helpers_test_clock,
  t_deleted_webhook_endpoint,
  t_discount,
  t_dispute,
  t_entitlements_active_entitlement,
  t_entitlements_feature,
  t_ephemeral_key,
  t_error,
  t_event,
  t_exchange_rate,
  t_external_account,
  t_fee_refund,
  t_file,
  t_file_link,
  t_financial_connections_account,
  t_financial_connections_account_owner,
  t_financial_connections_session,
  t_financial_connections_transaction,
  t_forwarding_request,
  t_funding_instructions,
  t_identity_verification_report,
  t_identity_verification_session,
  t_invoice,
  t_invoice_payment,
  t_invoice_rendering_template,
  t_invoiceitem,
  t_issuing_authorization,
  t_issuing_card,
  t_issuing_cardholder,
  t_issuing_dispute,
  t_issuing_personalization_design,
  t_issuing_physical_bundle,
  t_issuing_settlement,
  t_issuing_token,
  t_issuing_transaction,
  t_item,
  t_line_item,
  t_login_link,
  t_mandate,
  t_payment_intent,
  t_payment_link,
  t_payment_method,
  t_payment_method_configuration,
  t_payment_method_domain,
  t_payment_source,
  t_payout,
  t_person,
  t_plan,
  t_price,
  t_product,
  t_product_feature,
  t_promotion_code,
  t_quote,
  t_radar_early_fraud_warning,
  t_radar_value_list,
  t_radar_value_list_item,
  t_refund,
  t_reporting_report_run,
  t_reporting_report_type,
  t_review,
  t_scheduled_query_run,
  t_setup_attempt,
  t_setup_intent,
  t_shipping_rate,
  t_sigma_sigma_api_query,
  t_source,
  t_source_mandate_notification,
  t_source_transaction,
  t_subscription,
  t_subscription_item,
  t_subscription_schedule,
  t_tax_calculation,
  t_tax_calculation_line_item,
  t_tax_code,
  t_tax_id,
  t_tax_rate,
  t_tax_registration,
  t_tax_settings,
  t_tax_transaction,
  t_tax_transaction_line_item,
  t_terminal_configuration,
  t_terminal_connection_token,
  t_terminal_location,
  t_terminal_reader,
  t_test_helpers_test_clock,
  t_token,
  t_topup,
  t_transfer,
  t_transfer_reversal,
  t_treasury_credit_reversal,
  t_treasury_debit_reversal,
  t_treasury_financial_account,
  t_treasury_financial_account_features,
  t_treasury_inbound_transfer,
  t_treasury_outbound_payment,
  t_treasury_outbound_transfer,
  t_treasury_received_credit,
  t_treasury_received_debit,
  t_treasury_transaction,
  t_treasury_transaction_entry,
  t_webhook_endpoint,
} from "./models"
import {
  PermissiveBoolean,
  s_account,
  s_account_link,
  s_account_session,
  s_apple_pay_domain,
  s_application_fee,
  s_apps_secret,
  s_balance,
  s_balance_transaction,
  s_bank_account,
  s_billing_alert,
  s_billing_credit_balance_summary,
  s_billing_credit_balance_transaction,
  s_billing_credit_grant,
  s_billing_meter,
  s_billing_meter_event,
  s_billing_meter_event_adjustment,
  s_billing_meter_event_summary,
  s_billing_portal_configuration,
  s_billing_portal_session,
  s_capability,
  s_card,
  s_cash_balance,
  s_charge,
  s_checkout_session,
  s_climate_order,
  s_climate_product,
  s_climate_supplier,
  s_confirmation_token,
  s_country_spec,
  s_coupon,
  s_credit_note,
  s_credit_note_line_item,
  s_customer,
  s_customer_balance_transaction,
  s_customer_cash_balance_transaction,
  s_customer_session,
  s_deleted_account,
  s_deleted_apple_pay_domain,
  s_deleted_coupon,
  s_deleted_customer,
  s_deleted_discount,
  s_deleted_external_account,
  s_deleted_invoice,
  s_deleted_invoiceitem,
  s_deleted_payment_source,
  s_deleted_person,
  s_deleted_plan,
  s_deleted_product,
  s_deleted_product_feature,
  s_deleted_radar_value_list,
  s_deleted_radar_value_list_item,
  s_deleted_subscription_item,
  s_deleted_tax_id,
  s_deleted_terminal_configuration,
  s_deleted_terminal_location,
  s_deleted_terminal_reader,
  s_deleted_test_helpers_test_clock,
  s_deleted_webhook_endpoint,
  s_discount,
  s_dispute,
  s_entitlements_active_entitlement,
  s_entitlements_feature,
  s_ephemeral_key,
  s_error,
  s_event,
  s_exchange_rate,
  s_external_account,
  s_fee_refund,
  s_file,
  s_file_link,
  s_financial_connections_account,
  s_financial_connections_account_owner,
  s_financial_connections_session,
  s_financial_connections_transaction,
  s_forwarding_request,
  s_funding_instructions,
  s_identity_verification_report,
  s_identity_verification_session,
  s_invoice,
  s_invoice_payment,
  s_invoice_rendering_template,
  s_invoiceitem,
  s_issuing_authorization,
  s_issuing_card,
  s_issuing_cardholder,
  s_issuing_dispute,
  s_issuing_personalization_design,
  s_issuing_physical_bundle,
  s_issuing_settlement,
  s_issuing_token,
  s_issuing_transaction,
  s_item,
  s_line_item,
  s_login_link,
  s_mandate,
  s_payment_intent,
  s_payment_link,
  s_payment_method,
  s_payment_method_configuration,
  s_payment_method_domain,
  s_payment_source,
  s_payout,
  s_person,
  s_plan,
  s_price,
  s_product,
  s_product_feature,
  s_promotion_code,
  s_quote,
  s_radar_early_fraud_warning,
  s_radar_value_list,
  s_radar_value_list_item,
  s_refund,
  s_reporting_report_run,
  s_reporting_report_type,
  s_review,
  s_scheduled_query_run,
  s_setup_attempt,
  s_setup_intent,
  s_shipping_rate,
  s_sigma_sigma_api_query,
  s_source,
  s_source_mandate_notification,
  s_source_transaction,
  s_subscription,
  s_subscription_item,
  s_subscription_schedule,
  s_tax_calculation,
  s_tax_calculation_line_item,
  s_tax_code,
  s_tax_id,
  s_tax_rate,
  s_tax_registration,
  s_tax_settings,
  s_tax_transaction,
  s_tax_transaction_line_item,
  s_terminal_configuration,
  s_terminal_connection_token,
  s_terminal_location,
  s_terminal_reader,
  s_test_helpers_test_clock,
  s_token,
  s_topup,
  s_transfer,
  s_transfer_reversal,
  s_treasury_credit_reversal,
  s_treasury_debit_reversal,
  s_treasury_financial_account,
  s_treasury_financial_account_features,
  s_treasury_inbound_transfer,
  s_treasury_outbound_payment,
  s_treasury_outbound_transfer,
  s_treasury_received_credit,
  s_treasury_received_debit,
  s_treasury_transaction,
  s_treasury_transaction_entry,
  s_webhook_endpoint,
} from "./schemas"
import KoaRouter, {RouterContext} from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  KoaRuntimeResponder,
  KoaRuntimeResponse,
  Params,
  Response,
  ServerConfig,
  SkipResponse,
  StatusCode,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod"
import {Next} from "koa"
import {z} from "zod"

export type GetAccountResponder = {
  with200(): KoaRuntimeResponse<t_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccount = (
  params: Params<
    void,
    t_GetAccountQuerySchema,
    t_GetAccountBodySchema | undefined,
    void
  >,
  respond: GetAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountLinksResponder = {
  with200(): KoaRuntimeResponse<t_account_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountLinks = (
  params: Params<void, void, t_PostAccountLinksBodySchema, void>,
  respond: PostAccountLinksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountSessionsResponder = {
  with200(): KoaRuntimeResponse<t_account_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountSessions = (
  params: Params<void, void, t_PostAccountSessionsBodySchema, void>,
  respond: PostAccountSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccounts = (
  params: Params<
    void,
    t_GetAccountsQuerySchema,
    t_GetAccountsBodySchema | undefined,
    void
  >,
  respond: GetAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsResponder = {
  with200(): KoaRuntimeResponse<t_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccounts = (
  params: Params<void, void, t_PostAccountsBodySchema | undefined, void>,
  respond: PostAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteAccountsAccountResponder = {
  with200(): KoaRuntimeResponse<t_deleted_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteAccountsAccount = (
  params: Params<
    t_DeleteAccountsAccountParamSchema,
    void,
    t_DeleteAccountsAccountBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountResponder = {
  with200(): KoaRuntimeResponse<t_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccount = (
  params: Params<
    t_GetAccountsAccountParamSchema,
    t_GetAccountsAccountQuerySchema,
    t_GetAccountsAccountBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountResponder = {
  with200(): KoaRuntimeResponse<t_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccount = (
  params: Params<
    t_PostAccountsAccountParamSchema,
    void,
    t_PostAccountsAccountBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountBankAccountsResponder = {
  with200(): KoaRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountBankAccounts = (
  params: Params<
    t_PostAccountsAccountBankAccountsParamSchema,
    void,
    t_PostAccountsAccountBankAccountsBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountBankAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteAccountsAccountBankAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_deleted_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteAccountsAccountBankAccountsId = (
  params: Params<
    t_DeleteAccountsAccountBankAccountsIdParamSchema,
    void,
    t_DeleteAccountsAccountBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountBankAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountBankAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountBankAccountsId = (
  params: Params<
    t_GetAccountsAccountBankAccountsIdParamSchema,
    t_GetAccountsAccountBankAccountsIdQuerySchema,
    t_GetAccountsAccountBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountBankAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountBankAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountBankAccountsId = (
  params: Params<
    t_PostAccountsAccountBankAccountsIdParamSchema,
    void,
    t_PostAccountsAccountBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountBankAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountCapabilitiesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_capability[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountCapabilities = (
  params: Params<
    t_GetAccountsAccountCapabilitiesParamSchema,
    t_GetAccountsAccountCapabilitiesQuerySchema,
    t_GetAccountsAccountCapabilitiesBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountCapabilitiesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_capability[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountCapabilitiesCapabilityResponder = {
  with200(): KoaRuntimeResponse<t_capability>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountCapabilitiesCapability = (
  params: Params<
    t_GetAccountsAccountCapabilitiesCapabilityParamSchema,
    t_GetAccountsAccountCapabilitiesCapabilityQuerySchema,
    t_GetAccountsAccountCapabilitiesCapabilityBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountCapabilitiesCapabilityResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_capability>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountCapabilitiesCapabilityResponder = {
  with200(): KoaRuntimeResponse<t_capability>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountCapabilitiesCapability = (
  params: Params<
    t_PostAccountsAccountCapabilitiesCapabilityParamSchema,
    void,
    t_PostAccountsAccountCapabilitiesCapabilityBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountCapabilitiesCapabilityResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_capability>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountExternalAccountsResponder = {
  with200(): KoaRuntimeResponse<{
    data: (t_bank_account | t_card)[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountExternalAccounts = (
  params: Params<
    t_GetAccountsAccountExternalAccountsParamSchema,
    t_GetAccountsAccountExternalAccountsQuerySchema,
    t_GetAccountsAccountExternalAccountsBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountExternalAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: (t_bank_account | t_card)[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountExternalAccountsResponder = {
  with200(): KoaRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountExternalAccounts = (
  params: Params<
    t_PostAccountsAccountExternalAccountsParamSchema,
    void,
    t_PostAccountsAccountExternalAccountsBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountExternalAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteAccountsAccountExternalAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_deleted_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteAccountsAccountExternalAccountsId = (
  params: Params<
    t_DeleteAccountsAccountExternalAccountsIdParamSchema,
    void,
    t_DeleteAccountsAccountExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountExternalAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountExternalAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountExternalAccountsId = (
  params: Params<
    t_GetAccountsAccountExternalAccountsIdParamSchema,
    t_GetAccountsAccountExternalAccountsIdQuerySchema,
    t_GetAccountsAccountExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountExternalAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountExternalAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountExternalAccountsId = (
  params: Params<
    t_PostAccountsAccountExternalAccountsIdParamSchema,
    void,
    t_PostAccountsAccountExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountExternalAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountLoginLinksResponder = {
  with200(): KoaRuntimeResponse<t_login_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountLoginLinks = (
  params: Params<
    t_PostAccountsAccountLoginLinksParamSchema,
    void,
    t_PostAccountsAccountLoginLinksBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountLoginLinksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_login_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountPeopleResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_person[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountPeople = (
  params: Params<
    t_GetAccountsAccountPeopleParamSchema,
    t_GetAccountsAccountPeopleQuerySchema,
    t_GetAccountsAccountPeopleBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPeopleResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_person[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountPeopleResponder = {
  with200(): KoaRuntimeResponse<t_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountPeople = (
  params: Params<
    t_PostAccountsAccountPeopleParamSchema,
    void,
    t_PostAccountsAccountPeopleBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPeopleResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteAccountsAccountPeoplePersonResponder = {
  with200(): KoaRuntimeResponse<t_deleted_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteAccountsAccountPeoplePerson = (
  params: Params<
    t_DeleteAccountsAccountPeoplePersonParamSchema,
    void,
    t_DeleteAccountsAccountPeoplePersonBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountPeoplePersonResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountPeoplePersonResponder = {
  with200(): KoaRuntimeResponse<t_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountPeoplePerson = (
  params: Params<
    t_GetAccountsAccountPeoplePersonParamSchema,
    t_GetAccountsAccountPeoplePersonQuerySchema,
    t_GetAccountsAccountPeoplePersonBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPeoplePersonResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountPeoplePersonResponder = {
  with200(): KoaRuntimeResponse<t_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountPeoplePerson = (
  params: Params<
    t_PostAccountsAccountPeoplePersonParamSchema,
    void,
    t_PostAccountsAccountPeoplePersonBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPeoplePersonResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountPersonsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_person[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountPersons = (
  params: Params<
    t_GetAccountsAccountPersonsParamSchema,
    t_GetAccountsAccountPersonsQuerySchema,
    t_GetAccountsAccountPersonsBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPersonsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_person[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountPersonsResponder = {
  with200(): KoaRuntimeResponse<t_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountPersons = (
  params: Params<
    t_PostAccountsAccountPersonsParamSchema,
    void,
    t_PostAccountsAccountPersonsBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPersonsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteAccountsAccountPersonsPersonResponder = {
  with200(): KoaRuntimeResponse<t_deleted_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteAccountsAccountPersonsPerson = (
  params: Params<
    t_DeleteAccountsAccountPersonsPersonParamSchema,
    void,
    t_DeleteAccountsAccountPersonsPersonBodySchema | undefined,
    void
  >,
  respond: DeleteAccountsAccountPersonsPersonResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAccountsAccountPersonsPersonResponder = {
  with200(): KoaRuntimeResponse<t_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAccountsAccountPersonsPerson = (
  params: Params<
    t_GetAccountsAccountPersonsPersonParamSchema,
    t_GetAccountsAccountPersonsPersonQuerySchema,
    t_GetAccountsAccountPersonsPersonBodySchema | undefined,
    void
  >,
  respond: GetAccountsAccountPersonsPersonResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountPersonsPersonResponder = {
  with200(): KoaRuntimeResponse<t_person>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountPersonsPerson = (
  params: Params<
    t_PostAccountsAccountPersonsPersonParamSchema,
    void,
    t_PostAccountsAccountPersonsPersonBodySchema | undefined,
    void
  >,
  respond: PostAccountsAccountPersonsPersonResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAccountsAccountRejectResponder = {
  with200(): KoaRuntimeResponse<t_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAccountsAccountReject = (
  params: Params<
    t_PostAccountsAccountRejectParamSchema,
    void,
    t_PostAccountsAccountRejectBodySchema,
    void
  >,
  respond: PostAccountsAccountRejectResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetApplePayDomainsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_apple_pay_domain[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetApplePayDomains = (
  params: Params<
    void,
    t_GetApplePayDomainsQuerySchema,
    t_GetApplePayDomainsBodySchema | undefined,
    void
  >,
  respond: GetApplePayDomainsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_apple_pay_domain[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostApplePayDomainsResponder = {
  with200(): KoaRuntimeResponse<t_apple_pay_domain>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostApplePayDomains = (
  params: Params<void, void, t_PostApplePayDomainsBodySchema, void>,
  respond: PostApplePayDomainsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apple_pay_domain>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteApplePayDomainsDomainResponder = {
  with200(): KoaRuntimeResponse<t_deleted_apple_pay_domain>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteApplePayDomainsDomain = (
  params: Params<
    t_DeleteApplePayDomainsDomainParamSchema,
    void,
    t_DeleteApplePayDomainsDomainBodySchema | undefined,
    void
  >,
  respond: DeleteApplePayDomainsDomainResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_apple_pay_domain>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetApplePayDomainsDomainResponder = {
  with200(): KoaRuntimeResponse<t_apple_pay_domain>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetApplePayDomainsDomain = (
  params: Params<
    t_GetApplePayDomainsDomainParamSchema,
    t_GetApplePayDomainsDomainQuerySchema,
    t_GetApplePayDomainsDomainBodySchema | undefined,
    void
  >,
  respond: GetApplePayDomainsDomainResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apple_pay_domain>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetApplicationFeesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_application_fee[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetApplicationFees = (
  params: Params<
    void,
    t_GetApplicationFeesQuerySchema,
    t_GetApplicationFeesBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_application_fee[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetApplicationFeesFeeRefundsIdResponder = {
  with200(): KoaRuntimeResponse<t_fee_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetApplicationFeesFeeRefundsId = (
  params: Params<
    t_GetApplicationFeesFeeRefundsIdParamSchema,
    t_GetApplicationFeesFeeRefundsIdQuerySchema,
    t_GetApplicationFeesFeeRefundsIdBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesFeeRefundsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_fee_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostApplicationFeesFeeRefundsIdResponder = {
  with200(): KoaRuntimeResponse<t_fee_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostApplicationFeesFeeRefundsId = (
  params: Params<
    t_PostApplicationFeesFeeRefundsIdParamSchema,
    void,
    t_PostApplicationFeesFeeRefundsIdBodySchema | undefined,
    void
  >,
  respond: PostApplicationFeesFeeRefundsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_fee_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetApplicationFeesIdResponder = {
  with200(): KoaRuntimeResponse<t_application_fee>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetApplicationFeesId = (
  params: Params<
    t_GetApplicationFeesIdParamSchema,
    t_GetApplicationFeesIdQuerySchema,
    t_GetApplicationFeesIdBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_application_fee>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostApplicationFeesIdRefundResponder = {
  with200(): KoaRuntimeResponse<t_application_fee>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostApplicationFeesIdRefund = (
  params: Params<
    t_PostApplicationFeesIdRefundParamSchema,
    void,
    t_PostApplicationFeesIdRefundBodySchema | undefined,
    void
  >,
  respond: PostApplicationFeesIdRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_application_fee>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetApplicationFeesIdRefundsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_fee_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetApplicationFeesIdRefunds = (
  params: Params<
    t_GetApplicationFeesIdRefundsParamSchema,
    t_GetApplicationFeesIdRefundsQuerySchema,
    t_GetApplicationFeesIdRefundsBodySchema | undefined,
    void
  >,
  respond: GetApplicationFeesIdRefundsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_fee_refund[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostApplicationFeesIdRefundsResponder = {
  with200(): KoaRuntimeResponse<t_fee_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostApplicationFeesIdRefunds = (
  params: Params<
    t_PostApplicationFeesIdRefundsParamSchema,
    void,
    t_PostApplicationFeesIdRefundsBodySchema | undefined,
    void
  >,
  respond: PostApplicationFeesIdRefundsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_fee_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAppsSecretsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_apps_secret[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAppsSecrets = (
  params: Params<
    void,
    t_GetAppsSecretsQuerySchema,
    t_GetAppsSecretsBodySchema | undefined,
    void
  >,
  respond: GetAppsSecretsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_apps_secret[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAppsSecretsResponder = {
  with200(): KoaRuntimeResponse<t_apps_secret>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAppsSecrets = (
  params: Params<void, void, t_PostAppsSecretsBodySchema, void>,
  respond: PostAppsSecretsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apps_secret>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostAppsSecretsDeleteResponder = {
  with200(): KoaRuntimeResponse<t_apps_secret>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostAppsSecretsDelete = (
  params: Params<void, void, t_PostAppsSecretsDeleteBodySchema, void>,
  respond: PostAppsSecretsDeleteResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apps_secret>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetAppsSecretsFindResponder = {
  with200(): KoaRuntimeResponse<t_apps_secret>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetAppsSecretsFind = (
  params: Params<
    void,
    t_GetAppsSecretsFindQuerySchema,
    t_GetAppsSecretsFindBodySchema | undefined,
    void
  >,
  respond: GetAppsSecretsFindResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apps_secret>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBalanceResponder = {
  with200(): KoaRuntimeResponse<t_balance>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBalance = (
  params: Params<
    void,
    t_GetBalanceQuerySchema,
    t_GetBalanceBodySchema | undefined,
    void
  >,
  respond: GetBalanceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_balance>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBalanceHistoryResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBalanceHistory = (
  params: Params<
    void,
    t_GetBalanceHistoryQuerySchema,
    t_GetBalanceHistoryBodySchema | undefined,
    void
  >,
  respond: GetBalanceHistoryResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBalanceHistoryIdResponder = {
  with200(): KoaRuntimeResponse<t_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBalanceHistoryId = (
  params: Params<
    t_GetBalanceHistoryIdParamSchema,
    t_GetBalanceHistoryIdQuerySchema,
    t_GetBalanceHistoryIdBodySchema | undefined,
    void
  >,
  respond: GetBalanceHistoryIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBalanceTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBalanceTransactions = (
  params: Params<
    void,
    t_GetBalanceTransactionsQuerySchema,
    t_GetBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: GetBalanceTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBalanceTransactionsIdResponder = {
  with200(): KoaRuntimeResponse<t_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBalanceTransactionsId = (
  params: Params<
    t_GetBalanceTransactionsIdParamSchema,
    t_GetBalanceTransactionsIdQuerySchema,
    t_GetBalanceTransactionsIdBodySchema | undefined,
    void
  >,
  respond: GetBalanceTransactionsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingAlertsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_billing_alert[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingAlerts = (
  params: Params<
    void,
    t_GetBillingAlertsQuerySchema,
    t_GetBillingAlertsBodySchema | undefined,
    void
  >,
  respond: GetBillingAlertsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_alert[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingAlertsResponder = {
  with200(): KoaRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingAlerts = (
  params: Params<void, void, t_PostBillingAlertsBodySchema, void>,
  respond: PostBillingAlertsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingAlertsIdResponder = {
  with200(): KoaRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingAlertsId = (
  params: Params<
    t_GetBillingAlertsIdParamSchema,
    t_GetBillingAlertsIdQuerySchema,
    t_GetBillingAlertsIdBodySchema | undefined,
    void
  >,
  respond: GetBillingAlertsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingAlertsIdActivateResponder = {
  with200(): KoaRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingAlertsIdActivate = (
  params: Params<
    t_PostBillingAlertsIdActivateParamSchema,
    void,
    t_PostBillingAlertsIdActivateBodySchema | undefined,
    void
  >,
  respond: PostBillingAlertsIdActivateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingAlertsIdArchiveResponder = {
  with200(): KoaRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingAlertsIdArchive = (
  params: Params<
    t_PostBillingAlertsIdArchiveParamSchema,
    void,
    t_PostBillingAlertsIdArchiveBodySchema | undefined,
    void
  >,
  respond: PostBillingAlertsIdArchiveResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingAlertsIdDeactivateResponder = {
  with200(): KoaRuntimeResponse<t_billing_alert>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingAlertsIdDeactivate = (
  params: Params<
    t_PostBillingAlertsIdDeactivateParamSchema,
    void,
    t_PostBillingAlertsIdDeactivateBodySchema | undefined,
    void
  >,
  respond: PostBillingAlertsIdDeactivateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingCreditBalanceSummaryResponder = {
  with200(): KoaRuntimeResponse<t_billing_credit_balance_summary>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingCreditBalanceSummary = (
  params: Params<
    void,
    t_GetBillingCreditBalanceSummaryQuerySchema,
    t_GetBillingCreditBalanceSummaryBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditBalanceSummaryResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_balance_summary>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingCreditBalanceTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_billing_credit_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingCreditBalanceTransactions = (
  params: Params<
    void,
    t_GetBillingCreditBalanceTransactionsQuerySchema,
    t_GetBillingCreditBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditBalanceTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_credit_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingCreditBalanceTransactionsIdResponder = {
  with200(): KoaRuntimeResponse<t_billing_credit_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingCreditBalanceTransactionsId = (
  params: Params<
    t_GetBillingCreditBalanceTransactionsIdParamSchema,
    t_GetBillingCreditBalanceTransactionsIdQuerySchema,
    t_GetBillingCreditBalanceTransactionsIdBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditBalanceTransactionsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingCreditGrantsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_billing_credit_grant[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingCreditGrants = (
  params: Params<
    void,
    t_GetBillingCreditGrantsQuerySchema,
    t_GetBillingCreditGrantsBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditGrantsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_credit_grant[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingCreditGrantsResponder = {
  with200(): KoaRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingCreditGrants = (
  params: Params<void, void, t_PostBillingCreditGrantsBodySchema, void>,
  respond: PostBillingCreditGrantsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingCreditGrantsIdResponder = {
  with200(): KoaRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingCreditGrantsId = (
  params: Params<
    t_GetBillingCreditGrantsIdParamSchema,
    t_GetBillingCreditGrantsIdQuerySchema,
    t_GetBillingCreditGrantsIdBodySchema | undefined,
    void
  >,
  respond: GetBillingCreditGrantsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingCreditGrantsIdResponder = {
  with200(): KoaRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingCreditGrantsId = (
  params: Params<
    t_PostBillingCreditGrantsIdParamSchema,
    void,
    t_PostBillingCreditGrantsIdBodySchema | undefined,
    void
  >,
  respond: PostBillingCreditGrantsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingCreditGrantsIdExpireResponder = {
  with200(): KoaRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingCreditGrantsIdExpire = (
  params: Params<
    t_PostBillingCreditGrantsIdExpireParamSchema,
    void,
    t_PostBillingCreditGrantsIdExpireBodySchema | undefined,
    void
  >,
  respond: PostBillingCreditGrantsIdExpireResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingCreditGrantsIdVoidResponder = {
  with200(): KoaRuntimeResponse<t_billing_credit_grant>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingCreditGrantsIdVoid = (
  params: Params<
    t_PostBillingCreditGrantsIdVoidParamSchema,
    void,
    t_PostBillingCreditGrantsIdVoidBodySchema | undefined,
    void
  >,
  respond: PostBillingCreditGrantsIdVoidResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingMeterEventAdjustmentsResponder = {
  with200(): KoaRuntimeResponse<t_billing_meter_event_adjustment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingMeterEventAdjustments = (
  params: Params<
    void,
    void,
    t_PostBillingMeterEventAdjustmentsBodySchema,
    void
  >,
  respond: PostBillingMeterEventAdjustmentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter_event_adjustment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingMeterEventsResponder = {
  with200(): KoaRuntimeResponse<t_billing_meter_event>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingMeterEvents = (
  params: Params<void, void, t_PostBillingMeterEventsBodySchema, void>,
  respond: PostBillingMeterEventsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter_event>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingMetersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_billing_meter[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingMeters = (
  params: Params<
    void,
    t_GetBillingMetersQuerySchema,
    t_GetBillingMetersBodySchema | undefined,
    void
  >,
  respond: GetBillingMetersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_meter[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingMetersResponder = {
  with200(): KoaRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingMeters = (
  params: Params<void, void, t_PostBillingMetersBodySchema, void>,
  respond: PostBillingMetersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingMetersIdResponder = {
  with200(): KoaRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingMetersId = (
  params: Params<
    t_GetBillingMetersIdParamSchema,
    t_GetBillingMetersIdQuerySchema,
    t_GetBillingMetersIdBodySchema | undefined,
    void
  >,
  respond: GetBillingMetersIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingMetersIdResponder = {
  with200(): KoaRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingMetersId = (
  params: Params<
    t_PostBillingMetersIdParamSchema,
    void,
    t_PostBillingMetersIdBodySchema | undefined,
    void
  >,
  respond: PostBillingMetersIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingMetersIdDeactivateResponder = {
  with200(): KoaRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingMetersIdDeactivate = (
  params: Params<
    t_PostBillingMetersIdDeactivateParamSchema,
    void,
    t_PostBillingMetersIdDeactivateBodySchema | undefined,
    void
  >,
  respond: PostBillingMetersIdDeactivateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingMetersIdEventSummariesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_billing_meter_event_summary[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingMetersIdEventSummaries = (
  params: Params<
    t_GetBillingMetersIdEventSummariesParamSchema,
    t_GetBillingMetersIdEventSummariesQuerySchema,
    t_GetBillingMetersIdEventSummariesBodySchema | undefined,
    void
  >,
  respond: GetBillingMetersIdEventSummariesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_meter_event_summary[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingMetersIdReactivateResponder = {
  with200(): KoaRuntimeResponse<t_billing_meter>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingMetersIdReactivate = (
  params: Params<
    t_PostBillingMetersIdReactivateParamSchema,
    void,
    t_PostBillingMetersIdReactivateBodySchema | undefined,
    void
  >,
  respond: PostBillingMetersIdReactivateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingPortalConfigurationsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_billing_portal_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingPortalConfigurations = (
  params: Params<
    void,
    t_GetBillingPortalConfigurationsQuerySchema,
    t_GetBillingPortalConfigurationsBodySchema | undefined,
    void
  >,
  respond: GetBillingPortalConfigurationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_portal_configuration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingPortalConfigurationsResponder = {
  with200(): KoaRuntimeResponse<t_billing_portal_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingPortalConfigurations = (
  params: Params<void, void, t_PostBillingPortalConfigurationsBodySchema, void>,
  respond: PostBillingPortalConfigurationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetBillingPortalConfigurationsConfigurationResponder = {
  with200(): KoaRuntimeResponse<t_billing_portal_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetBillingPortalConfigurationsConfiguration = (
  params: Params<
    t_GetBillingPortalConfigurationsConfigurationParamSchema,
    t_GetBillingPortalConfigurationsConfigurationQuerySchema,
    t_GetBillingPortalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: GetBillingPortalConfigurationsConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingPortalConfigurationsConfigurationResponder = {
  with200(): KoaRuntimeResponse<t_billing_portal_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingPortalConfigurationsConfiguration = (
  params: Params<
    t_PostBillingPortalConfigurationsConfigurationParamSchema,
    void,
    t_PostBillingPortalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: PostBillingPortalConfigurationsConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostBillingPortalSessionsResponder = {
  with200(): KoaRuntimeResponse<t_billing_portal_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostBillingPortalSessions = (
  params: Params<void, void, t_PostBillingPortalSessionsBodySchema, void>,
  respond: PostBillingPortalSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetChargesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_charge[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCharges = (
  params: Params<
    void,
    t_GetChargesQuerySchema,
    t_GetChargesBodySchema | undefined,
    void
  >,
  respond: GetChargesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_charge[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesResponder = {
  with200(): KoaRuntimeResponse<t_charge>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCharges = (
  params: Params<void, void, t_PostChargesBodySchema | undefined, void>,
  respond: PostChargesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetChargesSearchResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_charge[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetChargesSearch = (
  params: Params<
    void,
    t_GetChargesSearchQuerySchema,
    t_GetChargesSearchBodySchema | undefined,
    void
  >,
  respond: GetChargesSearchResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_charge[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetChargesChargeResponder = {
  with200(): KoaRuntimeResponse<t_charge>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetChargesCharge = (
  params: Params<
    t_GetChargesChargeParamSchema,
    t_GetChargesChargeQuerySchema,
    t_GetChargesChargeBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesChargeResponder = {
  with200(): KoaRuntimeResponse<t_charge>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostChargesCharge = (
  params: Params<
    t_PostChargesChargeParamSchema,
    void,
    t_PostChargesChargeBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesChargeCaptureResponder = {
  with200(): KoaRuntimeResponse<t_charge>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostChargesChargeCapture = (
  params: Params<
    t_PostChargesChargeCaptureParamSchema,
    void,
    t_PostChargesChargeCaptureBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeCaptureResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetChargesChargeDisputeResponder = {
  with200(): KoaRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetChargesChargeDispute = (
  params: Params<
    t_GetChargesChargeDisputeParamSchema,
    t_GetChargesChargeDisputeQuerySchema,
    t_GetChargesChargeDisputeBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeDisputeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesChargeDisputeResponder = {
  with200(): KoaRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostChargesChargeDispute = (
  params: Params<
    t_PostChargesChargeDisputeParamSchema,
    void,
    t_PostChargesChargeDisputeBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeDisputeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesChargeDisputeCloseResponder = {
  with200(): KoaRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostChargesChargeDisputeClose = (
  params: Params<
    t_PostChargesChargeDisputeCloseParamSchema,
    void,
    t_PostChargesChargeDisputeCloseBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeDisputeCloseResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesChargeRefundResponder = {
  with200(): KoaRuntimeResponse<t_charge>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostChargesChargeRefund = (
  params: Params<
    t_PostChargesChargeRefundParamSchema,
    void,
    t_PostChargesChargeRefundBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetChargesChargeRefundsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetChargesChargeRefunds = (
  params: Params<
    t_GetChargesChargeRefundsParamSchema,
    t_GetChargesChargeRefundsQuerySchema,
    t_GetChargesChargeRefundsBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeRefundsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_refund[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesChargeRefundsResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostChargesChargeRefunds = (
  params: Params<
    t_PostChargesChargeRefundsParamSchema,
    void,
    t_PostChargesChargeRefundsBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeRefundsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetChargesChargeRefundsRefundResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetChargesChargeRefundsRefund = (
  params: Params<
    t_GetChargesChargeRefundsRefundParamSchema,
    t_GetChargesChargeRefundsRefundQuerySchema,
    t_GetChargesChargeRefundsRefundBodySchema | undefined,
    void
  >,
  respond: GetChargesChargeRefundsRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostChargesChargeRefundsRefundResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostChargesChargeRefundsRefund = (
  params: Params<
    t_PostChargesChargeRefundsRefundParamSchema,
    void,
    t_PostChargesChargeRefundsRefundBodySchema | undefined,
    void
  >,
  respond: PostChargesChargeRefundsRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCheckoutSessionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_checkout_session[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCheckoutSessions = (
  params: Params<
    void,
    t_GetCheckoutSessionsQuerySchema,
    t_GetCheckoutSessionsBodySchema | undefined,
    void
  >,
  respond: GetCheckoutSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_checkout_session[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCheckoutSessionsResponder = {
  with200(): KoaRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCheckoutSessions = (
  params: Params<
    void,
    void,
    t_PostCheckoutSessionsBodySchema | undefined,
    void
  >,
  respond: PostCheckoutSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCheckoutSessionsSessionResponder = {
  with200(): KoaRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCheckoutSessionsSession = (
  params: Params<
    t_GetCheckoutSessionsSessionParamSchema,
    t_GetCheckoutSessionsSessionQuerySchema,
    t_GetCheckoutSessionsSessionBodySchema | undefined,
    void
  >,
  respond: GetCheckoutSessionsSessionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCheckoutSessionsSessionResponder = {
  with200(): KoaRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCheckoutSessionsSession = (
  params: Params<
    t_PostCheckoutSessionsSessionParamSchema,
    void,
    t_PostCheckoutSessionsSessionBodySchema | undefined,
    void
  >,
  respond: PostCheckoutSessionsSessionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCheckoutSessionsSessionExpireResponder = {
  with200(): KoaRuntimeResponse<t_checkout_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCheckoutSessionsSessionExpire = (
  params: Params<
    t_PostCheckoutSessionsSessionExpireParamSchema,
    void,
    t_PostCheckoutSessionsSessionExpireBodySchema | undefined,
    void
  >,
  respond: PostCheckoutSessionsSessionExpireResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCheckoutSessionsSessionLineItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCheckoutSessionsSessionLineItems = (
  params: Params<
    t_GetCheckoutSessionsSessionLineItemsParamSchema,
    t_GetCheckoutSessionsSessionLineItemsQuerySchema,
    t_GetCheckoutSessionsSessionLineItemsBodySchema | undefined,
    void
  >,
  respond: GetCheckoutSessionsSessionLineItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetClimateOrdersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_climate_order[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetClimateOrders = (
  params: Params<
    void,
    t_GetClimateOrdersQuerySchema,
    t_GetClimateOrdersBodySchema | undefined,
    void
  >,
  respond: GetClimateOrdersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_climate_order[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostClimateOrdersResponder = {
  with200(): KoaRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostClimateOrders = (
  params: Params<void, void, t_PostClimateOrdersBodySchema, void>,
  respond: PostClimateOrdersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetClimateOrdersOrderResponder = {
  with200(): KoaRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetClimateOrdersOrder = (
  params: Params<
    t_GetClimateOrdersOrderParamSchema,
    t_GetClimateOrdersOrderQuerySchema,
    t_GetClimateOrdersOrderBodySchema | undefined,
    void
  >,
  respond: GetClimateOrdersOrderResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostClimateOrdersOrderResponder = {
  with200(): KoaRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostClimateOrdersOrder = (
  params: Params<
    t_PostClimateOrdersOrderParamSchema,
    void,
    t_PostClimateOrdersOrderBodySchema | undefined,
    void
  >,
  respond: PostClimateOrdersOrderResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostClimateOrdersOrderCancelResponder = {
  with200(): KoaRuntimeResponse<t_climate_order>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostClimateOrdersOrderCancel = (
  params: Params<
    t_PostClimateOrdersOrderCancelParamSchema,
    void,
    t_PostClimateOrdersOrderCancelBodySchema | undefined,
    void
  >,
  respond: PostClimateOrdersOrderCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetClimateProductsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_climate_product[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetClimateProducts = (
  params: Params<
    void,
    t_GetClimateProductsQuerySchema,
    t_GetClimateProductsBodySchema | undefined,
    void
  >,
  respond: GetClimateProductsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_climate_product[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetClimateProductsProductResponder = {
  with200(): KoaRuntimeResponse<t_climate_product>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetClimateProductsProduct = (
  params: Params<
    t_GetClimateProductsProductParamSchema,
    t_GetClimateProductsProductQuerySchema,
    t_GetClimateProductsProductBodySchema | undefined,
    void
  >,
  respond: GetClimateProductsProductResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_product>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetClimateSuppliersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_climate_supplier[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetClimateSuppliers = (
  params: Params<
    void,
    t_GetClimateSuppliersQuerySchema,
    t_GetClimateSuppliersBodySchema | undefined,
    void
  >,
  respond: GetClimateSuppliersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_climate_supplier[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetClimateSuppliersSupplierResponder = {
  with200(): KoaRuntimeResponse<t_climate_supplier>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetClimateSuppliersSupplier = (
  params: Params<
    t_GetClimateSuppliersSupplierParamSchema,
    t_GetClimateSuppliersSupplierQuerySchema,
    t_GetClimateSuppliersSupplierBodySchema | undefined,
    void
  >,
  respond: GetClimateSuppliersSupplierResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_supplier>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetConfirmationTokensConfirmationTokenResponder = {
  with200(): KoaRuntimeResponse<t_confirmation_token>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetConfirmationTokensConfirmationToken = (
  params: Params<
    t_GetConfirmationTokensConfirmationTokenParamSchema,
    t_GetConfirmationTokensConfirmationTokenQuerySchema,
    t_GetConfirmationTokensConfirmationTokenBodySchema | undefined,
    void
  >,
  respond: GetConfirmationTokensConfirmationTokenResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_confirmation_token>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCountrySpecsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_country_spec[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCountrySpecs = (
  params: Params<
    void,
    t_GetCountrySpecsQuerySchema,
    t_GetCountrySpecsBodySchema | undefined,
    void
  >,
  respond: GetCountrySpecsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_country_spec[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCountrySpecsCountryResponder = {
  with200(): KoaRuntimeResponse<t_country_spec>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCountrySpecsCountry = (
  params: Params<
    t_GetCountrySpecsCountryParamSchema,
    t_GetCountrySpecsCountryQuerySchema,
    t_GetCountrySpecsCountryBodySchema | undefined,
    void
  >,
  respond: GetCountrySpecsCountryResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_country_spec>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCouponsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_coupon[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCoupons = (
  params: Params<
    void,
    t_GetCouponsQuerySchema,
    t_GetCouponsBodySchema | undefined,
    void
  >,
  respond: GetCouponsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_coupon[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCouponsResponder = {
  with200(): KoaRuntimeResponse<t_coupon>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCoupons = (
  params: Params<void, void, t_PostCouponsBodySchema | undefined, void>,
  respond: PostCouponsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_coupon>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCouponsCouponResponder = {
  with200(): KoaRuntimeResponse<t_deleted_coupon>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteCouponsCoupon = (
  params: Params<
    t_DeleteCouponsCouponParamSchema,
    void,
    t_DeleteCouponsCouponBodySchema | undefined,
    void
  >,
  respond: DeleteCouponsCouponResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_coupon>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCouponsCouponResponder = {
  with200(): KoaRuntimeResponse<t_coupon>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCouponsCoupon = (
  params: Params<
    t_GetCouponsCouponParamSchema,
    t_GetCouponsCouponQuerySchema,
    t_GetCouponsCouponBodySchema | undefined,
    void
  >,
  respond: GetCouponsCouponResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_coupon>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCouponsCouponResponder = {
  with200(): KoaRuntimeResponse<t_coupon>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCouponsCoupon = (
  params: Params<
    t_PostCouponsCouponParamSchema,
    void,
    t_PostCouponsCouponBodySchema | undefined,
    void
  >,
  respond: PostCouponsCouponResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_coupon>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCreditNotesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_credit_note[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCreditNotes = (
  params: Params<
    void,
    t_GetCreditNotesQuerySchema,
    t_GetCreditNotesBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_credit_note[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCreditNotesResponder = {
  with200(): KoaRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCreditNotes = (
  params: Params<void, void, t_PostCreditNotesBodySchema, void>,
  respond: PostCreditNotesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCreditNotesPreviewResponder = {
  with200(): KoaRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCreditNotesPreview = (
  params: Params<
    void,
    t_GetCreditNotesPreviewQuerySchema,
    t_GetCreditNotesPreviewBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesPreviewResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCreditNotesPreviewLinesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_credit_note_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCreditNotesPreviewLines = (
  params: Params<
    void,
    t_GetCreditNotesPreviewLinesQuerySchema,
    t_GetCreditNotesPreviewLinesBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesPreviewLinesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_credit_note_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCreditNotesCreditNoteLinesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_credit_note_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCreditNotesCreditNoteLines = (
  params: Params<
    t_GetCreditNotesCreditNoteLinesParamSchema,
    t_GetCreditNotesCreditNoteLinesQuerySchema,
    t_GetCreditNotesCreditNoteLinesBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesCreditNoteLinesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_credit_note_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCreditNotesIdResponder = {
  with200(): KoaRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCreditNotesId = (
  params: Params<
    t_GetCreditNotesIdParamSchema,
    t_GetCreditNotesIdQuerySchema,
    t_GetCreditNotesIdBodySchema | undefined,
    void
  >,
  respond: GetCreditNotesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCreditNotesIdResponder = {
  with200(): KoaRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCreditNotesId = (
  params: Params<
    t_PostCreditNotesIdParamSchema,
    void,
    t_PostCreditNotesIdBodySchema | undefined,
    void
  >,
  respond: PostCreditNotesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCreditNotesIdVoidResponder = {
  with200(): KoaRuntimeResponse<t_credit_note>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCreditNotesIdVoid = (
  params: Params<
    t_PostCreditNotesIdVoidParamSchema,
    void,
    t_PostCreditNotesIdVoidBodySchema | undefined,
    void
  >,
  respond: PostCreditNotesIdVoidResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomerSessionsResponder = {
  with200(): KoaRuntimeResponse<t_customer_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomerSessions = (
  params: Params<void, void, t_PostCustomerSessionsBodySchema, void>,
  respond: PostCustomerSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_customer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomers = (
  params: Params<
    void,
    t_GetCustomersQuerySchema,
    t_GetCustomersBodySchema | undefined,
    void
  >,
  respond: GetCustomersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersResponder = {
  with200(): KoaRuntimeResponse<t_customer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomers = (
  params: Params<void, void, t_PostCustomersBodySchema | undefined, void>,
  respond: PostCustomersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersSearchResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_customer[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersSearch = (
  params: Params<
    void,
    t_GetCustomersSearchQuerySchema,
    t_GetCustomersSearchBodySchema | undefined,
    void
  >,
  respond: GetCustomersSearchResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerResponder = {
  with200(): KoaRuntimeResponse<t_deleted_customer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteCustomersCustomer = (
  params: Params<
    t_DeleteCustomersCustomerParamSchema,
    void,
    t_DeleteCustomersCustomerBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_customer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerResponder = {
  with200(): KoaRuntimeResponse<t_customer | t_deleted_customer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomer = (
  params: Params<
    t_GetCustomersCustomerParamSchema,
    t_GetCustomersCustomerQuerySchema,
    t_GetCustomersCustomerBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer | t_deleted_customer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerResponder = {
  with200(): KoaRuntimeResponse<t_customer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomer = (
  params: Params<
    t_PostCustomersCustomerParamSchema,
    void,
    t_PostCustomersCustomerBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerBalanceTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_customer_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerBalanceTransactions = (
  params: Params<
    t_GetCustomersCustomerBalanceTransactionsParamSchema,
    t_GetCustomersCustomerBalanceTransactionsQuerySchema,
    t_GetCustomersCustomerBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerBalanceTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerBalanceTransactionsResponder = {
  with200(): KoaRuntimeResponse<t_customer_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerBalanceTransactions = (
  params: Params<
    t_PostCustomersCustomerBalanceTransactionsParamSchema,
    void,
    t_PostCustomersCustomerBalanceTransactionsBodySchema,
    void
  >,
  respond: PostCustomersCustomerBalanceTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerBalanceTransactionsTransactionResponder = {
  with200(): KoaRuntimeResponse<t_customer_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerBalanceTransactionsTransaction = (
  params: Params<
    t_GetCustomersCustomerBalanceTransactionsTransactionParamSchema,
    t_GetCustomersCustomerBalanceTransactionsTransactionQuerySchema,
    t_GetCustomersCustomerBalanceTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerBalanceTransactionsTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerBalanceTransactionsTransactionResponder = {
  with200(): KoaRuntimeResponse<t_customer_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerBalanceTransactionsTransaction = (
  params: Params<
    t_PostCustomersCustomerBalanceTransactionsTransactionParamSchema,
    void,
    t_PostCustomersCustomerBalanceTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerBalanceTransactionsTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerBankAccountsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_bank_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerBankAccounts = (
  params: Params<
    t_GetCustomersCustomerBankAccountsParamSchema,
    t_GetCustomersCustomerBankAccountsQuerySchema,
    t_GetCustomersCustomerBankAccountsBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerBankAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_bank_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerBankAccountsResponder = {
  with200(): KoaRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerBankAccounts = (
  params: Params<
    t_PostCustomersCustomerBankAccountsParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerBankAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerBankAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_payment_source | t_deleted_payment_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteCustomersCustomerBankAccountsId = (
  params: Params<
    t_DeleteCustomersCustomerBankAccountsIdParamSchema,
    void,
    t_DeleteCustomersCustomerBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerBankAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source | t_deleted_payment_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerBankAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_bank_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerBankAccountsId = (
  params: Params<
    t_GetCustomersCustomerBankAccountsIdParamSchema,
    t_GetCustomersCustomerBankAccountsIdQuerySchema,
    t_GetCustomersCustomerBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerBankAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_bank_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerBankAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_card | t_bank_account | t_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerBankAccountsId = (
  params: Params<
    t_PostCustomersCustomerBankAccountsIdParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerBankAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card | t_bank_account | t_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerBankAccountsIdVerifyResponder = {
  with200(): KoaRuntimeResponse<t_bank_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerBankAccountsIdVerify = (
  params: Params<
    t_PostCustomersCustomerBankAccountsIdVerifyParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsIdVerifyBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerBankAccountsIdVerifyResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_bank_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerCardsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_card[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerCards = (
  params: Params<
    t_GetCustomersCustomerCardsParamSchema,
    t_GetCustomersCustomerCardsQuerySchema,
    t_GetCustomersCustomerCardsBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCardsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_card[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerCardsResponder = {
  with200(): KoaRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerCards = (
  params: Params<
    t_PostCustomersCustomerCardsParamSchema,
    void,
    t_PostCustomersCustomerCardsBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerCardsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerCardsIdResponder = {
  with200(): KoaRuntimeResponse<t_payment_source | t_deleted_payment_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteCustomersCustomerCardsId = (
  params: Params<
    t_DeleteCustomersCustomerCardsIdParamSchema,
    void,
    t_DeleteCustomersCustomerCardsIdBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerCardsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source | t_deleted_payment_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerCardsIdResponder = {
  with200(): KoaRuntimeResponse<t_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerCardsId = (
  params: Params<
    t_GetCustomersCustomerCardsIdParamSchema,
    t_GetCustomersCustomerCardsIdQuerySchema,
    t_GetCustomersCustomerCardsIdBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCardsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerCardsIdResponder = {
  with200(): KoaRuntimeResponse<t_card | t_bank_account | t_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerCardsId = (
  params: Params<
    t_PostCustomersCustomerCardsIdParamSchema,
    void,
    t_PostCustomersCustomerCardsIdBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerCardsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card | t_bank_account | t_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerCashBalanceResponder = {
  with200(): KoaRuntimeResponse<t_cash_balance>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerCashBalance = (
  params: Params<
    t_GetCustomersCustomerCashBalanceParamSchema,
    t_GetCustomersCustomerCashBalanceQuerySchema,
    t_GetCustomersCustomerCashBalanceBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCashBalanceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_cash_balance>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerCashBalanceResponder = {
  with200(): KoaRuntimeResponse<t_cash_balance>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerCashBalance = (
  params: Params<
    t_PostCustomersCustomerCashBalanceParamSchema,
    void,
    t_PostCustomersCustomerCashBalanceBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerCashBalanceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_cash_balance>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerCashBalanceTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_customer_cash_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerCashBalanceTransactions = (
  params: Params<
    t_GetCustomersCustomerCashBalanceTransactionsParamSchema,
    t_GetCustomersCustomerCashBalanceTransactionsQuerySchema,
    t_GetCustomersCustomerCashBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerCashBalanceTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer_cash_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerCashBalanceTransactionsTransactionResponder = {
  with200(): KoaRuntimeResponse<t_customer_cash_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerCashBalanceTransactionsTransaction = (
  params: Params<
    t_GetCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
    t_GetCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
    | t_GetCustomersCustomerCashBalanceTransactionsTransactionBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerCashBalanceTransactionsTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_cash_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerDiscountResponder = {
  with200(): KoaRuntimeResponse<t_deleted_discount>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteCustomersCustomerDiscount = (
  params: Params<
    t_DeleteCustomersCustomerDiscountParamSchema,
    void,
    t_DeleteCustomersCustomerDiscountBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerDiscountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_discount>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerDiscountResponder = {
  with200(): KoaRuntimeResponse<t_discount>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerDiscount = (
  params: Params<
    t_GetCustomersCustomerDiscountParamSchema,
    t_GetCustomersCustomerDiscountQuerySchema,
    t_GetCustomersCustomerDiscountBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerDiscountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_discount>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerFundingInstructionsResponder = {
  with200(): KoaRuntimeResponse<t_funding_instructions>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerFundingInstructions = (
  params: Params<
    t_PostCustomersCustomerFundingInstructionsParamSchema,
    void,
    t_PostCustomersCustomerFundingInstructionsBodySchema,
    void
  >,
  respond: PostCustomersCustomerFundingInstructionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_funding_instructions>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerPaymentMethodsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payment_method[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerPaymentMethods = (
  params: Params<
    t_GetCustomersCustomerPaymentMethodsParamSchema,
    t_GetCustomersCustomerPaymentMethodsQuerySchema,
    t_GetCustomersCustomerPaymentMethodsBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerPaymentMethodsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerPaymentMethodsPaymentMethodResponder = {
  with200(): KoaRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerPaymentMethodsPaymentMethod = (
  params: Params<
    t_GetCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
    t_GetCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
    t_GetCustomersCustomerPaymentMethodsPaymentMethodBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerPaymentMethodsPaymentMethodResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerSourcesResponder = {
  with200(): KoaRuntimeResponse<{
    data: (t_bank_account | t_card | t_source)[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerSources = (
  params: Params<
    t_GetCustomersCustomerSourcesParamSchema,
    t_GetCustomersCustomerSourcesQuerySchema,
    t_GetCustomersCustomerSourcesBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerSourcesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: (t_bank_account | t_card | t_source)[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerSourcesResponder = {
  with200(): KoaRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerSources = (
  params: Params<
    t_PostCustomersCustomerSourcesParamSchema,
    void,
    t_PostCustomersCustomerSourcesBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSourcesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerSourcesIdResponder = {
  with200(): KoaRuntimeResponse<t_payment_source | t_deleted_payment_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteCustomersCustomerSourcesId = (
  params: Params<
    t_DeleteCustomersCustomerSourcesIdParamSchema,
    void,
    t_DeleteCustomersCustomerSourcesIdBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerSourcesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source | t_deleted_payment_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerSourcesIdResponder = {
  with200(): KoaRuntimeResponse<t_payment_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerSourcesId = (
  params: Params<
    t_GetCustomersCustomerSourcesIdParamSchema,
    t_GetCustomersCustomerSourcesIdQuerySchema,
    t_GetCustomersCustomerSourcesIdBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerSourcesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerSourcesIdResponder = {
  with200(): KoaRuntimeResponse<t_card | t_bank_account | t_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerSourcesId = (
  params: Params<
    t_PostCustomersCustomerSourcesIdParamSchema,
    void,
    t_PostCustomersCustomerSourcesIdBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSourcesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card | t_bank_account | t_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerSourcesIdVerifyResponder = {
  with200(): KoaRuntimeResponse<t_bank_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerSourcesIdVerify = (
  params: Params<
    t_PostCustomersCustomerSourcesIdVerifyParamSchema,
    void,
    t_PostCustomersCustomerSourcesIdVerifyBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSourcesIdVerifyResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_bank_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerSubscriptionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_subscription[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerSubscriptions = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsParamSchema,
    t_GetCustomersCustomerSubscriptionsQuerySchema,
    t_GetCustomersCustomerSubscriptionsBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerSubscriptionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerSubscriptionsResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerSubscriptions = (
  params: Params<
    t_PostCustomersCustomerSubscriptionsParamSchema,
    void,
    t_PostCustomersCustomerSubscriptionsBodySchema | undefined,
    void
  >,
  respond: PostCustomersCustomerSubscriptionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponder =
  {
    with200(): KoaRuntimeResponse<t_subscription>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    | t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema
    | undefined,
    void
  >,
  respond: DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerSubscriptionsSubscriptionExposedIdResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
    | t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerSubscriptionsSubscriptionExposedIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerSubscriptionsSubscriptionExposedIdResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    | t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema
    | undefined,
    void
  >,
  respond: PostCustomersCustomerSubscriptionsSubscriptionExposedIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder =
  {
    with200(): KoaRuntimeResponse<t_deleted_discount>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount =
  (
    params: Params<
      t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
      void,
      | t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema
      | undefined,
      void
    >,
    respond: DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder,
    ctx: RouterContext,
    next: Next,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_deleted_discount>
    | Response<StatusCode, t_error>
    | typeof SkipResponse
  >

export type GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder =
  {
    with200(): KoaRuntimeResponse<t_discount>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
    | t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema
    | undefined,
    void
  >,
  respond: GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_discount>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerTaxIdsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_tax_id[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerTaxIds = (
  params: Params<
    t_GetCustomersCustomerTaxIdsParamSchema,
    t_GetCustomersCustomerTaxIdsQuerySchema,
    t_GetCustomersCustomerTaxIdsBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerTaxIdsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_id[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostCustomersCustomerTaxIdsResponder = {
  with200(): KoaRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostCustomersCustomerTaxIds = (
  params: Params<
    t_PostCustomersCustomerTaxIdsParamSchema,
    void,
    t_PostCustomersCustomerTaxIdsBodySchema,
    void
  >,
  respond: PostCustomersCustomerTaxIdsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteCustomersCustomerTaxIdsIdResponder = {
  with200(): KoaRuntimeResponse<t_deleted_tax_id>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteCustomersCustomerTaxIdsId = (
  params: Params<
    t_DeleteCustomersCustomerTaxIdsIdParamSchema,
    void,
    t_DeleteCustomersCustomerTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: DeleteCustomersCustomerTaxIdsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_tax_id>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetCustomersCustomerTaxIdsIdResponder = {
  with200(): KoaRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetCustomersCustomerTaxIdsId = (
  params: Params<
    t_GetCustomersCustomerTaxIdsIdParamSchema,
    t_GetCustomersCustomerTaxIdsIdQuerySchema,
    t_GetCustomersCustomerTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: GetCustomersCustomerTaxIdsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetDisputesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_dispute[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetDisputes = (
  params: Params<
    void,
    t_GetDisputesQuerySchema,
    t_GetDisputesBodySchema | undefined,
    void
  >,
  respond: GetDisputesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_dispute[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetDisputesDisputeResponder = {
  with200(): KoaRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetDisputesDispute = (
  params: Params<
    t_GetDisputesDisputeParamSchema,
    t_GetDisputesDisputeQuerySchema,
    t_GetDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: GetDisputesDisputeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostDisputesDisputeResponder = {
  with200(): KoaRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostDisputesDispute = (
  params: Params<
    t_PostDisputesDisputeParamSchema,
    void,
    t_PostDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: PostDisputesDisputeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostDisputesDisputeCloseResponder = {
  with200(): KoaRuntimeResponse<t_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostDisputesDisputeClose = (
  params: Params<
    t_PostDisputesDisputeCloseParamSchema,
    void,
    t_PostDisputesDisputeCloseBodySchema | undefined,
    void
  >,
  respond: PostDisputesDisputeCloseResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetEntitlementsActiveEntitlementsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_entitlements_active_entitlement[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetEntitlementsActiveEntitlements = (
  params: Params<
    void,
    t_GetEntitlementsActiveEntitlementsQuerySchema,
    t_GetEntitlementsActiveEntitlementsBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsActiveEntitlementsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_entitlements_active_entitlement[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetEntitlementsActiveEntitlementsIdResponder = {
  with200(): KoaRuntimeResponse<t_entitlements_active_entitlement>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetEntitlementsActiveEntitlementsId = (
  params: Params<
    t_GetEntitlementsActiveEntitlementsIdParamSchema,
    t_GetEntitlementsActiveEntitlementsIdQuerySchema,
    t_GetEntitlementsActiveEntitlementsIdBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsActiveEntitlementsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_active_entitlement>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetEntitlementsFeaturesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_entitlements_feature[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetEntitlementsFeatures = (
  params: Params<
    void,
    t_GetEntitlementsFeaturesQuerySchema,
    t_GetEntitlementsFeaturesBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsFeaturesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_entitlements_feature[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostEntitlementsFeaturesResponder = {
  with200(): KoaRuntimeResponse<t_entitlements_feature>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostEntitlementsFeatures = (
  params: Params<void, void, t_PostEntitlementsFeaturesBodySchema, void>,
  respond: PostEntitlementsFeaturesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_feature>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetEntitlementsFeaturesIdResponder = {
  with200(): KoaRuntimeResponse<t_entitlements_feature>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetEntitlementsFeaturesId = (
  params: Params<
    t_GetEntitlementsFeaturesIdParamSchema,
    t_GetEntitlementsFeaturesIdQuerySchema,
    t_GetEntitlementsFeaturesIdBodySchema | undefined,
    void
  >,
  respond: GetEntitlementsFeaturesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_feature>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostEntitlementsFeaturesIdResponder = {
  with200(): KoaRuntimeResponse<t_entitlements_feature>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostEntitlementsFeaturesId = (
  params: Params<
    t_PostEntitlementsFeaturesIdParamSchema,
    void,
    t_PostEntitlementsFeaturesIdBodySchema | undefined,
    void
  >,
  respond: PostEntitlementsFeaturesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_feature>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostEphemeralKeysResponder = {
  with200(): KoaRuntimeResponse<t_ephemeral_key>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostEphemeralKeys = (
  params: Params<void, void, t_PostEphemeralKeysBodySchema | undefined, void>,
  respond: PostEphemeralKeysResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ephemeral_key>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteEphemeralKeysKeyResponder = {
  with200(): KoaRuntimeResponse<t_ephemeral_key>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteEphemeralKeysKey = (
  params: Params<
    t_DeleteEphemeralKeysKeyParamSchema,
    void,
    t_DeleteEphemeralKeysKeyBodySchema | undefined,
    void
  >,
  respond: DeleteEphemeralKeysKeyResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ephemeral_key>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetEventsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_event[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetEvents = (
  params: Params<
    void,
    t_GetEventsQuerySchema,
    t_GetEventsBodySchema | undefined,
    void
  >,
  respond: GetEventsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_event[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetEventsIdResponder = {
  with200(): KoaRuntimeResponse<t_event>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetEventsId = (
  params: Params<
    t_GetEventsIdParamSchema,
    t_GetEventsIdQuerySchema,
    t_GetEventsIdBodySchema | undefined,
    void
  >,
  respond: GetEventsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_event>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetExchangeRatesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_exchange_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetExchangeRates = (
  params: Params<
    void,
    t_GetExchangeRatesQuerySchema,
    t_GetExchangeRatesBodySchema | undefined,
    void
  >,
  respond: GetExchangeRatesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_exchange_rate[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetExchangeRatesRateIdResponder = {
  with200(): KoaRuntimeResponse<t_exchange_rate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetExchangeRatesRateId = (
  params: Params<
    t_GetExchangeRatesRateIdParamSchema,
    t_GetExchangeRatesRateIdQuerySchema,
    t_GetExchangeRatesRateIdBodySchema | undefined,
    void
  >,
  respond: GetExchangeRatesRateIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_exchange_rate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostExternalAccountsIdResponder = {
  with200(): KoaRuntimeResponse<t_external_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostExternalAccountsId = (
  params: Params<
    t_PostExternalAccountsIdParamSchema,
    void,
    t_PostExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: PostExternalAccountsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFileLinksResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_file_link[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFileLinks = (
  params: Params<
    void,
    t_GetFileLinksQuerySchema,
    t_GetFileLinksBodySchema | undefined,
    void
  >,
  respond: GetFileLinksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_file_link[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFileLinksResponder = {
  with200(): KoaRuntimeResponse<t_file_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFileLinks = (
  params: Params<void, void, t_PostFileLinksBodySchema, void>,
  respond: PostFileLinksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFileLinksLinkResponder = {
  with200(): KoaRuntimeResponse<t_file_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFileLinksLink = (
  params: Params<
    t_GetFileLinksLinkParamSchema,
    t_GetFileLinksLinkQuerySchema,
    t_GetFileLinksLinkBodySchema | undefined,
    void
  >,
  respond: GetFileLinksLinkResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFileLinksLinkResponder = {
  with200(): KoaRuntimeResponse<t_file_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFileLinksLink = (
  params: Params<
    t_PostFileLinksLinkParamSchema,
    void,
    t_PostFileLinksLinkBodySchema | undefined,
    void
  >,
  respond: PostFileLinksLinkResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFilesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_file[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFiles = (
  params: Params<
    void,
    t_GetFilesQuerySchema,
    t_GetFilesBodySchema | undefined,
    void
  >,
  respond: GetFilesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_file[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFilesResponder = {
  with200(): KoaRuntimeResponse<t_file>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFiles = (
  params: Params<void, void, t_PostFilesBodySchema, void>,
  respond: PostFilesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFilesFileResponder = {
  with200(): KoaRuntimeResponse<t_file>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFilesFile = (
  params: Params<
    t_GetFilesFileParamSchema,
    t_GetFilesFileQuerySchema,
    t_GetFilesFileBodySchema | undefined,
    void
  >,
  respond: GetFilesFileResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFinancialConnectionsAccountsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_financial_connections_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFinancialConnectionsAccounts = (
  params: Params<
    void,
    t_GetFinancialConnectionsAccountsQuerySchema,
    t_GetFinancialConnectionsAccountsBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFinancialConnectionsAccountsAccountResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFinancialConnectionsAccountsAccount = (
  params: Params<
    t_GetFinancialConnectionsAccountsAccountParamSchema,
    t_GetFinancialConnectionsAccountsAccountQuerySchema,
    t_GetFinancialConnectionsAccountsAccountBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsAccountsAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFinancialConnectionsAccountsAccountDisconnectResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFinancialConnectionsAccountsAccountDisconnect = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountDisconnectParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountDisconnectBodySchema | undefined,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountDisconnectResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFinancialConnectionsAccountsAccountOwnersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_financial_connections_account_owner[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFinancialConnectionsAccountsAccountOwners = (
  params: Params<
    t_GetFinancialConnectionsAccountsAccountOwnersParamSchema,
    t_GetFinancialConnectionsAccountsAccountOwnersQuerySchema,
    t_GetFinancialConnectionsAccountsAccountOwnersBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsAccountsAccountOwnersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account_owner[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFinancialConnectionsAccountsAccountRefreshResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFinancialConnectionsAccountsAccountRefresh = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountRefreshParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountRefreshBodySchema,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountRefreshResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFinancialConnectionsAccountsAccountSubscribeResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFinancialConnectionsAccountsAccountSubscribe = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountSubscribeParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountSubscribeBodySchema,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountSubscribeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFinancialConnectionsAccountsAccountUnsubscribeResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFinancialConnectionsAccountsAccountUnsubscribe = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountUnsubscribeBodySchema,
    void
  >,
  respond: PostFinancialConnectionsAccountsAccountUnsubscribeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostFinancialConnectionsSessionsResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostFinancialConnectionsSessions = (
  params: Params<
    void,
    void,
    t_PostFinancialConnectionsSessionsBodySchema,
    void
  >,
  respond: PostFinancialConnectionsSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFinancialConnectionsSessionsSessionResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFinancialConnectionsSessionsSession = (
  params: Params<
    t_GetFinancialConnectionsSessionsSessionParamSchema,
    t_GetFinancialConnectionsSessionsSessionQuerySchema,
    t_GetFinancialConnectionsSessionsSessionBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsSessionsSessionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFinancialConnectionsTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_financial_connections_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFinancialConnectionsTransactions = (
  params: Params<
    void,
    t_GetFinancialConnectionsTransactionsQuerySchema,
    t_GetFinancialConnectionsTransactionsBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetFinancialConnectionsTransactionsTransactionResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetFinancialConnectionsTransactionsTransaction = (
  params: Params<
    t_GetFinancialConnectionsTransactionsTransactionParamSchema,
    t_GetFinancialConnectionsTransactionsTransactionQuerySchema,
    t_GetFinancialConnectionsTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: GetFinancialConnectionsTransactionsTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetForwardingRequestsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_forwarding_request[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetForwardingRequests = (
  params: Params<
    void,
    t_GetForwardingRequestsQuerySchema,
    t_GetForwardingRequestsBodySchema | undefined,
    void
  >,
  respond: GetForwardingRequestsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_forwarding_request[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostForwardingRequestsResponder = {
  with200(): KoaRuntimeResponse<t_forwarding_request>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostForwardingRequests = (
  params: Params<void, void, t_PostForwardingRequestsBodySchema, void>,
  respond: PostForwardingRequestsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_forwarding_request>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetForwardingRequestsIdResponder = {
  with200(): KoaRuntimeResponse<t_forwarding_request>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetForwardingRequestsId = (
  params: Params<
    t_GetForwardingRequestsIdParamSchema,
    t_GetForwardingRequestsIdQuerySchema,
    t_GetForwardingRequestsIdBodySchema | undefined,
    void
  >,
  respond: GetForwardingRequestsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_forwarding_request>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIdentityVerificationReportsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_identity_verification_report[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIdentityVerificationReports = (
  params: Params<
    void,
    t_GetIdentityVerificationReportsQuerySchema,
    t_GetIdentityVerificationReportsBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationReportsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_identity_verification_report[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIdentityVerificationReportsReportResponder = {
  with200(): KoaRuntimeResponse<t_identity_verification_report>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIdentityVerificationReportsReport = (
  params: Params<
    t_GetIdentityVerificationReportsReportParamSchema,
    t_GetIdentityVerificationReportsReportQuerySchema,
    t_GetIdentityVerificationReportsReportBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationReportsReportResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_report>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIdentityVerificationSessionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_identity_verification_session[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIdentityVerificationSessions = (
  params: Params<
    void,
    t_GetIdentityVerificationSessionsQuerySchema,
    t_GetIdentityVerificationSessionsBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_identity_verification_session[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIdentityVerificationSessionsResponder = {
  with200(): KoaRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIdentityVerificationSessions = (
  params: Params<
    void,
    void,
    t_PostIdentityVerificationSessionsBodySchema | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIdentityVerificationSessionsSessionResponder = {
  with200(): KoaRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIdentityVerificationSessionsSession = (
  params: Params<
    t_GetIdentityVerificationSessionsSessionParamSchema,
    t_GetIdentityVerificationSessionsSessionQuerySchema,
    t_GetIdentityVerificationSessionsSessionBodySchema | undefined,
    void
  >,
  respond: GetIdentityVerificationSessionsSessionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIdentityVerificationSessionsSessionResponder = {
  with200(): KoaRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIdentityVerificationSessionsSession = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionParamSchema,
    void,
    t_PostIdentityVerificationSessionsSessionBodySchema | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsSessionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIdentityVerificationSessionsSessionCancelResponder = {
  with200(): KoaRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIdentityVerificationSessionsSessionCancel = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionCancelParamSchema,
    void,
    t_PostIdentityVerificationSessionsSessionCancelBodySchema | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsSessionCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIdentityVerificationSessionsSessionRedactResponder = {
  with200(): KoaRuntimeResponse<t_identity_verification_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIdentityVerificationSessionsSessionRedact = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionRedactParamSchema,
    void,
    t_PostIdentityVerificationSessionsSessionRedactBodySchema | undefined,
    void
  >,
  respond: PostIdentityVerificationSessionsSessionRedactResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoicePaymentsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_invoice_payment[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoicePayments = (
  params: Params<
    void,
    t_GetInvoicePaymentsQuerySchema,
    t_GetInvoicePaymentsBodySchema | undefined,
    void
  >,
  respond: GetInvoicePaymentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice_payment[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoicePaymentsInvoicePaymentResponder = {
  with200(): KoaRuntimeResponse<t_invoice_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoicePaymentsInvoicePayment = (
  params: Params<
    t_GetInvoicePaymentsInvoicePaymentParamSchema,
    t_GetInvoicePaymentsInvoicePaymentQuerySchema,
    t_GetInvoicePaymentsInvoicePaymentBodySchema | undefined,
    void
  >,
  respond: GetInvoicePaymentsInvoicePaymentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoiceRenderingTemplatesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_invoice_rendering_template[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoiceRenderingTemplates = (
  params: Params<
    void,
    t_GetInvoiceRenderingTemplatesQuerySchema,
    t_GetInvoiceRenderingTemplatesBodySchema | undefined,
    void
  >,
  respond: GetInvoiceRenderingTemplatesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice_rendering_template[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoiceRenderingTemplatesTemplateResponder = {
  with200(): KoaRuntimeResponse<t_invoice_rendering_template>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoiceRenderingTemplatesTemplate = (
  params: Params<
    t_GetInvoiceRenderingTemplatesTemplateParamSchema,
    t_GetInvoiceRenderingTemplatesTemplateQuerySchema,
    t_GetInvoiceRenderingTemplatesTemplateBodySchema | undefined,
    void
  >,
  respond: GetInvoiceRenderingTemplatesTemplateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_rendering_template>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoiceRenderingTemplatesTemplateArchiveResponder = {
  with200(): KoaRuntimeResponse<t_invoice_rendering_template>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoiceRenderingTemplatesTemplateArchive = (
  params: Params<
    t_PostInvoiceRenderingTemplatesTemplateArchiveParamSchema,
    void,
    t_PostInvoiceRenderingTemplatesTemplateArchiveBodySchema | undefined,
    void
  >,
  respond: PostInvoiceRenderingTemplatesTemplateArchiveResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_rendering_template>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoiceRenderingTemplatesTemplateUnarchiveResponder = {
  with200(): KoaRuntimeResponse<t_invoice_rendering_template>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoiceRenderingTemplatesTemplateUnarchive = (
  params: Params<
    t_PostInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
    void,
    t_PostInvoiceRenderingTemplatesTemplateUnarchiveBodySchema | undefined,
    void
  >,
  respond: PostInvoiceRenderingTemplatesTemplateUnarchiveResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_rendering_template>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoiceitemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_invoiceitem[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoiceitems = (
  params: Params<
    void,
    t_GetInvoiceitemsQuerySchema,
    t_GetInvoiceitemsBodySchema | undefined,
    void
  >,
  respond: GetInvoiceitemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoiceitem[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoiceitemsResponder = {
  with200(): KoaRuntimeResponse<t_invoiceitem>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoiceitems = (
  params: Params<void, void, t_PostInvoiceitemsBodySchema, void>,
  respond: PostInvoiceitemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoiceitem>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteInvoiceitemsInvoiceitemResponder = {
  with200(): KoaRuntimeResponse<t_deleted_invoiceitem>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteInvoiceitemsInvoiceitem = (
  params: Params<
    t_DeleteInvoiceitemsInvoiceitemParamSchema,
    void,
    t_DeleteInvoiceitemsInvoiceitemBodySchema | undefined,
    void
  >,
  respond: DeleteInvoiceitemsInvoiceitemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_invoiceitem>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoiceitemsInvoiceitemResponder = {
  with200(): KoaRuntimeResponse<t_invoiceitem>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoiceitemsInvoiceitem = (
  params: Params<
    t_GetInvoiceitemsInvoiceitemParamSchema,
    t_GetInvoiceitemsInvoiceitemQuerySchema,
    t_GetInvoiceitemsInvoiceitemBodySchema | undefined,
    void
  >,
  respond: GetInvoiceitemsInvoiceitemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoiceitem>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoiceitemsInvoiceitemResponder = {
  with200(): KoaRuntimeResponse<t_invoiceitem>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoiceitemsInvoiceitem = (
  params: Params<
    t_PostInvoiceitemsInvoiceitemParamSchema,
    void,
    t_PostInvoiceitemsInvoiceitemBodySchema | undefined,
    void
  >,
  respond: PostInvoiceitemsInvoiceitemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoiceitem>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoicesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_invoice[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoices = (
  params: Params<
    void,
    t_GetInvoicesQuerySchema,
    t_GetInvoicesBodySchema | undefined,
    void
  >,
  respond: GetInvoicesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoices = (
  params: Params<void, void, t_PostInvoicesBodySchema | undefined, void>,
  respond: PostInvoicesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesCreatePreviewResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesCreatePreview = (
  params: Params<
    void,
    void,
    t_PostInvoicesCreatePreviewBodySchema | undefined,
    void
  >,
  respond: PostInvoicesCreatePreviewResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoicesSearchResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_invoice[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoicesSearch = (
  params: Params<
    void,
    t_GetInvoicesSearchQuerySchema,
    t_GetInvoicesSearchBodySchema | undefined,
    void
  >,
  respond: GetInvoicesSearchResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteInvoicesInvoiceResponder = {
  with200(): KoaRuntimeResponse<t_deleted_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteInvoicesInvoice = (
  params: Params<
    t_DeleteInvoicesInvoiceParamSchema,
    void,
    t_DeleteInvoicesInvoiceBodySchema | undefined,
    void
  >,
  respond: DeleteInvoicesInvoiceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoicesInvoiceResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoicesInvoice = (
  params: Params<
    t_GetInvoicesInvoiceParamSchema,
    t_GetInvoicesInvoiceQuerySchema,
    t_GetInvoicesInvoiceBodySchema | undefined,
    void
  >,
  respond: GetInvoicesInvoiceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoice = (
  params: Params<
    t_PostInvoicesInvoiceParamSchema,
    void,
    t_PostInvoicesInvoiceBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceAddLinesResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceAddLines = (
  params: Params<
    t_PostInvoicesInvoiceAddLinesParamSchema,
    void,
    t_PostInvoicesInvoiceAddLinesBodySchema,
    void
  >,
  respond: PostInvoicesInvoiceAddLinesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceAttachPaymentResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceAttachPayment = (
  params: Params<
    t_PostInvoicesInvoiceAttachPaymentParamSchema,
    void,
    t_PostInvoicesInvoiceAttachPaymentBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceAttachPaymentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceFinalizeResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceFinalize = (
  params: Params<
    t_PostInvoicesInvoiceFinalizeParamSchema,
    void,
    t_PostInvoicesInvoiceFinalizeBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceFinalizeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetInvoicesInvoiceLinesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetInvoicesInvoiceLines = (
  params: Params<
    t_GetInvoicesInvoiceLinesParamSchema,
    t_GetInvoicesInvoiceLinesQuerySchema,
    t_GetInvoicesInvoiceLinesBodySchema | undefined,
    void
  >,
  respond: GetInvoicesInvoiceLinesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceLinesLineItemIdResponder = {
  with200(): KoaRuntimeResponse<t_line_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceLinesLineItemId = (
  params: Params<
    t_PostInvoicesInvoiceLinesLineItemIdParamSchema,
    void,
    t_PostInvoicesInvoiceLinesLineItemIdBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceLinesLineItemIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_line_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceMarkUncollectibleResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceMarkUncollectible = (
  params: Params<
    t_PostInvoicesInvoiceMarkUncollectibleParamSchema,
    void,
    t_PostInvoicesInvoiceMarkUncollectibleBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceMarkUncollectibleResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoicePayResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoicePay = (
  params: Params<
    t_PostInvoicesInvoicePayParamSchema,
    void,
    t_PostInvoicesInvoicePayBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoicePayResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceRemoveLinesResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceRemoveLines = (
  params: Params<
    t_PostInvoicesInvoiceRemoveLinesParamSchema,
    void,
    t_PostInvoicesInvoiceRemoveLinesBodySchema,
    void
  >,
  respond: PostInvoicesInvoiceRemoveLinesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceSendResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceSend = (
  params: Params<
    t_PostInvoicesInvoiceSendParamSchema,
    void,
    t_PostInvoicesInvoiceSendBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceSendResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceUpdateLinesResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceUpdateLines = (
  params: Params<
    t_PostInvoicesInvoiceUpdateLinesParamSchema,
    void,
    t_PostInvoicesInvoiceUpdateLinesBodySchema,
    void
  >,
  respond: PostInvoicesInvoiceUpdateLinesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostInvoicesInvoiceVoidResponder = {
  with200(): KoaRuntimeResponse<t_invoice>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostInvoicesInvoiceVoid = (
  params: Params<
    t_PostInvoicesInvoiceVoidParamSchema,
    void,
    t_PostInvoicesInvoiceVoidBodySchema | undefined,
    void
  >,
  respond: PostInvoicesInvoiceVoidResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingAuthorizationsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_authorization[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingAuthorizations = (
  params: Params<
    void,
    t_GetIssuingAuthorizationsQuerySchema,
    t_GetIssuingAuthorizationsBodySchema | undefined,
    void
  >,
  respond: GetIssuingAuthorizationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_authorization[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingAuthorizationsAuthorizationResponder = {
  with200(): KoaRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingAuthorizationsAuthorization = (
  params: Params<
    t_GetIssuingAuthorizationsAuthorizationParamSchema,
    t_GetIssuingAuthorizationsAuthorizationQuerySchema,
    t_GetIssuingAuthorizationsAuthorizationBodySchema | undefined,
    void
  >,
  respond: GetIssuingAuthorizationsAuthorizationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingAuthorizationsAuthorizationResponder = {
  with200(): KoaRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingAuthorizationsAuthorization = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationParamSchema,
    void,
    t_PostIssuingAuthorizationsAuthorizationBodySchema | undefined,
    void
  >,
  respond: PostIssuingAuthorizationsAuthorizationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingAuthorizationsAuthorizationApproveResponder = {
  with200(): KoaRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingAuthorizationsAuthorizationApprove = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationApproveParamSchema,
    void,
    t_PostIssuingAuthorizationsAuthorizationApproveBodySchema | undefined,
    void
  >,
  respond: PostIssuingAuthorizationsAuthorizationApproveResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingAuthorizationsAuthorizationDeclineResponder = {
  with200(): KoaRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingAuthorizationsAuthorizationDecline = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationDeclineParamSchema,
    void,
    t_PostIssuingAuthorizationsAuthorizationDeclineBodySchema | undefined,
    void
  >,
  respond: PostIssuingAuthorizationsAuthorizationDeclineResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingCardholdersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_cardholder[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingCardholders = (
  params: Params<
    void,
    t_GetIssuingCardholdersQuerySchema,
    t_GetIssuingCardholdersBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardholdersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_cardholder[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingCardholdersResponder = {
  with200(): KoaRuntimeResponse<t_issuing_cardholder>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingCardholders = (
  params: Params<void, void, t_PostIssuingCardholdersBodySchema, void>,
  respond: PostIssuingCardholdersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_cardholder>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingCardholdersCardholderResponder = {
  with200(): KoaRuntimeResponse<t_issuing_cardholder>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingCardholdersCardholder = (
  params: Params<
    t_GetIssuingCardholdersCardholderParamSchema,
    t_GetIssuingCardholdersCardholderQuerySchema,
    t_GetIssuingCardholdersCardholderBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardholdersCardholderResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_cardholder>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingCardholdersCardholderResponder = {
  with200(): KoaRuntimeResponse<t_issuing_cardholder>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingCardholdersCardholder = (
  params: Params<
    t_PostIssuingCardholdersCardholderParamSchema,
    void,
    t_PostIssuingCardholdersCardholderBodySchema | undefined,
    void
  >,
  respond: PostIssuingCardholdersCardholderResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_cardholder>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingCardsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_card[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingCards = (
  params: Params<
    void,
    t_GetIssuingCardsQuerySchema,
    t_GetIssuingCardsBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_card[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingCardsResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingCards = (
  params: Params<void, void, t_PostIssuingCardsBodySchema, void>,
  respond: PostIssuingCardsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingCardsCardResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingCardsCard = (
  params: Params<
    t_GetIssuingCardsCardParamSchema,
    t_GetIssuingCardsCardQuerySchema,
    t_GetIssuingCardsCardBodySchema | undefined,
    void
  >,
  respond: GetIssuingCardsCardResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingCardsCardResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingCardsCard = (
  params: Params<
    t_PostIssuingCardsCardParamSchema,
    void,
    t_PostIssuingCardsCardBodySchema | undefined,
    void
  >,
  respond: PostIssuingCardsCardResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingDisputesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_dispute[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingDisputes = (
  params: Params<
    void,
    t_GetIssuingDisputesQuerySchema,
    t_GetIssuingDisputesBodySchema | undefined,
    void
  >,
  respond: GetIssuingDisputesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_dispute[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingDisputesResponder = {
  with200(): KoaRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingDisputes = (
  params: Params<void, void, t_PostIssuingDisputesBodySchema | undefined, void>,
  respond: PostIssuingDisputesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingDisputesDisputeResponder = {
  with200(): KoaRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingDisputesDispute = (
  params: Params<
    t_GetIssuingDisputesDisputeParamSchema,
    t_GetIssuingDisputesDisputeQuerySchema,
    t_GetIssuingDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: GetIssuingDisputesDisputeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingDisputesDisputeResponder = {
  with200(): KoaRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingDisputesDispute = (
  params: Params<
    t_PostIssuingDisputesDisputeParamSchema,
    void,
    t_PostIssuingDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: PostIssuingDisputesDisputeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingDisputesDisputeSubmitResponder = {
  with200(): KoaRuntimeResponse<t_issuing_dispute>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingDisputesDisputeSubmit = (
  params: Params<
    t_PostIssuingDisputesDisputeSubmitParamSchema,
    void,
    t_PostIssuingDisputesDisputeSubmitBodySchema | undefined,
    void
  >,
  respond: PostIssuingDisputesDisputeSubmitResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingPersonalizationDesignsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_personalization_design[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingPersonalizationDesigns = (
  params: Params<
    void,
    t_GetIssuingPersonalizationDesignsQuerySchema,
    t_GetIssuingPersonalizationDesignsBodySchema | undefined,
    void
  >,
  respond: GetIssuingPersonalizationDesignsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_personalization_design[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingPersonalizationDesignsResponder = {
  with200(): KoaRuntimeResponse<t_issuing_personalization_design>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingPersonalizationDesigns = (
  params: Params<
    void,
    void,
    t_PostIssuingPersonalizationDesignsBodySchema,
    void
  >,
  respond: PostIssuingPersonalizationDesignsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_personalization_design>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingPersonalizationDesignsPersonalizationDesignResponder = {
  with200(): KoaRuntimeResponse<t_issuing_personalization_design>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingPersonalizationDesignsPersonalizationDesign = (
  params: Params<
    t_GetIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
    t_GetIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
    | t_GetIssuingPersonalizationDesignsPersonalizationDesignBodySchema
    | undefined,
    void
  >,
  respond: GetIssuingPersonalizationDesignsPersonalizationDesignResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_personalization_design>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingPersonalizationDesignsPersonalizationDesignResponder = {
  with200(): KoaRuntimeResponse<t_issuing_personalization_design>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingPersonalizationDesignsPersonalizationDesign = (
  params: Params<
    t_PostIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
    void,
    | t_PostIssuingPersonalizationDesignsPersonalizationDesignBodySchema
    | undefined,
    void
  >,
  respond: PostIssuingPersonalizationDesignsPersonalizationDesignResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_personalization_design>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingPhysicalBundlesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_physical_bundle[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingPhysicalBundles = (
  params: Params<
    void,
    t_GetIssuingPhysicalBundlesQuerySchema,
    t_GetIssuingPhysicalBundlesBodySchema | undefined,
    void
  >,
  respond: GetIssuingPhysicalBundlesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_physical_bundle[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingPhysicalBundlesPhysicalBundleResponder = {
  with200(): KoaRuntimeResponse<t_issuing_physical_bundle>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingPhysicalBundlesPhysicalBundle = (
  params: Params<
    t_GetIssuingPhysicalBundlesPhysicalBundleParamSchema,
    t_GetIssuingPhysicalBundlesPhysicalBundleQuerySchema,
    t_GetIssuingPhysicalBundlesPhysicalBundleBodySchema | undefined,
    void
  >,
  respond: GetIssuingPhysicalBundlesPhysicalBundleResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_physical_bundle>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingSettlementsSettlementResponder = {
  with200(): KoaRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingSettlementsSettlement = (
  params: Params<
    t_GetIssuingSettlementsSettlementParamSchema,
    t_GetIssuingSettlementsSettlementQuerySchema,
    t_GetIssuingSettlementsSettlementBodySchema | undefined,
    void
  >,
  respond: GetIssuingSettlementsSettlementResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingSettlementsSettlementResponder = {
  with200(): KoaRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingSettlementsSettlement = (
  params: Params<
    t_PostIssuingSettlementsSettlementParamSchema,
    void,
    t_PostIssuingSettlementsSettlementBodySchema | undefined,
    void
  >,
  respond: PostIssuingSettlementsSettlementResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingTokensResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_token[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingTokens = (
  params: Params<
    void,
    t_GetIssuingTokensQuerySchema,
    t_GetIssuingTokensBodySchema | undefined,
    void
  >,
  respond: GetIssuingTokensResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_token[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingTokensTokenResponder = {
  with200(): KoaRuntimeResponse<t_issuing_token>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingTokensToken = (
  params: Params<
    t_GetIssuingTokensTokenParamSchema,
    t_GetIssuingTokensTokenQuerySchema,
    t_GetIssuingTokensTokenBodySchema | undefined,
    void
  >,
  respond: GetIssuingTokensTokenResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_token>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingTokensTokenResponder = {
  with200(): KoaRuntimeResponse<t_issuing_token>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingTokensToken = (
  params: Params<
    t_PostIssuingTokensTokenParamSchema,
    void,
    t_PostIssuingTokensTokenBodySchema,
    void
  >,
  respond: PostIssuingTokensTokenResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_token>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_issuing_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingTransactions = (
  params: Params<
    void,
    t_GetIssuingTransactionsQuerySchema,
    t_GetIssuingTransactionsBodySchema | undefined,
    void
  >,
  respond: GetIssuingTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetIssuingTransactionsTransactionResponder = {
  with200(): KoaRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetIssuingTransactionsTransaction = (
  params: Params<
    t_GetIssuingTransactionsTransactionParamSchema,
    t_GetIssuingTransactionsTransactionQuerySchema,
    t_GetIssuingTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: GetIssuingTransactionsTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostIssuingTransactionsTransactionResponder = {
  with200(): KoaRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostIssuingTransactionsTransaction = (
  params: Params<
    t_PostIssuingTransactionsTransactionParamSchema,
    void,
    t_PostIssuingTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: PostIssuingTransactionsTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostLinkAccountSessionsResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostLinkAccountSessions = (
  params: Params<void, void, t_PostLinkAccountSessionsBodySchema, void>,
  respond: PostLinkAccountSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetLinkAccountSessionsSessionResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_session>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetLinkAccountSessionsSession = (
  params: Params<
    t_GetLinkAccountSessionsSessionParamSchema,
    t_GetLinkAccountSessionsSessionQuerySchema,
    t_GetLinkAccountSessionsSessionBodySchema | undefined,
    void
  >,
  respond: GetLinkAccountSessionsSessionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetLinkedAccountsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_financial_connections_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetLinkedAccounts = (
  params: Params<
    void,
    t_GetLinkedAccountsQuerySchema,
    t_GetLinkedAccountsBodySchema | undefined,
    void
  >,
  respond: GetLinkedAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetLinkedAccountsAccountResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetLinkedAccountsAccount = (
  params: Params<
    t_GetLinkedAccountsAccountParamSchema,
    t_GetLinkedAccountsAccountQuerySchema,
    t_GetLinkedAccountsAccountBodySchema | undefined,
    void
  >,
  respond: GetLinkedAccountsAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostLinkedAccountsAccountDisconnectResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostLinkedAccountsAccountDisconnect = (
  params: Params<
    t_PostLinkedAccountsAccountDisconnectParamSchema,
    void,
    t_PostLinkedAccountsAccountDisconnectBodySchema | undefined,
    void
  >,
  respond: PostLinkedAccountsAccountDisconnectResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetLinkedAccountsAccountOwnersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_financial_connections_account_owner[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetLinkedAccountsAccountOwners = (
  params: Params<
    t_GetLinkedAccountsAccountOwnersParamSchema,
    t_GetLinkedAccountsAccountOwnersQuerySchema,
    t_GetLinkedAccountsAccountOwnersBodySchema | undefined,
    void
  >,
  respond: GetLinkedAccountsAccountOwnersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account_owner[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostLinkedAccountsAccountRefreshResponder = {
  with200(): KoaRuntimeResponse<t_financial_connections_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostLinkedAccountsAccountRefresh = (
  params: Params<
    t_PostLinkedAccountsAccountRefreshParamSchema,
    void,
    t_PostLinkedAccountsAccountRefreshBodySchema,
    void
  >,
  respond: PostLinkedAccountsAccountRefreshResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetMandatesMandateResponder = {
  with200(): KoaRuntimeResponse<t_mandate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetMandatesMandate = (
  params: Params<
    t_GetMandatesMandateParamSchema,
    t_GetMandatesMandateQuerySchema,
    t_GetMandatesMandateBodySchema | undefined,
    void
  >,
  respond: GetMandatesMandateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_mandate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentIntentsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payment_intent[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentIntents = (
  params: Params<
    void,
    t_GetPaymentIntentsQuerySchema,
    t_GetPaymentIntentsBodySchema | undefined,
    void
  >,
  respond: GetPaymentIntentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_intent[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntents = (
  params: Params<void, void, t_PostPaymentIntentsBodySchema, void>,
  respond: PostPaymentIntentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentIntentsSearchResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payment_intent[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentIntentsSearch = (
  params: Params<
    void,
    t_GetPaymentIntentsSearchQuerySchema,
    t_GetPaymentIntentsSearchBodySchema | undefined,
    void
  >,
  respond: GetPaymentIntentsSearchResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_intent[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentIntentsIntentResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentIntentsIntent = (
  params: Params<
    t_GetPaymentIntentsIntentParamSchema,
    t_GetPaymentIntentsIntentQuerySchema,
    t_GetPaymentIntentsIntentBodySchema | undefined,
    void
  >,
  respond: GetPaymentIntentsIntentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsIntentResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntentsIntent = (
  params: Params<
    t_PostPaymentIntentsIntentParamSchema,
    void,
    t_PostPaymentIntentsIntentBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsIntentApplyCustomerBalanceResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntentsIntentApplyCustomerBalance = (
  params: Params<
    t_PostPaymentIntentsIntentApplyCustomerBalanceParamSchema,
    void,
    t_PostPaymentIntentsIntentApplyCustomerBalanceBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentApplyCustomerBalanceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsIntentCancelResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntentsIntentCancel = (
  params: Params<
    t_PostPaymentIntentsIntentCancelParamSchema,
    void,
    t_PostPaymentIntentsIntentCancelBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsIntentCaptureResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntentsIntentCapture = (
  params: Params<
    t_PostPaymentIntentsIntentCaptureParamSchema,
    void,
    t_PostPaymentIntentsIntentCaptureBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentCaptureResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsIntentConfirmResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntentsIntentConfirm = (
  params: Params<
    t_PostPaymentIntentsIntentConfirmParamSchema,
    void,
    t_PostPaymentIntentsIntentConfirmBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentConfirmResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsIntentIncrementAuthorizationResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntentsIntentIncrementAuthorization = (
  params: Params<
    t_PostPaymentIntentsIntentIncrementAuthorizationParamSchema,
    void,
    t_PostPaymentIntentsIntentIncrementAuthorizationBodySchema,
    void
  >,
  respond: PostPaymentIntentsIntentIncrementAuthorizationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentIntentsIntentVerifyMicrodepositsResponder = {
  with200(): KoaRuntimeResponse<t_payment_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentIntentsIntentVerifyMicrodeposits = (
  params: Params<
    t_PostPaymentIntentsIntentVerifyMicrodepositsParamSchema,
    void,
    t_PostPaymentIntentsIntentVerifyMicrodepositsBodySchema | undefined,
    void
  >,
  respond: PostPaymentIntentsIntentVerifyMicrodepositsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentLinksResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payment_link[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentLinks = (
  params: Params<
    void,
    t_GetPaymentLinksQuerySchema,
    t_GetPaymentLinksBodySchema | undefined,
    void
  >,
  respond: GetPaymentLinksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_link[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentLinksResponder = {
  with200(): KoaRuntimeResponse<t_payment_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentLinks = (
  params: Params<void, void, t_PostPaymentLinksBodySchema, void>,
  respond: PostPaymentLinksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentLinksPaymentLinkResponder = {
  with200(): KoaRuntimeResponse<t_payment_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentLinksPaymentLink = (
  params: Params<
    t_GetPaymentLinksPaymentLinkParamSchema,
    t_GetPaymentLinksPaymentLinkQuerySchema,
    t_GetPaymentLinksPaymentLinkBodySchema | undefined,
    void
  >,
  respond: GetPaymentLinksPaymentLinkResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentLinksPaymentLinkResponder = {
  with200(): KoaRuntimeResponse<t_payment_link>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentLinksPaymentLink = (
  params: Params<
    t_PostPaymentLinksPaymentLinkParamSchema,
    void,
    t_PostPaymentLinksPaymentLinkBodySchema | undefined,
    void
  >,
  respond: PostPaymentLinksPaymentLinkResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_link>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentLinksPaymentLinkLineItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentLinksPaymentLinkLineItems = (
  params: Params<
    t_GetPaymentLinksPaymentLinkLineItemsParamSchema,
    t_GetPaymentLinksPaymentLinkLineItemsQuerySchema,
    t_GetPaymentLinksPaymentLinkLineItemsBodySchema | undefined,
    void
  >,
  respond: GetPaymentLinksPaymentLinkLineItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentMethodConfigurationsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payment_method_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentMethodConfigurations = (
  params: Params<
    void,
    t_GetPaymentMethodConfigurationsQuerySchema,
    t_GetPaymentMethodConfigurationsBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodConfigurationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method_configuration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodConfigurationsResponder = {
  with200(): KoaRuntimeResponse<t_payment_method_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodConfigurations = (
  params: Params<
    void,
    void,
    t_PostPaymentMethodConfigurationsBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodConfigurationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentMethodConfigurationsConfigurationResponder = {
  with200(): KoaRuntimeResponse<t_payment_method_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentMethodConfigurationsConfiguration = (
  params: Params<
    t_GetPaymentMethodConfigurationsConfigurationParamSchema,
    t_GetPaymentMethodConfigurationsConfigurationQuerySchema,
    t_GetPaymentMethodConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodConfigurationsConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodConfigurationsConfigurationResponder = {
  with200(): KoaRuntimeResponse<t_payment_method_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodConfigurationsConfiguration = (
  params: Params<
    t_PostPaymentMethodConfigurationsConfigurationParamSchema,
    void,
    t_PostPaymentMethodConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodConfigurationsConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentMethodDomainsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payment_method_domain[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentMethodDomains = (
  params: Params<
    void,
    t_GetPaymentMethodDomainsQuerySchema,
    t_GetPaymentMethodDomainsBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodDomainsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method_domain[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodDomainsResponder = {
  with200(): KoaRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodDomains = (
  params: Params<void, void, t_PostPaymentMethodDomainsBodySchema, void>,
  respond: PostPaymentMethodDomainsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentMethodDomainsPaymentMethodDomainResponder = {
  with200(): KoaRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentMethodDomainsPaymentMethodDomain = (
  params: Params<
    t_GetPaymentMethodDomainsPaymentMethodDomainParamSchema,
    t_GetPaymentMethodDomainsPaymentMethodDomainQuerySchema,
    t_GetPaymentMethodDomainsPaymentMethodDomainBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodDomainsPaymentMethodDomainResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodDomainsPaymentMethodDomainResponder = {
  with200(): KoaRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodDomainsPaymentMethodDomain = (
  params: Params<
    t_PostPaymentMethodDomainsPaymentMethodDomainParamSchema,
    void,
    t_PostPaymentMethodDomainsPaymentMethodDomainBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodDomainsPaymentMethodDomainResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodDomainsPaymentMethodDomainValidateResponder = {
  with200(): KoaRuntimeResponse<t_payment_method_domain>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodDomainsPaymentMethodDomainValidate = (
  params: Params<
    t_PostPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
    void,
    t_PostPaymentMethodDomainsPaymentMethodDomainValidateBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodDomainsPaymentMethodDomainValidateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentMethodsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payment_method[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentMethods = (
  params: Params<
    void,
    t_GetPaymentMethodsQuerySchema,
    t_GetPaymentMethodsBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodsResponder = {
  with200(): KoaRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethods = (
  params: Params<void, void, t_PostPaymentMethodsBodySchema | undefined, void>,
  respond: PostPaymentMethodsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPaymentMethodsPaymentMethodResponder = {
  with200(): KoaRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPaymentMethodsPaymentMethod = (
  params: Params<
    t_GetPaymentMethodsPaymentMethodParamSchema,
    t_GetPaymentMethodsPaymentMethodQuerySchema,
    t_GetPaymentMethodsPaymentMethodBodySchema | undefined,
    void
  >,
  respond: GetPaymentMethodsPaymentMethodResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodsPaymentMethodResponder = {
  with200(): KoaRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodsPaymentMethod = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodsPaymentMethodResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodsPaymentMethodAttachResponder = {
  with200(): KoaRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodsPaymentMethodAttach = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodAttachParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodAttachBodySchema,
    void
  >,
  respond: PostPaymentMethodsPaymentMethodAttachResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPaymentMethodsPaymentMethodDetachResponder = {
  with200(): KoaRuntimeResponse<t_payment_method>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPaymentMethodsPaymentMethodDetach = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodDetachParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodDetachBodySchema | undefined,
    void
  >,
  respond: PostPaymentMethodsPaymentMethodDetachResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPayoutsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_payout[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPayouts = (
  params: Params<
    void,
    t_GetPayoutsQuerySchema,
    t_GetPayoutsBodySchema | undefined,
    void
  >,
  respond: GetPayoutsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payout[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPayoutsResponder = {
  with200(): KoaRuntimeResponse<t_payout>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPayouts = (
  params: Params<void, void, t_PostPayoutsBodySchema, void>,
  respond: PostPayoutsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPayoutsPayoutResponder = {
  with200(): KoaRuntimeResponse<t_payout>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPayoutsPayout = (
  params: Params<
    t_GetPayoutsPayoutParamSchema,
    t_GetPayoutsPayoutQuerySchema,
    t_GetPayoutsPayoutBodySchema | undefined,
    void
  >,
  respond: GetPayoutsPayoutResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPayoutsPayoutResponder = {
  with200(): KoaRuntimeResponse<t_payout>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPayoutsPayout = (
  params: Params<
    t_PostPayoutsPayoutParamSchema,
    void,
    t_PostPayoutsPayoutBodySchema | undefined,
    void
  >,
  respond: PostPayoutsPayoutResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPayoutsPayoutCancelResponder = {
  with200(): KoaRuntimeResponse<t_payout>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPayoutsPayoutCancel = (
  params: Params<
    t_PostPayoutsPayoutCancelParamSchema,
    void,
    t_PostPayoutsPayoutCancelBodySchema | undefined,
    void
  >,
  respond: PostPayoutsPayoutCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPayoutsPayoutReverseResponder = {
  with200(): KoaRuntimeResponse<t_payout>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPayoutsPayoutReverse = (
  params: Params<
    t_PostPayoutsPayoutReverseParamSchema,
    void,
    t_PostPayoutsPayoutReverseBodySchema | undefined,
    void
  >,
  respond: PostPayoutsPayoutReverseResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPlansResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_plan[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPlans = (
  params: Params<
    void,
    t_GetPlansQuerySchema,
    t_GetPlansBodySchema | undefined,
    void
  >,
  respond: GetPlansResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_plan[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPlansResponder = {
  with200(): KoaRuntimeResponse<t_plan>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPlans = (
  params: Params<void, void, t_PostPlansBodySchema, void>,
  respond: PostPlansResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_plan>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeletePlansPlanResponder = {
  with200(): KoaRuntimeResponse<t_deleted_plan>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeletePlansPlan = (
  params: Params<
    t_DeletePlansPlanParamSchema,
    void,
    t_DeletePlansPlanBodySchema | undefined,
    void
  >,
  respond: DeletePlansPlanResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_plan>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPlansPlanResponder = {
  with200(): KoaRuntimeResponse<t_plan>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPlansPlan = (
  params: Params<
    t_GetPlansPlanParamSchema,
    t_GetPlansPlanQuerySchema,
    t_GetPlansPlanBodySchema | undefined,
    void
  >,
  respond: GetPlansPlanResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_plan>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPlansPlanResponder = {
  with200(): KoaRuntimeResponse<t_plan>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPlansPlan = (
  params: Params<
    t_PostPlansPlanParamSchema,
    void,
    t_PostPlansPlanBodySchema | undefined,
    void
  >,
  respond: PostPlansPlanResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_plan>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPricesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_price[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPrices = (
  params: Params<
    void,
    t_GetPricesQuerySchema,
    t_GetPricesBodySchema | undefined,
    void
  >,
  respond: GetPricesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_price[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPricesResponder = {
  with200(): KoaRuntimeResponse<t_price>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPrices = (
  params: Params<void, void, t_PostPricesBodySchema, void>,
  respond: PostPricesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_price>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPricesSearchResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_price[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPricesSearch = (
  params: Params<
    void,
    t_GetPricesSearchQuerySchema,
    t_GetPricesSearchBodySchema | undefined,
    void
  >,
  respond: GetPricesSearchResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_price[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPricesPriceResponder = {
  with200(): KoaRuntimeResponse<t_price>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPricesPrice = (
  params: Params<
    t_GetPricesPriceParamSchema,
    t_GetPricesPriceQuerySchema,
    t_GetPricesPriceBodySchema | undefined,
    void
  >,
  respond: GetPricesPriceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_price>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPricesPriceResponder = {
  with200(): KoaRuntimeResponse<t_price>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPricesPrice = (
  params: Params<
    t_PostPricesPriceParamSchema,
    void,
    t_PostPricesPriceBodySchema | undefined,
    void
  >,
  respond: PostPricesPriceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_price>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetProductsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_product[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetProducts = (
  params: Params<
    void,
    t_GetProductsQuerySchema,
    t_GetProductsBodySchema | undefined,
    void
  >,
  respond: GetProductsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_product[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostProductsResponder = {
  with200(): KoaRuntimeResponse<t_product>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostProducts = (
  params: Params<void, void, t_PostProductsBodySchema, void>,
  respond: PostProductsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetProductsSearchResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_product[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetProductsSearch = (
  params: Params<
    void,
    t_GetProductsSearchQuerySchema,
    t_GetProductsSearchBodySchema | undefined,
    void
  >,
  respond: GetProductsSearchResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_product[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteProductsIdResponder = {
  with200(): KoaRuntimeResponse<t_deleted_product>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteProductsId = (
  params: Params<
    t_DeleteProductsIdParamSchema,
    void,
    t_DeleteProductsIdBodySchema | undefined,
    void
  >,
  respond: DeleteProductsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_product>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetProductsIdResponder = {
  with200(): KoaRuntimeResponse<t_product>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetProductsId = (
  params: Params<
    t_GetProductsIdParamSchema,
    t_GetProductsIdQuerySchema,
    t_GetProductsIdBodySchema | undefined,
    void
  >,
  respond: GetProductsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostProductsIdResponder = {
  with200(): KoaRuntimeResponse<t_product>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostProductsId = (
  params: Params<
    t_PostProductsIdParamSchema,
    void,
    t_PostProductsIdBodySchema | undefined,
    void
  >,
  respond: PostProductsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetProductsProductFeaturesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_product_feature[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetProductsProductFeatures = (
  params: Params<
    t_GetProductsProductFeaturesParamSchema,
    t_GetProductsProductFeaturesQuerySchema,
    t_GetProductsProductFeaturesBodySchema | undefined,
    void
  >,
  respond: GetProductsProductFeaturesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_product_feature[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostProductsProductFeaturesResponder = {
  with200(): KoaRuntimeResponse<t_product_feature>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostProductsProductFeatures = (
  params: Params<
    t_PostProductsProductFeaturesParamSchema,
    void,
    t_PostProductsProductFeaturesBodySchema,
    void
  >,
  respond: PostProductsProductFeaturesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product_feature>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteProductsProductFeaturesIdResponder = {
  with200(): KoaRuntimeResponse<t_deleted_product_feature>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteProductsProductFeaturesId = (
  params: Params<
    t_DeleteProductsProductFeaturesIdParamSchema,
    void,
    t_DeleteProductsProductFeaturesIdBodySchema | undefined,
    void
  >,
  respond: DeleteProductsProductFeaturesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_product_feature>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetProductsProductFeaturesIdResponder = {
  with200(): KoaRuntimeResponse<t_product_feature>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetProductsProductFeaturesId = (
  params: Params<
    t_GetProductsProductFeaturesIdParamSchema,
    t_GetProductsProductFeaturesIdQuerySchema,
    t_GetProductsProductFeaturesIdBodySchema | undefined,
    void
  >,
  respond: GetProductsProductFeaturesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product_feature>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPromotionCodesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_promotion_code[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPromotionCodes = (
  params: Params<
    void,
    t_GetPromotionCodesQuerySchema,
    t_GetPromotionCodesBodySchema | undefined,
    void
  >,
  respond: GetPromotionCodesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_promotion_code[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPromotionCodesResponder = {
  with200(): KoaRuntimeResponse<t_promotion_code>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPromotionCodes = (
  params: Params<void, void, t_PostPromotionCodesBodySchema, void>,
  respond: PostPromotionCodesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_promotion_code>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetPromotionCodesPromotionCodeResponder = {
  with200(): KoaRuntimeResponse<t_promotion_code>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetPromotionCodesPromotionCode = (
  params: Params<
    t_GetPromotionCodesPromotionCodeParamSchema,
    t_GetPromotionCodesPromotionCodeQuerySchema,
    t_GetPromotionCodesPromotionCodeBodySchema | undefined,
    void
  >,
  respond: GetPromotionCodesPromotionCodeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_promotion_code>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostPromotionCodesPromotionCodeResponder = {
  with200(): KoaRuntimeResponse<t_promotion_code>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostPromotionCodesPromotionCode = (
  params: Params<
    t_PostPromotionCodesPromotionCodeParamSchema,
    void,
    t_PostPromotionCodesPromotionCodeBodySchema | undefined,
    void
  >,
  respond: PostPromotionCodesPromotionCodeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_promotion_code>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetQuotesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_quote[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetQuotes = (
  params: Params<
    void,
    t_GetQuotesQuerySchema,
    t_GetQuotesBodySchema | undefined,
    void
  >,
  respond: GetQuotesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_quote[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostQuotesResponder = {
  with200(): KoaRuntimeResponse<t_quote>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostQuotes = (
  params: Params<void, void, t_PostQuotesBodySchema | undefined, void>,
  respond: PostQuotesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetQuotesQuoteResponder = {
  with200(): KoaRuntimeResponse<t_quote>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetQuotesQuote = (
  params: Params<
    t_GetQuotesQuoteParamSchema,
    t_GetQuotesQuoteQuerySchema,
    t_GetQuotesQuoteBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuoteResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostQuotesQuoteResponder = {
  with200(): KoaRuntimeResponse<t_quote>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostQuotesQuote = (
  params: Params<
    t_PostQuotesQuoteParamSchema,
    void,
    t_PostQuotesQuoteBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostQuotesQuoteAcceptResponder = {
  with200(): KoaRuntimeResponse<t_quote>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostQuotesQuoteAccept = (
  params: Params<
    t_PostQuotesQuoteAcceptParamSchema,
    void,
    t_PostQuotesQuoteAcceptBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteAcceptResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostQuotesQuoteCancelResponder = {
  with200(): KoaRuntimeResponse<t_quote>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostQuotesQuoteCancel = (
  params: Params<
    t_PostQuotesQuoteCancelParamSchema,
    void,
    t_PostQuotesQuoteCancelBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetQuotesQuoteComputedUpfrontLineItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetQuotesQuoteComputedUpfrontLineItems = (
  params: Params<
    t_GetQuotesQuoteComputedUpfrontLineItemsParamSchema,
    t_GetQuotesQuoteComputedUpfrontLineItemsQuerySchema,
    t_GetQuotesQuoteComputedUpfrontLineItemsBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuoteComputedUpfrontLineItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostQuotesQuoteFinalizeResponder = {
  with200(): KoaRuntimeResponse<t_quote>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostQuotesQuoteFinalize = (
  params: Params<
    t_PostQuotesQuoteFinalizeParamSchema,
    void,
    t_PostQuotesQuoteFinalizeBodySchema | undefined,
    void
  >,
  respond: PostQuotesQuoteFinalizeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetQuotesQuoteLineItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetQuotesQuoteLineItems = (
  params: Params<
    t_GetQuotesQuoteLineItemsParamSchema,
    t_GetQuotesQuoteLineItemsQuerySchema,
    t_GetQuotesQuoteLineItemsBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuoteLineItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetQuotesQuotePdfResponder = {
  with200(): KoaRuntimeResponse<string>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetQuotesQuotePdf = (
  params: Params<
    t_GetQuotesQuotePdfParamSchema,
    t_GetQuotesQuotePdfQuerySchema,
    t_GetQuotesQuotePdfBodySchema | undefined,
    void
  >,
  respond: GetQuotesQuotePdfResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, string>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRadarEarlyFraudWarningsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_radar_early_fraud_warning[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRadarEarlyFraudWarnings = (
  params: Params<
    void,
    t_GetRadarEarlyFraudWarningsQuerySchema,
    t_GetRadarEarlyFraudWarningsBodySchema | undefined,
    void
  >,
  respond: GetRadarEarlyFraudWarningsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_radar_early_fraud_warning[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRadarEarlyFraudWarningsEarlyFraudWarningResponder = {
  with200(): KoaRuntimeResponse<t_radar_early_fraud_warning>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRadarEarlyFraudWarningsEarlyFraudWarning = (
  params: Params<
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningBodySchema | undefined,
    void
  >,
  respond: GetRadarEarlyFraudWarningsEarlyFraudWarningResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_early_fraud_warning>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRadarValueListItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_radar_value_list_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRadarValueListItems = (
  params: Params<
    void,
    t_GetRadarValueListItemsQuerySchema,
    t_GetRadarValueListItemsBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_radar_value_list_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostRadarValueListItemsResponder = {
  with200(): KoaRuntimeResponse<t_radar_value_list_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostRadarValueListItems = (
  params: Params<void, void, t_PostRadarValueListItemsBodySchema, void>,
  respond: PostRadarValueListItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteRadarValueListItemsItemResponder = {
  with200(): KoaRuntimeResponse<t_deleted_radar_value_list_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteRadarValueListItemsItem = (
  params: Params<
    t_DeleteRadarValueListItemsItemParamSchema,
    void,
    t_DeleteRadarValueListItemsItemBodySchema | undefined,
    void
  >,
  respond: DeleteRadarValueListItemsItemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_radar_value_list_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRadarValueListItemsItemResponder = {
  with200(): KoaRuntimeResponse<t_radar_value_list_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRadarValueListItemsItem = (
  params: Params<
    t_GetRadarValueListItemsItemParamSchema,
    t_GetRadarValueListItemsItemQuerySchema,
    t_GetRadarValueListItemsItemBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListItemsItemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRadarValueListsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_radar_value_list[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRadarValueLists = (
  params: Params<
    void,
    t_GetRadarValueListsQuerySchema,
    t_GetRadarValueListsBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_radar_value_list[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostRadarValueListsResponder = {
  with200(): KoaRuntimeResponse<t_radar_value_list>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostRadarValueLists = (
  params: Params<void, void, t_PostRadarValueListsBodySchema, void>,
  respond: PostRadarValueListsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteRadarValueListsValueListResponder = {
  with200(): KoaRuntimeResponse<t_deleted_radar_value_list>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteRadarValueListsValueList = (
  params: Params<
    t_DeleteRadarValueListsValueListParamSchema,
    void,
    t_DeleteRadarValueListsValueListBodySchema | undefined,
    void
  >,
  respond: DeleteRadarValueListsValueListResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_radar_value_list>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRadarValueListsValueListResponder = {
  with200(): KoaRuntimeResponse<t_radar_value_list>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRadarValueListsValueList = (
  params: Params<
    t_GetRadarValueListsValueListParamSchema,
    t_GetRadarValueListsValueListQuerySchema,
    t_GetRadarValueListsValueListBodySchema | undefined,
    void
  >,
  respond: GetRadarValueListsValueListResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostRadarValueListsValueListResponder = {
  with200(): KoaRuntimeResponse<t_radar_value_list>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostRadarValueListsValueList = (
  params: Params<
    t_PostRadarValueListsValueListParamSchema,
    void,
    t_PostRadarValueListsValueListBodySchema | undefined,
    void
  >,
  respond: PostRadarValueListsValueListResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRefundsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRefunds = (
  params: Params<
    void,
    t_GetRefundsQuerySchema,
    t_GetRefundsBodySchema | undefined,
    void
  >,
  respond: GetRefundsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_refund[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostRefundsResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostRefunds = (
  params: Params<void, void, t_PostRefundsBodySchema | undefined, void>,
  respond: PostRefundsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetRefundsRefundResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetRefundsRefund = (
  params: Params<
    t_GetRefundsRefundParamSchema,
    t_GetRefundsRefundQuerySchema,
    t_GetRefundsRefundBodySchema | undefined,
    void
  >,
  respond: GetRefundsRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostRefundsRefundResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostRefundsRefund = (
  params: Params<
    t_PostRefundsRefundParamSchema,
    void,
    t_PostRefundsRefundBodySchema | undefined,
    void
  >,
  respond: PostRefundsRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostRefundsRefundCancelResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostRefundsRefundCancel = (
  params: Params<
    t_PostRefundsRefundCancelParamSchema,
    void,
    t_PostRefundsRefundCancelBodySchema | undefined,
    void
  >,
  respond: PostRefundsRefundCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetReportingReportRunsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_reporting_report_run[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetReportingReportRuns = (
  params: Params<
    void,
    t_GetReportingReportRunsQuerySchema,
    t_GetReportingReportRunsBodySchema | undefined,
    void
  >,
  respond: GetReportingReportRunsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_reporting_report_run[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostReportingReportRunsResponder = {
  with200(): KoaRuntimeResponse<t_reporting_report_run>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostReportingReportRuns = (
  params: Params<void, void, t_PostReportingReportRunsBodySchema, void>,
  respond: PostReportingReportRunsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reporting_report_run>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetReportingReportRunsReportRunResponder = {
  with200(): KoaRuntimeResponse<t_reporting_report_run>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetReportingReportRunsReportRun = (
  params: Params<
    t_GetReportingReportRunsReportRunParamSchema,
    t_GetReportingReportRunsReportRunQuerySchema,
    t_GetReportingReportRunsReportRunBodySchema | undefined,
    void
  >,
  respond: GetReportingReportRunsReportRunResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reporting_report_run>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetReportingReportTypesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_reporting_report_type[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetReportingReportTypes = (
  params: Params<
    void,
    t_GetReportingReportTypesQuerySchema,
    t_GetReportingReportTypesBodySchema | undefined,
    void
  >,
  respond: GetReportingReportTypesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_reporting_report_type[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetReportingReportTypesReportTypeResponder = {
  with200(): KoaRuntimeResponse<t_reporting_report_type>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetReportingReportTypesReportType = (
  params: Params<
    t_GetReportingReportTypesReportTypeParamSchema,
    t_GetReportingReportTypesReportTypeQuerySchema,
    t_GetReportingReportTypesReportTypeBodySchema | undefined,
    void
  >,
  respond: GetReportingReportTypesReportTypeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reporting_report_type>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetReviewsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_review[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetReviews = (
  params: Params<
    void,
    t_GetReviewsQuerySchema,
    t_GetReviewsBodySchema | undefined,
    void
  >,
  respond: GetReviewsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_review[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetReviewsReviewResponder = {
  with200(): KoaRuntimeResponse<t_review>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetReviewsReview = (
  params: Params<
    t_GetReviewsReviewParamSchema,
    t_GetReviewsReviewQuerySchema,
    t_GetReviewsReviewBodySchema | undefined,
    void
  >,
  respond: GetReviewsReviewResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_review>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostReviewsReviewApproveResponder = {
  with200(): KoaRuntimeResponse<t_review>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostReviewsReviewApprove = (
  params: Params<
    t_PostReviewsReviewApproveParamSchema,
    void,
    t_PostReviewsReviewApproveBodySchema | undefined,
    void
  >,
  respond: PostReviewsReviewApproveResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_review>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSetupAttemptsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_setup_attempt[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSetupAttempts = (
  params: Params<
    void,
    t_GetSetupAttemptsQuerySchema,
    t_GetSetupAttemptsBodySchema | undefined,
    void
  >,
  respond: GetSetupAttemptsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_setup_attempt[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSetupIntentsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_setup_intent[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSetupIntents = (
  params: Params<
    void,
    t_GetSetupIntentsQuerySchema,
    t_GetSetupIntentsBodySchema | undefined,
    void
  >,
  respond: GetSetupIntentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_setup_intent[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSetupIntentsResponder = {
  with200(): KoaRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSetupIntents = (
  params: Params<void, void, t_PostSetupIntentsBodySchema | undefined, void>,
  respond: PostSetupIntentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSetupIntentsIntentResponder = {
  with200(): KoaRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSetupIntentsIntent = (
  params: Params<
    t_GetSetupIntentsIntentParamSchema,
    t_GetSetupIntentsIntentQuerySchema,
    t_GetSetupIntentsIntentBodySchema | undefined,
    void
  >,
  respond: GetSetupIntentsIntentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSetupIntentsIntentResponder = {
  with200(): KoaRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSetupIntentsIntent = (
  params: Params<
    t_PostSetupIntentsIntentParamSchema,
    void,
    t_PostSetupIntentsIntentBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSetupIntentsIntentCancelResponder = {
  with200(): KoaRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSetupIntentsIntentCancel = (
  params: Params<
    t_PostSetupIntentsIntentCancelParamSchema,
    void,
    t_PostSetupIntentsIntentCancelBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSetupIntentsIntentConfirmResponder = {
  with200(): KoaRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSetupIntentsIntentConfirm = (
  params: Params<
    t_PostSetupIntentsIntentConfirmParamSchema,
    void,
    t_PostSetupIntentsIntentConfirmBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentConfirmResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSetupIntentsIntentVerifyMicrodepositsResponder = {
  with200(): KoaRuntimeResponse<t_setup_intent>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSetupIntentsIntentVerifyMicrodeposits = (
  params: Params<
    t_PostSetupIntentsIntentVerifyMicrodepositsParamSchema,
    void,
    t_PostSetupIntentsIntentVerifyMicrodepositsBodySchema | undefined,
    void
  >,
  respond: PostSetupIntentsIntentVerifyMicrodepositsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetShippingRatesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_shipping_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetShippingRates = (
  params: Params<
    void,
    t_GetShippingRatesQuerySchema,
    t_GetShippingRatesBodySchema | undefined,
    void
  >,
  respond: GetShippingRatesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_shipping_rate[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostShippingRatesResponder = {
  with200(): KoaRuntimeResponse<t_shipping_rate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostShippingRates = (
  params: Params<void, void, t_PostShippingRatesBodySchema, void>,
  respond: PostShippingRatesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_shipping_rate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetShippingRatesShippingRateTokenResponder = {
  with200(): KoaRuntimeResponse<t_shipping_rate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetShippingRatesShippingRateToken = (
  params: Params<
    t_GetShippingRatesShippingRateTokenParamSchema,
    t_GetShippingRatesShippingRateTokenQuerySchema,
    t_GetShippingRatesShippingRateTokenBodySchema | undefined,
    void
  >,
  respond: GetShippingRatesShippingRateTokenResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_shipping_rate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostShippingRatesShippingRateTokenResponder = {
  with200(): KoaRuntimeResponse<t_shipping_rate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostShippingRatesShippingRateToken = (
  params: Params<
    t_PostShippingRatesShippingRateTokenParamSchema,
    void,
    t_PostShippingRatesShippingRateTokenBodySchema | undefined,
    void
  >,
  respond: PostShippingRatesShippingRateTokenResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_shipping_rate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSigmaSavedQueriesIdResponder = {
  with200(): KoaRuntimeResponse<t_sigma_sigma_api_query>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSigmaSavedQueriesId = (
  params: Params<
    t_PostSigmaSavedQueriesIdParamSchema,
    void,
    t_PostSigmaSavedQueriesIdBodySchema | undefined,
    void
  >,
  respond: PostSigmaSavedQueriesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_sigma_sigma_api_query>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSigmaScheduledQueryRunsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_scheduled_query_run[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSigmaScheduledQueryRuns = (
  params: Params<
    void,
    t_GetSigmaScheduledQueryRunsQuerySchema,
    t_GetSigmaScheduledQueryRunsBodySchema | undefined,
    void
  >,
  respond: GetSigmaScheduledQueryRunsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_scheduled_query_run[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSigmaScheduledQueryRunsScheduledQueryRunResponder = {
  with200(): KoaRuntimeResponse<t_scheduled_query_run>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSigmaScheduledQueryRunsScheduledQueryRun = (
  params: Params<
    t_GetSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
    t_GetSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
    t_GetSigmaScheduledQueryRunsScheduledQueryRunBodySchema | undefined,
    void
  >,
  respond: GetSigmaScheduledQueryRunsScheduledQueryRunResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_scheduled_query_run>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSourcesResponder = {
  with200(): KoaRuntimeResponse<t_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSources = (
  params: Params<void, void, t_PostSourcesBodySchema | undefined, void>,
  respond: PostSourcesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSourcesSourceResponder = {
  with200(): KoaRuntimeResponse<t_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSourcesSource = (
  params: Params<
    t_GetSourcesSourceParamSchema,
    t_GetSourcesSourceQuerySchema,
    t_GetSourcesSourceBodySchema | undefined,
    void
  >,
  respond: GetSourcesSourceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSourcesSourceResponder = {
  with200(): KoaRuntimeResponse<t_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSourcesSource = (
  params: Params<
    t_PostSourcesSourceParamSchema,
    void,
    t_PostSourcesSourceBodySchema | undefined,
    void
  >,
  respond: PostSourcesSourceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSourcesSourceMandateNotificationsMandateNotificationResponder = {
  with200(): KoaRuntimeResponse<t_source_mandate_notification>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSourcesSourceMandateNotificationsMandateNotification = (
  params: Params<
    t_GetSourcesSourceMandateNotificationsMandateNotificationParamSchema,
    t_GetSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
    | t_GetSourcesSourceMandateNotificationsMandateNotificationBodySchema
    | undefined,
    void
  >,
  respond: GetSourcesSourceMandateNotificationsMandateNotificationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source_mandate_notification>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSourcesSourceSourceTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_source_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSourcesSourceSourceTransactions = (
  params: Params<
    t_GetSourcesSourceSourceTransactionsParamSchema,
    t_GetSourcesSourceSourceTransactionsQuerySchema,
    t_GetSourcesSourceSourceTransactionsBodySchema | undefined,
    void
  >,
  respond: GetSourcesSourceSourceTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_source_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSourcesSourceSourceTransactionsSourceTransactionResponder = {
  with200(): KoaRuntimeResponse<t_source_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSourcesSourceSourceTransactionsSourceTransaction = (
  params: Params<
    t_GetSourcesSourceSourceTransactionsSourceTransactionParamSchema,
    t_GetSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
    t_GetSourcesSourceSourceTransactionsSourceTransactionBodySchema | undefined,
    void
  >,
  respond: GetSourcesSourceSourceTransactionsSourceTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSourcesSourceVerifyResponder = {
  with200(): KoaRuntimeResponse<t_source>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSourcesSourceVerify = (
  params: Params<
    t_PostSourcesSourceVerifyParamSchema,
    void,
    t_PostSourcesSourceVerifyBodySchema,
    void
  >,
  respond: PostSourcesSourceVerifyResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSubscriptionItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_subscription_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSubscriptionItems = (
  params: Params<
    void,
    t_GetSubscriptionItemsQuerySchema,
    t_GetSubscriptionItemsBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionItemsResponder = {
  with200(): KoaRuntimeResponse<t_subscription_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionItems = (
  params: Params<void, void, t_PostSubscriptionItemsBodySchema, void>,
  respond: PostSubscriptionItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteSubscriptionItemsItemResponder = {
  with200(): KoaRuntimeResponse<t_deleted_subscription_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteSubscriptionItemsItem = (
  params: Params<
    t_DeleteSubscriptionItemsItemParamSchema,
    void,
    t_DeleteSubscriptionItemsItemBodySchema | undefined,
    void
  >,
  respond: DeleteSubscriptionItemsItemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_subscription_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSubscriptionItemsItemResponder = {
  with200(): KoaRuntimeResponse<t_subscription_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSubscriptionItemsItem = (
  params: Params<
    t_GetSubscriptionItemsItemParamSchema,
    t_GetSubscriptionItemsItemQuerySchema,
    t_GetSubscriptionItemsItemBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionItemsItemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionItemsItemResponder = {
  with200(): KoaRuntimeResponse<t_subscription_item>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionItemsItem = (
  params: Params<
    t_PostSubscriptionItemsItemParamSchema,
    void,
    t_PostSubscriptionItemsItemBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionItemsItemResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_item>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSubscriptionSchedulesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_subscription_schedule[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSubscriptionSchedules = (
  params: Params<
    void,
    t_GetSubscriptionSchedulesQuerySchema,
    t_GetSubscriptionSchedulesBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionSchedulesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription_schedule[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionSchedulesResponder = {
  with200(): KoaRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionSchedules = (
  params: Params<
    void,
    void,
    t_PostSubscriptionSchedulesBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSubscriptionSchedulesScheduleResponder = {
  with200(): KoaRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSubscriptionSchedulesSchedule = (
  params: Params<
    t_GetSubscriptionSchedulesScheduleParamSchema,
    t_GetSubscriptionSchedulesScheduleQuerySchema,
    t_GetSubscriptionSchedulesScheduleBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionSchedulesScheduleResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionSchedulesScheduleResponder = {
  with200(): KoaRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionSchedulesSchedule = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesScheduleResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionSchedulesScheduleCancelResponder = {
  with200(): KoaRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionSchedulesScheduleCancel = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleCancelParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleCancelBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesScheduleCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionSchedulesScheduleReleaseResponder = {
  with200(): KoaRuntimeResponse<t_subscription_schedule>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionSchedulesScheduleRelease = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleReleaseParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleReleaseBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionSchedulesScheduleReleaseResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSubscriptionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_subscription[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSubscriptions = (
  params: Params<
    void,
    t_GetSubscriptionsQuerySchema,
    t_GetSubscriptionsBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionsResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptions = (
  params: Params<void, void, t_PostSubscriptionsBodySchema, void>,
  respond: PostSubscriptionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSubscriptionsSearchResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_subscription[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSubscriptionsSearch = (
  params: Params<
    void,
    t_GetSubscriptionsSearchQuerySchema,
    t_GetSubscriptionsSearchBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionsSearchResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteSubscriptionsSubscriptionExposedIdResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_DeleteSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    t_DeleteSubscriptionsSubscriptionExposedIdBodySchema | undefined,
    void
  >,
  respond: DeleteSubscriptionsSubscriptionExposedIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetSubscriptionsSubscriptionExposedIdResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_GetSubscriptionsSubscriptionExposedIdParamSchema,
    t_GetSubscriptionsSubscriptionExposedIdQuerySchema,
    t_GetSubscriptionsSubscriptionExposedIdBodySchema | undefined,
    void
  >,
  respond: GetSubscriptionsSubscriptionExposedIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionsSubscriptionExposedIdResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_PostSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    t_PostSubscriptionsSubscriptionExposedIdBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionsSubscriptionExposedIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteSubscriptionsSubscriptionExposedIdDiscountResponder = {
  with200(): KoaRuntimeResponse<t_deleted_discount>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteSubscriptionsSubscriptionExposedIdDiscount = (
  params: Params<
    t_DeleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
    void,
    t_DeleteSubscriptionsSubscriptionExposedIdDiscountBodySchema | undefined,
    void
  >,
  respond: DeleteSubscriptionsSubscriptionExposedIdDiscountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_discount>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionsSubscriptionMigrateResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionsSubscriptionMigrate = (
  params: Params<
    t_PostSubscriptionsSubscriptionMigrateParamSchema,
    void,
    t_PostSubscriptionsSubscriptionMigrateBodySchema,
    void
  >,
  respond: PostSubscriptionsSubscriptionMigrateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostSubscriptionsSubscriptionResumeResponder = {
  with200(): KoaRuntimeResponse<t_subscription>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostSubscriptionsSubscriptionResume = (
  params: Params<
    t_PostSubscriptionsSubscriptionResumeParamSchema,
    void,
    t_PostSubscriptionsSubscriptionResumeBodySchema | undefined,
    void
  >,
  respond: PostSubscriptionsSubscriptionResumeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxCalculationsResponder = {
  with200(): KoaRuntimeResponse<t_tax_calculation>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxCalculations = (
  params: Params<void, void, t_PostTaxCalculationsBodySchema, void>,
  respond: PostTaxCalculationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_calculation>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxCalculationsCalculationResponder = {
  with200(): KoaRuntimeResponse<t_tax_calculation>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxCalculationsCalculation = (
  params: Params<
    t_GetTaxCalculationsCalculationParamSchema,
    t_GetTaxCalculationsCalculationQuerySchema,
    t_GetTaxCalculationsCalculationBodySchema | undefined,
    void
  >,
  respond: GetTaxCalculationsCalculationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_calculation>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxCalculationsCalculationLineItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_tax_calculation_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxCalculationsCalculationLineItems = (
  params: Params<
    t_GetTaxCalculationsCalculationLineItemsParamSchema,
    t_GetTaxCalculationsCalculationLineItemsQuerySchema,
    t_GetTaxCalculationsCalculationLineItemsBodySchema | undefined,
    void
  >,
  respond: GetTaxCalculationsCalculationLineItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_calculation_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxRegistrationsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_tax_registration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxRegistrations = (
  params: Params<
    void,
    t_GetTaxRegistrationsQuerySchema,
    t_GetTaxRegistrationsBodySchema | undefined,
    void
  >,
  respond: GetTaxRegistrationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_registration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxRegistrationsResponder = {
  with200(): KoaRuntimeResponse<t_tax_registration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxRegistrations = (
  params: Params<void, void, t_PostTaxRegistrationsBodySchema, void>,
  respond: PostTaxRegistrationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_registration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxRegistrationsIdResponder = {
  with200(): KoaRuntimeResponse<t_tax_registration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxRegistrationsId = (
  params: Params<
    t_GetTaxRegistrationsIdParamSchema,
    t_GetTaxRegistrationsIdQuerySchema,
    t_GetTaxRegistrationsIdBodySchema | undefined,
    void
  >,
  respond: GetTaxRegistrationsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_registration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxRegistrationsIdResponder = {
  with200(): KoaRuntimeResponse<t_tax_registration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxRegistrationsId = (
  params: Params<
    t_PostTaxRegistrationsIdParamSchema,
    void,
    t_PostTaxRegistrationsIdBodySchema | undefined,
    void
  >,
  respond: PostTaxRegistrationsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_registration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxSettingsResponder = {
  with200(): KoaRuntimeResponse<t_tax_settings>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxSettings = (
  params: Params<
    void,
    t_GetTaxSettingsQuerySchema,
    t_GetTaxSettingsBodySchema | undefined,
    void
  >,
  respond: GetTaxSettingsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_settings>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxSettingsResponder = {
  with200(): KoaRuntimeResponse<t_tax_settings>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxSettings = (
  params: Params<void, void, t_PostTaxSettingsBodySchema | undefined, void>,
  respond: PostTaxSettingsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_settings>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxTransactionsCreateFromCalculationResponder = {
  with200(): KoaRuntimeResponse<t_tax_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxTransactionsCreateFromCalculation = (
  params: Params<
    void,
    void,
    t_PostTaxTransactionsCreateFromCalculationBodySchema,
    void
  >,
  respond: PostTaxTransactionsCreateFromCalculationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxTransactionsCreateReversalResponder = {
  with200(): KoaRuntimeResponse<t_tax_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxTransactionsCreateReversal = (
  params: Params<
    void,
    void,
    t_PostTaxTransactionsCreateReversalBodySchema,
    void
  >,
  respond: PostTaxTransactionsCreateReversalResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxTransactionsTransactionResponder = {
  with200(): KoaRuntimeResponse<t_tax_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxTransactionsTransaction = (
  params: Params<
    t_GetTaxTransactionsTransactionParamSchema,
    t_GetTaxTransactionsTransactionQuerySchema,
    t_GetTaxTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: GetTaxTransactionsTransactionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxTransactionsTransactionLineItemsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_tax_transaction_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxTransactionsTransactionLineItems = (
  params: Params<
    t_GetTaxTransactionsTransactionLineItemsParamSchema,
    t_GetTaxTransactionsTransactionLineItemsQuerySchema,
    t_GetTaxTransactionsTransactionLineItemsBodySchema | undefined,
    void
  >,
  respond: GetTaxTransactionsTransactionLineItemsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_transaction_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxCodesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_tax_code[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxCodes = (
  params: Params<
    void,
    t_GetTaxCodesQuerySchema,
    t_GetTaxCodesBodySchema | undefined,
    void
  >,
  respond: GetTaxCodesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_code[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxCodesIdResponder = {
  with200(): KoaRuntimeResponse<t_tax_code>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxCodesId = (
  params: Params<
    t_GetTaxCodesIdParamSchema,
    t_GetTaxCodesIdQuerySchema,
    t_GetTaxCodesIdBodySchema | undefined,
    void
  >,
  respond: GetTaxCodesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_code>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxIdsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_tax_id[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxIds = (
  params: Params<
    void,
    t_GetTaxIdsQuerySchema,
    t_GetTaxIdsBodySchema | undefined,
    void
  >,
  respond: GetTaxIdsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_id[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxIdsResponder = {
  with200(): KoaRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxIds = (
  params: Params<void, void, t_PostTaxIdsBodySchema, void>,
  respond: PostTaxIdsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteTaxIdsIdResponder = {
  with200(): KoaRuntimeResponse<t_deleted_tax_id>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteTaxIdsId = (
  params: Params<
    t_DeleteTaxIdsIdParamSchema,
    void,
    t_DeleteTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: DeleteTaxIdsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_tax_id>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxIdsIdResponder = {
  with200(): KoaRuntimeResponse<t_tax_id>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxIdsId = (
  params: Params<
    t_GetTaxIdsIdParamSchema,
    t_GetTaxIdsIdQuerySchema,
    t_GetTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: GetTaxIdsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxRatesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_tax_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxRates = (
  params: Params<
    void,
    t_GetTaxRatesQuerySchema,
    t_GetTaxRatesBodySchema | undefined,
    void
  >,
  respond: GetTaxRatesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_rate[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxRatesResponder = {
  with200(): KoaRuntimeResponse<t_tax_rate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxRates = (
  params: Params<void, void, t_PostTaxRatesBodySchema, void>,
  respond: PostTaxRatesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_rate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTaxRatesTaxRateResponder = {
  with200(): KoaRuntimeResponse<t_tax_rate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTaxRatesTaxRate = (
  params: Params<
    t_GetTaxRatesTaxRateParamSchema,
    t_GetTaxRatesTaxRateQuerySchema,
    t_GetTaxRatesTaxRateBodySchema | undefined,
    void
  >,
  respond: GetTaxRatesTaxRateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_rate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTaxRatesTaxRateResponder = {
  with200(): KoaRuntimeResponse<t_tax_rate>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTaxRatesTaxRate = (
  params: Params<
    t_PostTaxRatesTaxRateParamSchema,
    void,
    t_PostTaxRatesTaxRateBodySchema | undefined,
    void
  >,
  respond: PostTaxRatesTaxRateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_rate>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTerminalConfigurationsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_terminal_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTerminalConfigurations = (
  params: Params<
    void,
    t_GetTerminalConfigurationsQuerySchema,
    t_GetTerminalConfigurationsBodySchema | undefined,
    void
  >,
  respond: GetTerminalConfigurationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_terminal_configuration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalConfigurationsResponder = {
  with200(): KoaRuntimeResponse<t_terminal_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalConfigurations = (
  params: Params<
    void,
    void,
    t_PostTerminalConfigurationsBodySchema | undefined,
    void
  >,
  respond: PostTerminalConfigurationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteTerminalConfigurationsConfigurationResponder = {
  with200(): KoaRuntimeResponse<t_deleted_terminal_configuration>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteTerminalConfigurationsConfiguration = (
  params: Params<
    t_DeleteTerminalConfigurationsConfigurationParamSchema,
    void,
    t_DeleteTerminalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: DeleteTerminalConfigurationsConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_terminal_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTerminalConfigurationsConfigurationResponder = {
  with200(): KoaRuntimeResponse<
    t_terminal_configuration | t_deleted_terminal_configuration
  >
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTerminalConfigurationsConfiguration = (
  params: Params<
    t_GetTerminalConfigurationsConfigurationParamSchema,
    t_GetTerminalConfigurationsConfigurationQuerySchema,
    t_GetTerminalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: GetTerminalConfigurationsConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_configuration | t_deleted_terminal_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalConfigurationsConfigurationResponder = {
  with200(): KoaRuntimeResponse<
    t_terminal_configuration | t_deleted_terminal_configuration
  >
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalConfigurationsConfiguration = (
  params: Params<
    t_PostTerminalConfigurationsConfigurationParamSchema,
    void,
    t_PostTerminalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: PostTerminalConfigurationsConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_configuration | t_deleted_terminal_configuration>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalConnectionTokensResponder = {
  with200(): KoaRuntimeResponse<t_terminal_connection_token>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalConnectionTokens = (
  params: Params<
    void,
    void,
    t_PostTerminalConnectionTokensBodySchema | undefined,
    void
  >,
  respond: PostTerminalConnectionTokensResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_connection_token>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTerminalLocationsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_terminal_location[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTerminalLocations = (
  params: Params<
    void,
    t_GetTerminalLocationsQuerySchema,
    t_GetTerminalLocationsBodySchema | undefined,
    void
  >,
  respond: GetTerminalLocationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_terminal_location[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalLocationsResponder = {
  with200(): KoaRuntimeResponse<t_terminal_location>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalLocations = (
  params: Params<void, void, t_PostTerminalLocationsBodySchema, void>,
  respond: PostTerminalLocationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_location>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteTerminalLocationsLocationResponder = {
  with200(): KoaRuntimeResponse<t_deleted_terminal_location>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteTerminalLocationsLocation = (
  params: Params<
    t_DeleteTerminalLocationsLocationParamSchema,
    void,
    t_DeleteTerminalLocationsLocationBodySchema | undefined,
    void
  >,
  respond: DeleteTerminalLocationsLocationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_terminal_location>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTerminalLocationsLocationResponder = {
  with200(): KoaRuntimeResponse<
    t_terminal_location | t_deleted_terminal_location
  >
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTerminalLocationsLocation = (
  params: Params<
    t_GetTerminalLocationsLocationParamSchema,
    t_GetTerminalLocationsLocationQuerySchema,
    t_GetTerminalLocationsLocationBodySchema | undefined,
    void
  >,
  respond: GetTerminalLocationsLocationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_location | t_deleted_terminal_location>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalLocationsLocationResponder = {
  with200(): KoaRuntimeResponse<
    t_terminal_location | t_deleted_terminal_location
  >
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalLocationsLocation = (
  params: Params<
    t_PostTerminalLocationsLocationParamSchema,
    void,
    t_PostTerminalLocationsLocationBodySchema | undefined,
    void
  >,
  respond: PostTerminalLocationsLocationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_location | t_deleted_terminal_location>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTerminalReadersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_terminal_reader[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTerminalReaders = (
  params: Params<
    void,
    t_GetTerminalReadersQuerySchema,
    t_GetTerminalReadersBodySchema | undefined,
    void
  >,
  respond: GetTerminalReadersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_terminal_reader[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReaders = (
  params: Params<void, void, t_PostTerminalReadersBodySchema, void>,
  respond: PostTerminalReadersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteTerminalReadersReaderResponder = {
  with200(): KoaRuntimeResponse<t_deleted_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteTerminalReadersReader = (
  params: Params<
    t_DeleteTerminalReadersReaderParamSchema,
    void,
    t_DeleteTerminalReadersReaderBodySchema | undefined,
    void
  >,
  respond: DeleteTerminalReadersReaderResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTerminalReadersReaderResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader | t_deleted_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTerminalReadersReader = (
  params: Params<
    t_GetTerminalReadersReaderParamSchema,
    t_GetTerminalReadersReaderQuerySchema,
    t_GetTerminalReadersReaderBodySchema | undefined,
    void
  >,
  respond: GetTerminalReadersReaderResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader | t_deleted_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader | t_deleted_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReader = (
  params: Params<
    t_PostTerminalReadersReaderParamSchema,
    void,
    t_PostTerminalReadersReaderBodySchema | undefined,
    void
  >,
  respond: PostTerminalReadersReaderResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader | t_deleted_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderCancelActionResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderCancelAction = (
  params: Params<
    t_PostTerminalReadersReaderCancelActionParamSchema,
    void,
    t_PostTerminalReadersReaderCancelActionBodySchema | undefined,
    void
  >,
  respond: PostTerminalReadersReaderCancelActionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderCollectInputsResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderCollectInputs = (
  params: Params<
    t_PostTerminalReadersReaderCollectInputsParamSchema,
    void,
    t_PostTerminalReadersReaderCollectInputsBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderCollectInputsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderCollectPaymentMethodResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderCollectPaymentMethod = (
  params: Params<
    t_PostTerminalReadersReaderCollectPaymentMethodParamSchema,
    void,
    t_PostTerminalReadersReaderCollectPaymentMethodBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderCollectPaymentMethodResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderConfirmPaymentIntentResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderConfirmPaymentIntent = (
  params: Params<
    t_PostTerminalReadersReaderConfirmPaymentIntentParamSchema,
    void,
    t_PostTerminalReadersReaderConfirmPaymentIntentBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderConfirmPaymentIntentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderProcessPaymentIntentResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderProcessPaymentIntent = (
  params: Params<
    t_PostTerminalReadersReaderProcessPaymentIntentParamSchema,
    void,
    t_PostTerminalReadersReaderProcessPaymentIntentBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderProcessPaymentIntentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderProcessSetupIntentResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderProcessSetupIntent = (
  params: Params<
    t_PostTerminalReadersReaderProcessSetupIntentParamSchema,
    void,
    t_PostTerminalReadersReaderProcessSetupIntentBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderProcessSetupIntentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderRefundPaymentResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderRefundPayment = (
  params: Params<
    t_PostTerminalReadersReaderRefundPaymentParamSchema,
    void,
    t_PostTerminalReadersReaderRefundPaymentBodySchema | undefined,
    void
  >,
  respond: PostTerminalReadersReaderRefundPaymentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTerminalReadersReaderSetReaderDisplayResponder = {
  with200(): KoaRuntimeResponse<t_terminal_reader>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTerminalReadersReaderSetReaderDisplay = (
  params: Params<
    t_PostTerminalReadersReaderSetReaderDisplayParamSchema,
    void,
    t_PostTerminalReadersReaderSetReaderDisplayBodySchema,
    void
  >,
  respond: PostTerminalReadersReaderSetReaderDisplayResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersConfirmationTokensResponder = {
  with200(): KoaRuntimeResponse<t_confirmation_token>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersConfirmationTokens = (
  params: Params<
    void,
    void,
    t_PostTestHelpersConfirmationTokensBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersConfirmationTokensResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_confirmation_token>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersCustomersCustomerFundCashBalanceResponder = {
  with200(): KoaRuntimeResponse<t_customer_cash_balance_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersCustomersCustomerFundCashBalance = (
  params: Params<
    t_PostTestHelpersCustomersCustomerFundCashBalanceParamSchema,
    void,
    t_PostTestHelpersCustomersCustomerFundCashBalanceBodySchema,
    void
  >,
  respond: PostTestHelpersCustomersCustomerFundCashBalanceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_cash_balance_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingAuthorizationsResponder = {
  with200(): KoaRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingAuthorizations = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingAuthorizationsBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingAuthorizationsAuthorizationCaptureResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationCapture = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationCaptureResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingAuthorizationsAuthorizationExpireResponder = {
  with200(): KoaRuntimeResponse<t_issuing_authorization>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationExpire = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationExpireResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
    void,
    t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond =
  (
    params: Params<
      t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
      void,
      t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema,
      void
    >,
    respond: PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponder,
    ctx: RouterContext,
    next: Next,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_authorization>
    | Response<StatusCode, t_error>
    | typeof SkipResponse
  >

export type PostTestHelpersIssuingAuthorizationsAuthorizationIncrementResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationIncrement = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
    void,
    t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationIncrementResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingAuthorizationsAuthorizationReverseResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_authorization>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingAuthorizationsAuthorizationReverse = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersIssuingAuthorizationsAuthorizationReverseResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingCardsCardShippingDeliverResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingDeliver = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingDeliverParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingDeliverBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingDeliverResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingCardsCardShippingFailResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingFail = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingFailParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingFailBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingFailResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingCardsCardShippingReturnResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingReturn = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingReturnParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingReturnBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingReturnResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingCardsCardShippingShipResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingShip = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingShipParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingShipBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingShipResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingCardsCardShippingSubmitResponder = {
  with200(): KoaRuntimeResponse<t_issuing_card>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingCardsCardShippingSubmit = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingSubmitParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingSubmitBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingCardsCardShippingSubmitResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_personalization_design>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
      void,
      | t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema
      | undefined,
      void
    >,
    respond: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponder,
    ctx: RouterContext,
    next: Next,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_personalization_design>
    | Response<StatusCode, t_error>
    | typeof SkipResponse
  >

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_personalization_design>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
      void,
      | t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema
      | undefined,
      void
    >,
    respond: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponder,
    ctx: RouterContext,
    next: Next,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_personalization_design>
    | Response<StatusCode, t_error>
    | typeof SkipResponse
  >

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponder =
  {
    with200(): KoaRuntimeResponse<t_issuing_personalization_design>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
      void,
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema,
      void
    >,
    respond: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponder,
    ctx: RouterContext,
    next: Next,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_personalization_design>
    | Response<StatusCode, t_error>
    | typeof SkipResponse
  >

export type PostTestHelpersIssuingSettlementsResponder = {
  with200(): KoaRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingSettlements = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingSettlementsBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingSettlementsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingSettlementsSettlementCompleteResponder = {
  with200(): KoaRuntimeResponse<t_issuing_settlement>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingSettlementsSettlementComplete = (
  params: Params<
    t_PostTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
    void,
    t_PostTestHelpersIssuingSettlementsSettlementCompleteBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingSettlementsSettlementCompleteResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingTransactionsCreateForceCaptureResponder = {
  with200(): KoaRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingTransactionsCreateForceCapture = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingTransactionsCreateForceCaptureBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingTransactionsCreateForceCaptureResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingTransactionsCreateUnlinkedRefundResponder = {
  with200(): KoaRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingTransactionsCreateUnlinkedRefund = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema,
    void
  >,
  respond: PostTestHelpersIssuingTransactionsCreateUnlinkedRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersIssuingTransactionsTransactionRefundResponder = {
  with200(): KoaRuntimeResponse<t_issuing_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersIssuingTransactionsTransactionRefund = (
  params: Params<
    t_PostTestHelpersIssuingTransactionsTransactionRefundParamSchema,
    void,
    t_PostTestHelpersIssuingTransactionsTransactionRefundBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersIssuingTransactionsTransactionRefundResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersRefundsRefundExpireResponder = {
  with200(): KoaRuntimeResponse<t_refund>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersRefundsRefundExpire = (
  params: Params<
    t_PostTestHelpersRefundsRefundExpireParamSchema,
    void,
    t_PostTestHelpersRefundsRefundExpireBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersRefundsRefundExpireResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTerminalReadersReaderPresentPaymentMethodResponder =
  {
    with200(): KoaRuntimeResponse<t_terminal_reader>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersTerminalReadersReaderPresentPaymentMethod = (
  params: Params<
    t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
    void,
    | t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTerminalReadersReaderPresentPaymentMethodResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTerminalReadersReaderSucceedInputCollectionResponder =
  {
    with200(): KoaRuntimeResponse<t_terminal_reader>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersTerminalReadersReaderSucceedInputCollection = (
  params: Params<
    t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema,
    void,
    | t_PostTestHelpersTerminalReadersReaderSucceedInputCollectionBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTerminalReadersReaderSucceedInputCollectionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTerminalReadersReaderTimeoutInputCollectionResponder =
  {
    with200(): KoaRuntimeResponse<t_terminal_reader>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersTerminalReadersReaderTimeoutInputCollection = (
  params: Params<
    t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema,
    void,
    | t_PostTestHelpersTerminalReadersReaderTimeoutInputCollectionBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTerminalReadersReaderTimeoutInputCollectionResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTestHelpersTestClocksResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_test_helpers_test_clock[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTestHelpersTestClocks = (
  params: Params<
    void,
    t_GetTestHelpersTestClocksQuerySchema,
    t_GetTestHelpersTestClocksBodySchema | undefined,
    void
  >,
  respond: GetTestHelpersTestClocksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_test_helpers_test_clock[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTestClocksResponder = {
  with200(): KoaRuntimeResponse<t_test_helpers_test_clock>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTestClocks = (
  params: Params<void, void, t_PostTestHelpersTestClocksBodySchema, void>,
  respond: PostTestHelpersTestClocksResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_test_helpers_test_clock>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteTestHelpersTestClocksTestClockResponder = {
  with200(): KoaRuntimeResponse<t_deleted_test_helpers_test_clock>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteTestHelpersTestClocksTestClock = (
  params: Params<
    t_DeleteTestHelpersTestClocksTestClockParamSchema,
    void,
    t_DeleteTestHelpersTestClocksTestClockBodySchema | undefined,
    void
  >,
  respond: DeleteTestHelpersTestClocksTestClockResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_test_helpers_test_clock>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTestHelpersTestClocksTestClockResponder = {
  with200(): KoaRuntimeResponse<t_test_helpers_test_clock>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTestHelpersTestClocksTestClock = (
  params: Params<
    t_GetTestHelpersTestClocksTestClockParamSchema,
    t_GetTestHelpersTestClocksTestClockQuerySchema,
    t_GetTestHelpersTestClocksTestClockBodySchema | undefined,
    void
  >,
  respond: GetTestHelpersTestClocksTestClockResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_test_helpers_test_clock>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTestClocksTestClockAdvanceResponder = {
  with200(): KoaRuntimeResponse<t_test_helpers_test_clock>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTestClocksTestClockAdvance = (
  params: Params<
    t_PostTestHelpersTestClocksTestClockAdvanceParamSchema,
    void,
    t_PostTestHelpersTestClocksTestClockAdvanceBodySchema,
    void
  >,
  respond: PostTestHelpersTestClocksTestClockAdvanceResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_test_helpers_test_clock>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryInboundTransfersIdFailResponder = {
  with200(): KoaRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryInboundTransfersIdFail = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdFailParamSchema,
    void,
    t_PostTestHelpersTreasuryInboundTransfersIdFailBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryInboundTransfersIdFailResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryInboundTransfersIdReturnResponder = {
  with200(): KoaRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryInboundTransfersIdReturn = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
    void,
    t_PostTestHelpersTreasuryInboundTransfersIdReturnBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryInboundTransfersIdReturnResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryInboundTransfersIdSucceedResponder = {
  with200(): KoaRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryInboundTransfersIdSucceed = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
    void,
    t_PostTestHelpersTreasuryInboundTransfersIdSucceedBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryInboundTransfersIdSucceedResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundPaymentsIdResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsId = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundPaymentsIdFailResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsIdFail = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdFailBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdFailResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundPaymentsIdPostResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsIdPost = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdPostBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdPostResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundPaymentsIdReturnResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundPaymentsIdReturn = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundPaymentsIdReturnResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferResponder =
  {
    with200(): KoaRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransfer = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponder =
  {
    with200(): KoaRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferFail = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponder =
  {
    with200(): KoaRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferPost = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponder =
  {
    with200(): KoaRuntimeResponse<t_treasury_outbound_transfer>
    withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
  } & KoaRuntimeResponder

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturn = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema
    | undefined,
    void
  >,
  respond: PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryReceivedCreditsResponder = {
  with200(): KoaRuntimeResponse<t_treasury_received_credit>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryReceivedCredits = (
  params: Params<
    void,
    void,
    t_PostTestHelpersTreasuryReceivedCreditsBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryReceivedCreditsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_credit>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTestHelpersTreasuryReceivedDebitsResponder = {
  with200(): KoaRuntimeResponse<t_treasury_received_debit>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTestHelpersTreasuryReceivedDebits = (
  params: Params<
    void,
    void,
    t_PostTestHelpersTreasuryReceivedDebitsBodySchema,
    void
  >,
  respond: PostTestHelpersTreasuryReceivedDebitsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_debit>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTokensResponder = {
  with200(): KoaRuntimeResponse<t_token>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTokens = (
  params: Params<void, void, t_PostTokensBodySchema | undefined, void>,
  respond: PostTokensResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_token>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTokensTokenResponder = {
  with200(): KoaRuntimeResponse<t_token>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTokensToken = (
  params: Params<
    t_GetTokensTokenParamSchema,
    t_GetTokensTokenQuerySchema,
    t_GetTokensTokenBodySchema | undefined,
    void
  >,
  respond: GetTokensTokenResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_token>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTopupsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_topup[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTopups = (
  params: Params<
    void,
    t_GetTopupsQuerySchema,
    t_GetTopupsBodySchema | undefined,
    void
  >,
  respond: GetTopupsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_topup[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTopupsResponder = {
  with200(): KoaRuntimeResponse<t_topup>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTopups = (
  params: Params<void, void, t_PostTopupsBodySchema, void>,
  respond: PostTopupsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTopupsTopupResponder = {
  with200(): KoaRuntimeResponse<t_topup>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTopupsTopup = (
  params: Params<
    t_GetTopupsTopupParamSchema,
    t_GetTopupsTopupQuerySchema,
    t_GetTopupsTopupBodySchema | undefined,
    void
  >,
  respond: GetTopupsTopupResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTopupsTopupResponder = {
  with200(): KoaRuntimeResponse<t_topup>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTopupsTopup = (
  params: Params<
    t_PostTopupsTopupParamSchema,
    void,
    t_PostTopupsTopupBodySchema | undefined,
    void
  >,
  respond: PostTopupsTopupResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTopupsTopupCancelResponder = {
  with200(): KoaRuntimeResponse<t_topup>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTopupsTopupCancel = (
  params: Params<
    t_PostTopupsTopupCancelParamSchema,
    void,
    t_PostTopupsTopupCancelBodySchema | undefined,
    void
  >,
  respond: PostTopupsTopupCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTransfersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTransfers = (
  params: Params<
    void,
    t_GetTransfersQuerySchema,
    t_GetTransfersBodySchema | undefined,
    void
  >,
  respond: GetTransfersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_transfer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTransfersResponder = {
  with200(): KoaRuntimeResponse<t_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTransfers = (
  params: Params<void, void, t_PostTransfersBodySchema, void>,
  respond: PostTransfersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTransfersIdReversalsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_transfer_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTransfersIdReversals = (
  params: Params<
    t_GetTransfersIdReversalsParamSchema,
    t_GetTransfersIdReversalsQuerySchema,
    t_GetTransfersIdReversalsBodySchema | undefined,
    void
  >,
  respond: GetTransfersIdReversalsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_transfer_reversal[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTransfersIdReversalsResponder = {
  with200(): KoaRuntimeResponse<t_transfer_reversal>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTransfersIdReversals = (
  params: Params<
    t_PostTransfersIdReversalsParamSchema,
    void,
    t_PostTransfersIdReversalsBodySchema | undefined,
    void
  >,
  respond: PostTransfersIdReversalsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer_reversal>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTransfersTransferResponder = {
  with200(): KoaRuntimeResponse<t_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTransfersTransfer = (
  params: Params<
    t_GetTransfersTransferParamSchema,
    t_GetTransfersTransferQuerySchema,
    t_GetTransfersTransferBodySchema | undefined,
    void
  >,
  respond: GetTransfersTransferResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTransfersTransferResponder = {
  with200(): KoaRuntimeResponse<t_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTransfersTransfer = (
  params: Params<
    t_PostTransfersTransferParamSchema,
    void,
    t_PostTransfersTransferBodySchema | undefined,
    void
  >,
  respond: PostTransfersTransferResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTransfersTransferReversalsIdResponder = {
  with200(): KoaRuntimeResponse<t_transfer_reversal>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTransfersTransferReversalsId = (
  params: Params<
    t_GetTransfersTransferReversalsIdParamSchema,
    t_GetTransfersTransferReversalsIdQuerySchema,
    t_GetTransfersTransferReversalsIdBodySchema | undefined,
    void
  >,
  respond: GetTransfersTransferReversalsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer_reversal>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTransfersTransferReversalsIdResponder = {
  with200(): KoaRuntimeResponse<t_transfer_reversal>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTransfersTransferReversalsId = (
  params: Params<
    t_PostTransfersTransferReversalsIdParamSchema,
    void,
    t_PostTransfersTransferReversalsIdBodySchema | undefined,
    void
  >,
  respond: PostTransfersTransferReversalsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer_reversal>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryCreditReversalsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_credit_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryCreditReversals = (
  params: Params<
    void,
    t_GetTreasuryCreditReversalsQuerySchema,
    t_GetTreasuryCreditReversalsBodySchema | undefined,
    void
  >,
  respond: GetTreasuryCreditReversalsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_credit_reversal[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryCreditReversalsResponder = {
  with200(): KoaRuntimeResponse<t_treasury_credit_reversal>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryCreditReversals = (
  params: Params<void, void, t_PostTreasuryCreditReversalsBodySchema, void>,
  respond: PostTreasuryCreditReversalsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_credit_reversal>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryCreditReversalsCreditReversalResponder = {
  with200(): KoaRuntimeResponse<t_treasury_credit_reversal>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryCreditReversalsCreditReversal = (
  params: Params<
    t_GetTreasuryCreditReversalsCreditReversalParamSchema,
    t_GetTreasuryCreditReversalsCreditReversalQuerySchema,
    t_GetTreasuryCreditReversalsCreditReversalBodySchema | undefined,
    void
  >,
  respond: GetTreasuryCreditReversalsCreditReversalResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_credit_reversal>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryDebitReversalsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_debit_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryDebitReversals = (
  params: Params<
    void,
    t_GetTreasuryDebitReversalsQuerySchema,
    t_GetTreasuryDebitReversalsBodySchema | undefined,
    void
  >,
  respond: GetTreasuryDebitReversalsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_debit_reversal[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryDebitReversalsResponder = {
  with200(): KoaRuntimeResponse<t_treasury_debit_reversal>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryDebitReversals = (
  params: Params<void, void, t_PostTreasuryDebitReversalsBodySchema, void>,
  respond: PostTreasuryDebitReversalsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_debit_reversal>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryDebitReversalsDebitReversalResponder = {
  with200(): KoaRuntimeResponse<t_treasury_debit_reversal>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryDebitReversalsDebitReversal = (
  params: Params<
    t_GetTreasuryDebitReversalsDebitReversalParamSchema,
    t_GetTreasuryDebitReversalsDebitReversalQuerySchema,
    t_GetTreasuryDebitReversalsDebitReversalBodySchema | undefined,
    void
  >,
  respond: GetTreasuryDebitReversalsDebitReversalResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_debit_reversal>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryFinancialAccountsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_financial_account[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryFinancialAccounts = (
  params: Params<
    void,
    t_GetTreasuryFinancialAccountsQuerySchema,
    t_GetTreasuryFinancialAccountsBodySchema | undefined,
    void
  >,
  respond: GetTreasuryFinancialAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_financial_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryFinancialAccountsResponder = {
  with200(): KoaRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryFinancialAccounts = (
  params: Params<void, void, t_PostTreasuryFinancialAccountsBodySchema, void>,
  respond: PostTreasuryFinancialAccountsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryFinancialAccountsFinancialAccountResponder = {
  with200(): KoaRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryFinancialAccountsFinancialAccount = (
  params: Params<
    t_GetTreasuryFinancialAccountsFinancialAccountParamSchema,
    t_GetTreasuryFinancialAccountsFinancialAccountQuerySchema,
    t_GetTreasuryFinancialAccountsFinancialAccountBodySchema | undefined,
    void
  >,
  respond: GetTreasuryFinancialAccountsFinancialAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryFinancialAccountsFinancialAccountResponder = {
  with200(): KoaRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryFinancialAccountsFinancialAccount = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountParamSchema,
    void,
    t_PostTreasuryFinancialAccountsFinancialAccountBodySchema | undefined,
    void
  >,
  respond: PostTreasuryFinancialAccountsFinancialAccountResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryFinancialAccountsFinancialAccountCloseResponder = {
  with200(): KoaRuntimeResponse<t_treasury_financial_account>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryFinancialAccountsFinancialAccountClose = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
    void,
    t_PostTreasuryFinancialAccountsFinancialAccountCloseBodySchema | undefined,
    void
  >,
  respond: PostTreasuryFinancialAccountsFinancialAccountCloseResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryFinancialAccountsFinancialAccountFeaturesResponder = {
  with200(): KoaRuntimeResponse<t_treasury_financial_account_features>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryFinancialAccountsFinancialAccountFeatures = (
  params: Params<
    t_GetTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
    t_GetTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
    | t_GetTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema
    | undefined,
    void
  >,
  respond: GetTreasuryFinancialAccountsFinancialAccountFeaturesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account_features>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryFinancialAccountsFinancialAccountFeaturesResponder = {
  with200(): KoaRuntimeResponse<t_treasury_financial_account_features>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryFinancialAccountsFinancialAccountFeatures = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
    void,
    | t_PostTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema
    | undefined,
    void
  >,
  respond: PostTreasuryFinancialAccountsFinancialAccountFeaturesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account_features>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryInboundTransfersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_inbound_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryInboundTransfers = (
  params: Params<
    void,
    t_GetTreasuryInboundTransfersQuerySchema,
    t_GetTreasuryInboundTransfersBodySchema | undefined,
    void
  >,
  respond: GetTreasuryInboundTransfersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_inbound_transfer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryInboundTransfersResponder = {
  with200(): KoaRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryInboundTransfers = (
  params: Params<void, void, t_PostTreasuryInboundTransfersBodySchema, void>,
  respond: PostTreasuryInboundTransfersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryInboundTransfersIdResponder = {
  with200(): KoaRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryInboundTransfersId = (
  params: Params<
    t_GetTreasuryInboundTransfersIdParamSchema,
    t_GetTreasuryInboundTransfersIdQuerySchema,
    t_GetTreasuryInboundTransfersIdBodySchema | undefined,
    void
  >,
  respond: GetTreasuryInboundTransfersIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryInboundTransfersInboundTransferCancelResponder = {
  with200(): KoaRuntimeResponse<t_treasury_inbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryInboundTransfersInboundTransferCancel = (
  params: Params<
    t_PostTreasuryInboundTransfersInboundTransferCancelParamSchema,
    void,
    t_PostTreasuryInboundTransfersInboundTransferCancelBodySchema | undefined,
    void
  >,
  respond: PostTreasuryInboundTransfersInboundTransferCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryOutboundPaymentsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_outbound_payment[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryOutboundPayments = (
  params: Params<
    void,
    t_GetTreasuryOutboundPaymentsQuerySchema,
    t_GetTreasuryOutboundPaymentsBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundPaymentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_outbound_payment[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryOutboundPaymentsResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryOutboundPayments = (
  params: Params<void, void, t_PostTreasuryOutboundPaymentsBodySchema, void>,
  respond: PostTreasuryOutboundPaymentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryOutboundPaymentsIdResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryOutboundPaymentsId = (
  params: Params<
    t_GetTreasuryOutboundPaymentsIdParamSchema,
    t_GetTreasuryOutboundPaymentsIdQuerySchema,
    t_GetTreasuryOutboundPaymentsIdBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundPaymentsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryOutboundPaymentsIdCancelResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_payment>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryOutboundPaymentsIdCancel = (
  params: Params<
    t_PostTreasuryOutboundPaymentsIdCancelParamSchema,
    void,
    t_PostTreasuryOutboundPaymentsIdCancelBodySchema | undefined,
    void
  >,
  respond: PostTreasuryOutboundPaymentsIdCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryOutboundTransfersResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_outbound_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryOutboundTransfers = (
  params: Params<
    void,
    t_GetTreasuryOutboundTransfersQuerySchema,
    t_GetTreasuryOutboundTransfersBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundTransfersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_outbound_transfer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryOutboundTransfersResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryOutboundTransfers = (
  params: Params<void, void, t_PostTreasuryOutboundTransfersBodySchema, void>,
  respond: PostTreasuryOutboundTransfersResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryOutboundTransfersOutboundTransferResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryOutboundTransfersOutboundTransfer = (
  params: Params<
    t_GetTreasuryOutboundTransfersOutboundTransferParamSchema,
    t_GetTreasuryOutboundTransfersOutboundTransferQuerySchema,
    t_GetTreasuryOutboundTransfersOutboundTransferBodySchema | undefined,
    void
  >,
  respond: GetTreasuryOutboundTransfersOutboundTransferResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostTreasuryOutboundTransfersOutboundTransferCancelResponder = {
  with200(): KoaRuntimeResponse<t_treasury_outbound_transfer>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostTreasuryOutboundTransfersOutboundTransferCancel = (
  params: Params<
    t_PostTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
    void,
    t_PostTreasuryOutboundTransfersOutboundTransferCancelBodySchema | undefined,
    void
  >,
  respond: PostTreasuryOutboundTransfersOutboundTransferCancelResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryReceivedCreditsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_received_credit[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryReceivedCredits = (
  params: Params<
    void,
    t_GetTreasuryReceivedCreditsQuerySchema,
    t_GetTreasuryReceivedCreditsBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedCreditsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_received_credit[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryReceivedCreditsIdResponder = {
  with200(): KoaRuntimeResponse<t_treasury_received_credit>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryReceivedCreditsId = (
  params: Params<
    t_GetTreasuryReceivedCreditsIdParamSchema,
    t_GetTreasuryReceivedCreditsIdQuerySchema,
    t_GetTreasuryReceivedCreditsIdBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedCreditsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_credit>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryReceivedDebitsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_received_debit[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryReceivedDebits = (
  params: Params<
    void,
    t_GetTreasuryReceivedDebitsQuerySchema,
    t_GetTreasuryReceivedDebitsBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedDebitsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_received_debit[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryReceivedDebitsIdResponder = {
  with200(): KoaRuntimeResponse<t_treasury_received_debit>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryReceivedDebitsId = (
  params: Params<
    t_GetTreasuryReceivedDebitsIdParamSchema,
    t_GetTreasuryReceivedDebitsIdQuerySchema,
    t_GetTreasuryReceivedDebitsIdBodySchema | undefined,
    void
  >,
  respond: GetTreasuryReceivedDebitsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_debit>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryTransactionEntriesResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_transaction_entry[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryTransactionEntries = (
  params: Params<
    void,
    t_GetTreasuryTransactionEntriesQuerySchema,
    t_GetTreasuryTransactionEntriesBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionEntriesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_transaction_entry[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryTransactionEntriesIdResponder = {
  with200(): KoaRuntimeResponse<t_treasury_transaction_entry>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryTransactionEntriesId = (
  params: Params<
    t_GetTreasuryTransactionEntriesIdParamSchema,
    t_GetTreasuryTransactionEntriesIdQuerySchema,
    t_GetTreasuryTransactionEntriesIdBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionEntriesIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_transaction_entry>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryTransactionsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_treasury_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryTransactions = (
  params: Params<
    void,
    t_GetTreasuryTransactionsQuerySchema,
    t_GetTreasuryTransactionsBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetTreasuryTransactionsIdResponder = {
  with200(): KoaRuntimeResponse<t_treasury_transaction>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetTreasuryTransactionsId = (
  params: Params<
    t_GetTreasuryTransactionsIdParamSchema,
    t_GetTreasuryTransactionsIdQuerySchema,
    t_GetTreasuryTransactionsIdBodySchema | undefined,
    void
  >,
  respond: GetTreasuryTransactionsIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_transaction>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetWebhookEndpointsResponder = {
  with200(): KoaRuntimeResponse<{
    data: t_webhook_endpoint[]
    has_more: boolean
    object: "list"
    url: string
  }>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetWebhookEndpoints = (
  params: Params<
    void,
    t_GetWebhookEndpointsQuerySchema,
    t_GetWebhookEndpointsBodySchema | undefined,
    void
  >,
  respond: GetWebhookEndpointsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_webhook_endpoint[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostWebhookEndpointsResponder = {
  with200(): KoaRuntimeResponse<t_webhook_endpoint>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostWebhookEndpoints = (
  params: Params<void, void, t_PostWebhookEndpointsBodySchema, void>,
  respond: PostWebhookEndpointsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_webhook_endpoint>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type DeleteWebhookEndpointsWebhookEndpointResponder = {
  with200(): KoaRuntimeResponse<t_deleted_webhook_endpoint>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type DeleteWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_DeleteWebhookEndpointsWebhookEndpointParamSchema,
    void,
    t_DeleteWebhookEndpointsWebhookEndpointBodySchema | undefined,
    void
  >,
  respond: DeleteWebhookEndpointsWebhookEndpointResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_webhook_endpoint>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type GetWebhookEndpointsWebhookEndpointResponder = {
  with200(): KoaRuntimeResponse<t_webhook_endpoint>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type GetWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_GetWebhookEndpointsWebhookEndpointParamSchema,
    t_GetWebhookEndpointsWebhookEndpointQuerySchema,
    t_GetWebhookEndpointsWebhookEndpointBodySchema | undefined,
    void
  >,
  respond: GetWebhookEndpointsWebhookEndpointResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_webhook_endpoint>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type PostWebhookEndpointsWebhookEndpointResponder = {
  with200(): KoaRuntimeResponse<t_webhook_endpoint>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_error>
} & KoaRuntimeResponder

export type PostWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_PostWebhookEndpointsWebhookEndpointParamSchema,
    void,
    t_PostWebhookEndpointsWebhookEndpointBodySchema | undefined,
    void
  >,
  respond: PostWebhookEndpointsWebhookEndpointResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_webhook_endpoint>
  | Response<StatusCode, t_error>
  | typeof SkipResponse
>

export type Implementation = {
  getAccount: GetAccount
  postAccountLinks: PostAccountLinks
  postAccountSessions: PostAccountSessions
  getAccounts: GetAccounts
  postAccounts: PostAccounts
  deleteAccountsAccount: DeleteAccountsAccount
  getAccountsAccount: GetAccountsAccount
  postAccountsAccount: PostAccountsAccount
  postAccountsAccountBankAccounts: PostAccountsAccountBankAccounts
  deleteAccountsAccountBankAccountsId: DeleteAccountsAccountBankAccountsId
  getAccountsAccountBankAccountsId: GetAccountsAccountBankAccountsId
  postAccountsAccountBankAccountsId: PostAccountsAccountBankAccountsId
  getAccountsAccountCapabilities: GetAccountsAccountCapabilities
  getAccountsAccountCapabilitiesCapability: GetAccountsAccountCapabilitiesCapability
  postAccountsAccountCapabilitiesCapability: PostAccountsAccountCapabilitiesCapability
  getAccountsAccountExternalAccounts: GetAccountsAccountExternalAccounts
  postAccountsAccountExternalAccounts: PostAccountsAccountExternalAccounts
  deleteAccountsAccountExternalAccountsId: DeleteAccountsAccountExternalAccountsId
  getAccountsAccountExternalAccountsId: GetAccountsAccountExternalAccountsId
  postAccountsAccountExternalAccountsId: PostAccountsAccountExternalAccountsId
  postAccountsAccountLoginLinks: PostAccountsAccountLoginLinks
  getAccountsAccountPeople: GetAccountsAccountPeople
  postAccountsAccountPeople: PostAccountsAccountPeople
  deleteAccountsAccountPeoplePerson: DeleteAccountsAccountPeoplePerson
  getAccountsAccountPeoplePerson: GetAccountsAccountPeoplePerson
  postAccountsAccountPeoplePerson: PostAccountsAccountPeoplePerson
  getAccountsAccountPersons: GetAccountsAccountPersons
  postAccountsAccountPersons: PostAccountsAccountPersons
  deleteAccountsAccountPersonsPerson: DeleteAccountsAccountPersonsPerson
  getAccountsAccountPersonsPerson: GetAccountsAccountPersonsPerson
  postAccountsAccountPersonsPerson: PostAccountsAccountPersonsPerson
  postAccountsAccountReject: PostAccountsAccountReject
  getApplePayDomains: GetApplePayDomains
  postApplePayDomains: PostApplePayDomains
  deleteApplePayDomainsDomain: DeleteApplePayDomainsDomain
  getApplePayDomainsDomain: GetApplePayDomainsDomain
  getApplicationFees: GetApplicationFees
  getApplicationFeesFeeRefundsId: GetApplicationFeesFeeRefundsId
  postApplicationFeesFeeRefundsId: PostApplicationFeesFeeRefundsId
  getApplicationFeesId: GetApplicationFeesId
  postApplicationFeesIdRefund: PostApplicationFeesIdRefund
  getApplicationFeesIdRefunds: GetApplicationFeesIdRefunds
  postApplicationFeesIdRefunds: PostApplicationFeesIdRefunds
  getAppsSecrets: GetAppsSecrets
  postAppsSecrets: PostAppsSecrets
  postAppsSecretsDelete: PostAppsSecretsDelete
  getAppsSecretsFind: GetAppsSecretsFind
  getBalance: GetBalance
  getBalanceHistory: GetBalanceHistory
  getBalanceHistoryId: GetBalanceHistoryId
  getBalanceTransactions: GetBalanceTransactions
  getBalanceTransactionsId: GetBalanceTransactionsId
  getBillingAlerts: GetBillingAlerts
  postBillingAlerts: PostBillingAlerts
  getBillingAlertsId: GetBillingAlertsId
  postBillingAlertsIdActivate: PostBillingAlertsIdActivate
  postBillingAlertsIdArchive: PostBillingAlertsIdArchive
  postBillingAlertsIdDeactivate: PostBillingAlertsIdDeactivate
  getBillingCreditBalanceSummary: GetBillingCreditBalanceSummary
  getBillingCreditBalanceTransactions: GetBillingCreditBalanceTransactions
  getBillingCreditBalanceTransactionsId: GetBillingCreditBalanceTransactionsId
  getBillingCreditGrants: GetBillingCreditGrants
  postBillingCreditGrants: PostBillingCreditGrants
  getBillingCreditGrantsId: GetBillingCreditGrantsId
  postBillingCreditGrantsId: PostBillingCreditGrantsId
  postBillingCreditGrantsIdExpire: PostBillingCreditGrantsIdExpire
  postBillingCreditGrantsIdVoid: PostBillingCreditGrantsIdVoid
  postBillingMeterEventAdjustments: PostBillingMeterEventAdjustments
  postBillingMeterEvents: PostBillingMeterEvents
  getBillingMeters: GetBillingMeters
  postBillingMeters: PostBillingMeters
  getBillingMetersId: GetBillingMetersId
  postBillingMetersId: PostBillingMetersId
  postBillingMetersIdDeactivate: PostBillingMetersIdDeactivate
  getBillingMetersIdEventSummaries: GetBillingMetersIdEventSummaries
  postBillingMetersIdReactivate: PostBillingMetersIdReactivate
  getBillingPortalConfigurations: GetBillingPortalConfigurations
  postBillingPortalConfigurations: PostBillingPortalConfigurations
  getBillingPortalConfigurationsConfiguration: GetBillingPortalConfigurationsConfiguration
  postBillingPortalConfigurationsConfiguration: PostBillingPortalConfigurationsConfiguration
  postBillingPortalSessions: PostBillingPortalSessions
  getCharges: GetCharges
  postCharges: PostCharges
  getChargesSearch: GetChargesSearch
  getChargesCharge: GetChargesCharge
  postChargesCharge: PostChargesCharge
  postChargesChargeCapture: PostChargesChargeCapture
  getChargesChargeDispute: GetChargesChargeDispute
  postChargesChargeDispute: PostChargesChargeDispute
  postChargesChargeDisputeClose: PostChargesChargeDisputeClose
  postChargesChargeRefund: PostChargesChargeRefund
  getChargesChargeRefunds: GetChargesChargeRefunds
  postChargesChargeRefunds: PostChargesChargeRefunds
  getChargesChargeRefundsRefund: GetChargesChargeRefundsRefund
  postChargesChargeRefundsRefund: PostChargesChargeRefundsRefund
  getCheckoutSessions: GetCheckoutSessions
  postCheckoutSessions: PostCheckoutSessions
  getCheckoutSessionsSession: GetCheckoutSessionsSession
  postCheckoutSessionsSession: PostCheckoutSessionsSession
  postCheckoutSessionsSessionExpire: PostCheckoutSessionsSessionExpire
  getCheckoutSessionsSessionLineItems: GetCheckoutSessionsSessionLineItems
  getClimateOrders: GetClimateOrders
  postClimateOrders: PostClimateOrders
  getClimateOrdersOrder: GetClimateOrdersOrder
  postClimateOrdersOrder: PostClimateOrdersOrder
  postClimateOrdersOrderCancel: PostClimateOrdersOrderCancel
  getClimateProducts: GetClimateProducts
  getClimateProductsProduct: GetClimateProductsProduct
  getClimateSuppliers: GetClimateSuppliers
  getClimateSuppliersSupplier: GetClimateSuppliersSupplier
  getConfirmationTokensConfirmationToken: GetConfirmationTokensConfirmationToken
  getCountrySpecs: GetCountrySpecs
  getCountrySpecsCountry: GetCountrySpecsCountry
  getCoupons: GetCoupons
  postCoupons: PostCoupons
  deleteCouponsCoupon: DeleteCouponsCoupon
  getCouponsCoupon: GetCouponsCoupon
  postCouponsCoupon: PostCouponsCoupon
  getCreditNotes: GetCreditNotes
  postCreditNotes: PostCreditNotes
  getCreditNotesPreview: GetCreditNotesPreview
  getCreditNotesPreviewLines: GetCreditNotesPreviewLines
  getCreditNotesCreditNoteLines: GetCreditNotesCreditNoteLines
  getCreditNotesId: GetCreditNotesId
  postCreditNotesId: PostCreditNotesId
  postCreditNotesIdVoid: PostCreditNotesIdVoid
  postCustomerSessions: PostCustomerSessions
  getCustomers: GetCustomers
  postCustomers: PostCustomers
  getCustomersSearch: GetCustomersSearch
  deleteCustomersCustomer: DeleteCustomersCustomer
  getCustomersCustomer: GetCustomersCustomer
  postCustomersCustomer: PostCustomersCustomer
  getCustomersCustomerBalanceTransactions: GetCustomersCustomerBalanceTransactions
  postCustomersCustomerBalanceTransactions: PostCustomersCustomerBalanceTransactions
  getCustomersCustomerBalanceTransactionsTransaction: GetCustomersCustomerBalanceTransactionsTransaction
  postCustomersCustomerBalanceTransactionsTransaction: PostCustomersCustomerBalanceTransactionsTransaction
  getCustomersCustomerBankAccounts: GetCustomersCustomerBankAccounts
  postCustomersCustomerBankAccounts: PostCustomersCustomerBankAccounts
  deleteCustomersCustomerBankAccountsId: DeleteCustomersCustomerBankAccountsId
  getCustomersCustomerBankAccountsId: GetCustomersCustomerBankAccountsId
  postCustomersCustomerBankAccountsId: PostCustomersCustomerBankAccountsId
  postCustomersCustomerBankAccountsIdVerify: PostCustomersCustomerBankAccountsIdVerify
  getCustomersCustomerCards: GetCustomersCustomerCards
  postCustomersCustomerCards: PostCustomersCustomerCards
  deleteCustomersCustomerCardsId: DeleteCustomersCustomerCardsId
  getCustomersCustomerCardsId: GetCustomersCustomerCardsId
  postCustomersCustomerCardsId: PostCustomersCustomerCardsId
  getCustomersCustomerCashBalance: GetCustomersCustomerCashBalance
  postCustomersCustomerCashBalance: PostCustomersCustomerCashBalance
  getCustomersCustomerCashBalanceTransactions: GetCustomersCustomerCashBalanceTransactions
  getCustomersCustomerCashBalanceTransactionsTransaction: GetCustomersCustomerCashBalanceTransactionsTransaction
  deleteCustomersCustomerDiscount: DeleteCustomersCustomerDiscount
  getCustomersCustomerDiscount: GetCustomersCustomerDiscount
  postCustomersCustomerFundingInstructions: PostCustomersCustomerFundingInstructions
  getCustomersCustomerPaymentMethods: GetCustomersCustomerPaymentMethods
  getCustomersCustomerPaymentMethodsPaymentMethod: GetCustomersCustomerPaymentMethodsPaymentMethod
  getCustomersCustomerSources: GetCustomersCustomerSources
  postCustomersCustomerSources: PostCustomersCustomerSources
  deleteCustomersCustomerSourcesId: DeleteCustomersCustomerSourcesId
  getCustomersCustomerSourcesId: GetCustomersCustomerSourcesId
  postCustomersCustomerSourcesId: PostCustomersCustomerSourcesId
  postCustomersCustomerSourcesIdVerify: PostCustomersCustomerSourcesIdVerify
  getCustomersCustomerSubscriptions: GetCustomersCustomerSubscriptions
  postCustomersCustomerSubscriptions: PostCustomersCustomerSubscriptions
  deleteCustomersCustomerSubscriptionsSubscriptionExposedId: DeleteCustomersCustomerSubscriptionsSubscriptionExposedId
  getCustomersCustomerSubscriptionsSubscriptionExposedId: GetCustomersCustomerSubscriptionsSubscriptionExposedId
  postCustomersCustomerSubscriptionsSubscriptionExposedId: PostCustomersCustomerSubscriptionsSubscriptionExposedId
  deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount: DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount: GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  getCustomersCustomerTaxIds: GetCustomersCustomerTaxIds
  postCustomersCustomerTaxIds: PostCustomersCustomerTaxIds
  deleteCustomersCustomerTaxIdsId: DeleteCustomersCustomerTaxIdsId
  getCustomersCustomerTaxIdsId: GetCustomersCustomerTaxIdsId
  getDisputes: GetDisputes
  getDisputesDispute: GetDisputesDispute
  postDisputesDispute: PostDisputesDispute
  postDisputesDisputeClose: PostDisputesDisputeClose
  getEntitlementsActiveEntitlements: GetEntitlementsActiveEntitlements
  getEntitlementsActiveEntitlementsId: GetEntitlementsActiveEntitlementsId
  getEntitlementsFeatures: GetEntitlementsFeatures
  postEntitlementsFeatures: PostEntitlementsFeatures
  getEntitlementsFeaturesId: GetEntitlementsFeaturesId
  postEntitlementsFeaturesId: PostEntitlementsFeaturesId
  postEphemeralKeys: PostEphemeralKeys
  deleteEphemeralKeysKey: DeleteEphemeralKeysKey
  getEvents: GetEvents
  getEventsId: GetEventsId
  getExchangeRates: GetExchangeRates
  getExchangeRatesRateId: GetExchangeRatesRateId
  postExternalAccountsId: PostExternalAccountsId
  getFileLinks: GetFileLinks
  postFileLinks: PostFileLinks
  getFileLinksLink: GetFileLinksLink
  postFileLinksLink: PostFileLinksLink
  getFiles: GetFiles
  postFiles: PostFiles
  getFilesFile: GetFilesFile
  getFinancialConnectionsAccounts: GetFinancialConnectionsAccounts
  getFinancialConnectionsAccountsAccount: GetFinancialConnectionsAccountsAccount
  postFinancialConnectionsAccountsAccountDisconnect: PostFinancialConnectionsAccountsAccountDisconnect
  getFinancialConnectionsAccountsAccountOwners: GetFinancialConnectionsAccountsAccountOwners
  postFinancialConnectionsAccountsAccountRefresh: PostFinancialConnectionsAccountsAccountRefresh
  postFinancialConnectionsAccountsAccountSubscribe: PostFinancialConnectionsAccountsAccountSubscribe
  postFinancialConnectionsAccountsAccountUnsubscribe: PostFinancialConnectionsAccountsAccountUnsubscribe
  postFinancialConnectionsSessions: PostFinancialConnectionsSessions
  getFinancialConnectionsSessionsSession: GetFinancialConnectionsSessionsSession
  getFinancialConnectionsTransactions: GetFinancialConnectionsTransactions
  getFinancialConnectionsTransactionsTransaction: GetFinancialConnectionsTransactionsTransaction
  getForwardingRequests: GetForwardingRequests
  postForwardingRequests: PostForwardingRequests
  getForwardingRequestsId: GetForwardingRequestsId
  getIdentityVerificationReports: GetIdentityVerificationReports
  getIdentityVerificationReportsReport: GetIdentityVerificationReportsReport
  getIdentityVerificationSessions: GetIdentityVerificationSessions
  postIdentityVerificationSessions: PostIdentityVerificationSessions
  getIdentityVerificationSessionsSession: GetIdentityVerificationSessionsSession
  postIdentityVerificationSessionsSession: PostIdentityVerificationSessionsSession
  postIdentityVerificationSessionsSessionCancel: PostIdentityVerificationSessionsSessionCancel
  postIdentityVerificationSessionsSessionRedact: PostIdentityVerificationSessionsSessionRedact
  getInvoicePayments: GetInvoicePayments
  getInvoicePaymentsInvoicePayment: GetInvoicePaymentsInvoicePayment
  getInvoiceRenderingTemplates: GetInvoiceRenderingTemplates
  getInvoiceRenderingTemplatesTemplate: GetInvoiceRenderingTemplatesTemplate
  postInvoiceRenderingTemplatesTemplateArchive: PostInvoiceRenderingTemplatesTemplateArchive
  postInvoiceRenderingTemplatesTemplateUnarchive: PostInvoiceRenderingTemplatesTemplateUnarchive
  getInvoiceitems: GetInvoiceitems
  postInvoiceitems: PostInvoiceitems
  deleteInvoiceitemsInvoiceitem: DeleteInvoiceitemsInvoiceitem
  getInvoiceitemsInvoiceitem: GetInvoiceitemsInvoiceitem
  postInvoiceitemsInvoiceitem: PostInvoiceitemsInvoiceitem
  getInvoices: GetInvoices
  postInvoices: PostInvoices
  postInvoicesCreatePreview: PostInvoicesCreatePreview
  getInvoicesSearch: GetInvoicesSearch
  deleteInvoicesInvoice: DeleteInvoicesInvoice
  getInvoicesInvoice: GetInvoicesInvoice
  postInvoicesInvoice: PostInvoicesInvoice
  postInvoicesInvoiceAddLines: PostInvoicesInvoiceAddLines
  postInvoicesInvoiceAttachPayment: PostInvoicesInvoiceAttachPayment
  postInvoicesInvoiceFinalize: PostInvoicesInvoiceFinalize
  getInvoicesInvoiceLines: GetInvoicesInvoiceLines
  postInvoicesInvoiceLinesLineItemId: PostInvoicesInvoiceLinesLineItemId
  postInvoicesInvoiceMarkUncollectible: PostInvoicesInvoiceMarkUncollectible
  postInvoicesInvoicePay: PostInvoicesInvoicePay
  postInvoicesInvoiceRemoveLines: PostInvoicesInvoiceRemoveLines
  postInvoicesInvoiceSend: PostInvoicesInvoiceSend
  postInvoicesInvoiceUpdateLines: PostInvoicesInvoiceUpdateLines
  postInvoicesInvoiceVoid: PostInvoicesInvoiceVoid
  getIssuingAuthorizations: GetIssuingAuthorizations
  getIssuingAuthorizationsAuthorization: GetIssuingAuthorizationsAuthorization
  postIssuingAuthorizationsAuthorization: PostIssuingAuthorizationsAuthorization
  postIssuingAuthorizationsAuthorizationApprove: PostIssuingAuthorizationsAuthorizationApprove
  postIssuingAuthorizationsAuthorizationDecline: PostIssuingAuthorizationsAuthorizationDecline
  getIssuingCardholders: GetIssuingCardholders
  postIssuingCardholders: PostIssuingCardholders
  getIssuingCardholdersCardholder: GetIssuingCardholdersCardholder
  postIssuingCardholdersCardholder: PostIssuingCardholdersCardholder
  getIssuingCards: GetIssuingCards
  postIssuingCards: PostIssuingCards
  getIssuingCardsCard: GetIssuingCardsCard
  postIssuingCardsCard: PostIssuingCardsCard
  getIssuingDisputes: GetIssuingDisputes
  postIssuingDisputes: PostIssuingDisputes
  getIssuingDisputesDispute: GetIssuingDisputesDispute
  postIssuingDisputesDispute: PostIssuingDisputesDispute
  postIssuingDisputesDisputeSubmit: PostIssuingDisputesDisputeSubmit
  getIssuingPersonalizationDesigns: GetIssuingPersonalizationDesigns
  postIssuingPersonalizationDesigns: PostIssuingPersonalizationDesigns
  getIssuingPersonalizationDesignsPersonalizationDesign: GetIssuingPersonalizationDesignsPersonalizationDesign
  postIssuingPersonalizationDesignsPersonalizationDesign: PostIssuingPersonalizationDesignsPersonalizationDesign
  getIssuingPhysicalBundles: GetIssuingPhysicalBundles
  getIssuingPhysicalBundlesPhysicalBundle: GetIssuingPhysicalBundlesPhysicalBundle
  getIssuingSettlementsSettlement: GetIssuingSettlementsSettlement
  postIssuingSettlementsSettlement: PostIssuingSettlementsSettlement
  getIssuingTokens: GetIssuingTokens
  getIssuingTokensToken: GetIssuingTokensToken
  postIssuingTokensToken: PostIssuingTokensToken
  getIssuingTransactions: GetIssuingTransactions
  getIssuingTransactionsTransaction: GetIssuingTransactionsTransaction
  postIssuingTransactionsTransaction: PostIssuingTransactionsTransaction
  postLinkAccountSessions: PostLinkAccountSessions
  getLinkAccountSessionsSession: GetLinkAccountSessionsSession
  getLinkedAccounts: GetLinkedAccounts
  getLinkedAccountsAccount: GetLinkedAccountsAccount
  postLinkedAccountsAccountDisconnect: PostLinkedAccountsAccountDisconnect
  getLinkedAccountsAccountOwners: GetLinkedAccountsAccountOwners
  postLinkedAccountsAccountRefresh: PostLinkedAccountsAccountRefresh
  getMandatesMandate: GetMandatesMandate
  getPaymentIntents: GetPaymentIntents
  postPaymentIntents: PostPaymentIntents
  getPaymentIntentsSearch: GetPaymentIntentsSearch
  getPaymentIntentsIntent: GetPaymentIntentsIntent
  postPaymentIntentsIntent: PostPaymentIntentsIntent
  postPaymentIntentsIntentApplyCustomerBalance: PostPaymentIntentsIntentApplyCustomerBalance
  postPaymentIntentsIntentCancel: PostPaymentIntentsIntentCancel
  postPaymentIntentsIntentCapture: PostPaymentIntentsIntentCapture
  postPaymentIntentsIntentConfirm: PostPaymentIntentsIntentConfirm
  postPaymentIntentsIntentIncrementAuthorization: PostPaymentIntentsIntentIncrementAuthorization
  postPaymentIntentsIntentVerifyMicrodeposits: PostPaymentIntentsIntentVerifyMicrodeposits
  getPaymentLinks: GetPaymentLinks
  postPaymentLinks: PostPaymentLinks
  getPaymentLinksPaymentLink: GetPaymentLinksPaymentLink
  postPaymentLinksPaymentLink: PostPaymentLinksPaymentLink
  getPaymentLinksPaymentLinkLineItems: GetPaymentLinksPaymentLinkLineItems
  getPaymentMethodConfigurations: GetPaymentMethodConfigurations
  postPaymentMethodConfigurations: PostPaymentMethodConfigurations
  getPaymentMethodConfigurationsConfiguration: GetPaymentMethodConfigurationsConfiguration
  postPaymentMethodConfigurationsConfiguration: PostPaymentMethodConfigurationsConfiguration
  getPaymentMethodDomains: GetPaymentMethodDomains
  postPaymentMethodDomains: PostPaymentMethodDomains
  getPaymentMethodDomainsPaymentMethodDomain: GetPaymentMethodDomainsPaymentMethodDomain
  postPaymentMethodDomainsPaymentMethodDomain: PostPaymentMethodDomainsPaymentMethodDomain
  postPaymentMethodDomainsPaymentMethodDomainValidate: PostPaymentMethodDomainsPaymentMethodDomainValidate
  getPaymentMethods: GetPaymentMethods
  postPaymentMethods: PostPaymentMethods
  getPaymentMethodsPaymentMethod: GetPaymentMethodsPaymentMethod
  postPaymentMethodsPaymentMethod: PostPaymentMethodsPaymentMethod
  postPaymentMethodsPaymentMethodAttach: PostPaymentMethodsPaymentMethodAttach
  postPaymentMethodsPaymentMethodDetach: PostPaymentMethodsPaymentMethodDetach
  getPayouts: GetPayouts
  postPayouts: PostPayouts
  getPayoutsPayout: GetPayoutsPayout
  postPayoutsPayout: PostPayoutsPayout
  postPayoutsPayoutCancel: PostPayoutsPayoutCancel
  postPayoutsPayoutReverse: PostPayoutsPayoutReverse
  getPlans: GetPlans
  postPlans: PostPlans
  deletePlansPlan: DeletePlansPlan
  getPlansPlan: GetPlansPlan
  postPlansPlan: PostPlansPlan
  getPrices: GetPrices
  postPrices: PostPrices
  getPricesSearch: GetPricesSearch
  getPricesPrice: GetPricesPrice
  postPricesPrice: PostPricesPrice
  getProducts: GetProducts
  postProducts: PostProducts
  getProductsSearch: GetProductsSearch
  deleteProductsId: DeleteProductsId
  getProductsId: GetProductsId
  postProductsId: PostProductsId
  getProductsProductFeatures: GetProductsProductFeatures
  postProductsProductFeatures: PostProductsProductFeatures
  deleteProductsProductFeaturesId: DeleteProductsProductFeaturesId
  getProductsProductFeaturesId: GetProductsProductFeaturesId
  getPromotionCodes: GetPromotionCodes
  postPromotionCodes: PostPromotionCodes
  getPromotionCodesPromotionCode: GetPromotionCodesPromotionCode
  postPromotionCodesPromotionCode: PostPromotionCodesPromotionCode
  getQuotes: GetQuotes
  postQuotes: PostQuotes
  getQuotesQuote: GetQuotesQuote
  postQuotesQuote: PostQuotesQuote
  postQuotesQuoteAccept: PostQuotesQuoteAccept
  postQuotesQuoteCancel: PostQuotesQuoteCancel
  getQuotesQuoteComputedUpfrontLineItems: GetQuotesQuoteComputedUpfrontLineItems
  postQuotesQuoteFinalize: PostQuotesQuoteFinalize
  getQuotesQuoteLineItems: GetQuotesQuoteLineItems
  getQuotesQuotePdf: GetQuotesQuotePdf
  getRadarEarlyFraudWarnings: GetRadarEarlyFraudWarnings
  getRadarEarlyFraudWarningsEarlyFraudWarning: GetRadarEarlyFraudWarningsEarlyFraudWarning
  getRadarValueListItems: GetRadarValueListItems
  postRadarValueListItems: PostRadarValueListItems
  deleteRadarValueListItemsItem: DeleteRadarValueListItemsItem
  getRadarValueListItemsItem: GetRadarValueListItemsItem
  getRadarValueLists: GetRadarValueLists
  postRadarValueLists: PostRadarValueLists
  deleteRadarValueListsValueList: DeleteRadarValueListsValueList
  getRadarValueListsValueList: GetRadarValueListsValueList
  postRadarValueListsValueList: PostRadarValueListsValueList
  getRefunds: GetRefunds
  postRefunds: PostRefunds
  getRefundsRefund: GetRefundsRefund
  postRefundsRefund: PostRefundsRefund
  postRefundsRefundCancel: PostRefundsRefundCancel
  getReportingReportRuns: GetReportingReportRuns
  postReportingReportRuns: PostReportingReportRuns
  getReportingReportRunsReportRun: GetReportingReportRunsReportRun
  getReportingReportTypes: GetReportingReportTypes
  getReportingReportTypesReportType: GetReportingReportTypesReportType
  getReviews: GetReviews
  getReviewsReview: GetReviewsReview
  postReviewsReviewApprove: PostReviewsReviewApprove
  getSetupAttempts: GetSetupAttempts
  getSetupIntents: GetSetupIntents
  postSetupIntents: PostSetupIntents
  getSetupIntentsIntent: GetSetupIntentsIntent
  postSetupIntentsIntent: PostSetupIntentsIntent
  postSetupIntentsIntentCancel: PostSetupIntentsIntentCancel
  postSetupIntentsIntentConfirm: PostSetupIntentsIntentConfirm
  postSetupIntentsIntentVerifyMicrodeposits: PostSetupIntentsIntentVerifyMicrodeposits
  getShippingRates: GetShippingRates
  postShippingRates: PostShippingRates
  getShippingRatesShippingRateToken: GetShippingRatesShippingRateToken
  postShippingRatesShippingRateToken: PostShippingRatesShippingRateToken
  postSigmaSavedQueriesId: PostSigmaSavedQueriesId
  getSigmaScheduledQueryRuns: GetSigmaScheduledQueryRuns
  getSigmaScheduledQueryRunsScheduledQueryRun: GetSigmaScheduledQueryRunsScheduledQueryRun
  postSources: PostSources
  getSourcesSource: GetSourcesSource
  postSourcesSource: PostSourcesSource
  getSourcesSourceMandateNotificationsMandateNotification: GetSourcesSourceMandateNotificationsMandateNotification
  getSourcesSourceSourceTransactions: GetSourcesSourceSourceTransactions
  getSourcesSourceSourceTransactionsSourceTransaction: GetSourcesSourceSourceTransactionsSourceTransaction
  postSourcesSourceVerify: PostSourcesSourceVerify
  getSubscriptionItems: GetSubscriptionItems
  postSubscriptionItems: PostSubscriptionItems
  deleteSubscriptionItemsItem: DeleteSubscriptionItemsItem
  getSubscriptionItemsItem: GetSubscriptionItemsItem
  postSubscriptionItemsItem: PostSubscriptionItemsItem
  getSubscriptionSchedules: GetSubscriptionSchedules
  postSubscriptionSchedules: PostSubscriptionSchedules
  getSubscriptionSchedulesSchedule: GetSubscriptionSchedulesSchedule
  postSubscriptionSchedulesSchedule: PostSubscriptionSchedulesSchedule
  postSubscriptionSchedulesScheduleCancel: PostSubscriptionSchedulesScheduleCancel
  postSubscriptionSchedulesScheduleRelease: PostSubscriptionSchedulesScheduleRelease
  getSubscriptions: GetSubscriptions
  postSubscriptions: PostSubscriptions
  getSubscriptionsSearch: GetSubscriptionsSearch
  deleteSubscriptionsSubscriptionExposedId: DeleteSubscriptionsSubscriptionExposedId
  getSubscriptionsSubscriptionExposedId: GetSubscriptionsSubscriptionExposedId
  postSubscriptionsSubscriptionExposedId: PostSubscriptionsSubscriptionExposedId
  deleteSubscriptionsSubscriptionExposedIdDiscount: DeleteSubscriptionsSubscriptionExposedIdDiscount
  postSubscriptionsSubscriptionMigrate: PostSubscriptionsSubscriptionMigrate
  postSubscriptionsSubscriptionResume: PostSubscriptionsSubscriptionResume
  postTaxCalculations: PostTaxCalculations
  getTaxCalculationsCalculation: GetTaxCalculationsCalculation
  getTaxCalculationsCalculationLineItems: GetTaxCalculationsCalculationLineItems
  getTaxRegistrations: GetTaxRegistrations
  postTaxRegistrations: PostTaxRegistrations
  getTaxRegistrationsId: GetTaxRegistrationsId
  postTaxRegistrationsId: PostTaxRegistrationsId
  getTaxSettings: GetTaxSettings
  postTaxSettings: PostTaxSettings
  postTaxTransactionsCreateFromCalculation: PostTaxTransactionsCreateFromCalculation
  postTaxTransactionsCreateReversal: PostTaxTransactionsCreateReversal
  getTaxTransactionsTransaction: GetTaxTransactionsTransaction
  getTaxTransactionsTransactionLineItems: GetTaxTransactionsTransactionLineItems
  getTaxCodes: GetTaxCodes
  getTaxCodesId: GetTaxCodesId
  getTaxIds: GetTaxIds
  postTaxIds: PostTaxIds
  deleteTaxIdsId: DeleteTaxIdsId
  getTaxIdsId: GetTaxIdsId
  getTaxRates: GetTaxRates
  postTaxRates: PostTaxRates
  getTaxRatesTaxRate: GetTaxRatesTaxRate
  postTaxRatesTaxRate: PostTaxRatesTaxRate
  getTerminalConfigurations: GetTerminalConfigurations
  postTerminalConfigurations: PostTerminalConfigurations
  deleteTerminalConfigurationsConfiguration: DeleteTerminalConfigurationsConfiguration
  getTerminalConfigurationsConfiguration: GetTerminalConfigurationsConfiguration
  postTerminalConfigurationsConfiguration: PostTerminalConfigurationsConfiguration
  postTerminalConnectionTokens: PostTerminalConnectionTokens
  getTerminalLocations: GetTerminalLocations
  postTerminalLocations: PostTerminalLocations
  deleteTerminalLocationsLocation: DeleteTerminalLocationsLocation
  getTerminalLocationsLocation: GetTerminalLocationsLocation
  postTerminalLocationsLocation: PostTerminalLocationsLocation
  getTerminalReaders: GetTerminalReaders
  postTerminalReaders: PostTerminalReaders
  deleteTerminalReadersReader: DeleteTerminalReadersReader
  getTerminalReadersReader: GetTerminalReadersReader
  postTerminalReadersReader: PostTerminalReadersReader
  postTerminalReadersReaderCancelAction: PostTerminalReadersReaderCancelAction
  postTerminalReadersReaderCollectInputs: PostTerminalReadersReaderCollectInputs
  postTerminalReadersReaderCollectPaymentMethod: PostTerminalReadersReaderCollectPaymentMethod
  postTerminalReadersReaderConfirmPaymentIntent: PostTerminalReadersReaderConfirmPaymentIntent
  postTerminalReadersReaderProcessPaymentIntent: PostTerminalReadersReaderProcessPaymentIntent
  postTerminalReadersReaderProcessSetupIntent: PostTerminalReadersReaderProcessSetupIntent
  postTerminalReadersReaderRefundPayment: PostTerminalReadersReaderRefundPayment
  postTerminalReadersReaderSetReaderDisplay: PostTerminalReadersReaderSetReaderDisplay
  postTestHelpersConfirmationTokens: PostTestHelpersConfirmationTokens
  postTestHelpersCustomersCustomerFundCashBalance: PostTestHelpersCustomersCustomerFundCashBalance
  postTestHelpersIssuingAuthorizations: PostTestHelpersIssuingAuthorizations
  postTestHelpersIssuingAuthorizationsAuthorizationCapture: PostTestHelpersIssuingAuthorizationsAuthorizationCapture
  postTestHelpersIssuingAuthorizationsAuthorizationExpire: PostTestHelpersIssuingAuthorizationsAuthorizationExpire
  postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount: PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount
  postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond: PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond
  postTestHelpersIssuingAuthorizationsAuthorizationIncrement: PostTestHelpersIssuingAuthorizationsAuthorizationIncrement
  postTestHelpersIssuingAuthorizationsAuthorizationReverse: PostTestHelpersIssuingAuthorizationsAuthorizationReverse
  postTestHelpersIssuingCardsCardShippingDeliver: PostTestHelpersIssuingCardsCardShippingDeliver
  postTestHelpersIssuingCardsCardShippingFail: PostTestHelpersIssuingCardsCardShippingFail
  postTestHelpersIssuingCardsCardShippingReturn: PostTestHelpersIssuingCardsCardShippingReturn
  postTestHelpersIssuingCardsCardShippingShip: PostTestHelpersIssuingCardsCardShippingShip
  postTestHelpersIssuingCardsCardShippingSubmit: PostTestHelpersIssuingCardsCardShippingSubmit
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject
  postTestHelpersIssuingSettlements: PostTestHelpersIssuingSettlements
  postTestHelpersIssuingSettlementsSettlementComplete: PostTestHelpersIssuingSettlementsSettlementComplete
  postTestHelpersIssuingTransactionsCreateForceCapture: PostTestHelpersIssuingTransactionsCreateForceCapture
  postTestHelpersIssuingTransactionsCreateUnlinkedRefund: PostTestHelpersIssuingTransactionsCreateUnlinkedRefund
  postTestHelpersIssuingTransactionsTransactionRefund: PostTestHelpersIssuingTransactionsTransactionRefund
  postTestHelpersRefundsRefundExpire: PostTestHelpersRefundsRefundExpire
  postTestHelpersTerminalReadersReaderPresentPaymentMethod: PostTestHelpersTerminalReadersReaderPresentPaymentMethod
  postTestHelpersTerminalReadersReaderSucceedInputCollection: PostTestHelpersTerminalReadersReaderSucceedInputCollection
  postTestHelpersTerminalReadersReaderTimeoutInputCollection: PostTestHelpersTerminalReadersReaderTimeoutInputCollection
  getTestHelpersTestClocks: GetTestHelpersTestClocks
  postTestHelpersTestClocks: PostTestHelpersTestClocks
  deleteTestHelpersTestClocksTestClock: DeleteTestHelpersTestClocksTestClock
  getTestHelpersTestClocksTestClock: GetTestHelpersTestClocksTestClock
  postTestHelpersTestClocksTestClockAdvance: PostTestHelpersTestClocksTestClockAdvance
  postTestHelpersTreasuryInboundTransfersIdFail: PostTestHelpersTreasuryInboundTransfersIdFail
  postTestHelpersTreasuryInboundTransfersIdReturn: PostTestHelpersTreasuryInboundTransfersIdReturn
  postTestHelpersTreasuryInboundTransfersIdSucceed: PostTestHelpersTreasuryInboundTransfersIdSucceed
  postTestHelpersTreasuryOutboundPaymentsId: PostTestHelpersTreasuryOutboundPaymentsId
  postTestHelpersTreasuryOutboundPaymentsIdFail: PostTestHelpersTreasuryOutboundPaymentsIdFail
  postTestHelpersTreasuryOutboundPaymentsIdPost: PostTestHelpersTreasuryOutboundPaymentsIdPost
  postTestHelpersTreasuryOutboundPaymentsIdReturn: PostTestHelpersTreasuryOutboundPaymentsIdReturn
  postTestHelpersTreasuryOutboundTransfersOutboundTransfer: PostTestHelpersTreasuryOutboundTransfersOutboundTransfer
  postTestHelpersTreasuryOutboundTransfersOutboundTransferFail: PostTestHelpersTreasuryOutboundTransfersOutboundTransferFail
  postTestHelpersTreasuryOutboundTransfersOutboundTransferPost: PostTestHelpersTreasuryOutboundTransfersOutboundTransferPost
  postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn: PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturn
  postTestHelpersTreasuryReceivedCredits: PostTestHelpersTreasuryReceivedCredits
  postTestHelpersTreasuryReceivedDebits: PostTestHelpersTreasuryReceivedDebits
  postTokens: PostTokens
  getTokensToken: GetTokensToken
  getTopups: GetTopups
  postTopups: PostTopups
  getTopupsTopup: GetTopupsTopup
  postTopupsTopup: PostTopupsTopup
  postTopupsTopupCancel: PostTopupsTopupCancel
  getTransfers: GetTransfers
  postTransfers: PostTransfers
  getTransfersIdReversals: GetTransfersIdReversals
  postTransfersIdReversals: PostTransfersIdReversals
  getTransfersTransfer: GetTransfersTransfer
  postTransfersTransfer: PostTransfersTransfer
  getTransfersTransferReversalsId: GetTransfersTransferReversalsId
  postTransfersTransferReversalsId: PostTransfersTransferReversalsId
  getTreasuryCreditReversals: GetTreasuryCreditReversals
  postTreasuryCreditReversals: PostTreasuryCreditReversals
  getTreasuryCreditReversalsCreditReversal: GetTreasuryCreditReversalsCreditReversal
  getTreasuryDebitReversals: GetTreasuryDebitReversals
  postTreasuryDebitReversals: PostTreasuryDebitReversals
  getTreasuryDebitReversalsDebitReversal: GetTreasuryDebitReversalsDebitReversal
  getTreasuryFinancialAccounts: GetTreasuryFinancialAccounts
  postTreasuryFinancialAccounts: PostTreasuryFinancialAccounts
  getTreasuryFinancialAccountsFinancialAccount: GetTreasuryFinancialAccountsFinancialAccount
  postTreasuryFinancialAccountsFinancialAccount: PostTreasuryFinancialAccountsFinancialAccount
  postTreasuryFinancialAccountsFinancialAccountClose: PostTreasuryFinancialAccountsFinancialAccountClose
  getTreasuryFinancialAccountsFinancialAccountFeatures: GetTreasuryFinancialAccountsFinancialAccountFeatures
  postTreasuryFinancialAccountsFinancialAccountFeatures: PostTreasuryFinancialAccountsFinancialAccountFeatures
  getTreasuryInboundTransfers: GetTreasuryInboundTransfers
  postTreasuryInboundTransfers: PostTreasuryInboundTransfers
  getTreasuryInboundTransfersId: GetTreasuryInboundTransfersId
  postTreasuryInboundTransfersInboundTransferCancel: PostTreasuryInboundTransfersInboundTransferCancel
  getTreasuryOutboundPayments: GetTreasuryOutboundPayments
  postTreasuryOutboundPayments: PostTreasuryOutboundPayments
  getTreasuryOutboundPaymentsId: GetTreasuryOutboundPaymentsId
  postTreasuryOutboundPaymentsIdCancel: PostTreasuryOutboundPaymentsIdCancel
  getTreasuryOutboundTransfers: GetTreasuryOutboundTransfers
  postTreasuryOutboundTransfers: PostTreasuryOutboundTransfers
  getTreasuryOutboundTransfersOutboundTransfer: GetTreasuryOutboundTransfersOutboundTransfer
  postTreasuryOutboundTransfersOutboundTransferCancel: PostTreasuryOutboundTransfersOutboundTransferCancel
  getTreasuryReceivedCredits: GetTreasuryReceivedCredits
  getTreasuryReceivedCreditsId: GetTreasuryReceivedCreditsId
  getTreasuryReceivedDebits: GetTreasuryReceivedDebits
  getTreasuryReceivedDebitsId: GetTreasuryReceivedDebitsId
  getTreasuryTransactionEntries: GetTreasuryTransactionEntries
  getTreasuryTransactionEntriesId: GetTreasuryTransactionEntriesId
  getTreasuryTransactions: GetTreasuryTransactions
  getTreasuryTransactionsId: GetTreasuryTransactionsId
  getWebhookEndpoints: GetWebhookEndpoints
  postWebhookEndpoints: PostWebhookEndpoints
  deleteWebhookEndpointsWebhookEndpoint: DeleteWebhookEndpointsWebhookEndpoint
  getWebhookEndpointsWebhookEndpoint: GetWebhookEndpointsWebhookEndpoint
  postWebhookEndpointsWebhookEndpoint: PostWebhookEndpointsWebhookEndpoint
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const getAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountBodySchema = z.never().optional()

  const getAccountResponseValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  router.get("getAccount", "/v1/account", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getAccountQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getAccountBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_account>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getAccount(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getAccountResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountLinksBodySchema = z.never()

  const postAccountLinksResponseValidator = responseValidationFactory(
    [["200", s_account_link]],
    s_error,
  )

  router.post("postAccountLinks", "/v1/account_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postAccountLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_account_link>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postAccountLinks(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postAccountLinksResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountSessionsBodySchema = z.never()

  const postAccountSessionsResponseValidator = responseValidationFactory(
    [["200", s_account_session]],
    s_error,
  )

  router.post(
    "postAccountSessions",
    "/v1/account_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postAccountSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_account_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsBodySchema = z.never().optional()

  const getAccountsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_account)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/accounts")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getAccounts", "/v1/accounts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getAccountsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getAccountsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_account[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getAccounts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getAccountsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsBodySchema = z.never().optional()

  const postAccountsResponseValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  router.post("postAccounts", "/v1/accounts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postAccountsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_account>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postAccounts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postAccountsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountBodySchema = z.never().optional()

  const deleteAccountsAccountResponseValidator = responseValidationFactory(
    [["200", s_deleted_account]],
    s_error,
  )

  router.delete(
    "deleteAccountsAccount",
    "/v1/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteAccountsAccount(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountBodySchema = z.never().optional()

  const getAccountsAccountResponseValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  router.get(
    "getAccountsAccount",
    "/v1/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccount(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountBodySchema = z.never().optional()

  const postAccountsAccountResponseValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  router.post(
    "postAccountsAccount",
    "/v1/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccount(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountBankAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountBankAccountsBodySchema = z.never().optional()

  const postAccountsAccountBankAccountsResponseValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  router.post(
    "postAccountsAccountBankAccounts",
    "/v1/accounts/:account/bank_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountBankAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountBankAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountBankAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountBankAccountsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountBankAccountsIdBodySchema = z.never().optional()

  const deleteAccountsAccountBankAccountsIdResponseValidator =
    responseValidationFactory([["200", s_deleted_external_account]], s_error)

  router.delete(
    "deleteAccountsAccountBankAccountsId",
    "/v1/accounts/:account/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteAccountsAccountBankAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountBankAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const getAccountsAccountBankAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountBankAccountsIdBodySchema = z.never().optional()

  const getAccountsAccountBankAccountsIdResponseValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  router.get(
    "getAccountsAccountBankAccountsId",
    "/v1/accounts/:account/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountBankAccountsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountBankAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountBankAccountsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountBankAccountsIdBodySchema = z.never().optional()

  const postAccountsAccountBankAccountsIdResponseValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  router.post(
    "postAccountsAccountBankAccountsId",
    "/v1/accounts/:account/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountBankAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountBankAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountCapabilitiesParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountCapabilitiesQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountCapabilitiesBodySchema = z.never().optional()

  const getAccountsAccountCapabilitiesResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_capability)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getAccountsAccountCapabilities",
    "/v1/accounts/:account/capabilities",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountCapabilitiesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountCapabilitiesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountCapabilitiesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_capability[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountCapabilities(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountCapabilitiesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountCapabilitiesCapabilityParamSchema = z.object({
    account: z.string().max(5000),
    capability: z.string(),
  })

  const getAccountsAccountCapabilitiesCapabilityQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountCapabilitiesCapabilityBodySchema = z
    .never()
    .optional()

  const getAccountsAccountCapabilitiesCapabilityResponseValidator =
    responseValidationFactory([["200", s_capability]], s_error)

  router.get(
    "getAccountsAccountCapabilitiesCapability",
    "/v1/accounts/:account/capabilities/:capability",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountCapabilitiesCapabilityParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountCapabilitiesCapabilityQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountCapabilitiesCapabilityBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_capability>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountCapabilitiesCapability(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountCapabilitiesCapabilityResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountCapabilitiesCapabilityParamSchema = z.object({
    account: z.string().max(5000),
    capability: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountCapabilitiesCapabilityBodySchema = z
    .never()
    .optional()

  const postAccountsAccountCapabilitiesCapabilityResponseValidator =
    responseValidationFactory([["200", s_capability]], s_error)

  router.post(
    "postAccountsAccountCapabilitiesCapability",
    "/v1/accounts/:account/capabilities/:capability",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountCapabilitiesCapabilityParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountCapabilitiesCapabilityBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_capability>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountCapabilitiesCapability(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountCapabilitiesCapabilityResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountExternalAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountExternalAccountsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    object: z.enum(["bank_account", "card"]).optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountExternalAccountsBodySchema = z.never().optional()

  const getAccountsAccountExternalAccountsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(
              z.union([z.lazy(() => s_bank_account), z.lazy(() => s_card)]),
            ),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getAccountsAccountExternalAccounts",
    "/v1/accounts/:account/external_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountExternalAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountExternalAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountExternalAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: (t_bank_account | t_card)[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountExternalAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountExternalAccountsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountExternalAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountExternalAccountsBodySchema = z.never().optional()

  const postAccountsAccountExternalAccountsResponseValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  router.post(
    "postAccountsAccountExternalAccounts",
    "/v1/accounts/:account/external_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountExternalAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountExternalAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountExternalAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountExternalAccountsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountExternalAccountsIdBodySchema = z.never().optional()

  const deleteAccountsAccountExternalAccountsIdResponseValidator =
    responseValidationFactory([["200", s_deleted_external_account]], s_error)

  router.delete(
    "deleteAccountsAccountExternalAccountsId",
    "/v1/accounts/:account/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteAccountsAccountExternalAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountExternalAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const getAccountsAccountExternalAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountExternalAccountsIdBodySchema = z.never().optional()

  const getAccountsAccountExternalAccountsIdResponseValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  router.get(
    "getAccountsAccountExternalAccountsId",
    "/v1/accounts/:account/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountExternalAccountsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountExternalAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountExternalAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountExternalAccountsIdBodySchema = z.never().optional()

  const postAccountsAccountExternalAccountsIdResponseValidator =
    responseValidationFactory([["200", s_external_account]], s_error)

  router.post(
    "postAccountsAccountExternalAccountsId",
    "/v1/accounts/:account/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountExternalAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountExternalAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountLoginLinksParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountLoginLinksBodySchema = z.never().optional()

  const postAccountsAccountLoginLinksResponseValidator =
    responseValidationFactory([["200", s_login_link]], s_error)

  router.post(
    "postAccountsAccountLoginLinks",
    "/v1/accounts/:account/login_links",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountLoginLinksParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountLoginLinksBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_login_link>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountLoginLinks(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountLoginLinksResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPeopleParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountPeopleQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    relationship: z
      .object({
        authorizer: PermissiveBoolean.optional(),
        director: PermissiveBoolean.optional(),
        executive: PermissiveBoolean.optional(),
        legal_guardian: PermissiveBoolean.optional(),
        owner: PermissiveBoolean.optional(),
        representative: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPeopleBodySchema = z.never().optional()

  const getAccountsAccountPeopleResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_person)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getAccountsAccountPeople",
    "/v1/accounts/:account/people",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPeopleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPeopleQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPeopleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_person[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountPeople(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPeopleResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPeopleParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPeopleBodySchema = z.never().optional()

  const postAccountsAccountPeopleResponseValidator = responseValidationFactory(
    [["200", s_person]],
    s_error,
  )

  router.post(
    "postAccountsAccountPeople",
    "/v1/accounts/:account/people",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPeopleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPeopleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountPeople(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPeopleResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountPeoplePersonBodySchema = z.never().optional()

  const deleteAccountsAccountPeoplePersonResponseValidator =
    responseValidationFactory([["200", s_deleted_person]], s_error)

  router.delete(
    "deleteAccountsAccountPeoplePerson",
    "/v1/accounts/:account/people/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountPeoplePersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountPeoplePersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteAccountsAccountPeoplePerson(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountPeoplePersonResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const getAccountsAccountPeoplePersonQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPeoplePersonBodySchema = z.never().optional()

  const getAccountsAccountPeoplePersonResponseValidator =
    responseValidationFactory([["200", s_person]], s_error)

  router.get(
    "getAccountsAccountPeoplePerson",
    "/v1/accounts/:account/people/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPeoplePersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPeoplePersonQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPeoplePersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountPeoplePerson(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPeoplePersonResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPeoplePersonBodySchema = z.never().optional()

  const postAccountsAccountPeoplePersonResponseValidator =
    responseValidationFactory([["200", s_person]], s_error)

  router.post(
    "postAccountsAccountPeoplePerson",
    "/v1/accounts/:account/people/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPeoplePersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPeoplePersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountPeoplePerson(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPeoplePersonResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPersonsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountPersonsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    relationship: z
      .object({
        authorizer: PermissiveBoolean.optional(),
        director: PermissiveBoolean.optional(),
        executive: PermissiveBoolean.optional(),
        legal_guardian: PermissiveBoolean.optional(),
        owner: PermissiveBoolean.optional(),
        representative: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPersonsBodySchema = z.never().optional()

  const getAccountsAccountPersonsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_person)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getAccountsAccountPersons",
    "/v1/accounts/:account/persons",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPersonsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPersonsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPersonsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_person[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountPersons(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPersonsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPersonsParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPersonsBodySchema = z.never().optional()

  const postAccountsAccountPersonsResponseValidator = responseValidationFactory(
    [["200", s_person]],
    s_error,
  )

  router.post(
    "postAccountsAccountPersons",
    "/v1/accounts/:account/persons",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPersonsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPersonsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountPersons(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPersonsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteAccountsAccountPersonsPersonBodySchema = z.never().optional()

  const deleteAccountsAccountPersonsPersonResponseValidator =
    responseValidationFactory([["200", s_deleted_person]], s_error)

  router.delete(
    "deleteAccountsAccountPersonsPerson",
    "/v1/accounts/:account/persons/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountPersonsPersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountPersonsPersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteAccountsAccountPersonsPerson(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountPersonsPersonResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const getAccountsAccountPersonsPersonQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAccountsAccountPersonsPersonBodySchema = z.never().optional()

  const getAccountsAccountPersonsPersonResponseValidator =
    responseValidationFactory([["200", s_person]], s_error)

  router.get(
    "getAccountsAccountPersonsPerson",
    "/v1/accounts/:account/persons/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPersonsPersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPersonsPersonQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPersonsPersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAccountsAccountPersonsPerson(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPersonsPersonResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountPersonsPersonBodySchema = z.never().optional()

  const postAccountsAccountPersonsPersonResponseValidator =
    responseValidationFactory([["200", s_person]], s_error)

  router.post(
    "postAccountsAccountPersonsPerson",
    "/v1/accounts/:account/persons/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPersonsPersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPersonsPersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_person>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountPersonsPerson(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPersonsPersonResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountRejectParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAccountsAccountRejectBodySchema = z.never()

  const postAccountsAccountRejectResponseValidator = responseValidationFactory(
    [["200", s_account]],
    s_error,
  )

  router.post(
    "postAccountsAccountReject",
    "/v1/accounts/:account/reject",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountRejectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountRejectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAccountsAccountReject(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountRejectResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplePayDomainsQuerySchema = z.object({
    domain_name: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplePayDomainsBodySchema = z.never().optional()

  const getApplePayDomainsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_apple_pay_domain),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/apple_pay/domains")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getApplePayDomains",
    "/v1/apple_pay/domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getApplePayDomainsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplePayDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_apple_pay_domain[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getApplePayDomains(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplePayDomainsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplePayDomainsBodySchema = z.never()

  const postApplePayDomainsResponseValidator = responseValidationFactory(
    [["200", s_apple_pay_domain]],
    s_error,
  )

  router.post(
    "postApplePayDomains",
    "/v1/apple_pay/domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postApplePayDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_apple_pay_domain>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postApplePayDomains(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplePayDomainsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteApplePayDomainsDomainParamSchema = z.object({
    domain: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteApplePayDomainsDomainBodySchema = z.never().optional()

  const deleteApplePayDomainsDomainResponseValidator =
    responseValidationFactory([["200", s_deleted_apple_pay_domain]], s_error)

  router.delete(
    "deleteApplePayDomainsDomain",
    "/v1/apple_pay/domains/:domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteApplePayDomainsDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteApplePayDomainsDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_apple_pay_domain>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteApplePayDomainsDomain(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteApplePayDomainsDomainResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplePayDomainsDomainParamSchema = z.object({
    domain: z.string().max(5000),
  })

  const getApplePayDomainsDomainQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplePayDomainsDomainBodySchema = z.never().optional()

  const getApplePayDomainsDomainResponseValidator = responseValidationFactory(
    [["200", s_apple_pay_domain]],
    s_error,
  )

  router.get(
    "getApplePayDomainsDomain",
    "/v1/apple_pay/domains/:domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplePayDomainsDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplePayDomainsDomainQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplePayDomainsDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_apple_pay_domain>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getApplePayDomainsDomain(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplePayDomainsDomainResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesQuerySchema = z.object({
    charge: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesBodySchema = z.never().optional()

  const getApplicationFeesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_application_fee)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/application_fees")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getApplicationFees",
    "/v1/application_fees",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getApplicationFeesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_application_fee[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getApplicationFees(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFeesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesFeeRefundsIdParamSchema = z.object({
    fee: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getApplicationFeesFeeRefundsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesFeeRefundsIdBodySchema = z.never().optional()

  const getApplicationFeesFeeRefundsIdResponseValidator =
    responseValidationFactory([["200", s_fee_refund]], s_error)

  router.get(
    "getApplicationFeesFeeRefundsId",
    "/v1/application_fees/:fee/refunds/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplicationFeesFeeRefundsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplicationFeesFeeRefundsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesFeeRefundsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_fee_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getApplicationFeesFeeRefundsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFeesFeeRefundsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postApplicationFeesFeeRefundsIdParamSchema = z.object({
    fee: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplicationFeesFeeRefundsIdBodySchema = z.never().optional()

  const postApplicationFeesFeeRefundsIdResponseValidator =
    responseValidationFactory([["200", s_fee_refund]], s_error)

  router.post(
    "postApplicationFeesFeeRefundsId",
    "/v1/application_fees/:fee/refunds/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postApplicationFeesFeeRefundsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postApplicationFeesFeeRefundsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_fee_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postApplicationFeesFeeRefundsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplicationFeesFeeRefundsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesIdParamSchema = z.object({id: z.string().max(5000)})

  const getApplicationFeesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesIdBodySchema = z.never().optional()

  const getApplicationFeesIdResponseValidator = responseValidationFactory(
    [["200", s_application_fee]],
    s_error,
  )

  router.get(
    "getApplicationFeesId",
    "/v1/application_fees/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplicationFeesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplicationFeesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_application_fee>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getApplicationFeesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFeesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postApplicationFeesIdRefundParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplicationFeesIdRefundBodySchema = z.never().optional()

  const postApplicationFeesIdRefundResponseValidator =
    responseValidationFactory([["200", s_application_fee]], s_error)

  router.post(
    "postApplicationFeesIdRefund",
    "/v1/application_fees/:id/refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postApplicationFeesIdRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postApplicationFeesIdRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_application_fee>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postApplicationFeesIdRefund(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplicationFeesIdRefundResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesIdRefundsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getApplicationFeesIdRefundsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getApplicationFeesIdRefundsBodySchema = z.never().optional()

  const getApplicationFeesIdRefundsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_fee_refund)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getApplicationFeesIdRefunds",
    "/v1/application_fees/:id/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplicationFeesIdRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplicationFeesIdRefundsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesIdRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_fee_refund[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getApplicationFeesIdRefunds(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFeesIdRefundsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postApplicationFeesIdRefundsParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postApplicationFeesIdRefundsBodySchema = z.never().optional()

  const postApplicationFeesIdRefundsResponseValidator =
    responseValidationFactory([["200", s_fee_refund]], s_error)

  router.post(
    "postApplicationFeesIdRefunds",
    "/v1/application_fees/:id/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postApplicationFeesIdRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postApplicationFeesIdRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_fee_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postApplicationFeesIdRefunds(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplicationFeesIdRefundsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAppsSecretsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAppsSecretsBodySchema = z.never().optional()

  const getAppsSecretsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_apps_secret),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/apps/secrets")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getAppsSecrets", "/v1/apps/secrets", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getAppsSecretsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getAppsSecretsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_apps_secret[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getAppsSecrets(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getAppsSecretsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAppsSecretsBodySchema = z.never()

  const postAppsSecretsResponseValidator = responseValidationFactory(
    [["200", s_apps_secret]],
    s_error,
  )

  router.post("postAppsSecrets", "/v1/apps/secrets", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postAppsSecretsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_apps_secret>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postAppsSecrets(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postAppsSecretsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postAppsSecretsDeleteBodySchema = z.never()

  const postAppsSecretsDeleteResponseValidator = responseValidationFactory(
    [["200", s_apps_secret]],
    s_error,
  )

  router.post(
    "postAppsSecretsDelete",
    "/v1/apps/secrets/delete",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postAppsSecretsDeleteBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_apps_secret>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postAppsSecretsDelete(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAppsSecretsDeleteResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAppsSecretsFindQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    name: z.string().max(5000),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getAppsSecretsFindBodySchema = z.never().optional()

  const getAppsSecretsFindResponseValidator = responseValidationFactory(
    [["200", s_apps_secret]],
    s_error,
  )

  router.get(
    "getAppsSecretsFind",
    "/v1/apps/secrets/find",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getAppsSecretsFindQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAppsSecretsFindBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_apps_secret>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAppsSecretsFind(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAppsSecretsFindResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBalanceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceBodySchema = z.never().optional()

  const getBalanceResponseValidator = responseValidationFactory(
    [["200", s_balance]],
    s_error,
  )

  router.get("getBalance", "/v1/balance", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBalanceQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBalanceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_balance>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getBalance(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBalanceResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getBalanceHistoryQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payout: z.string().max(5000).optional(),
    source: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceHistoryBodySchema = z.never().optional()

  const getBalanceHistoryResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_balance_transaction)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/balance_transactions")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getBalanceHistory", "/v1/balance/history", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBalanceHistoryQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBalanceHistoryBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_balance_transaction[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getBalanceHistory(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBalanceHistoryResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getBalanceHistoryIdParamSchema = z.object({id: z.string().max(5000)})

  const getBalanceHistoryIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceHistoryIdBodySchema = z.never().optional()

  const getBalanceHistoryIdResponseValidator = responseValidationFactory(
    [["200", s_balance_transaction]],
    s_error,
  )

  router.get(
    "getBalanceHistoryId",
    "/v1/balance/history/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBalanceHistoryIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBalanceHistoryIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBalanceHistoryIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_balance_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBalanceHistoryId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBalanceHistoryIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBalanceTransactionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payout: z.string().max(5000).optional(),
    source: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceTransactionsBodySchema = z.never().optional()

  const getBalanceTransactionsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_balance_transaction)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/balance_transactions")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getBalanceTransactions",
    "/v1/balance_transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBalanceTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBalanceTransactionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBalanceTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBalanceTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBalanceTransactionsIdBodySchema = z.never().optional()

  const getBalanceTransactionsIdResponseValidator = responseValidationFactory(
    [["200", s_balance_transaction]],
    s_error,
  )

  router.get(
    "getBalanceTransactionsId",
    "/v1/balance_transactions/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBalanceTransactionsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBalanceTransactionsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBalanceTransactionsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_balance_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBalanceTransactionsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBalanceTransactionsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingAlertsQuerySchema = z.object({
    alert_type: z.enum(["usage_threshold"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    meter: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingAlertsBodySchema = z.never().optional()

  const getBillingAlertsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_billing_alert)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/billing/alerts")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getBillingAlerts", "/v1/billing/alerts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBillingAlertsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBillingAlertsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_billing_alert[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getBillingAlerts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBillingAlertsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsBodySchema = z.never()

  const postBillingAlertsResponseValidator = responseValidationFactory(
    [["200", s_billing_alert]],
    s_error,
  )

  router.post("postBillingAlerts", "/v1/billing/alerts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postBillingAlertsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_billing_alert>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postBillingAlerts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postBillingAlertsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getBillingAlertsIdParamSchema = z.object({id: z.string().max(5000)})

  const getBillingAlertsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingAlertsIdBodySchema = z.never().optional()

  const getBillingAlertsIdResponseValidator = responseValidationFactory(
    [["200", s_billing_alert]],
    s_error,
  )

  router.get(
    "getBillingAlertsId",
    "/v1/billing/alerts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingAlertsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingAlertsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingAlertsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_alert>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingAlertsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingAlertsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingAlertsIdActivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsIdActivateBodySchema = z.never().optional()

  const postBillingAlertsIdActivateResponseValidator =
    responseValidationFactory([["200", s_billing_alert]], s_error)

  router.post(
    "postBillingAlertsIdActivate",
    "/v1/billing/alerts/:id/activate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingAlertsIdActivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingAlertsIdActivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_alert>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingAlertsIdActivate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingAlertsIdActivateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingAlertsIdArchiveParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsIdArchiveBodySchema = z.never().optional()

  const postBillingAlertsIdArchiveResponseValidator = responseValidationFactory(
    [["200", s_billing_alert]],
    s_error,
  )

  router.post(
    "postBillingAlertsIdArchive",
    "/v1/billing/alerts/:id/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingAlertsIdArchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingAlertsIdArchiveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_alert>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingAlertsIdArchive(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingAlertsIdArchiveResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingAlertsIdDeactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingAlertsIdDeactivateBodySchema = z.never().optional()

  const postBillingAlertsIdDeactivateResponseValidator =
    responseValidationFactory([["200", s_billing_alert]], s_error)

  router.post(
    "postBillingAlertsIdDeactivate",
    "/v1/billing/alerts/:id/deactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingAlertsIdDeactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingAlertsIdDeactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_alert>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingAlertsIdDeactivate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingAlertsIdDeactivateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditBalanceSummaryQuerySchema = z.object({
    customer: z.string().max(5000),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    filter: z.object({
      applicability_scope: z
        .object({
          price_type: z.enum(["metered"]).optional(),
          prices: z.array(z.object({id: z.string().max(5000)})).optional(),
        })
        .optional(),
      credit_grant: z.string().max(5000).optional(),
      type: z.enum(["applicability_scope", "credit_grant"]),
    }),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditBalanceSummaryBodySchema = z.never().optional()

  const getBillingCreditBalanceSummaryResponseValidator =
    responseValidationFactory(
      [["200", s_billing_credit_balance_summary]],
      s_error,
    )

  router.get(
    "getBillingCreditBalanceSummary",
    "/v1/billing/credit_balance_summary",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingCreditBalanceSummaryQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditBalanceSummaryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_credit_balance_summary>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingCreditBalanceSummary(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditBalanceSummaryResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditBalanceTransactionsQuerySchema = z.object({
    credit_grant: z.string().max(5000).optional(),
    customer: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditBalanceTransactionsBodySchema = z.never().optional()

  const getBillingCreditBalanceTransactionsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_billing_credit_balance_transaction)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/billing/credit_grants")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getBillingCreditBalanceTransactions",
    "/v1/billing/credit_balance_transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingCreditBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_billing_credit_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingCreditBalanceTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditBalanceTransactionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditBalanceTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingCreditBalanceTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditBalanceTransactionsIdBodySchema = z.never().optional()

  const getBillingCreditBalanceTransactionsIdResponseValidator =
    responseValidationFactory(
      [["200", s_billing_credit_balance_transaction]],
      s_error,
    )

  router.get(
    "getBillingCreditBalanceTransactionsId",
    "/v1/billing/credit_balance_transactions/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingCreditBalanceTransactionsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingCreditBalanceTransactionsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditBalanceTransactionsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_credit_balance_transaction>(
            200,
          )
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingCreditBalanceTransactionsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditBalanceTransactionsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditGrantsQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditGrantsBodySchema = z.never().optional()

  const getBillingCreditGrantsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_billing_credit_grant)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/billing/credit_grants")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getBillingCreditGrants",
    "/v1/billing/credit_grants",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingCreditGrantsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditGrantsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_billing_credit_grant[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingCreditGrants(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditGrantsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsBodySchema = z.never()

  const postBillingCreditGrantsResponseValidator = responseValidationFactory(
    [["200", s_billing_credit_grant]],
    s_error,
  )

  router.post(
    "postBillingCreditGrants",
    "/v1/billing/credit_grants",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_credit_grant>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingCreditGrants(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrantsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditGrantsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingCreditGrantsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingCreditGrantsIdBodySchema = z.never().optional()

  const getBillingCreditGrantsIdResponseValidator = responseValidationFactory(
    [["200", s_billing_credit_grant]],
    s_error,
  )

  router.get(
    "getBillingCreditGrantsId",
    "/v1/billing/credit_grants/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingCreditGrantsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingCreditGrantsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditGrantsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_credit_grant>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingCreditGrantsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditGrantsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingCreditGrantsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsIdBodySchema = z.never().optional()

  const postBillingCreditGrantsIdResponseValidator = responseValidationFactory(
    [["200", s_billing_credit_grant]],
    s_error,
  )

  router.post(
    "postBillingCreditGrantsId",
    "/v1/billing/credit_grants/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingCreditGrantsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_credit_grant>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingCreditGrantsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrantsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingCreditGrantsIdExpireParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsIdExpireBodySchema = z.never().optional()

  const postBillingCreditGrantsIdExpireResponseValidator =
    responseValidationFactory([["200", s_billing_credit_grant]], s_error)

  router.post(
    "postBillingCreditGrantsIdExpire",
    "/v1/billing/credit_grants/:id/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingCreditGrantsIdExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsIdExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_credit_grant>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingCreditGrantsIdExpire(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrantsIdExpireResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingCreditGrantsIdVoidParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingCreditGrantsIdVoidBodySchema = z.never().optional()

  const postBillingCreditGrantsIdVoidResponseValidator =
    responseValidationFactory([["200", s_billing_credit_grant]], s_error)

  router.post(
    "postBillingCreditGrantsIdVoid",
    "/v1/billing/credit_grants/:id/void",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingCreditGrantsIdVoidParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsIdVoidBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_credit_grant>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingCreditGrantsIdVoid(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrantsIdVoidResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMeterEventAdjustmentsBodySchema = z.never()

  const postBillingMeterEventAdjustmentsResponseValidator =
    responseValidationFactory(
      [["200", s_billing_meter_event_adjustment]],
      s_error,
    )

  router.post(
    "postBillingMeterEventAdjustments",
    "/v1/billing/meter_event_adjustments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingMeterEventAdjustmentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_meter_event_adjustment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingMeterEventAdjustments(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMeterEventAdjustmentsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMeterEventsBodySchema = z.never()

  const postBillingMeterEventsResponseValidator = responseValidationFactory(
    [["200", s_billing_meter_event]],
    s_error,
  )

  router.post(
    "postBillingMeterEvents",
    "/v1/billing/meter_events",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingMeterEventsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_meter_event>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingMeterEvents(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMeterEventsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingMetersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingMetersBodySchema = z.never().optional()

  const getBillingMetersResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_billing_meter),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/billing/meters")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getBillingMeters", "/v1/billing/meters", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBillingMetersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBillingMetersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_billing_meter[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getBillingMeters(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBillingMetersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersBodySchema = z.never()

  const postBillingMetersResponseValidator = responseValidationFactory(
    [["200", s_billing_meter]],
    s_error,
  )

  router.post("postBillingMeters", "/v1/billing/meters", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postBillingMetersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_billing_meter>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postBillingMeters(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postBillingMetersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getBillingMetersIdParamSchema = z.object({id: z.string().max(5000)})

  const getBillingMetersIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingMetersIdBodySchema = z.never().optional()

  const getBillingMetersIdResponseValidator = responseValidationFactory(
    [["200", s_billing_meter]],
    s_error,
  )

  router.get(
    "getBillingMetersId",
    "/v1/billing/meters/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingMetersIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingMetersIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingMetersIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_meter>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingMetersId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingMetersIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMetersIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersIdBodySchema = z.never().optional()

  const postBillingMetersIdResponseValidator = responseValidationFactory(
    [["200", s_billing_meter]],
    s_error,
  )

  router.post(
    "postBillingMetersId",
    "/v1/billing/meters/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingMetersIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingMetersIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_meter>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingMetersId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMetersIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMetersIdDeactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersIdDeactivateBodySchema = z.never().optional()

  const postBillingMetersIdDeactivateResponseValidator =
    responseValidationFactory([["200", s_billing_meter]], s_error)

  router.post(
    "postBillingMetersIdDeactivate",
    "/v1/billing/meters/:id/deactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingMetersIdDeactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingMetersIdDeactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_meter>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingMetersIdDeactivate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMetersIdDeactivateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingMetersIdEventSummariesParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingMetersIdEventSummariesQuerySchema = z.object({
    customer: z.string().max(5000),
    end_time: z.coerce.number(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    start_time: z.coerce.number(),
    starting_after: z.string().max(5000).optional(),
    value_grouping_window: z.enum(["day", "hour"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingMetersIdEventSummariesBodySchema = z.never().optional()

  const getBillingMetersIdEventSummariesResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_billing_meter_event_summary),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/billing/meters/[^/]+/event_summaries")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getBillingMetersIdEventSummaries",
    "/v1/billing/meters/:id/event_summaries",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingMetersIdEventSummariesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingMetersIdEventSummariesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingMetersIdEventSummariesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_billing_meter_event_summary[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingMetersIdEventSummaries(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingMetersIdEventSummariesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMetersIdReactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingMetersIdReactivateBodySchema = z.never().optional()

  const postBillingMetersIdReactivateResponseValidator =
    responseValidationFactory([["200", s_billing_meter]], s_error)

  router.post(
    "postBillingMetersIdReactivate",
    "/v1/billing/meters/:id/reactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingMetersIdReactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingMetersIdReactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_meter>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingMetersIdReactivate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMetersIdReactivateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingPortalConfigurationsQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    is_default: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingPortalConfigurationsBodySchema = z.never().optional()

  const getBillingPortalConfigurationsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_billing_portal_configuration),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/billing_portal/configurations")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getBillingPortalConfigurations",
    "/v1/billing_portal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingPortalConfigurationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingPortalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_billing_portal_configuration[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingPortalConfigurations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingPortalConfigurationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingPortalConfigurationsBodySchema = z.never()

  const postBillingPortalConfigurationsResponseValidator =
    responseValidationFactory(
      [["200", s_billing_portal_configuration]],
      s_error,
    )

  router.post(
    "postBillingPortalConfigurations",
    "/v1/billing_portal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingPortalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_portal_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingPortalConfigurations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingPortalConfigurationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingPortalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getBillingPortalConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getBillingPortalConfigurationsConfigurationBodySchema = z
    .never()
    .optional()

  const getBillingPortalConfigurationsConfigurationResponseValidator =
    responseValidationFactory(
      [["200", s_billing_portal_configuration]],
      s_error,
    )

  router.get(
    "getBillingPortalConfigurationsConfiguration",
    "/v1/billing_portal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingPortalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingPortalConfigurationsConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingPortalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_portal_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getBillingPortalConfigurationsConfiguration(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingPortalConfigurationsConfigurationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postBillingPortalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingPortalConfigurationsConfigurationBodySchema = z
    .never()
    .optional()

  const postBillingPortalConfigurationsConfigurationResponseValidator =
    responseValidationFactory(
      [["200", s_billing_portal_configuration]],
      s_error,
    )

  router.post(
    "postBillingPortalConfigurationsConfiguration",
    "/v1/billing_portal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingPortalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingPortalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_portal_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingPortalConfigurationsConfiguration(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingPortalConfigurationsConfigurationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postBillingPortalSessionsBodySchema = z.never()

  const postBillingPortalSessionsResponseValidator = responseValidationFactory(
    [["200", s_billing_portal_session]],
    s_error,
  )

  router.post(
    "postBillingPortalSessions",
    "/v1/billing_portal/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingPortalSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_billing_portal_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postBillingPortalSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingPortalSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
    transfer_group: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesBodySchema = z.never().optional()

  const getChargesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_charge)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/charges")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getCharges", "/v1/charges", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getChargesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getChargesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_charge[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getCharges(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getChargesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesBodySchema = z.never().optional()

  const postChargesResponseValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  router.post("postCharges", "/v1/charges", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postChargesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_charge>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postCharges(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postChargesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getChargesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesSearchBodySchema = z.never().optional()

  const getChargesSearchResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_charge)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getChargesSearch", "/v1/charges/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getChargesSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getChargesSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_charge[]
          has_more: boolean
          next_page?: string | null
          object: "search_result"
          total_count?: number
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getChargesSearch(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getChargesSearchResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getChargesChargeParamSchema = z.object({charge: z.string().max(5000)})

  const getChargesChargeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeBodySchema = z.never().optional()

  const getChargesChargeResponseValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  router.get("getChargesCharge", "/v1/charges/:charge", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getChargesChargeParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getChargesChargeQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getChargesChargeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_charge>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getChargesCharge(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getChargesChargeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postChargesChargeParamSchema = z.object({charge: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeBodySchema = z.never().optional()

  const postChargesChargeResponseValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  router.post("postChargesCharge", "/v1/charges/:charge", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postChargesChargeParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postChargesChargeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_charge>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postChargesCharge(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postChargesChargeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postChargesChargeCaptureParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeCaptureBodySchema = z.never().optional()

  const postChargesChargeCaptureResponseValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  router.post(
    "postChargesChargeCapture",
    "/v1/charges/:charge/capture",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeCaptureParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_charge>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postChargesChargeCapture(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeCaptureResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesChargeDisputeParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const getChargesChargeDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeDisputeBodySchema = z.never().optional()

  const getChargesChargeDisputeResponseValidator = responseValidationFactory(
    [["200", s_dispute]],
    s_error,
  )

  router.get(
    "getChargesChargeDispute",
    "/v1/charges/:charge/dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getChargesChargeDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getChargesChargeDisputeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getChargesChargeDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getChargesChargeDispute(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getChargesChargeDisputeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeDisputeParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeDisputeBodySchema = z.never().optional()

  const postChargesChargeDisputeResponseValidator = responseValidationFactory(
    [["200", s_dispute]],
    s_error,
  )

  router.post(
    "postChargesChargeDispute",
    "/v1/charges/:charge/dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postChargesChargeDispute(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeDisputeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeDisputeCloseParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeDisputeCloseBodySchema = z.never().optional()

  const postChargesChargeDisputeCloseResponseValidator =
    responseValidationFactory([["200", s_dispute]], s_error)

  router.post(
    "postChargesChargeDisputeClose",
    "/v1/charges/:charge/dispute/close",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeDisputeCloseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeDisputeCloseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postChargesChargeDisputeClose(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeDisputeCloseResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeRefundParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeRefundBodySchema = z.never().optional()

  const postChargesChargeRefundResponseValidator = responseValidationFactory(
    [["200", s_charge]],
    s_error,
  )

  router.post(
    "postChargesChargeRefund",
    "/v1/charges/:charge/refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_charge>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postChargesChargeRefund(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeRefundResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesChargeRefundsParamSchema = z.object({charge: z.string()})

  const getChargesChargeRefundsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeRefundsBodySchema = z.never().optional()

  const getChargesChargeRefundsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_refund)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getChargesChargeRefunds",
    "/v1/charges/:charge/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getChargesChargeRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getChargesChargeRefundsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getChargesChargeRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_refund[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getChargesChargeRefunds(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getChargesChargeRefundsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeRefundsParamSchema = z.object({
    charge: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeRefundsBodySchema = z.never().optional()

  const postChargesChargeRefundsResponseValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  router.post(
    "postChargesChargeRefunds",
    "/v1/charges/:charge/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postChargesChargeRefunds(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeRefundsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesChargeRefundsRefundParamSchema = z.object({
    charge: z.string(),
    refund: z.string(),
  })

  const getChargesChargeRefundsRefundQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getChargesChargeRefundsRefundBodySchema = z.never().optional()

  const getChargesChargeRefundsRefundResponseValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  router.get(
    "getChargesChargeRefundsRefund",
    "/v1/charges/:charge/refunds/:refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getChargesChargeRefundsRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getChargesChargeRefundsRefundQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getChargesChargeRefundsRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getChargesChargeRefundsRefund(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getChargesChargeRefundsRefundResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeRefundsRefundParamSchema = z.object({
    charge: z.string(),
    refund: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postChargesChargeRefundsRefundBodySchema = z.never().optional()

  const postChargesChargeRefundsRefundResponseValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  router.post(
    "postChargesChargeRefundsRefund",
    "/v1/charges/:charge/refunds/:refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeRefundsRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeRefundsRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postChargesChargeRefundsRefund(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeRefundsRefundResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCheckoutSessionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    customer_details: z.object({email: z.string()}).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    payment_link: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["complete", "expired", "open"]).optional(),
    subscription: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCheckoutSessionsBodySchema = z.never().optional()

  const getCheckoutSessionsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_checkout_session)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getCheckoutSessions",
    "/v1/checkout/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCheckoutSessionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCheckoutSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_checkout_session[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCheckoutSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCheckoutSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCheckoutSessionsBodySchema = z.never().optional()

  const postCheckoutSessionsResponseValidator = responseValidationFactory(
    [["200", s_checkout_session]],
    s_error,
  )

  router.post(
    "postCheckoutSessions",
    "/v1/checkout/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postCheckoutSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_checkout_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCheckoutSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCheckoutSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCheckoutSessionsSessionParamSchema = z.object({
    session: z.string().max(66),
  })

  const getCheckoutSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCheckoutSessionsSessionBodySchema = z.never().optional()

  const getCheckoutSessionsSessionResponseValidator = responseValidationFactory(
    [["200", s_checkout_session]],
    s_error,
  )

  router.get(
    "getCheckoutSessionsSession",
    "/v1/checkout/sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCheckoutSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCheckoutSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCheckoutSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_checkout_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCheckoutSessionsSession(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCheckoutSessionsSessionResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCheckoutSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCheckoutSessionsSessionBodySchema = z.never().optional()

  const postCheckoutSessionsSessionResponseValidator =
    responseValidationFactory([["200", s_checkout_session]], s_error)

  router.post(
    "postCheckoutSessionsSession",
    "/v1/checkout/sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCheckoutSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCheckoutSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_checkout_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCheckoutSessionsSession(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCheckoutSessionsSessionResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCheckoutSessionsSessionExpireParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCheckoutSessionsSessionExpireBodySchema = z.never().optional()

  const postCheckoutSessionsSessionExpireResponseValidator =
    responseValidationFactory([["200", s_checkout_session]], s_error)

  router.post(
    "postCheckoutSessionsSessionExpire",
    "/v1/checkout/sessions/:session/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCheckoutSessionsSessionExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCheckoutSessionsSessionExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_checkout_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCheckoutSessionsSessionExpire(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCheckoutSessionsSessionExpireResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCheckoutSessionsSessionLineItemsParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getCheckoutSessionsSessionLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCheckoutSessionsSessionLineItemsBodySchema = z.never().optional()

  const getCheckoutSessionsSessionLineItemsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCheckoutSessionsSessionLineItems",
    "/v1/checkout/sessions/:session/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCheckoutSessionsSessionLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCheckoutSessionsSessionLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCheckoutSessionsSessionLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCheckoutSessionsSessionLineItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCheckoutSessionsSessionLineItemsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getClimateOrdersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateOrdersBodySchema = z.never().optional()

  const getClimateOrdersResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_climate_order),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/climate/orders")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getClimateOrders", "/v1/climate/orders", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getClimateOrdersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getClimateOrdersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_climate_order[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getClimateOrders(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getClimateOrdersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postClimateOrdersBodySchema = z.never()

  const postClimateOrdersResponseValidator = responseValidationFactory(
    [["200", s_climate_order]],
    s_error,
  )

  router.post("postClimateOrders", "/v1/climate/orders", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postClimateOrdersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_climate_order>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postClimateOrders(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postClimateOrdersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getClimateOrdersOrderParamSchema = z.object({
    order: z.string().max(5000),
  })

  const getClimateOrdersOrderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateOrdersOrderBodySchema = z.never().optional()

  const getClimateOrdersOrderResponseValidator = responseValidationFactory(
    [["200", s_climate_order]],
    s_error,
  )

  router.get(
    "getClimateOrdersOrder",
    "/v1/climate/orders/:order",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getClimateOrdersOrderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getClimateOrdersOrderQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateOrdersOrderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_climate_order>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getClimateOrdersOrder(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateOrdersOrderResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postClimateOrdersOrderParamSchema = z.object({
    order: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postClimateOrdersOrderBodySchema = z.never().optional()

  const postClimateOrdersOrderResponseValidator = responseValidationFactory(
    [["200", s_climate_order]],
    s_error,
  )

  router.post(
    "postClimateOrdersOrder",
    "/v1/climate/orders/:order",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postClimateOrdersOrderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postClimateOrdersOrderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_climate_order>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postClimateOrdersOrder(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postClimateOrdersOrderResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postClimateOrdersOrderCancelParamSchema = z.object({
    order: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postClimateOrdersOrderCancelBodySchema = z.never().optional()

  const postClimateOrdersOrderCancelResponseValidator =
    responseValidationFactory([["200", s_climate_order]], s_error)

  router.post(
    "postClimateOrdersOrderCancel",
    "/v1/climate/orders/:order/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postClimateOrdersOrderCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postClimateOrdersOrderCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_climate_order>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postClimateOrdersOrderCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postClimateOrdersOrderCancelResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateProductsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateProductsBodySchema = z.never().optional()

  const getClimateProductsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_climate_product),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/climate/products")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getClimateProducts",
    "/v1/climate/products",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getClimateProductsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateProductsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_climate_product[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getClimateProducts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateProductsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateProductsProductParamSchema = z.object({
    product: z.string().max(5000),
  })

  const getClimateProductsProductQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateProductsProductBodySchema = z.never().optional()

  const getClimateProductsProductResponseValidator = responseValidationFactory(
    [["200", s_climate_product]],
    s_error,
  )

  router.get(
    "getClimateProductsProduct",
    "/v1/climate/products/:product",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getClimateProductsProductParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getClimateProductsProductQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateProductsProductBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_climate_product>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getClimateProductsProduct(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateProductsProductResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateSuppliersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateSuppliersBodySchema = z.never().optional()

  const getClimateSuppliersResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_climate_supplier),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/climate/suppliers")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getClimateSuppliers",
    "/v1/climate/suppliers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getClimateSuppliersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateSuppliersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_climate_supplier[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getClimateSuppliers(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateSuppliersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateSuppliersSupplierParamSchema = z.object({
    supplier: z.string().max(5000),
  })

  const getClimateSuppliersSupplierQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getClimateSuppliersSupplierBodySchema = z.never().optional()

  const getClimateSuppliersSupplierResponseValidator =
    responseValidationFactory([["200", s_climate_supplier]], s_error)

  router.get(
    "getClimateSuppliersSupplier",
    "/v1/climate/suppliers/:supplier",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getClimateSuppliersSupplierParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getClimateSuppliersSupplierQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateSuppliersSupplierBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_climate_supplier>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getClimateSuppliersSupplier(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateSuppliersSupplierResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getConfirmationTokensConfirmationTokenParamSchema = z.object({
    confirmation_token: z.string().max(5000),
  })

  const getConfirmationTokensConfirmationTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getConfirmationTokensConfirmationTokenBodySchema = z.never().optional()

  const getConfirmationTokensConfirmationTokenResponseValidator =
    responseValidationFactory([["200", s_confirmation_token]], s_error)

  router.get(
    "getConfirmationTokensConfirmationToken",
    "/v1/confirmation_tokens/:confirmation_token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getConfirmationTokensConfirmationTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getConfirmationTokensConfirmationTokenQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getConfirmationTokensConfirmationTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_confirmation_token>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getConfirmationTokensConfirmationToken(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getConfirmationTokensConfirmationTokenResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCountrySpecsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCountrySpecsBodySchema = z.never().optional()

  const getCountrySpecsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_country_spec),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/country_specs")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getCountrySpecs", "/v1/country_specs", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCountrySpecsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCountrySpecsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_country_spec[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getCountrySpecs(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCountrySpecsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getCountrySpecsCountryParamSchema = z.object({
    country: z.string().max(5000),
  })

  const getCountrySpecsCountryQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCountrySpecsCountryBodySchema = z.never().optional()

  const getCountrySpecsCountryResponseValidator = responseValidationFactory(
    [["200", s_country_spec]],
    s_error,
  )

  router.get(
    "getCountrySpecsCountry",
    "/v1/country_specs/:country",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCountrySpecsCountryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCountrySpecsCountryQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCountrySpecsCountryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_country_spec>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCountrySpecsCountry(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCountrySpecsCountryResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCouponsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCouponsBodySchema = z.never().optional()

  const getCouponsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_coupon),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/coupons")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getCoupons", "/v1/coupons", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCouponsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCouponsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_coupon[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getCoupons(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCouponsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCouponsBodySchema = z.never().optional()

  const postCouponsResponseValidator = responseValidationFactory(
    [["200", s_coupon]],
    s_error,
  )

  router.post("postCoupons", "/v1/coupons", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postCouponsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_coupon>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postCoupons(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCouponsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteCouponsCouponParamSchema = z.object({
    coupon: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCouponsCouponBodySchema = z.never().optional()

  const deleteCouponsCouponResponseValidator = responseValidationFactory(
    [["200", s_deleted_coupon]],
    s_error,
  )

  router.delete(
    "deleteCouponsCoupon",
    "/v1/coupons/:coupon",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCouponsCouponParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCouponsCouponBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_coupon>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCouponsCoupon(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCouponsCouponResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCouponsCouponParamSchema = z.object({coupon: z.string().max(5000)})

  const getCouponsCouponQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCouponsCouponBodySchema = z.never().optional()

  const getCouponsCouponResponseValidator = responseValidationFactory(
    [["200", s_coupon]],
    s_error,
  )

  router.get("getCouponsCoupon", "/v1/coupons/:coupon", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getCouponsCouponParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getCouponsCouponQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCouponsCouponBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_coupon>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getCouponsCoupon(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCouponsCouponResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postCouponsCouponParamSchema = z.object({coupon: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCouponsCouponBodySchema = z.never().optional()

  const postCouponsCouponResponseValidator = responseValidationFactory(
    [["200", s_coupon]],
    s_error,
  )

  router.post("postCouponsCoupon", "/v1/coupons/:coupon", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postCouponsCouponParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postCouponsCouponBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_coupon>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postCouponsCoupon(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCouponsCouponResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getCreditNotesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesBodySchema = z.never().optional()

  const getCreditNotesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_credit_note)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getCreditNotes", "/v1/credit_notes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCreditNotesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCreditNotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_credit_note[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getCreditNotes(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCreditNotesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCreditNotesBodySchema = z.never()

  const postCreditNotesResponseValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  router.post("postCreditNotes", "/v1/credit_notes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postCreditNotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_credit_note>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postCreditNotes(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCreditNotesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getCreditNotesPreviewQuerySchema = z.object({
    amount: z.coerce.number().optional(),
    credit_amount: z.coerce.number().optional(),
    effective_at: z.coerce.number().optional(),
    email_type: z.enum(["credit_note", "none"]).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000),
    lines: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount: z.coerce.number().optional(),
            description: z.string().max(5000).optional(),
            invoice_line_item: z.string().max(5000).optional(),
            quantity: z.coerce.number().optional(),
            tax_amounts: z
              .union([
                z.array(
                  z.object({
                    amount: z.coerce.number(),
                    tax_rate: z.string().max(5000),
                    taxable_amount: z.coerce.number(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            type: z.enum(["custom_line_item", "invoice_line_item"]),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          }),
        ),
      )
      .optional(),
    memo: z.string().max(5000).optional(),
    metadata: z.record(z.string()).optional(),
    out_of_band_amount: z.coerce.number().optional(),
    reason: z
      .enum([
        "duplicate",
        "fraudulent",
        "order_change",
        "product_unsatisfactory",
      ])
      .optional(),
    refund_amount: z.coerce.number().optional(),
    refunds: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount_refunded: z.coerce.number().optional(),
            refund: z.string().optional(),
          }),
        ),
      )
      .optional(),
    shipping_cost: z
      .object({shipping_rate: z.string().max(5000).optional()})
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesPreviewBodySchema = z.never().optional()

  const getCreditNotesPreviewResponseValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  router.get(
    "getCreditNotesPreview",
    "/v1/credit_notes/preview",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCreditNotesPreviewQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCreditNotesPreviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_credit_note>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCreditNotesPreview(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCreditNotesPreviewResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCreditNotesPreviewLinesQuerySchema = z.object({
    amount: z.coerce.number().optional(),
    credit_amount: z.coerce.number().optional(),
    effective_at: z.coerce.number().optional(),
    email_type: z.enum(["credit_note", "none"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000),
    limit: z.coerce.number().optional(),
    lines: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount: z.coerce.number().optional(),
            description: z.string().max(5000).optional(),
            invoice_line_item: z.string().max(5000).optional(),
            quantity: z.coerce.number().optional(),
            tax_amounts: z
              .union([
                z.array(
                  z.object({
                    amount: z.coerce.number(),
                    tax_rate: z.string().max(5000),
                    taxable_amount: z.coerce.number(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            type: z.enum(["custom_line_item", "invoice_line_item"]),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          }),
        ),
      )
      .optional(),
    memo: z.string().max(5000).optional(),
    metadata: z.record(z.string()).optional(),
    out_of_band_amount: z.coerce.number().optional(),
    reason: z
      .enum([
        "duplicate",
        "fraudulent",
        "order_change",
        "product_unsatisfactory",
      ])
      .optional(),
    refund_amount: z.coerce.number().optional(),
    refunds: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount_refunded: z.coerce.number().optional(),
            refund: z.string().optional(),
          }),
        ),
      )
      .optional(),
    shipping_cost: z
      .object({shipping_rate: z.string().max(5000).optional()})
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesPreviewLinesBodySchema = z.never().optional()

  const getCreditNotesPreviewLinesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_credit_note_line_item)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getCreditNotesPreviewLines",
    "/v1/credit_notes/preview/lines",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCreditNotesPreviewLinesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCreditNotesPreviewLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_credit_note_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCreditNotesPreviewLines(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCreditNotesPreviewLinesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCreditNotesCreditNoteLinesParamSchema = z.object({
    credit_note: z.string().max(5000),
  })

  const getCreditNotesCreditNoteLinesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesCreditNoteLinesBodySchema = z.never().optional()

  const getCreditNotesCreditNoteLinesResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_credit_note_line_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCreditNotesCreditNoteLines",
    "/v1/credit_notes/:credit_note/lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCreditNotesCreditNoteLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCreditNotesCreditNoteLinesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCreditNotesCreditNoteLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_credit_note_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCreditNotesCreditNoteLines(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCreditNotesCreditNoteLinesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCreditNotesIdParamSchema = z.object({id: z.string().max(5000)})

  const getCreditNotesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCreditNotesIdBodySchema = z.never().optional()

  const getCreditNotesIdResponseValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  router.get("getCreditNotesId", "/v1/credit_notes/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getCreditNotesIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getCreditNotesIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCreditNotesIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_credit_note>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getCreditNotesId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCreditNotesIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postCreditNotesIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCreditNotesIdBodySchema = z.never().optional()

  const postCreditNotesIdResponseValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  router.post(
    "postCreditNotesId",
    "/v1/credit_notes/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCreditNotesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCreditNotesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_credit_note>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCreditNotesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCreditNotesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCreditNotesIdVoidParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCreditNotesIdVoidBodySchema = z.never().optional()

  const postCreditNotesIdVoidResponseValidator = responseValidationFactory(
    [["200", s_credit_note]],
    s_error,
  )

  router.post(
    "postCreditNotesIdVoid",
    "/v1/credit_notes/:id/void",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCreditNotesIdVoidParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCreditNotesIdVoidBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_credit_note>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCreditNotesIdVoid(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCreditNotesIdVoidResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomerSessionsBodySchema = z.never()

  const postCustomerSessionsResponseValidator = responseValidationFactory(
    [["200", s_customer_session]],
    s_error,
  )

  router.post(
    "postCustomerSessions",
    "/v1/customer_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postCustomerSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomerSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomerSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    email: z.string().max(512).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    test_clock: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersBodySchema = z.never().optional()

  const getCustomersResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_customer)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/customers")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getCustomers", "/v1/customers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCustomersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCustomersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_customer[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getCustomers(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCustomersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersBodySchema = z.never().optional()

  const postCustomersResponseValidator = responseValidationFactory(
    [["200", s_customer]],
    s_error,
  )

  router.post("postCustomers", "/v1/customers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postCustomersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_customer>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postCustomers(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCustomersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getCustomersSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersSearchBodySchema = z.never().optional()

  const getCustomersSearchResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_customer)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getCustomersSearch",
    "/v1/customers/search",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCustomersSearchQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersSearchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_customer[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersSearch(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersSearchResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerBodySchema = z.never().optional()

  const deleteCustomersCustomerResponseValidator = responseValidationFactory(
    [["200", s_deleted_customer]],
    s_error,
  )

  router.delete(
    "deleteCustomersCustomer",
    "/v1/customers/:customer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_customer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBodySchema = z.never().optional()

  const getCustomersCustomerResponseValidator = responseValidationFactory(
    [["200", z.union([z.lazy(() => s_customer), s_deleted_customer])]],
    s_error,
  )

  router.get(
    "getCustomersCustomer",
    "/v1/customers/:customer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer | t_deleted_customer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBodySchema = z.never().optional()

  const postCustomersCustomerResponseValidator = responseValidationFactory(
    [["200", s_customer]],
    s_error,
  )

  router.post(
    "postCustomersCustomer",
    "/v1/customers/:customer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerBalanceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBalanceTransactionsBodySchema = z.never().optional()

  const getCustomersCustomerBalanceTransactionsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_customer_balance_transaction)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCustomersCustomerBalanceTransactions",
    "/v1/customers/:customer/balance_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBalanceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_customer_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerBalanceTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerBalanceTransactionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBalanceTransactionsBodySchema = z.never()

  const postCustomersCustomerBalanceTransactionsResponseValidator =
    responseValidationFactory(
      [["200", s_customer_balance_transaction]],
      s_error,
    )

  router.post(
    "postCustomersCustomerBalanceTransactions",
    "/v1/customers/:customer/balance_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBalanceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer_balance_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerBalanceTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBalanceTransactionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBalanceTransactionsTransactionParamSchema =
    z.object({customer: z.string().max(5000), transaction: z.string()})

  const getCustomersCustomerBalanceTransactionsTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBalanceTransactionsTransactionBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerBalanceTransactionsTransactionResponseValidator =
    responseValidationFactory(
      [["200", s_customer_balance_transaction]],
      s_error,
    )

  router.get(
    "getCustomersCustomerBalanceTransactionsTransaction",
    "/v1/customers/:customer/balance_transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBalanceTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBalanceTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBalanceTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer_balance_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerBalanceTransactionsTransaction(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerBalanceTransactionsTransactionResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBalanceTransactionsTransactionParamSchema =
    z.object({
      customer: z.string().max(5000),
      transaction: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBalanceTransactionsTransactionBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerBalanceTransactionsTransactionResponseValidator =
    responseValidationFactory(
      [["200", s_customer_balance_transaction]],
      s_error,
    )

  router.post(
    "postCustomersCustomerBalanceTransactionsTransaction",
    "/v1/customers/:customer/balance_transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBalanceTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBalanceTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer_balance_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerBalanceTransactionsTransaction(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postCustomersCustomerBalanceTransactionsTransactionResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBankAccountsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerBankAccountsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBankAccountsBodySchema = z.never().optional()

  const getCustomersCustomerBankAccountsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_bank_account)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCustomersCustomerBankAccounts",
    "/v1/customers/:customer/bank_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBankAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBankAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBankAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_bank_account[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerBankAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerBankAccountsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBankAccountsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBankAccountsBodySchema = z.never().optional()

  const postCustomersCustomerBankAccountsResponseValidator =
    responseValidationFactory([["200", s_payment_source]], s_error)

  router.post(
    "postCustomersCustomerBankAccounts",
    "/v1/customers/:customer/bank_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBankAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBankAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerBankAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBankAccountsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerBankAccountsIdBodySchema = z.never().optional()

  const deleteCustomersCustomerBankAccountsIdResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
        ],
      ],
      s_error,
    )

  router.delete(
    "deleteCustomersCustomerBankAccountsId",
    "/v1/customers/:customer/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_payment_source | t_deleted_payment_source
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomerBankAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerBankAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getCustomersCustomerBankAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerBankAccountsIdBodySchema = z.never().optional()

  const getCustomersCustomerBankAccountsIdResponseValidator =
    responseValidationFactory([["200", s_bank_account]], s_error)

  router.get(
    "getCustomersCustomerBankAccountsId",
    "/v1/customers/:customer/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBankAccountsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_bank_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerBankAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerBankAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBankAccountsIdBodySchema = z.never().optional()

  const postCustomersCustomerBankAccountsIdResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_card),
            z.lazy(() => s_bank_account),
            s_source,
          ]),
        ],
      ],
      s_error,
    )

  router.post(
    "postCustomersCustomerBankAccountsId",
    "/v1/customers/:customer/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_card | t_bank_account | t_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerBankAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBankAccountsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBankAccountsIdVerifyParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerBankAccountsIdVerifyBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerBankAccountsIdVerifyResponseValidator =
    responseValidationFactory([["200", s_bank_account]], s_error)

  router.post(
    "postCustomersCustomerBankAccountsIdVerify",
    "/v1/customers/:customer/bank_accounts/:id/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBankAccountsIdVerifyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBankAccountsIdVerifyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_bank_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerBankAccountsIdVerify(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBankAccountsIdVerifyResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCardsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCardsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCardsBodySchema = z.never().optional()

  const getCustomersCustomerCardsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_card)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getCustomersCustomerCards",
    "/v1/customers/:customer/cards",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCardsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCardsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCardsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_card[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerCards(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCardsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerCardsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerCardsBodySchema = z.never().optional()

  const postCustomersCustomerCardsResponseValidator = responseValidationFactory(
    [["200", s_payment_source]],
    s_error,
  )

  router.post(
    "postCustomersCustomerCards",
    "/v1/customers/:customer/cards",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerCardsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerCardsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerCards(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerCardsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerCardsIdBodySchema = z.never().optional()

  const deleteCustomersCustomerCardsIdResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
        ],
      ],
      s_error,
    )

  router.delete(
    "deleteCustomersCustomerCardsId",
    "/v1/customers/:customer/cards/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerCardsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerCardsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_payment_source | t_deleted_payment_source
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomerCardsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerCardsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getCustomersCustomerCardsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCardsIdBodySchema = z.never().optional()

  const getCustomersCustomerCardsIdResponseValidator =
    responseValidationFactory([["200", s_card]], s_error)

  router.get(
    "getCustomersCustomerCardsId",
    "/v1/customers/:customer/cards/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCardsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCardsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCardsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerCardsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCardsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerCardsIdBodySchema = z.never().optional()

  const postCustomersCustomerCardsIdResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_card),
            z.lazy(() => s_bank_account),
            s_source,
          ]),
        ],
      ],
      s_error,
    )

  router.post(
    "postCustomersCustomerCardsId",
    "/v1/customers/:customer/cards/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerCardsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerCardsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_card | t_bank_account | t_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerCardsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerCardsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCashBalanceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCashBalanceBodySchema = z.never().optional()

  const getCustomersCustomerCashBalanceResponseValidator =
    responseValidationFactory([["200", s_cash_balance]], s_error)

  router.get(
    "getCustomersCustomerCashBalance",
    "/v1/customers/:customer/cash_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCashBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCashBalanceQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCashBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_cash_balance>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerCashBalance(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCashBalanceResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerCashBalanceBodySchema = z.never().optional()

  const postCustomersCustomerCashBalanceResponseValidator =
    responseValidationFactory([["200", s_cash_balance]], s_error)

  router.post(
    "postCustomersCustomerCashBalance",
    "/v1/customers/:customer/cash_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerCashBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerCashBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_cash_balance>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerCashBalance(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerCashBalanceResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCashBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCashBalanceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCashBalanceTransactionsBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerCashBalanceTransactionsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_customer_cash_balance_transaction)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCustomersCustomerCashBalanceTransactions",
    "/v1/customers/:customer/cash_balance_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_customer_cash_balance_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerCashBalanceTransactions(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCashBalanceTransactionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCashBalanceTransactionsTransactionParamSchema =
    z.object({customer: z.string().max(5000), transaction: z.string()})

  const getCustomersCustomerCashBalanceTransactionsTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerCashBalanceTransactionsTransactionBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerCashBalanceTransactionsTransactionResponseValidator =
    responseValidationFactory(
      [["200", s_customer_cash_balance_transaction]],
      s_error,
    )

  router.get(
    "getCustomersCustomerCashBalanceTransactionsTransaction",
    "/v1/customers/:customer/cash_balance_transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer_cash_balance_transaction>(
            200,
          )
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerCashBalanceTransactionsTransaction(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerCashBalanceTransactionsTransactionResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerDiscountParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerDiscountBodySchema = z.never().optional()

  const deleteCustomersCustomerDiscountResponseValidator =
    responseValidationFactory([["200", s_deleted_discount]], s_error)

  router.delete(
    "deleteCustomersCustomerDiscount",
    "/v1/customers/:customer/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_discount>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomerDiscount(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerDiscountResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerDiscountParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerDiscountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerDiscountBodySchema = z.never().optional()

  const getCustomersCustomerDiscountResponseValidator =
    responseValidationFactory([["200", s_discount]], s_error)

  router.get(
    "getCustomersCustomerDiscount",
    "/v1/customers/:customer/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerDiscountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_discount>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerDiscount(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerDiscountResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerFundingInstructionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerFundingInstructionsBodySchema = z.never()

  const postCustomersCustomerFundingInstructionsResponseValidator =
    responseValidationFactory([["200", s_funding_instructions]], s_error)

  router.post(
    "postCustomersCustomerFundingInstructions",
    "/v1/customers/:customer/funding_instructions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerFundingInstructionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerFundingInstructionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_funding_instructions>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerFundingInstructions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerFundingInstructionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerPaymentMethodsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerPaymentMethodsQuerySchema = z.object({
    allow_redisplay: z.enum(["always", "limited", "unspecified"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z
      .enum([
        "acss_debit",
        "affirm",
        "afterpay_clearpay",
        "alipay",
        "alma",
        "amazon_pay",
        "au_becs_debit",
        "bacs_debit",
        "bancontact",
        "billie",
        "blik",
        "boleto",
        "card",
        "cashapp",
        "crypto",
        "customer_balance",
        "eps",
        "fpx",
        "giropay",
        "grabpay",
        "ideal",
        "kakao_pay",
        "klarna",
        "konbini",
        "kr_card",
        "link",
        "mobilepay",
        "multibanco",
        "naver_pay",
        "nz_bank_account",
        "oxxo",
        "p24",
        "pay_by_bank",
        "payco",
        "paynow",
        "paypal",
        "pix",
        "promptpay",
        "revolut_pay",
        "samsung_pay",
        "satispay",
        "sepa_debit",
        "sofort",
        "swish",
        "twint",
        "us_bank_account",
        "wechat_pay",
        "zip",
      ])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerPaymentMethodsBodySchema = z.never().optional()

  const getCustomersCustomerPaymentMethodsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_payment_method)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCustomersCustomerPaymentMethods",
    "/v1/customers/:customer/payment_methods",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerPaymentMethodsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerPaymentMethodsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerPaymentMethodsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_payment_method[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerPaymentMethods(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerPaymentMethodsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerPaymentMethodsPaymentMethodParamSchema = z.object({
    customer: z.string().max(5000),
    payment_method: z.string().max(5000),
  })

  const getCustomersCustomerPaymentMethodsPaymentMethodQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerPaymentMethodsPaymentMethodBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerPaymentMethodsPaymentMethodResponseValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  router.get(
    "getCustomersCustomerPaymentMethodsPaymentMethod",
    "/v1/customers/:customer/payment_methods/:payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerPaymentMethodsPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerPaymentMethodsPaymentMethod(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerPaymentMethodsPaymentMethodResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSourcesParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerSourcesQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    object: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSourcesBodySchema = z.never().optional()

  const getCustomersCustomerSourcesResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(
              z.union([
                z.lazy(() => s_bank_account),
                z.lazy(() => s_card),
                s_source,
              ]),
            ),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCustomersCustomerSources",
    "/v1/customers/:customer/sources",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSourcesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSourcesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSourcesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: (t_bank_account | t_card | t_source)[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerSources(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerSourcesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSourcesParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSourcesBodySchema = z.never().optional()

  const postCustomersCustomerSourcesResponseValidator =
    responseValidationFactory([["200", s_payment_source]], s_error)

  router.post(
    "postCustomersCustomerSources",
    "/v1/customers/:customer/sources",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSourcesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSourcesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerSources(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSourcesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerSourcesIdBodySchema = z.never().optional()

  const deleteCustomersCustomerSourcesIdResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
        ],
      ],
      s_error,
    )

  router.delete(
    "deleteCustomersCustomerSourcesId",
    "/v1/customers/:customer/sources/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerSourcesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerSourcesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_payment_source | t_deleted_payment_source
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomerSourcesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerSourcesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(500),
  })

  const getCustomersCustomerSourcesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSourcesIdBodySchema = z.never().optional()

  const getCustomersCustomerSourcesIdResponseValidator =
    responseValidationFactory([["200", s_payment_source]], s_error)

  router.get(
    "getCustomersCustomerSourcesId",
    "/v1/customers/:customer/sources/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSourcesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSourcesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSourcesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerSourcesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerSourcesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSourcesIdBodySchema = z.never().optional()

  const postCustomersCustomerSourcesIdResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_card),
            z.lazy(() => s_bank_account),
            s_source,
          ]),
        ],
      ],
      s_error,
    )

  router.post(
    "postCustomersCustomerSourcesId",
    "/v1/customers/:customer/sources/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSourcesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSourcesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_card | t_bank_account | t_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerSourcesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSourcesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSourcesIdVerifyParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSourcesIdVerifyBodySchema = z.never().optional()

  const postCustomersCustomerSourcesIdVerifyResponseValidator =
    responseValidationFactory([["200", s_bank_account]], s_error)

  router.post(
    "postCustomersCustomerSourcesIdVerify",
    "/v1/customers/:customer/sources/:id/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSourcesIdVerifyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSourcesIdVerifyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_bank_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerSourcesIdVerify(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSourcesIdVerifyResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSubscriptionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerSubscriptionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSubscriptionsBodySchema = z.never().optional()

  const getCustomersCustomerSubscriptionsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_subscription)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getCustomersCustomerSubscriptions",
    "/v1/customers/:customer/subscriptions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSubscriptionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSubscriptionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSubscriptionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_subscription[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerSubscriptions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerSubscriptionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSubscriptionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSubscriptionsBodySchema = z.never().optional()

  const postCustomersCustomerSubscriptionsResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.post(
    "postCustomersCustomerSubscriptions",
    "/v1/customers/:customer/subscriptions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSubscriptionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSubscriptionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerSubscriptions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSubscriptionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema = z
    .never()
    .optional()

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.delete(
    "deleteCustomersCustomerSubscriptionsSubscriptionExposedId",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomerSubscriptionsSubscriptionExposedId(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        deleteCustomersCustomerSubscriptionsSubscriptionExposedIdResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema = z
    .never()
    .optional()

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.get(
    "getCustomersCustomerSubscriptionsSubscriptionExposedId",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerSubscriptionsSubscriptionExposedId(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerSubscriptionsSubscriptionExposedIdResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema = z
    .never()
    .optional()

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.post(
    "postCustomersCustomerSubscriptionsSubscriptionExposedId",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerSubscriptionsSubscriptionExposedId(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postCustomersCustomerSubscriptionsSubscriptionExposedIdResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema =
    z.never().optional()

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseValidator =
    responseValidationFactory([["200", s_deleted_discount]], s_error)

  router.delete(
    "deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_discount>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema =
    z.never().optional()

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseValidator =
    responseValidationFactory([["200", s_discount]], s_error)

  router.get(
    "getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_discount>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerTaxIdsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerTaxIdsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerTaxIdsBodySchema = z.never().optional()

  const getCustomersCustomerTaxIdsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_tax_id)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getCustomersCustomerTaxIds",
    "/v1/customers/:customer/tax_ids",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerTaxIdsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerTaxIdsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerTaxIdsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_tax_id[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerTaxIds(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerTaxIdsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerTaxIdsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postCustomersCustomerTaxIdsBodySchema = z.never()

  const postCustomersCustomerTaxIdsResponseValidator =
    responseValidationFactory([["200", s_tax_id]], s_error)

  router.post(
    "postCustomersCustomerTaxIds",
    "/v1/customers/:customer/tax_ids",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerTaxIdsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerTaxIdsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_id>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postCustomersCustomerTaxIds(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerTaxIdsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerTaxIdsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteCustomersCustomerTaxIdsIdBodySchema = z.never().optional()

  const deleteCustomersCustomerTaxIdsIdResponseValidator =
    responseValidationFactory([["200", s_deleted_tax_id]], s_error)

  router.delete(
    "deleteCustomersCustomerTaxIdsId",
    "/v1/customers/:customer/tax_ids/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerTaxIdsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerTaxIdsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_tax_id>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteCustomersCustomerTaxIdsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerTaxIdsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerTaxIdsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  const getCustomersCustomerTaxIdsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getCustomersCustomerTaxIdsIdBodySchema = z.never().optional()

  const getCustomersCustomerTaxIdsIdResponseValidator =
    responseValidationFactory([["200", s_tax_id]], s_error)

  router.get(
    "getCustomersCustomerTaxIdsId",
    "/v1/customers/:customer/tax_ids/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerTaxIdsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerTaxIdsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerTaxIdsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_id>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getCustomersCustomerTaxIdsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerTaxIdsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getDisputesQuerySchema = z.object({
    charge: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getDisputesBodySchema = z.never().optional()

  const getDisputesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_dispute)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/disputes")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getDisputes", "/v1/disputes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getDisputesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getDisputesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_dispute[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getDisputes(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getDisputesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const getDisputesDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getDisputesDisputeBodySchema = z.never().optional()

  const getDisputesDisputeResponseValidator = responseValidationFactory(
    [["200", s_dispute]],
    s_error,
  )

  router.get(
    "getDisputesDispute",
    "/v1/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getDisputesDisputeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getDisputesDispute(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getDisputesDisputeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postDisputesDisputeBodySchema = z.never().optional()

  const postDisputesDisputeResponseValidator = responseValidationFactory(
    [["200", s_dispute]],
    s_error,
  )

  router.post(
    "postDisputesDispute",
    "/v1/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postDisputesDispute(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postDisputesDisputeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postDisputesDisputeCloseParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postDisputesDisputeCloseBodySchema = z.never().optional()

  const postDisputesDisputeCloseResponseValidator = responseValidationFactory(
    [["200", s_dispute]],
    s_error,
  )

  router.post(
    "postDisputesDisputeClose",
    "/v1/disputes/:dispute/close",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postDisputesDisputeCloseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postDisputesDisputeCloseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postDisputesDisputeClose(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postDisputesDisputeCloseResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsActiveEntitlementsQuerySchema = z.object({
    customer: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsActiveEntitlementsBodySchema = z.never().optional()

  const getEntitlementsActiveEntitlementsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_entitlements_active_entitlement),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getEntitlementsActiveEntitlements",
    "/v1/entitlements/active_entitlements",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getEntitlementsActiveEntitlementsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsActiveEntitlementsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_entitlements_active_entitlement[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getEntitlementsActiveEntitlements(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsActiveEntitlementsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsActiveEntitlementsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getEntitlementsActiveEntitlementsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsActiveEntitlementsIdBodySchema = z.never().optional()

  const getEntitlementsActiveEntitlementsIdResponseValidator =
    responseValidationFactory(
      [["200", s_entitlements_active_entitlement]],
      s_error,
    )

  router.get(
    "getEntitlementsActiveEntitlementsId",
    "/v1/entitlements/active_entitlements/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getEntitlementsActiveEntitlementsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getEntitlementsActiveEntitlementsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsActiveEntitlementsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_entitlements_active_entitlement>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getEntitlementsActiveEntitlementsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsActiveEntitlementsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsFeaturesQuerySchema = z.object({
    archived: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_key: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsFeaturesBodySchema = z.never().optional()

  const getEntitlementsFeaturesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_entitlements_feature),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/entitlements/features")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getEntitlementsFeatures",
    "/v1/entitlements/features",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getEntitlementsFeaturesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_entitlements_feature[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getEntitlementsFeatures(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsFeaturesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postEntitlementsFeaturesBodySchema = z.never()

  const postEntitlementsFeaturesResponseValidator = responseValidationFactory(
    [["200", s_entitlements_feature]],
    s_error,
  )

  router.post(
    "postEntitlementsFeatures",
    "/v1/entitlements/features",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postEntitlementsFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_entitlements_feature>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postEntitlementsFeatures(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postEntitlementsFeaturesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getEntitlementsFeaturesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEntitlementsFeaturesIdBodySchema = z.never().optional()

  const getEntitlementsFeaturesIdResponseValidator = responseValidationFactory(
    [["200", s_entitlements_feature]],
    s_error,
  )

  router.get(
    "getEntitlementsFeaturesId",
    "/v1/entitlements/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getEntitlementsFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getEntitlementsFeaturesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_entitlements_feature>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getEntitlementsFeaturesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsFeaturesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postEntitlementsFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postEntitlementsFeaturesIdBodySchema = z.never().optional()

  const postEntitlementsFeaturesIdResponseValidator = responseValidationFactory(
    [["200", s_entitlements_feature]],
    s_error,
  )

  router.post(
    "postEntitlementsFeaturesId",
    "/v1/entitlements/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postEntitlementsFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postEntitlementsFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_entitlements_feature>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postEntitlementsFeaturesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postEntitlementsFeaturesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postEphemeralKeysBodySchema = z.never().optional()

  const postEphemeralKeysResponseValidator = responseValidationFactory(
    [["200", s_ephemeral_key]],
    s_error,
  )

  router.post("postEphemeralKeys", "/v1/ephemeral_keys", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postEphemeralKeysBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_ephemeral_key>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postEphemeralKeys(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postEphemeralKeysResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteEphemeralKeysKeyParamSchema = z.object({
    key: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteEphemeralKeysKeyBodySchema = z.never().optional()

  const deleteEphemeralKeysKeyResponseValidator = responseValidationFactory(
    [["200", s_ephemeral_key]],
    s_error,
  )

  router.delete(
    "deleteEphemeralKeysKey",
    "/v1/ephemeral_keys/:key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteEphemeralKeysKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteEphemeralKeysKeyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_ephemeral_key>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteEphemeralKeysKey(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteEphemeralKeysKeyResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEventsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    delivery_success: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
    types: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEventsBodySchema = z.never().optional()

  const getEventsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_event),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/events")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getEvents", "/v1/events", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getEventsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getEventsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_event[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getEvents(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getEventsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getEventsIdParamSchema = z.object({id: z.string().max(5000)})

  const getEventsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getEventsIdBodySchema = z.never().optional()

  const getEventsIdResponseValidator = responseValidationFactory(
    [["200", s_event]],
    s_error,
  )

  router.get("getEventsId", "/v1/events/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getEventsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getEventsIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getEventsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_event>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getEventsId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getEventsIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getExchangeRatesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getExchangeRatesBodySchema = z.never().optional()

  const getExchangeRatesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_exchange_rate),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/exchange_rates")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getExchangeRates", "/v1/exchange_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getExchangeRatesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getExchangeRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_exchange_rate[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getExchangeRates(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getExchangeRatesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getExchangeRatesRateIdParamSchema = z.object({
    rate_id: z.string().max(5000),
  })

  const getExchangeRatesRateIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getExchangeRatesRateIdBodySchema = z.never().optional()

  const getExchangeRatesRateIdResponseValidator = responseValidationFactory(
    [["200", s_exchange_rate]],
    s_error,
  )

  router.get(
    "getExchangeRatesRateId",
    "/v1/exchange_rates/:rate_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getExchangeRatesRateIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getExchangeRatesRateIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getExchangeRatesRateIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_exchange_rate>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getExchangeRatesRateId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getExchangeRatesRateIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postExternalAccountsIdParamSchema = z.object({id: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postExternalAccountsIdBodySchema = z.never().optional()

  const postExternalAccountsIdResponseValidator = responseValidationFactory(
    [["200", s_external_account]],
    s_error,
  )

  router.post(
    "postExternalAccountsId",
    "/v1/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_external_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postExternalAccountsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postExternalAccountsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFileLinksQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    expired: PermissiveBoolean.optional(),
    file: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFileLinksBodySchema = z.never().optional()

  const getFileLinksResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_file_link)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/file_links")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getFileLinks", "/v1/file_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getFileLinksQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFileLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_file_link[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getFileLinks(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFileLinksResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFileLinksBodySchema = z.never()

  const postFileLinksResponseValidator = responseValidationFactory(
    [["200", s_file_link]],
    s_error,
  )

  router.post("postFileLinks", "/v1/file_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postFileLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_file_link>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postFileLinks(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postFileLinksResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getFileLinksLinkParamSchema = z.object({link: z.string()})

  const getFileLinksLinkQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFileLinksLinkBodySchema = z.never().optional()

  const getFileLinksLinkResponseValidator = responseValidationFactory(
    [["200", s_file_link]],
    s_error,
  )

  router.get("getFileLinksLink", "/v1/file_links/:link", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getFileLinksLinkParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getFileLinksLinkQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFileLinksLinkBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_file_link>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getFileLinksLink(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFileLinksLinkResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postFileLinksLinkParamSchema = z.object({link: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFileLinksLinkBodySchema = z.never().optional()

  const postFileLinksLinkResponseValidator = responseValidationFactory(
    [["200", s_file_link]],
    s_error,
  )

  router.post(
    "postFileLinksLink",
    "/v1/file_links/:link",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFileLinksLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFileLinksLinkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_file_link>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postFileLinksLink(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFileLinksLinkResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFilesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    purpose: z
      .enum([
        "account_requirement",
        "additional_verification",
        "business_icon",
        "business_logo",
        "customer_signature",
        "dispute_evidence",
        "document_provider_identity_document",
        "finance_report_run",
        "financial_account_statement",
        "identity_document",
        "identity_document_downloadable",
        "issuing_regulatory_reporting",
        "pci_document",
        "selfie",
        "sigma_scheduled_query",
        "tax_document_user_upload",
        "terminal_reader_splashscreen",
      ])
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFilesBodySchema = z.never().optional()

  const getFilesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_file)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/files")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getFiles", "/v1/files", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getFilesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFilesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_file[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getFiles(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFilesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'multipart/form-data' not yet supported

  const postFilesBodySchema = z.never()

  const postFilesResponseValidator = responseValidationFactory(
    [["200", s_file]],
    s_error,
  )

  router.post("postFiles", "/v1/files", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postFilesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_file>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postFiles(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postFilesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getFilesFileParamSchema = z.object({file: z.string().max(5000)})

  const getFilesFileQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFilesFileBodySchema = z.never().optional()

  const getFilesFileResponseValidator = responseValidationFactory(
    [["200", s_file]],
    s_error,
  )

  router.get("getFilesFile", "/v1/files/:file", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getFilesFileParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getFilesFileQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFilesFileBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_file>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getFilesFile(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFilesFileResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getFinancialConnectionsAccountsQuerySchema = z.object({
    account_holder: z
      .object({
        account: z.string().max(5000).optional(),
        customer: z.string().max(5000).optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    session: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsAccountsBodySchema = z.never().optional()

  const getFinancialConnectionsAccountsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_financial_connections_account)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/financial_connections/accounts")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getFinancialConnectionsAccounts",
    "/v1/financial_connections/accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getFinancialConnectionsAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_financial_connections_account[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getFinancialConnectionsAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsAccountsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getFinancialConnectionsAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsAccountsAccountBodySchema = z.never().optional()

  const getFinancialConnectionsAccountsAccountResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  router.get(
    "getFinancialConnectionsAccountsAccount",
    "/v1/financial_connections/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsAccountsAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getFinancialConnectionsAccountsAccount(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsAccountsAccountResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountDisconnectParamSchema = z.object(
    {account: z.string().max(5000)},
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountDisconnectBodySchema = z
    .never()
    .optional()

  const postFinancialConnectionsAccountsAccountDisconnectResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  router.post(
    "postFinancialConnectionsAccountsAccountDisconnect",
    "/v1/financial_connections/accounts/:account/disconnect",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountDisconnectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountDisconnectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountDisconnect(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postFinancialConnectionsAccountsAccountDisconnectResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsAccountsAccountOwnersParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getFinancialConnectionsAccountsAccountOwnersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    ownership: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsAccountsAccountOwnersBodySchema = z
    .never()
    .optional()

  const getFinancialConnectionsAccountsAccountOwnersResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_financial_connections_account_owner),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getFinancialConnectionsAccountsAccountOwners",
    "/v1/financial_connections/accounts/:account/owners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsAccountsAccountOwnersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsAccountsAccountOwnersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsAccountsAccountOwnersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_financial_connections_account_owner[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getFinancialConnectionsAccountsAccountOwners(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsAccountsAccountOwnersResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountRefreshParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountRefreshBodySchema = z.never()

  const postFinancialConnectionsAccountsAccountRefreshResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  router.post(
    "postFinancialConnectionsAccountsAccountRefresh",
    "/v1/financial_connections/accounts/:account/refresh",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountRefreshParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountRefreshBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountRefresh(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postFinancialConnectionsAccountsAccountRefreshResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountSubscribeParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountSubscribeBodySchema = z.never()

  const postFinancialConnectionsAccountsAccountSubscribeResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  router.post(
    "postFinancialConnectionsAccountsAccountSubscribe",
    "/v1/financial_connections/accounts/:account/subscribe",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountSubscribeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountSubscribeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountSubscribe(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postFinancialConnectionsAccountsAccountSubscribeResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountUnsubscribeParamSchema =
    z.object({account: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsAccountsAccountUnsubscribeBodySchema = z.never()

  const postFinancialConnectionsAccountsAccountUnsubscribeResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  router.post(
    "postFinancialConnectionsAccountsAccountUnsubscribe",
    "/v1/financial_connections/accounts/:account/unsubscribe",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountUnsubscribeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountUnsubscribe(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postFinancialConnectionsAccountsAccountUnsubscribeResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postFinancialConnectionsSessionsBodySchema = z.never()

  const postFinancialConnectionsSessionsResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_session]],
      s_error,
    )

  router.post(
    "postFinancialConnectionsSessions",
    "/v1/financial_connections/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postFinancialConnectionsSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFinancialConnectionsSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getFinancialConnectionsSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsSessionsSessionBodySchema = z.never().optional()

  const getFinancialConnectionsSessionsSessionResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_session]],
      s_error,
    )

  router.get(
    "getFinancialConnectionsSessionsSession",
    "/v1/financial_connections/sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getFinancialConnectionsSessionsSession(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsSessionsSessionResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsTransactionsQuerySchema = z.object({
    account: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    transacted_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    transaction_refresh: z.object({after: z.string().max(5000)}).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsTransactionsBodySchema = z.never().optional()

  const getFinancialConnectionsTransactionsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_financial_connections_transaction),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/financial_connections/transactions")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getFinancialConnectionsTransactions",
    "/v1/financial_connections/transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getFinancialConnectionsTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_financial_connections_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getFinancialConnectionsTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsTransactionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getFinancialConnectionsTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getFinancialConnectionsTransactionsTransactionBodySchema = z
    .never()
    .optional()

  const getFinancialConnectionsTransactionsTransactionResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_transaction]],
      s_error,
    )

  router.get(
    "getFinancialConnectionsTransactionsTransaction",
    "/v1/financial_connections/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_transaction>(
            200,
          )
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getFinancialConnectionsTransactionsTransaction(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getFinancialConnectionsTransactionsTransactionResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getForwardingRequestsQuerySchema = z.object({
    created: z
      .object({
        gt: z.coerce.number().optional(),
        gte: z.coerce.number().optional(),
        lt: z.coerce.number().optional(),
        lte: z.coerce.number().optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getForwardingRequestsBodySchema = z.never().optional()

  const getForwardingRequestsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_forwarding_request),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getForwardingRequests",
    "/v1/forwarding/requests",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getForwardingRequestsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getForwardingRequestsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_forwarding_request[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getForwardingRequests(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getForwardingRequestsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postForwardingRequestsBodySchema = z.never()

  const postForwardingRequestsResponseValidator = responseValidationFactory(
    [["200", s_forwarding_request]],
    s_error,
  )

  router.post(
    "postForwardingRequests",
    "/v1/forwarding/requests",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postForwardingRequestsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_forwarding_request>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postForwardingRequests(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postForwardingRequestsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getForwardingRequestsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getForwardingRequestsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getForwardingRequestsIdBodySchema = z.never().optional()

  const getForwardingRequestsIdResponseValidator = responseValidationFactory(
    [["200", s_forwarding_request]],
    s_error,
  )

  router.get(
    "getForwardingRequestsId",
    "/v1/forwarding/requests/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getForwardingRequestsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getForwardingRequestsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getForwardingRequestsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_forwarding_request>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getForwardingRequestsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getForwardingRequestsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationReportsQuerySchema = z.object({
    client_reference_id: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["document", "id_number"]).optional(),
    verification_session: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationReportsBodySchema = z.never().optional()

  const getIdentityVerificationReportsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_identity_verification_report),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/identity/verification_reports")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getIdentityVerificationReports",
    "/v1/identity/verification_reports",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIdentityVerificationReportsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationReportsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_identity_verification_report[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIdentityVerificationReports(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationReportsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationReportsReportParamSchema = z.object({
    report: z.string().max(5000),
  })

  const getIdentityVerificationReportsReportQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationReportsReportBodySchema = z.never().optional()

  const getIdentityVerificationReportsReportResponseValidator =
    responseValidationFactory(
      [["200", s_identity_verification_report]],
      s_error,
    )

  router.get(
    "getIdentityVerificationReportsReport",
    "/v1/identity/verification_reports/:report",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIdentityVerificationReportsReportParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIdentityVerificationReportsReportQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationReportsReportBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_identity_verification_report>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIdentityVerificationReportsReport(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationReportsReportResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationSessionsQuerySchema = z.object({
    client_reference_id: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    related_customer: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "processing", "requires_input", "verified"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationSessionsBodySchema = z.never().optional()

  const getIdentityVerificationSessionsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_identity_verification_session),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/identity/verification_sessions")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getIdentityVerificationSessions",
    "/v1/identity/verification_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIdentityVerificationSessionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_identity_verification_session[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIdentityVerificationSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsBodySchema = z.never().optional()

  const postIdentityVerificationSessionsResponseValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  router.post(
    "postIdentityVerificationSessions",
    "/v1/identity/verification_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_identity_verification_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIdentityVerificationSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getIdentityVerificationSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIdentityVerificationSessionsSessionBodySchema = z.never().optional()

  const getIdentityVerificationSessionsSessionResponseValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  router.get(
    "getIdentityVerificationSessionsSession",
    "/v1/identity/verification_sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIdentityVerificationSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIdentityVerificationSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_identity_verification_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIdentityVerificationSessionsSession(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationSessionsSessionResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIdentityVerificationSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsSessionBodySchema = z.never().optional()

  const postIdentityVerificationSessionsSessionResponseValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  router.post(
    "postIdentityVerificationSessionsSession",
    "/v1/identity/verification_sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIdentityVerificationSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_identity_verification_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIdentityVerificationSessionsSession(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessionsSessionResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIdentityVerificationSessionsSessionCancelParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsSessionCancelBodySchema = z
    .never()
    .optional()

  const postIdentityVerificationSessionsSessionCancelResponseValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  router.post(
    "postIdentityVerificationSessionsSessionCancel",
    "/v1/identity/verification_sessions/:session/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIdentityVerificationSessionsSessionCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsSessionCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_identity_verification_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIdentityVerificationSessionsSessionCancel(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessionsSessionCancelResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIdentityVerificationSessionsSessionRedactParamSchema = z.object({
    session: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIdentityVerificationSessionsSessionRedactBodySchema = z
    .never()
    .optional()

  const postIdentityVerificationSessionsSessionRedactResponseValidator =
    responseValidationFactory(
      [["200", s_identity_verification_session]],
      s_error,
    )

  router.post(
    "postIdentityVerificationSessionsSessionRedact",
    "/v1/identity/verification_sessions/:session/redact",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIdentityVerificationSessionsSessionRedactParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsSessionRedactBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_identity_verification_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIdentityVerificationSessionsSessionRedact(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessionsSessionRedactResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getInvoicePaymentsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    payment: z
      .object({
        payment_intent: z.string().max(5000).optional(),
        type: z.enum(["payment_intent"]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "open", "paid"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicePaymentsBodySchema = z.never().optional()

  const getInvoicePaymentsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoice_payment)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getInvoicePayments",
    "/v1/invoice_payments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getInvoicePaymentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicePaymentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_invoice_payment[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getInvoicePayments(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicePaymentsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicePaymentsInvoicePaymentParamSchema = z.object({
    invoice_payment: z.string().max(5000),
  })

  const getInvoicePaymentsInvoicePaymentQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicePaymentsInvoicePaymentBodySchema = z.never().optional()

  const getInvoicePaymentsInvoicePaymentResponseValidator =
    responseValidationFactory([["200", s_invoice_payment]], s_error)

  router.get(
    "getInvoicePaymentsInvoicePayment",
    "/v1/invoice_payments/:invoice_payment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoicePaymentsInvoicePaymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoicePaymentsInvoicePaymentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicePaymentsInvoicePaymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getInvoicePaymentsInvoicePayment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicePaymentsInvoicePaymentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoiceRenderingTemplatesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "archived"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceRenderingTemplatesBodySchema = z.never().optional()

  const getInvoiceRenderingTemplatesResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_invoice_rendering_template),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getInvoiceRenderingTemplates",
    "/v1/invoice_rendering_templates",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getInvoiceRenderingTemplatesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoiceRenderingTemplatesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_invoice_rendering_template[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getInvoiceRenderingTemplates(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoiceRenderingTemplatesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoiceRenderingTemplatesTemplateParamSchema = z.object({
    template: z.string().max(5000),
  })

  const getInvoiceRenderingTemplatesTemplateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    version: z.coerce.number().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceRenderingTemplatesTemplateBodySchema = z.never().optional()

  const getInvoiceRenderingTemplatesTemplateResponseValidator =
    responseValidationFactory([["200", s_invoice_rendering_template]], s_error)

  router.get(
    "getInvoiceRenderingTemplatesTemplate",
    "/v1/invoice_rendering_templates/:template",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoiceRenderingTemplatesTemplateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoiceRenderingTemplatesTemplateQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoiceRenderingTemplatesTemplateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice_rendering_template>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getInvoiceRenderingTemplatesTemplate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoiceRenderingTemplatesTemplateResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postInvoiceRenderingTemplatesTemplateArchiveParamSchema = z.object({
    template: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceRenderingTemplatesTemplateArchiveBodySchema = z
    .never()
    .optional()

  const postInvoiceRenderingTemplatesTemplateArchiveResponseValidator =
    responseValidationFactory([["200", s_invoice_rendering_template]], s_error)

  router.post(
    "postInvoiceRenderingTemplatesTemplateArchive",
    "/v1/invoice_rendering_templates/:template/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateArchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateArchiveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice_rendering_template>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoiceRenderingTemplatesTemplateArchive(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoiceRenderingTemplatesTemplateArchiveResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postInvoiceRenderingTemplatesTemplateUnarchiveParamSchema = z.object({
    template: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceRenderingTemplatesTemplateUnarchiveBodySchema = z
    .never()
    .optional()

  const postInvoiceRenderingTemplatesTemplateUnarchiveResponseValidator =
    responseValidationFactory([["200", s_invoice_rendering_template]], s_error)

  router.post(
    "postInvoiceRenderingTemplatesTemplateUnarchive",
    "/v1/invoice_rendering_templates/:template/unarchive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateUnarchiveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice_rendering_template>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoiceRenderingTemplatesTemplateUnarchive(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postInvoiceRenderingTemplatesTemplateUnarchiveResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getInvoiceitemsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    pending: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceitemsBodySchema = z.never().optional()

  const getInvoiceitemsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoiceitem)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/invoiceitems")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getInvoiceitems", "/v1/invoiceitems", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getInvoiceitemsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getInvoiceitemsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_invoiceitem[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getInvoiceitems(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getInvoiceitemsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceitemsBodySchema = z.never()

  const postInvoiceitemsResponseValidator = responseValidationFactory(
    [["200", s_invoiceitem]],
    s_error,
  )

  router.post("postInvoiceitems", "/v1/invoiceitems", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postInvoiceitemsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_invoiceitem>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postInvoiceitems(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postInvoiceitemsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteInvoiceitemsInvoiceitemBodySchema = z.never().optional()

  const deleteInvoiceitemsInvoiceitemResponseValidator =
    responseValidationFactory([["200", s_deleted_invoiceitem]], s_error)

  router.delete(
    "deleteInvoiceitemsInvoiceitem",
    "/v1/invoiceitems/:invoiceitem",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteInvoiceitemsInvoiceitemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteInvoiceitemsInvoiceitemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_invoiceitem>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteInvoiceitemsInvoiceitem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteInvoiceitemsInvoiceitemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  const getInvoiceitemsInvoiceitemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoiceitemsInvoiceitemBodySchema = z.never().optional()

  const getInvoiceitemsInvoiceitemResponseValidator = responseValidationFactory(
    [["200", s_invoiceitem]],
    s_error,
  )

  router.get(
    "getInvoiceitemsInvoiceitem",
    "/v1/invoiceitems/:invoiceitem",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoiceitemsInvoiceitemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoiceitemsInvoiceitemQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoiceitemsInvoiceitemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoiceitem>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getInvoiceitemsInvoiceitem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoiceitemsInvoiceitemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoiceitemsInvoiceitemBodySchema = z.never().optional()

  const postInvoiceitemsInvoiceitemResponseValidator =
    responseValidationFactory([["200", s_invoiceitem]], s_error)

  router.post(
    "postInvoiceitemsInvoiceitem",
    "/v1/invoiceitems/:invoiceitem",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoiceitemsInvoiceitemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoiceitemsInvoiceitemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoiceitem>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoiceitemsInvoiceitem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoiceitemsInvoiceitemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesQuerySchema = z.object({
    collection_method: z
      .enum(["charge_automatically", "send_invoice"])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    due_date: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["draft", "open", "paid", "uncollectible", "void"])
      .optional(),
    subscription: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesBodySchema = z.never().optional()

  const getInvoicesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoice)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/invoices")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getInvoices", "/v1/invoices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getInvoicesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getInvoicesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_invoice[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getInvoices(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getInvoicesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesBodySchema = z.never().optional()

  const postInvoicesResponseValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  router.post("postInvoices", "/v1/invoices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postInvoicesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_invoice>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postInvoices(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postInvoicesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesCreatePreviewBodySchema = z.never().optional()

  const postInvoicesCreatePreviewResponseValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  router.post(
    "postInvoicesCreatePreview",
    "/v1/invoices/create_preview",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postInvoicesCreatePreviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesCreatePreview(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesCreatePreviewResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesSearchBodySchema = z.never().optional()

  const getInvoicesSearchResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_invoice)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getInvoicesSearch", "/v1/invoices/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getInvoicesSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getInvoicesSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_invoice[]
          has_more: boolean
          next_page?: string | null
          object: "search_result"
          total_count?: number
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getInvoicesSearch(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getInvoicesSearchResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteInvoicesInvoiceBodySchema = z.never().optional()

  const deleteInvoicesInvoiceResponseValidator = responseValidationFactory(
    [["200", s_deleted_invoice]],
    s_error,
  )

  router.delete(
    "deleteInvoicesInvoice",
    "/v1/invoices/:invoice",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteInvoicesInvoiceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteInvoicesInvoiceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteInvoicesInvoice(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteInvoicesInvoiceResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const getInvoicesInvoiceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesInvoiceBodySchema = z.never().optional()

  const getInvoicesInvoiceResponseValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  router.get(
    "getInvoicesInvoice",
    "/v1/invoices/:invoice",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoicesInvoiceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoicesInvoiceQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicesInvoiceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getInvoicesInvoice(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicesInvoiceResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceBodySchema = z.never().optional()

  const postInvoicesInvoiceResponseValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  router.post(
    "postInvoicesInvoice",
    "/v1/invoices/:invoice",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoice(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceAddLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceAddLinesBodySchema = z.never()

  const postInvoicesInvoiceAddLinesResponseValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  router.post(
    "postInvoicesInvoiceAddLines",
    "/v1/invoices/:invoice/add_lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceAddLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceAddLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceAddLines(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceAddLinesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceAttachPaymentParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceAttachPaymentBodySchema = z.never().optional()

  const postInvoicesInvoiceAttachPaymentResponseValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  router.post(
    "postInvoicesInvoiceAttachPayment",
    "/v1/invoices/:invoice/attach_payment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceAttachPaymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceAttachPaymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceAttachPayment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceAttachPaymentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceFinalizeParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceFinalizeBodySchema = z.never().optional()

  const postInvoicesInvoiceFinalizeResponseValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  router.post(
    "postInvoicesInvoiceFinalize",
    "/v1/invoices/:invoice/finalize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceFinalizeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceFinalizeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceFinalize(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceFinalizeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesInvoiceLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const getInvoicesInvoiceLinesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getInvoicesInvoiceLinesBodySchema = z.never().optional()

  const getInvoicesInvoiceLinesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_line_item)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getInvoicesInvoiceLines",
    "/v1/invoices/:invoice/lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoicesInvoiceLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoicesInvoiceLinesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicesInvoiceLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getInvoicesInvoiceLines(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicesInvoiceLinesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceLinesLineItemIdParamSchema = z.object({
    invoice: z.string().max(5000),
    line_item_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceLinesLineItemIdBodySchema = z.never().optional()

  const postInvoicesInvoiceLinesLineItemIdResponseValidator =
    responseValidationFactory([["200", s_line_item]], s_error)

  router.post(
    "postInvoicesInvoiceLinesLineItemId",
    "/v1/invoices/:invoice/lines/:line_item_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceLinesLineItemIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceLinesLineItemIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_line_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceLinesLineItemId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceLinesLineItemIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceMarkUncollectibleParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceMarkUncollectibleBodySchema = z.never().optional()

  const postInvoicesInvoiceMarkUncollectibleResponseValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  router.post(
    "postInvoicesInvoiceMarkUncollectible",
    "/v1/invoices/:invoice/mark_uncollectible",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceMarkUncollectibleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceMarkUncollectibleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceMarkUncollectible(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceMarkUncollectibleResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoicePayParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoicePayBodySchema = z.never().optional()

  const postInvoicesInvoicePayResponseValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  router.post(
    "postInvoicesInvoicePay",
    "/v1/invoices/:invoice/pay",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoicePayParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoicePayBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoicePay(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoicePayResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceRemoveLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceRemoveLinesBodySchema = z.never()

  const postInvoicesInvoiceRemoveLinesResponseValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  router.post(
    "postInvoicesInvoiceRemoveLines",
    "/v1/invoices/:invoice/remove_lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceRemoveLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceRemoveLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceRemoveLines(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceRemoveLinesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceSendParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceSendBodySchema = z.never().optional()

  const postInvoicesInvoiceSendResponseValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  router.post(
    "postInvoicesInvoiceSend",
    "/v1/invoices/:invoice/send",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceSendParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceSendBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceSend(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceSendResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceUpdateLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceUpdateLinesBodySchema = z.never()

  const postInvoicesInvoiceUpdateLinesResponseValidator =
    responseValidationFactory([["200", s_invoice]], s_error)

  router.post(
    "postInvoicesInvoiceUpdateLines",
    "/v1/invoices/:invoice/update_lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceUpdateLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceUpdateLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceUpdateLines(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceUpdateLinesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceVoidParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postInvoicesInvoiceVoidBodySchema = z.never().optional()

  const postInvoicesInvoiceVoidResponseValidator = responseValidationFactory(
    [["200", s_invoice]],
    s_error,
  )

  router.post(
    "postInvoicesInvoiceVoid",
    "/v1/invoices/:invoice/void",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceVoidParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceVoidBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_invoice>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postInvoicesInvoiceVoid(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceVoidResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingAuthorizationsQuerySchema = z.object({
    card: z.string().max(5000).optional(),
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["closed", "expired", "pending", "reversed"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingAuthorizationsBodySchema = z.never().optional()

  const getIssuingAuthorizationsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_authorization)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/issuing/authorizations")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getIssuingAuthorizations",
    "/v1/issuing/authorizations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingAuthorizationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingAuthorizationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_issuing_authorization[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingAuthorizations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingAuthorizationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingAuthorizationsAuthorizationParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  const getIssuingAuthorizationsAuthorizationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingAuthorizationsAuthorizationBodySchema = z.never().optional()

  const getIssuingAuthorizationsAuthorizationResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.get(
    "getIssuingAuthorizationsAuthorization",
    "/v1/issuing/authorizations/:authorization",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingAuthorizationsAuthorizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingAuthorizationsAuthorizationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingAuthorizationsAuthorizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingAuthorizationsAuthorization(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingAuthorizationsAuthorizationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIssuingAuthorizationsAuthorizationParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingAuthorizationsAuthorizationBodySchema = z.never().optional()

  const postIssuingAuthorizationsAuthorizationResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postIssuingAuthorizationsAuthorization",
    "/v1/issuing/authorizations/:authorization",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingAuthorizationsAuthorizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingAuthorizationsAuthorizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingAuthorizationsAuthorization(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingAuthorizationsAuthorizationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIssuingAuthorizationsAuthorizationApproveParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingAuthorizationsAuthorizationApproveBodySchema = z
    .never()
    .optional()

  const postIssuingAuthorizationsAuthorizationApproveResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postIssuingAuthorizationsAuthorizationApprove",
    "/v1/issuing/authorizations/:authorization/approve",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingAuthorizationsAuthorizationApproveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingAuthorizationsAuthorizationApproveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingAuthorizationsAuthorizationApprove(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingAuthorizationsAuthorizationApproveResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIssuingAuthorizationsAuthorizationDeclineParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingAuthorizationsAuthorizationDeclineBodySchema = z
    .never()
    .optional()

  const postIssuingAuthorizationsAuthorizationDeclineResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postIssuingAuthorizationsAuthorizationDecline",
    "/v1/issuing/authorizations/:authorization/decline",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingAuthorizationsAuthorizationDeclineParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingAuthorizationsAuthorizationDeclineBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingAuthorizationsAuthorizationDecline(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingAuthorizationsAuthorizationDeclineResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getIssuingCardholdersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    email: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    phone_number: z.string().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "blocked", "inactive"]).optional(),
    type: z.enum(["company", "individual"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardholdersBodySchema = z.never().optional()

  const getIssuingCardholdersResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_cardholder)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/issuing/cardholders")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getIssuingCardholders",
    "/v1/issuing/cardholders",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingCardholdersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingCardholdersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_issuing_cardholder[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingCardholders(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingCardholdersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardholdersBodySchema = z.never()

  const postIssuingCardholdersResponseValidator = responseValidationFactory(
    [["200", s_issuing_cardholder]],
    s_error,
  )

  router.post(
    "postIssuingCardholders",
    "/v1/issuing/cardholders",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIssuingCardholdersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_cardholder>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingCardholders(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingCardholdersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingCardholdersCardholderParamSchema = z.object({
    cardholder: z.string().max(5000),
  })

  const getIssuingCardholdersCardholderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardholdersCardholderBodySchema = z.never().optional()

  const getIssuingCardholdersCardholderResponseValidator =
    responseValidationFactory([["200", s_issuing_cardholder]], s_error)

  router.get(
    "getIssuingCardholdersCardholder",
    "/v1/issuing/cardholders/:cardholder",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingCardholdersCardholderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingCardholdersCardholderQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingCardholdersCardholderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_cardholder>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingCardholdersCardholder(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingCardholdersCardholderResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingCardholdersCardholderParamSchema = z.object({
    cardholder: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardholdersCardholderBodySchema = z.never().optional()

  const postIssuingCardholdersCardholderResponseValidator =
    responseValidationFactory([["200", s_issuing_cardholder]], s_error)

  router.post(
    "postIssuingCardholdersCardholder",
    "/v1/issuing/cardholders/:cardholder",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingCardholdersCardholderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingCardholdersCardholderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_cardholder>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingCardholdersCardholder(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingCardholdersCardholderResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingCardsQuerySchema = z.object({
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    exp_month: z.coerce.number().optional(),
    exp_year: z.coerce.number().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    last4: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    personalization_design: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "canceled", "inactive"]).optional(),
    type: z.enum(["physical", "virtual"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardsBodySchema = z.never().optional()

  const getIssuingCardsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_card)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/issuing/cards")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getIssuingCards", "/v1/issuing/cards", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getIssuingCardsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getIssuingCardsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_issuing_card[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getIssuingCards(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getIssuingCardsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardsBodySchema = z.never()

  const postIssuingCardsResponseValidator = responseValidationFactory(
    [["200", s_issuing_card]],
    s_error,
  )

  router.post("postIssuingCards", "/v1/issuing/cards", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postIssuingCardsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_issuing_card>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postIssuingCards(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postIssuingCardsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getIssuingCardsCardParamSchema = z.object({card: z.string().max(5000)})

  const getIssuingCardsCardQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingCardsCardBodySchema = z.never().optional()

  const getIssuingCardsCardResponseValidator = responseValidationFactory(
    [["200", s_issuing_card]],
    s_error,
  )

  router.get(
    "getIssuingCardsCard",
    "/v1/issuing/cards/:card",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingCardsCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingCardsCardQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingCardsCardBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingCardsCard(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingCardsCardResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingCardsCardParamSchema = z.object({card: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingCardsCardBodySchema = z.never().optional()

  const postIssuingCardsCardResponseValidator = responseValidationFactory(
    [["200", s_issuing_card]],
    s_error,
  )

  router.post(
    "postIssuingCardsCard",
    "/v1/issuing/cards/:card",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingCardsCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingCardsCardBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingCardsCard(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingCardsCardResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingDisputesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["expired", "lost", "submitted", "unsubmitted", "won"])
      .optional(),
    transaction: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingDisputesBodySchema = z.never().optional()

  const getIssuingDisputesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_dispute)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/issuing/disputes")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getIssuingDisputes",
    "/v1/issuing/disputes",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingDisputesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingDisputesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_issuing_dispute[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingDisputes(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingDisputesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingDisputesBodySchema = z.never().optional()

  const postIssuingDisputesResponseValidator = responseValidationFactory(
    [["200", s_issuing_dispute]],
    s_error,
  )

  router.post(
    "postIssuingDisputes",
    "/v1/issuing/disputes",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIssuingDisputesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingDisputes(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingDisputesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const getIssuingDisputesDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingDisputesDisputeBodySchema = z.never().optional()

  const getIssuingDisputesDisputeResponseValidator = responseValidationFactory(
    [["200", s_issuing_dispute]],
    s_error,
  )

  router.get(
    "getIssuingDisputesDispute",
    "/v1/issuing/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingDisputesDisputeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingDisputesDispute(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingDisputesDisputeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingDisputesDisputeBodySchema = z.never().optional()

  const postIssuingDisputesDisputeResponseValidator = responseValidationFactory(
    [["200", s_issuing_dispute]],
    s_error,
  )

  router.post(
    "postIssuingDisputesDispute",
    "/v1/issuing/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingDisputesDispute(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingDisputesDisputeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingDisputesDisputeSubmitParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingDisputesDisputeSubmitBodySchema = z.never().optional()

  const postIssuingDisputesDisputeSubmitResponseValidator =
    responseValidationFactory([["200", s_issuing_dispute]], s_error)

  router.post(
    "postIssuingDisputesDisputeSubmit",
    "/v1/issuing/disputes/:dispute/submit",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingDisputesDisputeSubmitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingDisputesDisputeSubmitBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_dispute>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingDisputesDisputeSubmit(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingDisputesDisputeSubmitResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingPersonalizationDesignsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_keys: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(200)),
      )
      .optional(),
    preferences: z
      .object({
        is_default: PermissiveBoolean.optional(),
        is_platform_default: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive", "rejected", "review"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPersonalizationDesignsBodySchema = z.never().optional()

  const getIssuingPersonalizationDesignsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_issuing_personalization_design)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/issuing/personalization_designs")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getIssuingPersonalizationDesigns",
    "/v1/issuing/personalization_designs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingPersonalizationDesignsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPersonalizationDesignsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_issuing_personalization_design[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingPersonalizationDesigns(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingPersonalizationDesignsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingPersonalizationDesignsBodySchema = z.never()

  const postIssuingPersonalizationDesignsResponseValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  router.post(
    "postIssuingPersonalizationDesigns",
    "/v1/issuing/personalization_designs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIssuingPersonalizationDesignsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_personalization_design>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingPersonalizationDesigns(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingPersonalizationDesignsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getIssuingPersonalizationDesignsPersonalizationDesignParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  const getIssuingPersonalizationDesignsPersonalizationDesignQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPersonalizationDesignsPersonalizationDesignBodySchema = z
    .never()
    .optional()

  const getIssuingPersonalizationDesignsPersonalizationDesignResponseValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  router.get(
    "getIssuingPersonalizationDesignsPersonalizationDesign",
    "/v1/issuing/personalization_designs/:personalization_design",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_personalization_design>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingPersonalizationDesignsPersonalizationDesign(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getIssuingPersonalizationDesignsPersonalizationDesignResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postIssuingPersonalizationDesignsPersonalizationDesignParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingPersonalizationDesignsPersonalizationDesignBodySchema = z
    .never()
    .optional()

  const postIssuingPersonalizationDesignsPersonalizationDesignResponseValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  router.post(
    "postIssuingPersonalizationDesignsPersonalizationDesign",
    "/v1/issuing/personalization_designs/:personalization_design",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_personalization_design>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingPersonalizationDesignsPersonalizationDesign(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postIssuingPersonalizationDesignsPersonalizationDesignResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getIssuingPhysicalBundlesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive", "review"]).optional(),
    type: z.enum(["custom", "standard"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPhysicalBundlesBodySchema = z.never().optional()

  const getIssuingPhysicalBundlesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_issuing_physical_bundle),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/issuing/physical_bundles")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getIssuingPhysicalBundles",
    "/v1/issuing/physical_bundles",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingPhysicalBundlesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPhysicalBundlesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_issuing_physical_bundle[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingPhysicalBundles(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingPhysicalBundlesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingPhysicalBundlesPhysicalBundleParamSchema = z.object({
    physical_bundle: z.string().max(5000),
  })

  const getIssuingPhysicalBundlesPhysicalBundleQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingPhysicalBundlesPhysicalBundleBodySchema = z.never().optional()

  const getIssuingPhysicalBundlesPhysicalBundleResponseValidator =
    responseValidationFactory([["200", s_issuing_physical_bundle]], s_error)

  router.get(
    "getIssuingPhysicalBundlesPhysicalBundle",
    "/v1/issuing/physical_bundles/:physical_bundle",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingPhysicalBundlesPhysicalBundleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingPhysicalBundlesPhysicalBundleQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPhysicalBundlesPhysicalBundleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_physical_bundle>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingPhysicalBundlesPhysicalBundle(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingPhysicalBundlesPhysicalBundleResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getIssuingSettlementsSettlementParamSchema = z.object({
    settlement: z.string().max(5000),
  })

  const getIssuingSettlementsSettlementQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingSettlementsSettlementBodySchema = z.never().optional()

  const getIssuingSettlementsSettlementResponseValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  router.get(
    "getIssuingSettlementsSettlement",
    "/v1/issuing/settlements/:settlement",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingSettlementsSettlementParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingSettlementsSettlementQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingSettlementsSettlementBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_settlement>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingSettlementsSettlement(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingSettlementsSettlementResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingSettlementsSettlementParamSchema = z.object({
    settlement: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingSettlementsSettlementBodySchema = z.never().optional()

  const postIssuingSettlementsSettlementResponseValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  router.post(
    "postIssuingSettlementsSettlement",
    "/v1/issuing/settlements/:settlement",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingSettlementsSettlementParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingSettlementsSettlementBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_settlement>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingSettlementsSettlement(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingSettlementsSettlementResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingTokensQuerySchema = z.object({
    card: z.string().max(5000),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "deleted", "requested", "suspended"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTokensBodySchema = z.never().optional()

  const getIssuingTokensResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_token)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getIssuingTokens", "/v1/issuing/tokens", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getIssuingTokensQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getIssuingTokensBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_issuing_token[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getIssuingTokens(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getIssuingTokensResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getIssuingTokensTokenParamSchema = z.object({
    token: z.string().max(5000),
  })

  const getIssuingTokensTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTokensTokenBodySchema = z.never().optional()

  const getIssuingTokensTokenResponseValidator = responseValidationFactory(
    [["200", s_issuing_token]],
    s_error,
  )

  router.get(
    "getIssuingTokensToken",
    "/v1/issuing/tokens/:token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingTokensTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingTokensTokenQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingTokensTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_token>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingTokensToken(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingTokensTokenResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingTokensTokenParamSchema = z.object({
    token: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingTokensTokenBodySchema = z.never()

  const postIssuingTokensTokenResponseValidator = responseValidationFactory(
    [["200", s_issuing_token]],
    s_error,
  )

  router.post(
    "postIssuingTokensToken",
    "/v1/issuing/tokens/:token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingTokensTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingTokensTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_token>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingTokensToken(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingTokensTokenResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingTransactionsQuerySchema = z.object({
    card: z.string().max(5000).optional(),
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["capture", "refund"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTransactionsBodySchema = z.never().optional()

  const getIssuingTransactionsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_issuing_transaction)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/issuing/transactions")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getIssuingTransactions",
    "/v1/issuing/transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_issuing_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingTransactionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getIssuingTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getIssuingTransactionsTransactionBodySchema = z.never().optional()

  const getIssuingTransactionsTransactionResponseValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  router.get(
    "getIssuingTransactionsTransaction",
    "/v1/issuing/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getIssuingTransactionsTransaction(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingTransactionsTransactionResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIssuingTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postIssuingTransactionsTransactionBodySchema = z.never().optional()

  const postIssuingTransactionsTransactionResponseValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  router.post(
    "postIssuingTransactionsTransaction",
    "/v1/issuing/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postIssuingTransactionsTransaction(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingTransactionsTransactionResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postLinkAccountSessionsBodySchema = z.never()

  const postLinkAccountSessionsResponseValidator = responseValidationFactory(
    [["200", s_financial_connections_session]],
    s_error,
  )

  router.post(
    "postLinkAccountSessions",
    "/v1/link_account_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postLinkAccountSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postLinkAccountSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postLinkAccountSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getLinkAccountSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getLinkAccountSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkAccountSessionsSessionBodySchema = z.never().optional()

  const getLinkAccountSessionsSessionResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_session]],
      s_error,
    )

  router.get(
    "getLinkAccountSessionsSession",
    "/v1/link_account_sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getLinkAccountSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getLinkAccountSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getLinkAccountSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_session>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getLinkAccountSessionsSession(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getLinkAccountSessionsSessionResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getLinkedAccountsQuerySchema = z.object({
    account_holder: z
      .object({
        account: z.string().max(5000).optional(),
        customer: z.string().max(5000).optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    session: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkedAccountsBodySchema = z.never().optional()

  const getLinkedAccountsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_financial_connections_account)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/financial_connections/accounts")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getLinkedAccounts", "/v1/linked_accounts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getLinkedAccountsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getLinkedAccountsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_financial_connections_account[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getLinkedAccounts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getLinkedAccountsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getLinkedAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getLinkedAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkedAccountsAccountBodySchema = z.never().optional()

  const getLinkedAccountsAccountResponseValidator = responseValidationFactory(
    [["200", s_financial_connections_account]],
    s_error,
  )

  router.get(
    "getLinkedAccountsAccount",
    "/v1/linked_accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getLinkedAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getLinkedAccountsAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getLinkedAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getLinkedAccountsAccount(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getLinkedAccountsAccountResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postLinkedAccountsAccountDisconnectParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postLinkedAccountsAccountDisconnectBodySchema = z.never().optional()

  const postLinkedAccountsAccountDisconnectResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  router.post(
    "postLinkedAccountsAccountDisconnect",
    "/v1/linked_accounts/:account/disconnect",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postLinkedAccountsAccountDisconnectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postLinkedAccountsAccountDisconnectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postLinkedAccountsAccountDisconnect(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postLinkedAccountsAccountDisconnectResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getLinkedAccountsAccountOwnersParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getLinkedAccountsAccountOwnersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    ownership: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getLinkedAccountsAccountOwnersBodySchema = z.never().optional()

  const getLinkedAccountsAccountOwnersResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_financial_connections_account_owner),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getLinkedAccountsAccountOwners",
    "/v1/linked_accounts/:account/owners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getLinkedAccountsAccountOwnersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getLinkedAccountsAccountOwnersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getLinkedAccountsAccountOwnersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_financial_connections_account_owner[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getLinkedAccountsAccountOwners(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getLinkedAccountsAccountOwnersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postLinkedAccountsAccountRefreshParamSchema = z.object({
    account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postLinkedAccountsAccountRefreshBodySchema = z.never()

  const postLinkedAccountsAccountRefreshResponseValidator =
    responseValidationFactory(
      [["200", s_financial_connections_account]],
      s_error,
    )

  router.post(
    "postLinkedAccountsAccountRefresh",
    "/v1/linked_accounts/:account/refresh",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postLinkedAccountsAccountRefreshParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postLinkedAccountsAccountRefreshBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_financial_connections_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postLinkedAccountsAccountRefresh(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postLinkedAccountsAccountRefreshResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getMandatesMandateParamSchema = z.object({mandate: z.string()})

  const getMandatesMandateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getMandatesMandateBodySchema = z.never().optional()

  const getMandatesMandateResponseValidator = responseValidationFactory(
    [["200", s_mandate]],
    s_error,
  )

  router.get(
    "getMandatesMandate",
    "/v1/mandates/:mandate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getMandatesMandateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getMandatesMandateQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getMandatesMandateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_mandate>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getMandatesMandate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getMandatesMandateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentIntentsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentIntentsBodySchema = z.never().optional()

  const getPaymentIntentsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payment_intent)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payment_intents")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPaymentIntents", "/v1/payment_intents", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPaymentIntentsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPaymentIntentsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_payment_intent[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPaymentIntents(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPaymentIntentsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsBodySchema = z.never()

  const postPaymentIntentsResponseValidator = responseValidationFactory(
    [["200", s_payment_intent]],
    s_error,
  )

  router.post(
    "postPaymentIntents",
    "/v1/payment_intents",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntents(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentIntentsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentIntentsSearchBodySchema = z.never().optional()

  const getPaymentIntentsSearchResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payment_intent)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getPaymentIntentsSearch",
    "/v1/payment_intents/search",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getPaymentIntentsSearchQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentIntentsSearchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_payment_intent[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentIntentsSearch(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentIntentsSearchResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const getPaymentIntentsIntentQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentIntentsIntentBodySchema = z.never().optional()

  const getPaymentIntentsIntentResponseValidator = responseValidationFactory(
    [["200", s_payment_intent]],
    s_error,
  )

  router.get(
    "getPaymentIntentsIntent",
    "/v1/payment_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentIntentsIntentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentIntentsIntent(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentIntentsIntentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentBodySchema = z.never().optional()

  const postPaymentIntentsIntentResponseValidator = responseValidationFactory(
    [["200", s_payment_intent]],
    s_error,
  )

  router.post(
    "postPaymentIntentsIntent",
    "/v1/payment_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntentsIntent(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentApplyCustomerBalanceParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentApplyCustomerBalanceBodySchema = z
    .never()
    .optional()

  const postPaymentIntentsIntentApplyCustomerBalanceResponseValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  router.post(
    "postPaymentIntentsIntentApplyCustomerBalance",
    "/v1/payment_intents/:intent/apply_customer_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentApplyCustomerBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentApplyCustomerBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntentsIntentApplyCustomerBalance(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentApplyCustomerBalanceResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentCancelParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentCancelBodySchema = z.never().optional()

  const postPaymentIntentsIntentCancelResponseValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  router.post(
    "postPaymentIntentsIntentCancel",
    "/v1/payment_intents/:intent/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntentsIntentCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentCancelResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentCaptureParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentCaptureBodySchema = z.never().optional()

  const postPaymentIntentsIntentCaptureResponseValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  router.post(
    "postPaymentIntentsIntentCapture",
    "/v1/payment_intents/:intent/capture",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentCaptureParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntentsIntentCapture(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentCaptureResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentConfirmParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentConfirmBodySchema = z.never().optional()

  const postPaymentIntentsIntentConfirmResponseValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  router.post(
    "postPaymentIntentsIntentConfirm",
    "/v1/payment_intents/:intent/confirm",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentConfirmParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentConfirmBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntentsIntentConfirm(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentConfirmResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentIncrementAuthorizationParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentIncrementAuthorizationBodySchema = z.never()

  const postPaymentIntentsIntentIncrementAuthorizationResponseValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  router.post(
    "postPaymentIntentsIntentIncrementAuthorization",
    "/v1/payment_intents/:intent/increment_authorization",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentIncrementAuthorizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentIncrementAuthorizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntentsIntentIncrementAuthorization(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postPaymentIntentsIntentIncrementAuthorizationResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentVerifyMicrodepositsParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentIntentsIntentVerifyMicrodepositsBodySchema = z
    .never()
    .optional()

  const postPaymentIntentsIntentVerifyMicrodepositsResponseValidator =
    responseValidationFactory([["200", s_payment_intent]], s_error)

  router.post(
    "postPaymentIntentsIntentVerifyMicrodeposits",
    "/v1/payment_intents/:intent/verify_microdeposits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentVerifyMicrodepositsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentVerifyMicrodepositsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentIntentsIntentVerifyMicrodeposits(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentVerifyMicrodepositsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getPaymentLinksQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentLinksBodySchema = z.never().optional()

  const getPaymentLinksResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payment_link)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payment_links")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPaymentLinks", "/v1/payment_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPaymentLinksQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPaymentLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_payment_link[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPaymentLinks(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPaymentLinksResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentLinksBodySchema = z.never()

  const postPaymentLinksResponseValidator = responseValidationFactory(
    [["200", s_payment_link]],
    s_error,
  )

  router.post("postPaymentLinks", "/v1/payment_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPaymentLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_payment_link>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postPaymentLinks(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPaymentLinksResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPaymentLinksPaymentLinkParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  const getPaymentLinksPaymentLinkQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentLinksPaymentLinkBodySchema = z.never().optional()

  const getPaymentLinksPaymentLinkResponseValidator = responseValidationFactory(
    [["200", s_payment_link]],
    s_error,
  )

  router.get(
    "getPaymentLinksPaymentLink",
    "/v1/payment_links/:payment_link",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentLinksPaymentLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentLinksPaymentLinkQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentLinksPaymentLinkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_link>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentLinksPaymentLink(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentLinksPaymentLinkResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentLinksPaymentLinkParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentLinksPaymentLinkBodySchema = z.never().optional()

  const postPaymentLinksPaymentLinkResponseValidator =
    responseValidationFactory([["200", s_payment_link]], s_error)

  router.post(
    "postPaymentLinksPaymentLink",
    "/v1/payment_links/:payment_link",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentLinksPaymentLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentLinksPaymentLinkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_link>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentLinksPaymentLink(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentLinksPaymentLinkResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentLinksPaymentLinkLineItemsParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  const getPaymentLinksPaymentLinkLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentLinksPaymentLinkLineItemsBodySchema = z.never().optional()

  const getPaymentLinksPaymentLinkLineItemsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getPaymentLinksPaymentLinkLineItems",
    "/v1/payment_links/:payment_link/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentLinksPaymentLinkLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentLinksPaymentLinkLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentLinksPaymentLinkLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentLinksPaymentLinkLineItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentLinksPaymentLinkLineItemsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodConfigurationsQuerySchema = z.object({
    application: z.union([z.string().max(100), z.enum([""])]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodConfigurationsBodySchema = z.never().optional()

  const getPaymentMethodConfigurationsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_payment_method_configuration),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/payment_method_configurations")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getPaymentMethodConfigurations",
    "/v1/payment_method_configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getPaymentMethodConfigurationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_payment_method_configuration[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentMethodConfigurations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodConfigurationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodConfigurationsBodySchema = z.never().optional()

  const postPaymentMethodConfigurationsResponseValidator =
    responseValidationFactory(
      [["200", s_payment_method_configuration]],
      s_error,
    )

  router.post(
    "postPaymentMethodConfigurations",
    "/v1/payment_method_configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodConfigurations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodConfigurationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getPaymentMethodConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodConfigurationsConfigurationBodySchema = z
    .never()
    .optional()

  const getPaymentMethodConfigurationsConfigurationResponseValidator =
    responseValidationFactory(
      [["200", s_payment_method_configuration]],
      s_error,
    )

  router.get(
    "getPaymentMethodConfigurationsConfiguration",
    "/v1/payment_method_configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentMethodConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentMethodConfigurationsConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentMethodConfigurationsConfiguration(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodConfigurationsConfigurationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodConfigurationsConfigurationBodySchema = z
    .never()
    .optional()

  const postPaymentMethodConfigurationsConfigurationResponseValidator =
    responseValidationFactory(
      [["200", s_payment_method_configuration]],
      s_error,
    )

  router.post(
    "postPaymentMethodConfigurationsConfiguration",
    "/v1/payment_method_configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodConfigurationsConfiguration(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodConfigurationsConfigurationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodDomainsQuerySchema = z.object({
    domain_name: z.string().max(5000).optional(),
    enabled: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodDomainsBodySchema = z.never().optional()

  const getPaymentMethodDomainsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_payment_method_domain),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/payment_method_domains")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getPaymentMethodDomains",
    "/v1/payment_method_domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getPaymentMethodDomainsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_payment_method_domain[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentMethodDomains(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodDomainsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodDomainsBodySchema = z.never()

  const postPaymentMethodDomainsResponseValidator = responseValidationFactory(
    [["200", s_payment_method_domain]],
    s_error,
  )

  router.post(
    "postPaymentMethodDomains",
    "/v1/payment_method_domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method_domain>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodDomains(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodDomainsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodDomainsPaymentMethodDomainParamSchema = z.object({
    payment_method_domain: z.string().max(5000),
  })

  const getPaymentMethodDomainsPaymentMethodDomainQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodDomainsPaymentMethodDomainBodySchema = z
    .never()
    .optional()

  const getPaymentMethodDomainsPaymentMethodDomainResponseValidator =
    responseValidationFactory([["200", s_payment_method_domain]], s_error)

  router.get(
    "getPaymentMethodDomainsPaymentMethodDomain",
    "/v1/payment_method_domains/:payment_method_domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentMethodDomainsPaymentMethodDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentMethodDomainsPaymentMethodDomainQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodDomainsPaymentMethodDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method_domain>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentMethodDomainsPaymentMethodDomain(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodDomainsPaymentMethodDomainResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodDomainsPaymentMethodDomainParamSchema = z.object({
    payment_method_domain: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodDomainsPaymentMethodDomainBodySchema = z
    .never()
    .optional()

  const postPaymentMethodDomainsPaymentMethodDomainResponseValidator =
    responseValidationFactory([["200", s_payment_method_domain]], s_error)

  router.post(
    "postPaymentMethodDomainsPaymentMethodDomain",
    "/v1/payment_method_domains/:payment_method_domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method_domain>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodDomainsPaymentMethodDomain(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodDomainsPaymentMethodDomainResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodDomainsPaymentMethodDomainValidateParamSchema =
    z.object({payment_method_domain: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodDomainsPaymentMethodDomainValidateBodySchema = z
    .never()
    .optional()

  const postPaymentMethodDomainsPaymentMethodDomainValidateResponseValidator =
    responseValidationFactory([["200", s_payment_method_domain]], s_error)

  router.post(
    "postPaymentMethodDomainsPaymentMethodDomainValidate",
    "/v1/payment_method_domains/:payment_method_domain/validate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainValidateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method_domain>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodDomainsPaymentMethodDomainValidate(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postPaymentMethodDomainsPaymentMethodDomainValidateResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodsQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z
      .enum([
        "acss_debit",
        "affirm",
        "afterpay_clearpay",
        "alipay",
        "alma",
        "amazon_pay",
        "au_becs_debit",
        "bacs_debit",
        "bancontact",
        "billie",
        "blik",
        "boleto",
        "card",
        "cashapp",
        "crypto",
        "customer_balance",
        "eps",
        "fpx",
        "giropay",
        "grabpay",
        "ideal",
        "kakao_pay",
        "klarna",
        "konbini",
        "kr_card",
        "link",
        "mobilepay",
        "multibanco",
        "naver_pay",
        "nz_bank_account",
        "oxxo",
        "p24",
        "pay_by_bank",
        "payco",
        "paynow",
        "paypal",
        "pix",
        "promptpay",
        "revolut_pay",
        "samsung_pay",
        "satispay",
        "sepa_debit",
        "sofort",
        "swish",
        "twint",
        "us_bank_account",
        "wechat_pay",
        "zip",
      ])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodsBodySchema = z.never().optional()

  const getPaymentMethodsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payment_method)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payment_methods")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPaymentMethods", "/v1/payment_methods", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPaymentMethodsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPaymentMethodsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_payment_method[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPaymentMethods(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPaymentMethodsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsBodySchema = z.never().optional()

  const postPaymentMethodsResponseValidator = responseValidationFactory(
    [["200", s_payment_method]],
    s_error,
  )

  router.post(
    "postPaymentMethods",
    "/v1/payment_methods",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethods(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodsPaymentMethodParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  const getPaymentMethodsPaymentMethodQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPaymentMethodsPaymentMethodBodySchema = z.never().optional()

  const getPaymentMethodsPaymentMethodResponseValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  router.get(
    "getPaymentMethodsPaymentMethod",
    "/v1/payment_methods/:payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentMethodsPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentMethodsPaymentMethodQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodsPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPaymentMethodsPaymentMethod(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodsPaymentMethodResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodsPaymentMethodParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsPaymentMethodBodySchema = z.never().optional()

  const postPaymentMethodsPaymentMethodResponseValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  router.post(
    "postPaymentMethodsPaymentMethod",
    "/v1/payment_methods/:payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodsPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodsPaymentMethod(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodsPaymentMethodResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodsPaymentMethodAttachParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsPaymentMethodAttachBodySchema = z.never()

  const postPaymentMethodsPaymentMethodAttachResponseValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  router.post(
    "postPaymentMethodsPaymentMethodAttach",
    "/v1/payment_methods/:payment_method/attach",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodsPaymentMethodAttachParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsPaymentMethodAttachBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodsPaymentMethodAttach(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodsPaymentMethodAttachResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodsPaymentMethodDetachParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPaymentMethodsPaymentMethodDetachBodySchema = z.never().optional()

  const postPaymentMethodsPaymentMethodDetachResponseValidator =
    responseValidationFactory([["200", s_payment_method]], s_error)

  router.post(
    "postPaymentMethodsPaymentMethodDetach",
    "/v1/payment_methods/:payment_method/detach",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodsPaymentMethodDetachParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsPaymentMethodDetachBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payment_method>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPaymentMethodsPaymentMethodDetach(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodsPaymentMethodDetachResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getPayoutsQuerySchema = z.object({
    arrival_date: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    destination: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPayoutsBodySchema = z.never().optional()

  const getPayoutsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_payout)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/payouts")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPayouts", "/v1/payouts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPayoutsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPayoutsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_payout[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPayouts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPayoutsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsBodySchema = z.never()

  const postPayoutsResponseValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  router.post("postPayouts", "/v1/payouts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPayoutsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_payout>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postPayouts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPayoutsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPayoutsPayoutParamSchema = z.object({payout: z.string().max(5000)})

  const getPayoutsPayoutQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPayoutsPayoutBodySchema = z.never().optional()

  const getPayoutsPayoutResponseValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  router.get("getPayoutsPayout", "/v1/payouts/:payout", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPayoutsPayoutParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getPayoutsPayoutQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPayoutsPayoutBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_payout>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPayoutsPayout(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPayoutsPayoutResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postPayoutsPayoutParamSchema = z.object({payout: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsPayoutBodySchema = z.never().optional()

  const postPayoutsPayoutResponseValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  router.post("postPayoutsPayout", "/v1/payouts/:payout", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postPayoutsPayoutParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postPayoutsPayoutBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_payout>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postPayoutsPayout(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPayoutsPayoutResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postPayoutsPayoutCancelParamSchema = z.object({
    payout: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsPayoutCancelBodySchema = z.never().optional()

  const postPayoutsPayoutCancelResponseValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  router.post(
    "postPayoutsPayoutCancel",
    "/v1/payouts/:payout/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPayoutsPayoutCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPayoutsPayoutCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payout>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPayoutsPayoutCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPayoutsPayoutCancelResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPayoutsPayoutReverseParamSchema = z.object({
    payout: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPayoutsPayoutReverseBodySchema = z.never().optional()

  const postPayoutsPayoutReverseResponseValidator = responseValidationFactory(
    [["200", s_payout]],
    s_error,
  )

  router.post(
    "postPayoutsPayoutReverse",
    "/v1/payouts/:payout/reverse",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPayoutsPayoutReverseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPayoutsPayoutReverseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_payout>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPayoutsPayoutReverse(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPayoutsPayoutReverseResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPlansQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    product: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPlansBodySchema = z.never().optional()

  const getPlansResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_plan)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/plans")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPlans", "/v1/plans", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPlansQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPlansBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_plan[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPlans(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPlansResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPlansBodySchema = z.never()

  const postPlansResponseValidator = responseValidationFactory(
    [["200", s_plan]],
    s_error,
  )

  router.post("postPlans", "/v1/plans", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPlansBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_plan>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postPlans(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPlansResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deletePlansPlanParamSchema = z.object({plan: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deletePlansPlanBodySchema = z.never().optional()

  const deletePlansPlanResponseValidator = responseValidationFactory(
    [["200", s_deleted_plan]],
    s_error,
  )

  router.delete("deletePlansPlan", "/v1/plans/:plan", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deletePlansPlanParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        deletePlansPlanBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_deleted_plan>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .deletePlansPlan(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deletePlansPlanResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPlansPlanParamSchema = z.object({plan: z.string().max(5000)})

  const getPlansPlanQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPlansPlanBodySchema = z.never().optional()

  const getPlansPlanResponseValidator = responseValidationFactory(
    [["200", s_plan]],
    s_error,
  )

  router.get("getPlansPlan", "/v1/plans/:plan", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPlansPlanParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getPlansPlanQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPlansPlanBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_plan>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPlansPlan(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPlansPlanResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postPlansPlanParamSchema = z.object({plan: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPlansPlanBodySchema = z.never().optional()

  const postPlansPlanResponseValidator = responseValidationFactory(
    [["200", s_plan]],
    s_error,
  )

  router.post("postPlansPlan", "/v1/plans/:plan", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postPlansPlanParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postPlansPlanBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_plan>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postPlansPlan(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPlansPlanResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPricesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_keys: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    product: z.string().max(5000).optional(),
    recurring: z
      .object({
        interval: z.enum(["day", "month", "week", "year"]).optional(),
        meter: z.string().max(5000).optional(),
        usage_type: z.enum(["licensed", "metered"]).optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["one_time", "recurring"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPricesBodySchema = z.never().optional()

  const getPricesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_price)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/prices")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPrices", "/v1/prices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPricesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPricesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_price[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPrices(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPricesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPricesBodySchema = z.never()

  const postPricesResponseValidator = responseValidationFactory(
    [["200", s_price]],
    s_error,
  )

  router.post("postPrices", "/v1/prices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPricesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_price>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postPrices(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPricesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPricesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPricesSearchBodySchema = z.never().optional()

  const getPricesSearchResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_price)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPricesSearch", "/v1/prices/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPricesSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPricesSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_price[]
          has_more: boolean
          next_page?: string | null
          object: "search_result"
          total_count?: number
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPricesSearch(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPricesSearchResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPricesPriceParamSchema = z.object({price: z.string().max(5000)})

  const getPricesPriceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPricesPriceBodySchema = z.never().optional()

  const getPricesPriceResponseValidator = responseValidationFactory(
    [["200", s_price]],
    s_error,
  )

  router.get("getPricesPrice", "/v1/prices/:price", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPricesPriceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getPricesPriceQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPricesPriceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_price>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPricesPrice(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPricesPriceResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postPricesPriceParamSchema = z.object({price: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPricesPriceBodySchema = z.never().optional()

  const postPricesPriceResponseValidator = responseValidationFactory(
    [["200", s_price]],
    s_error,
  )

  router.post("postPricesPrice", "/v1/prices/:price", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postPricesPriceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postPricesPriceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_price>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postPricesPrice(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPricesPriceResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    ids: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    shippable: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
    url: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsBodySchema = z.never().optional()

  const getProductsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_product)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/products")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getProducts", "/v1/products", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getProductsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getProductsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_product[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getProducts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getProductsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postProductsBodySchema = z.never()

  const postProductsResponseValidator = responseValidationFactory(
    [["200", s_product]],
    s_error,
  )

  router.post("postProducts", "/v1/products", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postProductsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_product>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postProducts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postProductsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsSearchBodySchema = z.never().optional()

  const getProductsSearchResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_product)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getProductsSearch", "/v1/products/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getProductsSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getProductsSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_product[]
          has_more: boolean
          next_page?: string | null
          object: "search_result"
          total_count?: number
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getProductsSearch(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getProductsSearchResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteProductsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteProductsIdBodySchema = z.never().optional()

  const deleteProductsIdResponseValidator = responseValidationFactory(
    [["200", s_deleted_product]],
    s_error,
  )

  router.delete("deleteProductsId", "/v1/products/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deleteProductsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        deleteProductsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_deleted_product>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .deleteProductsId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deleteProductsIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsIdParamSchema = z.object({id: z.string().max(5000)})

  const getProductsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsIdBodySchema = z.never().optional()

  const getProductsIdResponseValidator = responseValidationFactory(
    [["200", s_product]],
    s_error,
  )

  router.get("getProductsId", "/v1/products/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getProductsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getProductsIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getProductsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_product>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getProductsId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getProductsIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postProductsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postProductsIdBodySchema = z.never().optional()

  const postProductsIdResponseValidator = responseValidationFactory(
    [["200", s_product]],
    s_error,
  )

  router.post("postProductsId", "/v1/products/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postProductsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postProductsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_product>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postProductsId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postProductsIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsProductFeaturesParamSchema = z.object({
    product: z.string().max(5000),
  })

  const getProductsProductFeaturesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsProductFeaturesBodySchema = z.never().optional()

  const getProductsProductFeaturesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_product_feature),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getProductsProductFeatures",
    "/v1/products/:product/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getProductsProductFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getProductsProductFeaturesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getProductsProductFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_product_feature[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getProductsProductFeatures(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getProductsProductFeaturesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postProductsProductFeaturesParamSchema = z.object({
    product: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postProductsProductFeaturesBodySchema = z.never()

  const postProductsProductFeaturesResponseValidator =
    responseValidationFactory([["200", s_product_feature]], s_error)

  router.post(
    "postProductsProductFeatures",
    "/v1/products/:product/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postProductsProductFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postProductsProductFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_product_feature>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postProductsProductFeatures(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postProductsProductFeaturesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteProductsProductFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
    product: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteProductsProductFeaturesIdBodySchema = z.never().optional()

  const deleteProductsProductFeaturesIdResponseValidator =
    responseValidationFactory([["200", s_deleted_product_feature]], s_error)

  router.delete(
    "deleteProductsProductFeaturesId",
    "/v1/products/:product/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteProductsProductFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteProductsProductFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_product_feature>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteProductsProductFeaturesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteProductsProductFeaturesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getProductsProductFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
    product: z.string().max(5000),
  })

  const getProductsProductFeaturesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getProductsProductFeaturesIdBodySchema = z.never().optional()

  const getProductsProductFeaturesIdResponseValidator =
    responseValidationFactory([["200", s_product_feature]], s_error)

  router.get(
    "getProductsProductFeaturesId",
    "/v1/products/:product/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getProductsProductFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getProductsProductFeaturesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getProductsProductFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_product_feature>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getProductsProductFeaturesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getProductsProductFeaturesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPromotionCodesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    code: z.string().max(5000).optional(),
    coupon: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPromotionCodesBodySchema = z.never().optional()

  const getPromotionCodesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_promotion_code)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/promotion_codes")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getPromotionCodes", "/v1/promotion_codes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPromotionCodesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPromotionCodesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_promotion_code[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPromotionCodes(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPromotionCodesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPromotionCodesBodySchema = z.never()

  const postPromotionCodesResponseValidator = responseValidationFactory(
    [["200", s_promotion_code]],
    s_error,
  )

  router.post(
    "postPromotionCodes",
    "/v1/promotion_codes",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPromotionCodesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_promotion_code>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPromotionCodes(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPromotionCodesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPromotionCodesPromotionCodeParamSchema = z.object({
    promotion_code: z.string().max(5000),
  })

  const getPromotionCodesPromotionCodeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getPromotionCodesPromotionCodeBodySchema = z.never().optional()

  const getPromotionCodesPromotionCodeResponseValidator =
    responseValidationFactory([["200", s_promotion_code]], s_error)

  router.get(
    "getPromotionCodesPromotionCode",
    "/v1/promotion_codes/:promotion_code",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPromotionCodesPromotionCodeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPromotionCodesPromotionCodeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPromotionCodesPromotionCodeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_promotion_code>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getPromotionCodesPromotionCode(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPromotionCodesPromotionCodeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPromotionCodesPromotionCodeParamSchema = z.object({
    promotion_code: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postPromotionCodesPromotionCodeBodySchema = z.never().optional()

  const postPromotionCodesPromotionCodeResponseValidator =
    responseValidationFactory([["200", s_promotion_code]], s_error)

  router.post(
    "postPromotionCodesPromotionCode",
    "/v1/promotion_codes/:promotion_code",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPromotionCodesPromotionCodeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPromotionCodesPromotionCodeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_promotion_code>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postPromotionCodesPromotionCode(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPromotionCodesPromotionCodeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["accepted", "canceled", "draft", "open"]).optional(),
    test_clock: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesBodySchema = z.never().optional()

  const getQuotesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_quote)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/quotes")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getQuotes", "/v1/quotes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getQuotesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getQuotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_quote[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getQuotes(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getQuotesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesBodySchema = z.never().optional()

  const postQuotesResponseValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  router.post("postQuotes", "/v1/quotes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postQuotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_quote>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postQuotes(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postQuotesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getQuotesQuoteParamSchema = z.object({quote: z.string().max(5000)})

  const getQuotesQuoteQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuoteBodySchema = z.never().optional()

  const getQuotesQuoteResponseValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  router.get("getQuotesQuote", "/v1/quotes/:quote", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getQuotesQuoteParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getQuotesQuoteQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getQuotesQuoteBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_quote>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getQuotesQuote(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getQuotesQuoteResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postQuotesQuoteParamSchema = z.object({quote: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteBodySchema = z.never().optional()

  const postQuotesQuoteResponseValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  router.post("postQuotesQuote", "/v1/quotes/:quote", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postQuotesQuoteParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postQuotesQuoteBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_quote>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postQuotesQuote(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postQuotesQuoteResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postQuotesQuoteAcceptParamSchema = z.object({
    quote: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteAcceptBodySchema = z.never().optional()

  const postQuotesQuoteAcceptResponseValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  router.post(
    "postQuotesQuoteAccept",
    "/v1/quotes/:quote/accept",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postQuotesQuoteAcceptParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postQuotesQuoteAcceptBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_quote>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postQuotesQuoteAccept(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postQuotesQuoteAcceptResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postQuotesQuoteCancelParamSchema = z.object({
    quote: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteCancelBodySchema = z.never().optional()

  const postQuotesQuoteCancelResponseValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  router.post(
    "postQuotesQuoteCancel",
    "/v1/quotes/:quote/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postQuotesQuoteCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postQuotesQuoteCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_quote>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postQuotesQuoteCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postQuotesQuoteCancelResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuoteComputedUpfrontLineItemsParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const getQuotesQuoteComputedUpfrontLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuoteComputedUpfrontLineItemsBodySchema = z.never().optional()

  const getQuotesQuoteComputedUpfrontLineItemsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_item)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getQuotesQuoteComputedUpfrontLineItems",
    "/v1/quotes/:quote/computed_upfront_line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getQuotesQuoteComputedUpfrontLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getQuotesQuoteComputedUpfrontLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getQuotesQuoteComputedUpfrontLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getQuotesQuoteComputedUpfrontLineItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getQuotesQuoteComputedUpfrontLineItemsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postQuotesQuoteFinalizeParamSchema = z.object({
    quote: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postQuotesQuoteFinalizeBodySchema = z.never().optional()

  const postQuotesQuoteFinalizeResponseValidator = responseValidationFactory(
    [["200", s_quote]],
    s_error,
  )

  router.post(
    "postQuotesQuoteFinalize",
    "/v1/quotes/:quote/finalize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postQuotesQuoteFinalizeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postQuotesQuoteFinalizeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_quote>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postQuotesQuoteFinalize(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postQuotesQuoteFinalizeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuoteLineItemsParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const getQuotesQuoteLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuoteLineItemsBodySchema = z.never().optional()

  const getQuotesQuoteLineItemsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_item)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getQuotesQuoteLineItems",
    "/v1/quotes/:quote/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getQuotesQuoteLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getQuotesQuoteLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getQuotesQuoteLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getQuotesQuoteLineItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getQuotesQuoteLineItemsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuotePdfParamSchema = z.object({quote: z.string().max(5000)})

  const getQuotesQuotePdfQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getQuotesQuotePdfBodySchema = z.never().optional()

  const getQuotesQuotePdfResponseValidator = responseValidationFactory(
    [["200", z.string()]],
    s_error,
  )

  router.get(
    "getQuotesQuotePdf",
    "/v1/quotes/:quote/pdf",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getQuotesQuotePdfParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getQuotesQuotePdfQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getQuotesQuotePdfBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<string>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getQuotesQuotePdf(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getQuotesQuotePdfResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarEarlyFraudWarningsQuerySchema = z.object({
    charge: z.string().optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarEarlyFraudWarningsBodySchema = z.never().optional()

  const getRadarEarlyFraudWarningsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_radar_early_fraud_warning)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/radar/early_fraud_warnings")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getRadarEarlyFraudWarnings",
    "/v1/radar/early_fraud_warnings",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getRadarEarlyFraudWarningsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarEarlyFraudWarningsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_radar_early_fraud_warning[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getRadarEarlyFraudWarnings(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarEarlyFraudWarningsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarEarlyFraudWarningsEarlyFraudWarningParamSchema = z.object({
    early_fraud_warning: z.string().max(5000),
  })

  const getRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarEarlyFraudWarningsEarlyFraudWarningBodySchema = z
    .never()
    .optional()

  const getRadarEarlyFraudWarningsEarlyFraudWarningResponseValidator =
    responseValidationFactory([["200", s_radar_early_fraud_warning]], s_error)

  router.get(
    "getRadarEarlyFraudWarningsEarlyFraudWarning",
    "/v1/radar/early_fraud_warnings/:early_fraud_warning",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarEarlyFraudWarningsEarlyFraudWarningBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_radar_early_fraud_warning>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getRadarEarlyFraudWarningsEarlyFraudWarning(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarEarlyFraudWarningsEarlyFraudWarningResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListItemsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    value: z.string().max(800).optional(),
    value_list: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListItemsBodySchema = z.never().optional()

  const getRadarValueListItemsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_radar_value_list_item),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/radar/value_list_items")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getRadarValueListItems",
    "/v1/radar/value_list_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getRadarValueListItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_radar_value_list_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getRadarValueListItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueListItemsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRadarValueListItemsBodySchema = z.never()

  const postRadarValueListItemsResponseValidator = responseValidationFactory(
    [["200", s_radar_value_list_item]],
    s_error,
  )

  router.post(
    "postRadarValueListItems",
    "/v1/radar/value_list_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postRadarValueListItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_radar_value_list_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postRadarValueListItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRadarValueListItemsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteRadarValueListItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteRadarValueListItemsItemBodySchema = z.never().optional()

  const deleteRadarValueListItemsItemResponseValidator =
    responseValidationFactory(
      [["200", s_deleted_radar_value_list_item]],
      s_error,
    )

  router.delete(
    "deleteRadarValueListItemsItem",
    "/v1/radar/value_list_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteRadarValueListItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteRadarValueListItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_radar_value_list_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteRadarValueListItemsItem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteRadarValueListItemsItemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const getRadarValueListItemsItemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListItemsItemBodySchema = z.never().optional()

  const getRadarValueListItemsItemResponseValidator = responseValidationFactory(
    [["200", s_radar_value_list_item]],
    s_error,
  )

  router.get(
    "getRadarValueListItemsItem",
    "/v1/radar/value_list_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getRadarValueListItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getRadarValueListItemsItemQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_radar_value_list_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getRadarValueListItemsItem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueListItemsItemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListsQuerySchema = z.object({
    alias: z.string().max(100).optional(),
    contains: z.string().max(800).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListsBodySchema = z.never().optional()

  const getRadarValueListsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_radar_value_list),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/radar/value_lists")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getRadarValueLists",
    "/v1/radar/value_lists",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getRadarValueListsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_radar_value_list[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getRadarValueLists(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueListsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRadarValueListsBodySchema = z.never()

  const postRadarValueListsResponseValidator = responseValidationFactory(
    [["200", s_radar_value_list]],
    s_error,
  )

  router.post(
    "postRadarValueLists",
    "/v1/radar/value_lists",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postRadarValueListsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_radar_value_list>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postRadarValueLists(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRadarValueListsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteRadarValueListsValueListBodySchema = z.never().optional()

  const deleteRadarValueListsValueListResponseValidator =
    responseValidationFactory([["200", s_deleted_radar_value_list]], s_error)

  router.delete(
    "deleteRadarValueListsValueList",
    "/v1/radar/value_lists/:value_list",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteRadarValueListsValueListParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteRadarValueListsValueListBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_radar_value_list>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteRadarValueListsValueList(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteRadarValueListsValueListResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  const getRadarValueListsValueListQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRadarValueListsValueListBodySchema = z.never().optional()

  const getRadarValueListsValueListResponseValidator =
    responseValidationFactory([["200", s_radar_value_list]], s_error)

  router.get(
    "getRadarValueListsValueList",
    "/v1/radar/value_lists/:value_list",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getRadarValueListsValueListParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getRadarValueListsValueListQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListsValueListBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_radar_value_list>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getRadarValueListsValueList(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueListsValueListResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRadarValueListsValueListBodySchema = z.never().optional()

  const postRadarValueListsValueListResponseValidator =
    responseValidationFactory([["200", s_radar_value_list]], s_error)

  router.post(
    "postRadarValueListsValueList",
    "/v1/radar/value_lists/:value_list",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postRadarValueListsValueListParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postRadarValueListsValueListBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_radar_value_list>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postRadarValueListsValueList(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRadarValueListsValueListResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRefundsQuerySchema = z.object({
    charge: z.string().optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRefundsBodySchema = z.never().optional()

  const getRefundsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_refund)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/refunds")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getRefunds", "/v1/refunds", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getRefundsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getRefundsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_refund[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getRefunds(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getRefundsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRefundsBodySchema = z.never().optional()

  const postRefundsResponseValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  router.post("postRefunds", "/v1/refunds", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postRefundsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_refund>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postRefunds(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postRefundsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getRefundsRefundParamSchema = z.object({refund: z.string()})

  const getRefundsRefundQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getRefundsRefundBodySchema = z.never().optional()

  const getRefundsRefundResponseValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  router.get("getRefundsRefund", "/v1/refunds/:refund", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getRefundsRefundParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getRefundsRefundQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getRefundsRefundBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_refund>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getRefundsRefund(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getRefundsRefundResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postRefundsRefundParamSchema = z.object({refund: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRefundsRefundBodySchema = z.never().optional()

  const postRefundsRefundResponseValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  router.post("postRefundsRefund", "/v1/refunds/:refund", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postRefundsRefundParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postRefundsRefundBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_refund>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postRefundsRefund(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postRefundsRefundResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postRefundsRefundCancelParamSchema = z.object({refund: z.string()})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postRefundsRefundCancelBodySchema = z.never().optional()

  const postRefundsRefundCancelResponseValidator = responseValidationFactory(
    [["200", s_refund]],
    s_error,
  )

  router.post(
    "postRefundsRefundCancel",
    "/v1/refunds/:refund/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postRefundsRefundCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postRefundsRefundCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postRefundsRefundCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRefundsRefundCancelResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportRunsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportRunsBodySchema = z.never().optional()

  const getReportingReportRunsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_reporting_report_run)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/reporting/report_runs")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getReportingReportRuns",
    "/v1/reporting/report_runs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getReportingReportRunsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportRunsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_reporting_report_run[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getReportingReportRuns(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportRunsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postReportingReportRunsBodySchema = z.never()

  const postReportingReportRunsResponseValidator = responseValidationFactory(
    [["200", s_reporting_report_run]],
    s_error,
  )

  router.post(
    "postReportingReportRuns",
    "/v1/reporting/report_runs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postReportingReportRunsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_reporting_report_run>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postReportingReportRuns(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postReportingReportRunsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportRunsReportRunParamSchema = z.object({
    report_run: z.string().max(5000),
  })

  const getReportingReportRunsReportRunQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportRunsReportRunBodySchema = z.never().optional()

  const getReportingReportRunsReportRunResponseValidator =
    responseValidationFactory([["200", s_reporting_report_run]], s_error)

  router.get(
    "getReportingReportRunsReportRun",
    "/v1/reporting/report_runs/:report_run",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getReportingReportRunsReportRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getReportingReportRunsReportRunQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportRunsReportRunBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_reporting_report_run>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getReportingReportRunsReportRun(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportRunsReportRunResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportTypesQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportTypesBodySchema = z.never().optional()

  const getReportingReportTypesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_reporting_report_type),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getReportingReportTypes",
    "/v1/reporting/report_types",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getReportingReportTypesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportTypesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_reporting_report_type[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getReportingReportTypes(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportTypesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportTypesReportTypeParamSchema = z.object({
    report_type: z.string(),
  })

  const getReportingReportTypesReportTypeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReportingReportTypesReportTypeBodySchema = z.never().optional()

  const getReportingReportTypesReportTypeResponseValidator =
    responseValidationFactory([["200", s_reporting_report_type]], s_error)

  router.get(
    "getReportingReportTypesReportType",
    "/v1/reporting/report_types/:report_type",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getReportingReportTypesReportTypeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getReportingReportTypesReportTypeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportTypesReportTypeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_reporting_report_type>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getReportingReportTypesReportType(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportTypesReportTypeResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getReviewsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReviewsBodySchema = z.never().optional()

  const getReviewsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_review)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getReviews", "/v1/reviews", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getReviewsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getReviewsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_review[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getReviews(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getReviewsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getReviewsReviewParamSchema = z.object({review: z.string().max(5000)})

  const getReviewsReviewQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getReviewsReviewBodySchema = z.never().optional()

  const getReviewsReviewResponseValidator = responseValidationFactory(
    [["200", s_review]],
    s_error,
  )

  router.get("getReviewsReview", "/v1/reviews/:review", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getReviewsReviewParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getReviewsReviewQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getReviewsReviewBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_review>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getReviewsReview(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getReviewsReviewResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postReviewsReviewApproveParamSchema = z.object({
    review: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postReviewsReviewApproveBodySchema = z.never().optional()

  const postReviewsReviewApproveResponseValidator = responseValidationFactory(
    [["200", s_review]],
    s_error,
  )

  router.post(
    "postReviewsReviewApprove",
    "/v1/reviews/:review/approve",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postReviewsReviewApproveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postReviewsReviewApproveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_review>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postReviewsReviewApprove(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postReviewsReviewApproveResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSetupAttemptsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    setup_intent: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSetupAttemptsBodySchema = z.never().optional()

  const getSetupAttemptsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_setup_attempt)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/setup_attempts")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getSetupAttempts", "/v1/setup_attempts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getSetupAttemptsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSetupAttemptsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_setup_attempt[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getSetupAttempts(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSetupAttemptsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getSetupIntentsQuerySchema = z.object({
    attach_to_self: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_method: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSetupIntentsBodySchema = z.never().optional()

  const getSetupIntentsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_setup_intent)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/setup_intents")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getSetupIntents", "/v1/setup_intents", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getSetupIntentsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSetupIntentsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_setup_intent[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getSetupIntents(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSetupIntentsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsBodySchema = z.never().optional()

  const postSetupIntentsResponseValidator = responseValidationFactory(
    [["200", s_setup_intent]],
    s_error,
  )

  router.post("postSetupIntents", "/v1/setup_intents", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postSetupIntentsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_setup_intent>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postSetupIntents(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSetupIntentsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getSetupIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const getSetupIntentsIntentQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSetupIntentsIntentBodySchema = z.never().optional()

  const getSetupIntentsIntentResponseValidator = responseValidationFactory(
    [["200", s_setup_intent]],
    s_error,
  )

  router.get(
    "getSetupIntentsIntent",
    "/v1/setup_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSetupIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSetupIntentsIntentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSetupIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_setup_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSetupIntentsIntent(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSetupIntentsIntentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentBodySchema = z.never().optional()

  const postSetupIntentsIntentResponseValidator = responseValidationFactory(
    [["200", s_setup_intent]],
    s_error,
  )

  router.post(
    "postSetupIntentsIntent",
    "/v1/setup_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_setup_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSetupIntentsIntent(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentCancelParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentCancelBodySchema = z.never().optional()

  const postSetupIntentsIntentCancelResponseValidator =
    responseValidationFactory([["200", s_setup_intent]], s_error)

  router.post(
    "postSetupIntentsIntentCancel",
    "/v1/setup_intents/:intent/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_setup_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSetupIntentsIntentCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntentCancelResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentConfirmParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentConfirmBodySchema = z.never().optional()

  const postSetupIntentsIntentConfirmResponseValidator =
    responseValidationFactory([["200", s_setup_intent]], s_error)

  router.post(
    "postSetupIntentsIntentConfirm",
    "/v1/setup_intents/:intent/confirm",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentConfirmParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentConfirmBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_setup_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSetupIntentsIntentConfirm(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntentConfirmResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentVerifyMicrodepositsParamSchema = z.object({
    intent: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSetupIntentsIntentVerifyMicrodepositsBodySchema = z
    .never()
    .optional()

  const postSetupIntentsIntentVerifyMicrodepositsResponseValidator =
    responseValidationFactory([["200", s_setup_intent]], s_error)

  router.post(
    "postSetupIntentsIntentVerifyMicrodeposits",
    "/v1/setup_intents/:intent/verify_microdeposits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentVerifyMicrodepositsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentVerifyMicrodepositsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_setup_intent>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSetupIntentsIntentVerifyMicrodeposits(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntentVerifyMicrodepositsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getShippingRatesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getShippingRatesBodySchema = z.never().optional()

  const getShippingRatesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_shipping_rate),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/shipping_rates")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getShippingRates", "/v1/shipping_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getShippingRatesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getShippingRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_shipping_rate[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getShippingRates(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getShippingRatesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postShippingRatesBodySchema = z.never()

  const postShippingRatesResponseValidator = responseValidationFactory(
    [["200", s_shipping_rate]],
    s_error,
  )

  router.post("postShippingRates", "/v1/shipping_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postShippingRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_shipping_rate>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postShippingRates(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postShippingRatesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getShippingRatesShippingRateTokenParamSchema = z.object({
    shipping_rate_token: z.string().max(5000),
  })

  const getShippingRatesShippingRateTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getShippingRatesShippingRateTokenBodySchema = z.never().optional()

  const getShippingRatesShippingRateTokenResponseValidator =
    responseValidationFactory([["200", s_shipping_rate]], s_error)

  router.get(
    "getShippingRatesShippingRateToken",
    "/v1/shipping_rates/:shipping_rate_token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getShippingRatesShippingRateTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getShippingRatesShippingRateTokenQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getShippingRatesShippingRateTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_shipping_rate>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getShippingRatesShippingRateToken(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getShippingRatesShippingRateTokenResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postShippingRatesShippingRateTokenParamSchema = z.object({
    shipping_rate_token: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postShippingRatesShippingRateTokenBodySchema = z.never().optional()

  const postShippingRatesShippingRateTokenResponseValidator =
    responseValidationFactory([["200", s_shipping_rate]], s_error)

  router.post(
    "postShippingRatesShippingRateToken",
    "/v1/shipping_rates/:shipping_rate_token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postShippingRatesShippingRateTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postShippingRatesShippingRateTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_shipping_rate>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postShippingRatesShippingRateToken(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postShippingRatesShippingRateTokenResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSigmaSavedQueriesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSigmaSavedQueriesIdBodySchema = z.never().optional()

  const postSigmaSavedQueriesIdResponseValidator = responseValidationFactory(
    [["200", s_sigma_sigma_api_query]],
    s_error,
  )

  router.post(
    "postSigmaSavedQueriesId",
    "/v1/sigma/saved_queries/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSigmaSavedQueriesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSigmaSavedQueriesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_sigma_sigma_api_query>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSigmaSavedQueriesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSigmaSavedQueriesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSigmaScheduledQueryRunsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSigmaScheduledQueryRunsBodySchema = z.never().optional()

  const getSigmaScheduledQueryRunsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_scheduled_query_run)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/sigma/scheduled_query_runs")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getSigmaScheduledQueryRuns",
    "/v1/sigma/scheduled_query_runs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSigmaScheduledQueryRunsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSigmaScheduledQueryRunsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_scheduled_query_run[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSigmaScheduledQueryRuns(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSigmaScheduledQueryRunsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSigmaScheduledQueryRunsScheduledQueryRunParamSchema = z.object({
    scheduled_query_run: z.string().max(5000),
  })

  const getSigmaScheduledQueryRunsScheduledQueryRunQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSigmaScheduledQueryRunsScheduledQueryRunBodySchema = z
    .never()
    .optional()

  const getSigmaScheduledQueryRunsScheduledQueryRunResponseValidator =
    responseValidationFactory([["200", s_scheduled_query_run]], s_error)

  router.get(
    "getSigmaScheduledQueryRunsScheduledQueryRun",
    "/v1/sigma/scheduled_query_runs/:scheduled_query_run",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSigmaScheduledQueryRunsScheduledQueryRunBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_scheduled_query_run>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSigmaScheduledQueryRunsScheduledQueryRun(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSigmaScheduledQueryRunsScheduledQueryRunResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSourcesBodySchema = z.never().optional()

  const postSourcesResponseValidator = responseValidationFactory(
    [["200", s_source]],
    s_error,
  )

  router.post("postSources", "/v1/sources", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postSourcesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_source>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postSources(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSourcesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getSourcesSourceParamSchema = z.object({source: z.string().max(5000)})

  const getSourcesSourceQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceBodySchema = z.never().optional()

  const getSourcesSourceResponseValidator = responseValidationFactory(
    [["200", s_source]],
    s_error,
  )

  router.get("getSourcesSource", "/v1/sources/:source", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getSourcesSourceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getSourcesSourceQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSourcesSourceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_source>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getSourcesSource(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSourcesSourceResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postSourcesSourceParamSchema = z.object({source: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSourcesSourceBodySchema = z.never().optional()

  const postSourcesSourceResponseValidator = responseValidationFactory(
    [["200", s_source]],
    s_error,
  )

  router.post("postSourcesSource", "/v1/sources/:source", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postSourcesSourceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postSourcesSourceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_source>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postSourcesSource(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSourcesSourceResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getSourcesSourceMandateNotificationsMandateNotificationParamSchema =
    z.object({
      mandate_notification: z.string().max(5000),
      source: z.string().max(5000),
    })

  const getSourcesSourceMandateNotificationsMandateNotificationQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceMandateNotificationsMandateNotificationBodySchema = z
    .never()
    .optional()

  const getSourcesSourceMandateNotificationsMandateNotificationResponseValidator =
    responseValidationFactory([["200", s_source_mandate_notification]], s_error)

  router.get(
    "getSourcesSourceMandateNotificationsMandateNotification",
    "/v1/sources/:source/mandate_notifications/:mandate_notification",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSourcesSourceMandateNotificationsMandateNotificationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSourcesSourceMandateNotificationsMandateNotificationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_source_mandate_notification>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSourcesSourceMandateNotificationsMandateNotification(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getSourcesSourceMandateNotificationsMandateNotificationResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getSourcesSourceSourceTransactionsParamSchema = z.object({
    source: z.string().max(5000),
  })

  const getSourcesSourceSourceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceSourceTransactionsBodySchema = z.never().optional()

  const getSourcesSourceSourceTransactionsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_source_transaction),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getSourcesSourceSourceTransactions",
    "/v1/sources/:source/source_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSourcesSourceSourceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSourcesSourceSourceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSourcesSourceSourceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_source_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSourcesSourceSourceTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSourcesSourceSourceTransactionsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getSourcesSourceSourceTransactionsSourceTransactionParamSchema =
    z.object({
      source: z.string().max(5000),
      source_transaction: z.string().max(5000),
    })

  const getSourcesSourceSourceTransactionsSourceTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSourcesSourceSourceTransactionsSourceTransactionBodySchema = z
    .never()
    .optional()

  const getSourcesSourceSourceTransactionsSourceTransactionResponseValidator =
    responseValidationFactory([["200", s_source_transaction]], s_error)

  router.get(
    "getSourcesSourceSourceTransactionsSourceTransaction",
    "/v1/sources/:source/source_transactions/:source_transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSourcesSourceSourceTransactionsSourceTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSourcesSourceSourceTransactionsSourceTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_source_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSourcesSourceSourceTransactionsSourceTransaction(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getSourcesSourceSourceTransactionsSourceTransactionResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postSourcesSourceVerifyParamSchema = z.object({
    source: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSourcesSourceVerifyBodySchema = z.never()

  const postSourcesSourceVerifyResponseValidator = responseValidationFactory(
    [["200", s_source]],
    s_error,
  )

  router.post(
    "postSourcesSourceVerify",
    "/v1/sources/:source/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSourcesSourceVerifyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSourcesSourceVerifyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_source>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSourcesSourceVerify(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSourcesSourceVerifyResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionItemsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
    subscription: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionItemsBodySchema = z.never().optional()

  const getSubscriptionItemsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_subscription_item)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/subscription_items")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getSubscriptionItems",
    "/v1/subscription_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSubscriptionItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_subscription_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSubscriptionItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionItemsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionItemsBodySchema = z.never()

  const postSubscriptionItemsResponseValidator = responseValidationFactory(
    [["200", s_subscription_item]],
    s_error,
  )

  router.post(
    "postSubscriptionItems",
    "/v1/subscription_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postSubscriptionItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionItemsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteSubscriptionItemsItemBodySchema = z.never().optional()

  const deleteSubscriptionItemsItemResponseValidator =
    responseValidationFactory([["200", s_deleted_subscription_item]], s_error)

  router.delete(
    "deleteSubscriptionItemsItem",
    "/v1/subscription_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteSubscriptionItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteSubscriptionItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_subscription_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteSubscriptionItemsItem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteSubscriptionItemsItemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const getSubscriptionItemsItemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionItemsItemBodySchema = z.never().optional()

  const getSubscriptionItemsItemResponseValidator = responseValidationFactory(
    [["200", s_subscription_item]],
    s_error,
  )

  router.get(
    "getSubscriptionItemsItem",
    "/v1/subscription_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSubscriptionItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSubscriptionItemsItemQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSubscriptionItemsItem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionItemsItemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionItemsItemBodySchema = z.never().optional()

  const postSubscriptionItemsItemResponseValidator = responseValidationFactory(
    [["200", s_subscription_item]],
    s_error,
  )

  router.post(
    "postSubscriptionItemsItem",
    "/v1/subscription_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_item>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionItemsItem(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionItemsItemResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionSchedulesQuerySchema = z.object({
    canceled_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    completed_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    released_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    scheduled: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionSchedulesBodySchema = z.never().optional()

  const getSubscriptionSchedulesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_subscription_schedule)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/subscription_schedules")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getSubscriptionSchedules",
    "/v1/subscription_schedules",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSubscriptionSchedulesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionSchedulesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_subscription_schedule[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSubscriptionSchedules(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionSchedulesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesBodySchema = z.never().optional()

  const postSubscriptionSchedulesResponseValidator = responseValidationFactory(
    [["200", s_subscription_schedule]],
    s_error,
  )

  router.post(
    "postSubscriptionSchedules",
    "/v1/subscription_schedules",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_schedule>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionSchedules(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedulesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionSchedulesScheduleParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  const getSubscriptionSchedulesScheduleQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionSchedulesScheduleBodySchema = z.never().optional()

  const getSubscriptionSchedulesScheduleResponseValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  router.get(
    "getSubscriptionSchedulesSchedule",
    "/v1/subscription_schedules/:schedule",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSubscriptionSchedulesScheduleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSubscriptionSchedulesScheduleQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionSchedulesScheduleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_schedule>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSubscriptionSchedulesSchedule(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionSchedulesScheduleResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionSchedulesScheduleParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesScheduleBodySchema = z.never().optional()

  const postSubscriptionSchedulesScheduleResponseValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  router.post(
    "postSubscriptionSchedulesSchedule",
    "/v1/subscription_schedules/:schedule",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionSchedulesScheduleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesScheduleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_schedule>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionSchedulesSchedule(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedulesScheduleResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionSchedulesScheduleCancelParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesScheduleCancelBodySchema = z.never().optional()

  const postSubscriptionSchedulesScheduleCancelResponseValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  router.post(
    "postSubscriptionSchedulesScheduleCancel",
    "/v1/subscription_schedules/:schedule/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionSchedulesScheduleCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesScheduleCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_schedule>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionSchedulesScheduleCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedulesScheduleCancelResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionSchedulesScheduleReleaseParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionSchedulesScheduleReleaseBodySchema = z
    .never()
    .optional()

  const postSubscriptionSchedulesScheduleReleaseResponseValidator =
    responseValidationFactory([["200", s_subscription_schedule]], s_error)

  router.post(
    "postSubscriptionSchedulesScheduleRelease",
    "/v1/subscription_schedules/:schedule/release",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionSchedulesScheduleReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesScheduleReleaseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription_schedule>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionSchedulesScheduleRelease(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedulesScheduleReleaseResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionsQuerySchema = z.object({
    automatic_tax: z.object({enabled: PermissiveBoolean}).optional(),
    collection_method: z
      .enum(["charge_automatically", "send_invoice"])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    current_period_end: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    current_period_start: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    price: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum([
        "active",
        "all",
        "canceled",
        "ended",
        "incomplete",
        "incomplete_expired",
        "past_due",
        "paused",
        "trialing",
        "unpaid",
      ])
      .optional(),
    test_clock: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionsBodySchema = z.never().optional()

  const getSubscriptionsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_subscription)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/subscriptions")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getSubscriptions", "/v1/subscriptions", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getSubscriptionsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSubscriptionsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_subscription[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getSubscriptions(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSubscriptionsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsBodySchema = z.never()

  const postSubscriptionsResponseValidator = responseValidationFactory(
    [["200", s_subscription]],
    s_error,
  )

  router.post("postSubscriptions", "/v1/subscriptions", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postSubscriptionsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_subscription>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postSubscriptions(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSubscriptionsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getSubscriptionsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionsSearchBodySchema = z.never().optional()

  const getSubscriptionsSearchResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_subscription)),
          has_more: PermissiveBoolean,
          next_page: z.string().max(5000).nullable().optional(),
          object: z.enum(["search_result"]),
          total_count: z.coerce.number().optional(),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getSubscriptionsSearch",
    "/v1/subscriptions/search",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSubscriptionsSearchQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionsSearchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_subscription[]
            has_more: boolean
            next_page?: string | null
            object: "search_result"
            total_count?: number
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSubscriptionsSearch(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionsSearchResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteSubscriptionsSubscriptionExposedIdBodySchema = z
    .never()
    .optional()

  const deleteSubscriptionsSubscriptionExposedIdResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.delete(
    "deleteSubscriptionsSubscriptionExposedId",
    "/v1/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteSubscriptionsSubscriptionExposedId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteSubscriptionsSubscriptionExposedIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  const getSubscriptionsSubscriptionExposedIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getSubscriptionsSubscriptionExposedIdBodySchema = z.never().optional()

  const getSubscriptionsSubscriptionExposedIdResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.get(
    "getSubscriptionsSubscriptionExposedId",
    "/v1/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSubscriptionsSubscriptionExposedIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getSubscriptionsSubscriptionExposedId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionsSubscriptionExposedIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsSubscriptionExposedIdBodySchema = z.never().optional()

  const postSubscriptionsSubscriptionExposedIdResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.post(
    "postSubscriptionsSubscriptionExposedId",
    "/v1/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionsSubscriptionExposedId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionsSubscriptionExposedIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const deleteSubscriptionsSubscriptionExposedIdDiscountParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteSubscriptionsSubscriptionExposedIdDiscountBodySchema = z
    .never()
    .optional()

  const deleteSubscriptionsSubscriptionExposedIdDiscountResponseValidator =
    responseValidationFactory([["200", s_deleted_discount]], s_error)

  router.delete(
    "deleteSubscriptionsSubscriptionExposedIdDiscount",
    "/v1/subscriptions/:subscription_exposed_id/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_discount>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteSubscriptionsSubscriptionExposedIdDiscount(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        deleteSubscriptionsSubscriptionExposedIdDiscountResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionsSubscriptionMigrateParamSchema = z.object({
    subscription: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsSubscriptionMigrateBodySchema = z.never()

  const postSubscriptionsSubscriptionMigrateResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.post(
    "postSubscriptionsSubscriptionMigrate",
    "/v1/subscriptions/:subscription/migrate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionsSubscriptionMigrateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionsSubscriptionMigrateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionsSubscriptionMigrate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionsSubscriptionMigrateResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionsSubscriptionResumeParamSchema = z.object({
    subscription: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postSubscriptionsSubscriptionResumeBodySchema = z.never().optional()

  const postSubscriptionsSubscriptionResumeResponseValidator =
    responseValidationFactory([["200", s_subscription]], s_error)

  router.post(
    "postSubscriptionsSubscriptionResume",
    "/v1/subscriptions/:subscription/resume",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionsSubscriptionResumeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionsSubscriptionResumeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_subscription>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postSubscriptionsSubscriptionResume(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionsSubscriptionResumeResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxCalculationsBodySchema = z.never()

  const postTaxCalculationsResponseValidator = responseValidationFactory(
    [["200", s_tax_calculation]],
    s_error,
  )

  router.post(
    "postTaxCalculations",
    "/v1/tax/calculations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxCalculationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_calculation>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTaxCalculations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxCalculationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxCalculationsCalculationParamSchema = z.object({
    calculation: z.string().max(5000),
  })

  const getTaxCalculationsCalculationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCalculationsCalculationBodySchema = z.never().optional()

  const getTaxCalculationsCalculationResponseValidator =
    responseValidationFactory([["200", s_tax_calculation]], s_error)

  router.get(
    "getTaxCalculationsCalculation",
    "/v1/tax/calculations/:calculation",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxCalculationsCalculationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxCalculationsCalculationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxCalculationsCalculationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_calculation>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTaxCalculationsCalculation(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxCalculationsCalculationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxCalculationsCalculationLineItemsParamSchema = z.object({
    calculation: z.string().max(5000),
  })

  const getTaxCalculationsCalculationLineItemsQuerySchema = z.object({
    ending_before: z.string().max(500).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(500).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCalculationsCalculationLineItemsBodySchema = z.never().optional()

  const getTaxCalculationsCalculationLineItemsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_tax_calculation_line_item),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/tax/calculations/[^/]+/line_items")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getTaxCalculationsCalculationLineItems",
    "/v1/tax/calculations/:calculation/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxCalculationsCalculationLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxCalculationsCalculationLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxCalculationsCalculationLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_tax_calculation_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTaxCalculationsCalculationLineItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxCalculationsCalculationLineItemsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTaxRegistrationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "all", "expired", "scheduled"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRegistrationsBodySchema = z.never().optional()

  const getTaxRegistrationsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_tax_registration),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/tax/registrations")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTaxRegistrations",
    "/v1/tax/registrations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTaxRegistrationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxRegistrationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_tax_registration[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTaxRegistrations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxRegistrationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRegistrationsBodySchema = z.never()

  const postTaxRegistrationsResponseValidator = responseValidationFactory(
    [["200", s_tax_registration]],
    s_error,
  )

  router.post(
    "postTaxRegistrations",
    "/v1/tax/registrations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxRegistrationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_registration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTaxRegistrations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxRegistrationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxRegistrationsIdParamSchema = z.object({id: z.string().max(5000)})

  const getTaxRegistrationsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRegistrationsIdBodySchema = z.never().optional()

  const getTaxRegistrationsIdResponseValidator = responseValidationFactory(
    [["200", s_tax_registration]],
    s_error,
  )

  router.get(
    "getTaxRegistrationsId",
    "/v1/tax/registrations/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxRegistrationsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxRegistrationsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxRegistrationsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_registration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTaxRegistrationsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxRegistrationsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTaxRegistrationsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRegistrationsIdBodySchema = z.never().optional()

  const postTaxRegistrationsIdResponseValidator = responseValidationFactory(
    [["200", s_tax_registration]],
    s_error,
  )

  router.post(
    "postTaxRegistrationsId",
    "/v1/tax/registrations/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTaxRegistrationsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTaxRegistrationsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_registration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTaxRegistrationsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxRegistrationsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxSettingsQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxSettingsBodySchema = z.never().optional()

  const getTaxSettingsResponseValidator = responseValidationFactory(
    [["200", s_tax_settings]],
    s_error,
  )

  router.get("getTaxSettings", "/v1/tax/settings", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxSettingsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxSettingsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_tax_settings>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTaxSettings(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxSettingsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxSettingsBodySchema = z.never().optional()

  const postTaxSettingsResponseValidator = responseValidationFactory(
    [["200", s_tax_settings]],
    s_error,
  )

  router.post("postTaxSettings", "/v1/tax/settings", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTaxSettingsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_tax_settings>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postTaxSettings(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTaxSettingsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxTransactionsCreateFromCalculationBodySchema = z.never()

  const postTaxTransactionsCreateFromCalculationResponseValidator =
    responseValidationFactory([["200", s_tax_transaction]], s_error)

  router.post(
    "postTaxTransactionsCreateFromCalculation",
    "/v1/tax/transactions/create_from_calculation",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxTransactionsCreateFromCalculationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTaxTransactionsCreateFromCalculation(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxTransactionsCreateFromCalculationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxTransactionsCreateReversalBodySchema = z.never()

  const postTaxTransactionsCreateReversalResponseValidator =
    responseValidationFactory([["200", s_tax_transaction]], s_error)

  router.post(
    "postTaxTransactionsCreateReversal",
    "/v1/tax/transactions/create_reversal",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxTransactionsCreateReversalBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTaxTransactionsCreateReversal(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxTransactionsCreateReversalResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTaxTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getTaxTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxTransactionsTransactionBodySchema = z.never().optional()

  const getTaxTransactionsTransactionResponseValidator =
    responseValidationFactory([["200", s_tax_transaction]], s_error)

  router.get(
    "getTaxTransactionsTransaction",
    "/v1/tax/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTaxTransactionsTransaction(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxTransactionsTransactionResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxTransactionsTransactionLineItemsParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getTaxTransactionsTransactionLineItemsQuerySchema = z.object({
    ending_before: z.string().max(500).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(500).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxTransactionsTransactionLineItemsBodySchema = z.never().optional()

  const getTaxTransactionsTransactionLineItemsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_tax_transaction_line_item),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/tax/transactions/[^/]+/line_items")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getTaxTransactionsTransactionLineItems",
    "/v1/tax/transactions/:transaction/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxTransactionsTransactionLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxTransactionsTransactionLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxTransactionsTransactionLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_tax_transaction_line_item[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTaxTransactionsTransactionLineItems(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxTransactionsTransactionLineItemsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTaxCodesQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCodesBodySchema = z.never().optional()

  const getTaxCodesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_tax_code),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getTaxCodes", "/v1/tax_codes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxCodesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxCodesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_tax_code[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTaxCodes(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxCodesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxCodesIdParamSchema = z.object({id: z.string().max(5000)})

  const getTaxCodesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxCodesIdBodySchema = z.never().optional()

  const getTaxCodesIdResponseValidator = responseValidationFactory(
    [["200", s_tax_code]],
    s_error,
  )

  router.get("getTaxCodesId", "/v1/tax_codes/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTaxCodesIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTaxCodesIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxCodesIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_tax_code>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTaxCodesId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxCodesIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxIdsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    owner: z
      .object({
        account: z.string().optional(),
        customer: z.string().max(5000).optional(),
        type: z.enum(["account", "application", "customer", "self"]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxIdsBodySchema = z.never().optional()

  const getTaxIdsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_tax_id)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get("getTaxIds", "/v1/tax_ids", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxIdsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxIdsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_tax_id[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTaxIds(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxIdsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxIdsBodySchema = z.never()

  const postTaxIdsResponseValidator = responseValidationFactory(
    [["200", s_tax_id]],
    s_error,
  )

  router.post("postTaxIds", "/v1/tax_ids", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTaxIdsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_tax_id>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postTaxIds(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTaxIdsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteTaxIdsIdParamSchema = z.object({id: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTaxIdsIdBodySchema = z.never().optional()

  const deleteTaxIdsIdResponseValidator = responseValidationFactory(
    [["200", s_deleted_tax_id]],
    s_error,
  )

  router.delete("deleteTaxIdsId", "/v1/tax_ids/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deleteTaxIdsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        deleteTaxIdsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_deleted_tax_id>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .deleteTaxIdsId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deleteTaxIdsIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxIdsIdParamSchema = z.object({id: z.string().max(5000)})

  const getTaxIdsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxIdsIdBodySchema = z.never().optional()

  const getTaxIdsIdResponseValidator = responseValidationFactory(
    [["200", s_tax_id]],
    s_error,
  )

  router.get("getTaxIdsId", "/v1/tax_ids/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTaxIdsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTaxIdsIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxIdsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_tax_id>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTaxIdsId(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxIdsIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxRatesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    inclusive: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRatesBodySchema = z.never().optional()

  const getTaxRatesResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_tax_rate),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/tax_rates")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getTaxRates", "/v1/tax_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxRatesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_tax_rate[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTaxRates(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxRatesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRatesBodySchema = z.never()

  const postTaxRatesResponseValidator = responseValidationFactory(
    [["200", s_tax_rate]],
    s_error,
  )

  router.post("postTaxRates", "/v1/tax_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTaxRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_tax_rate>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postTaxRates(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTaxRatesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxRatesTaxRateParamSchema = z.object({
    tax_rate: z.string().max(5000),
  })

  const getTaxRatesTaxRateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTaxRatesTaxRateBodySchema = z.never().optional()

  const getTaxRatesTaxRateResponseValidator = responseValidationFactory(
    [["200", s_tax_rate]],
    s_error,
  )

  router.get(
    "getTaxRatesTaxRate",
    "/v1/tax_rates/:tax_rate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxRatesTaxRateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxRatesTaxRateQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxRatesTaxRateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_rate>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTaxRatesTaxRate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxRatesTaxRateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTaxRatesTaxRateParamSchema = z.object({
    tax_rate: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTaxRatesTaxRateBodySchema = z.never().optional()

  const postTaxRatesTaxRateResponseValidator = responseValidationFactory(
    [["200", s_tax_rate]],
    s_error,
  )

  router.post(
    "postTaxRatesTaxRate",
    "/v1/tax_rates/:tax_rate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTaxRatesTaxRateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTaxRatesTaxRateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_tax_rate>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTaxRatesTaxRate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxRatesTaxRateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalConfigurationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    is_account_default: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalConfigurationsBodySchema = z.never().optional()

  const getTerminalConfigurationsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_terminal_configuration)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/terminal/configurations")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTerminalConfigurations",
    "/v1/terminal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTerminalConfigurationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_terminal_configuration[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTerminalConfigurations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalConfigurationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalConfigurationsBodySchema = z.never().optional()

  const postTerminalConfigurationsResponseValidator = responseValidationFactory(
    [["200", s_terminal_configuration]],
    s_error,
  )

  router.post(
    "postTerminalConfigurations",
    "/v1/terminal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalConfigurations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalConfigurationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTerminalConfigurationsConfigurationBodySchema = z
    .never()
    .optional()

  const deleteTerminalConfigurationsConfigurationResponseValidator =
    responseValidationFactory(
      [["200", s_deleted_terminal_configuration]],
      s_error,
    )

  router.delete(
    "deleteTerminalConfigurationsConfiguration",
    "/v1/terminal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTerminalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTerminalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_terminal_configuration>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteTerminalConfigurationsConfiguration(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTerminalConfigurationsConfigurationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getTerminalConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalConfigurationsConfigurationBodySchema = z.never().optional()

  const getTerminalConfigurationsConfigurationResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_terminal_configuration),
            s_deleted_terminal_configuration,
          ]),
        ],
      ],
      s_error,
    )

  router.get(
    "getTerminalConfigurationsConfiguration",
    "/v1/terminal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTerminalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTerminalConfigurationsConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_terminal_configuration | t_deleted_terminal_configuration
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTerminalConfigurationsConfiguration(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalConfigurationsConfigurationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalConfigurationsConfigurationBodySchema = z.never().optional()

  const postTerminalConfigurationsConfigurationResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.lazy(() => s_terminal_configuration),
            s_deleted_terminal_configuration,
          ]),
        ],
      ],
      s_error,
    )

  router.post(
    "postTerminalConfigurationsConfiguration",
    "/v1/terminal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_terminal_configuration | t_deleted_terminal_configuration
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalConfigurationsConfiguration(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalConfigurationsConfigurationResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalConnectionTokensBodySchema = z.never().optional()

  const postTerminalConnectionTokensResponseValidator =
    responseValidationFactory([["200", s_terminal_connection_token]], s_error)

  router.post(
    "postTerminalConnectionTokens",
    "/v1/terminal/connection_tokens",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalConnectionTokensBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_connection_token>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalConnectionTokens(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalConnectionTokensResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalLocationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalLocationsBodySchema = z.never().optional()

  const getTerminalLocationsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_terminal_location),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/terminal/locations")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTerminalLocations",
    "/v1/terminal/locations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTerminalLocationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalLocationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_terminal_location[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTerminalLocations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalLocationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalLocationsBodySchema = z.never()

  const postTerminalLocationsResponseValidator = responseValidationFactory(
    [["200", s_terminal_location]],
    s_error,
  )

  router.post(
    "postTerminalLocations",
    "/v1/terminal/locations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalLocationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_location>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalLocations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalLocationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTerminalLocationsLocationBodySchema = z.never().optional()

  const deleteTerminalLocationsLocationResponseValidator =
    responseValidationFactory([["200", s_deleted_terminal_location]], s_error)

  router.delete(
    "deleteTerminalLocationsLocation",
    "/v1/terminal/locations/:location",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTerminalLocationsLocationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTerminalLocationsLocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_terminal_location>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteTerminalLocationsLocation(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTerminalLocationsLocationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  const getTerminalLocationsLocationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalLocationsLocationBodySchema = z.never().optional()

  const getTerminalLocationsLocationResponseValidator =
    responseValidationFactory(
      [["200", z.union([s_terminal_location, s_deleted_terminal_location])]],
      s_error,
    )

  router.get(
    "getTerminalLocationsLocation",
    "/v1/terminal/locations/:location",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTerminalLocationsLocationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTerminalLocationsLocationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalLocationsLocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_terminal_location | t_deleted_terminal_location
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTerminalLocationsLocation(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalLocationsLocationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalLocationsLocationBodySchema = z.never().optional()

  const postTerminalLocationsLocationResponseValidator =
    responseValidationFactory(
      [["200", z.union([s_terminal_location, s_deleted_terminal_location])]],
      s_error,
    )

  router.post(
    "postTerminalLocationsLocation",
    "/v1/terminal/locations/:location",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalLocationsLocationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalLocationsLocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_terminal_location | t_deleted_terminal_location
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalLocationsLocation(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalLocationsLocationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalReadersQuerySchema = z.object({
    device_type: z
      .enum([
        "bbpos_chipper2x",
        "bbpos_wisepad3",
        "bbpos_wisepos_e",
        "mobile_phone_reader",
        "simulated_stripe_s700",
        "simulated_wisepos_e",
        "stripe_m2",
        "stripe_s700",
        "verifone_P400",
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    location: z.string().max(5000).optional(),
    serial_number: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["offline", "online"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalReadersBodySchema = z.never().optional()

  const getTerminalReadersResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_terminal_reader)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTerminalReaders",
    "/v1/terminal/readers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTerminalReadersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalReadersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_terminal_reader[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTerminalReaders(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalReadersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersBodySchema = z.never()

  const postTerminalReadersResponseValidator = responseValidationFactory(
    [["200", s_terminal_reader]],
    s_error,
  )

  router.post(
    "postTerminalReaders",
    "/v1/terminal/readers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReaders(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTerminalReadersReaderBodySchema = z.never().optional()

  const deleteTerminalReadersReaderResponseValidator =
    responseValidationFactory([["200", s_deleted_terminal_reader]], s_error)

  router.delete(
    "deleteTerminalReadersReader",
    "/v1/terminal/readers/:reader",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTerminalReadersReaderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTerminalReadersReaderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteTerminalReadersReader(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTerminalReadersReaderResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const getTerminalReadersReaderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTerminalReadersReaderBodySchema = z.never().optional()

  const getTerminalReadersReaderResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.union([z.lazy(() => s_terminal_reader), s_deleted_terminal_reader]),
      ],
    ],
    s_error,
  )

  router.get(
    "getTerminalReadersReader",
    "/v1/terminal/readers/:reader",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTerminalReadersReaderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTerminalReadersReaderQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalReadersReaderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_terminal_reader | t_deleted_terminal_reader
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTerminalReadersReader(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalReadersReaderResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderBodySchema = z.never().optional()

  const postTerminalReadersReaderResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.union([z.lazy(() => s_terminal_reader), s_deleted_terminal_reader]),
      ],
    ],
    s_error,
  )

  router.post(
    "postTerminalReadersReader",
    "/v1/terminal/readers/:reader",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_terminal_reader | t_deleted_terminal_reader
          >(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReader(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderCancelActionParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderCancelActionBodySchema = z.never().optional()

  const postTerminalReadersReaderCancelActionResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderCancelAction",
    "/v1/terminal/readers/:reader/cancel_action",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderCancelActionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderCancelActionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderCancelAction(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderCancelActionResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderCollectInputsParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderCollectInputsBodySchema = z.never()

  const postTerminalReadersReaderCollectInputsResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderCollectInputs",
    "/v1/terminal/readers/:reader/collect_inputs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderCollectInputsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderCollectInputsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderCollectInputs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderCollectInputsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderCollectPaymentMethodParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderCollectPaymentMethodBodySchema = z.never()

  const postTerminalReadersReaderCollectPaymentMethodResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderCollectPaymentMethod",
    "/v1/terminal/readers/:reader/collect_payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderCollectPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderCollectPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderCollectPaymentMethod(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderCollectPaymentMethodResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderConfirmPaymentIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderConfirmPaymentIntentBodySchema = z.never()

  const postTerminalReadersReaderConfirmPaymentIntentResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderConfirmPaymentIntent",
    "/v1/terminal/readers/:reader/confirm_payment_intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderConfirmPaymentIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderConfirmPaymentIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderConfirmPaymentIntent(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderConfirmPaymentIntentResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderProcessPaymentIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderProcessPaymentIntentBodySchema = z.never()

  const postTerminalReadersReaderProcessPaymentIntentResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderProcessPaymentIntent",
    "/v1/terminal/readers/:reader/process_payment_intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderProcessPaymentIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderProcessPaymentIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderProcessPaymentIntent(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderProcessPaymentIntentResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderProcessSetupIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderProcessSetupIntentBodySchema = z.never()

  const postTerminalReadersReaderProcessSetupIntentResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderProcessSetupIntent",
    "/v1/terminal/readers/:reader/process_setup_intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderProcessSetupIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderProcessSetupIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderProcessSetupIntent(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderProcessSetupIntentResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderRefundPaymentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderRefundPaymentBodySchema = z.never().optional()

  const postTerminalReadersReaderRefundPaymentResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderRefundPayment",
    "/v1/terminal/readers/:reader/refund_payment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderRefundPaymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderRefundPaymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderRefundPayment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderRefundPaymentResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderSetReaderDisplayParamSchema = z.object({
    reader: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTerminalReadersReaderSetReaderDisplayBodySchema = z.never()

  const postTerminalReadersReaderSetReaderDisplayResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTerminalReadersReaderSetReaderDisplay",
    "/v1/terminal/readers/:reader/set_reader_display",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderSetReaderDisplayParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderSetReaderDisplayBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTerminalReadersReaderSetReaderDisplay(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderSetReaderDisplayResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersConfirmationTokensBodySchema = z.never().optional()

  const postTestHelpersConfirmationTokensResponseValidator =
    responseValidationFactory([["200", s_confirmation_token]], s_error)

  router.post(
    "postTestHelpersConfirmationTokens",
    "/v1/test_helpers/confirmation_tokens",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersConfirmationTokensBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_confirmation_token>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersConfirmationTokens(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersConfirmationTokensResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersCustomersCustomerFundCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersCustomersCustomerFundCashBalanceBodySchema = z.never()

  const postTestHelpersCustomersCustomerFundCashBalanceResponseValidator =
    responseValidationFactory(
      [["200", s_customer_cash_balance_transaction]],
      s_error,
    )

  router.post(
    "postTestHelpersCustomersCustomerFundCashBalance",
    "/v1/test_helpers/customers/:customer/fund_cash_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersCustomersCustomerFundCashBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersCustomersCustomerFundCashBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_customer_cash_balance_transaction>(
            200,
          )
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersCustomersCustomerFundCashBalance(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersCustomersCustomerFundCashBalanceResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsBodySchema = z.never()

  const postTestHelpersIssuingAuthorizationsResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postTestHelpersIssuingAuthorizations",
    "/v1/test_helpers/issuing/authorizations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizations(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingAuthorizationsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationCapture",
    "/v1/test_helpers/issuing/authorizations/:authorization/capture",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationCapture(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationCaptureResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationExpire",
    "/v1/test_helpers/issuing/authorizations/:authorization/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationExpire(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationExpireResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema =
    z.never()

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount",
    "/v1/test_helpers/issuing/authorizations/:authorization/finalize_amount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema =
    z.never()

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond",
    "/v1/test_helpers/issuing/authorizations/:authorization/fraud_challenges/respond",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema =
    z.never()

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationIncrement",
    "/v1/test_helpers/issuing/authorizations/:authorization/increment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationIncrement(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationIncrementResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema =
    z.object({authorization: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseResponseValidator =
    responseValidationFactory([["200", s_issuing_authorization]], s_error)

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationReverse",
    "/v1/test_helpers/issuing/authorizations/:authorization/reverse",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_authorization>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationReverse(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationReverseResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingDeliverParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingDeliverBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingDeliverResponseValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  router.post(
    "postTestHelpersIssuingCardsCardShippingDeliver",
    "/v1/test_helpers/issuing/cards/:card/shipping/deliver",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingDeliverParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingDeliverBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingDeliver(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingCardsCardShippingDeliverResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingFailParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingFailBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingFailResponseValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  router.post(
    "postTestHelpersIssuingCardsCardShippingFail",
    "/v1/test_helpers/issuing/cards/:card/shipping/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingFail(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingFailResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingReturnParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingReturnBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingReturnResponseValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  router.post(
    "postTestHelpersIssuingCardsCardShippingReturn",
    "/v1/test_helpers/issuing/cards/:card/shipping/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingReturn(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingReturnResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingShipParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingShipBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingShipResponseValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  router.post(
    "postTestHelpersIssuingCardsCardShippingShip",
    "/v1/test_helpers/issuing/cards/:card/shipping/ship",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingShipParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingShipBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingShip(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingShipResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingSubmitParamSchema = z.object({
    card: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingCardsCardShippingSubmitBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingCardsCardShippingSubmitResponseValidator =
    responseValidationFactory([["200", s_issuing_card]], s_error)

  router.post(
    "postTestHelpersIssuingCardsCardShippingSubmit",
    "/v1/test_helpers/issuing/cards/:card/shipping/submit",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingSubmitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingSubmitBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_card>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingSubmit(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingSubmitResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema =
    z.never().optional()

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponseValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  router.post(
    "postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate",
    "/v1/test_helpers/issuing/personalization_designs/:personalization_design/activate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_personalization_design>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema =
    z.never().optional()

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponseValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  router.post(
    "postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate",
    "/v1/test_helpers/issuing/personalization_designs/:personalization_design/deactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_personalization_design>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema =
    z.object({personalization_design: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema =
    z.never()

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponseValidator =
    responseValidationFactory(
      [["200", s_issuing_personalization_design]],
      s_error,
    )

  router.post(
    "postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject",
    "/v1/test_helpers/issuing/personalization_designs/:personalization_design/reject",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_personalization_design>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingSettlementsBodySchema = z.never()

  const postTestHelpersIssuingSettlementsResponseValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  router.post(
    "postTestHelpersIssuingSettlements",
    "/v1/test_helpers/issuing/settlements",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingSettlementsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_settlement>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingSettlements(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingSettlementsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingSettlementsSettlementCompleteParamSchema =
    z.object({settlement: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingSettlementsSettlementCompleteBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingSettlementsSettlementCompleteResponseValidator =
    responseValidationFactory([["200", s_issuing_settlement]], s_error)

  router.post(
    "postTestHelpersIssuingSettlementsSettlementComplete",
    "/v1/test_helpers/issuing/settlements/:settlement/complete",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingSettlementsSettlementCompleteBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_settlement>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingSettlementsSettlementComplete(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingSettlementsSettlementCompleteResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingTransactionsCreateForceCaptureBodySchema =
    z.never()

  const postTestHelpersIssuingTransactionsCreateForceCaptureResponseValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  router.post(
    "postTestHelpersIssuingTransactionsCreateForceCapture",
    "/v1/test_helpers/issuing/transactions/create_force_capture",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingTransactionsCreateForceCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingTransactionsCreateForceCapture(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingTransactionsCreateForceCaptureResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema =
    z.never()

  const postTestHelpersIssuingTransactionsCreateUnlinkedRefundResponseValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  router.post(
    "postTestHelpersIssuingTransactionsCreateUnlinkedRefund",
    "/v1/test_helpers/issuing/transactions/create_unlinked_refund",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingTransactionsCreateUnlinkedRefund(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingTransactionsCreateUnlinkedRefundResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingTransactionsTransactionRefundParamSchema =
    z.object({transaction: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersIssuingTransactionsTransactionRefundBodySchema = z
    .never()
    .optional()

  const postTestHelpersIssuingTransactionsTransactionRefundResponseValidator =
    responseValidationFactory([["200", s_issuing_transaction]], s_error)

  router.post(
    "postTestHelpersIssuingTransactionsTransactionRefund",
    "/v1/test_helpers/issuing/transactions/:transaction/refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingTransactionsTransactionRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingTransactionsTransactionRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_issuing_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersIssuingTransactionsTransactionRefund(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingTransactionsTransactionRefundResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersRefundsRefundExpireParamSchema = z.object({
    refund: z.string(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersRefundsRefundExpireBodySchema = z.never().optional()

  const postTestHelpersRefundsRefundExpireResponseValidator =
    responseValidationFactory([["200", s_refund]], s_error)

  router.post(
    "postTestHelpersRefundsRefundExpire",
    "/v1/test_helpers/refunds/:refund/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersRefundsRefundExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersRefundsRefundExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_refund>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersRefundsRefundExpire(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersRefundsRefundExpireResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema =
    z.object({reader: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema = z
    .never()
    .optional()

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTestHelpersTerminalReadersReaderPresentPaymentMethod",
    "/v1/test_helpers/terminal/readers/:reader/present_payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTerminalReadersReaderPresentPaymentMethod(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTerminalReadersReaderPresentPaymentMethodResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema =
    z.object({reader: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTerminalReadersReaderSucceedInputCollectionBodySchema = z
    .never()
    .optional()

  const postTestHelpersTerminalReadersReaderSucceedInputCollectionResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTestHelpersTerminalReadersReaderSucceedInputCollection",
    "/v1/test_helpers/terminal/readers/:reader/succeed_input_collection",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTerminalReadersReaderSucceedInputCollectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTerminalReadersReaderSucceedInputCollectionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTerminalReadersReaderSucceedInputCollection(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTerminalReadersReaderSucceedInputCollectionResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema =
    z.object({reader: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTerminalReadersReaderTimeoutInputCollectionBodySchema = z
    .never()
    .optional()

  const postTestHelpersTerminalReadersReaderTimeoutInputCollectionResponseValidator =
    responseValidationFactory([["200", s_terminal_reader]], s_error)

  router.post(
    "postTestHelpersTerminalReadersReaderTimeoutInputCollection",
    "/v1/test_helpers/terminal/readers/:reader/timeout_input_collection",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTerminalReadersReaderTimeoutInputCollectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTerminalReadersReaderTimeoutInputCollectionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_terminal_reader>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTerminalReadersReaderTimeoutInputCollection(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTerminalReadersReaderTimeoutInputCollectionResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getTestHelpersTestClocksQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTestHelpersTestClocksBodySchema = z.never().optional()

  const getTestHelpersTestClocksResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_test_helpers_test_clock),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z
            .string()
            .max(5000)
            .regex(new RegExp("^/v1/test_helpers/test_clocks")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTestHelpersTestClocks",
    "/v1/test_helpers/test_clocks",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTestHelpersTestClocksQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTestHelpersTestClocksBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_test_helpers_test_clock[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTestHelpersTestClocks(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTestHelpersTestClocksResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTestClocksBodySchema = z.never()

  const postTestHelpersTestClocksResponseValidator = responseValidationFactory(
    [["200", s_test_helpers_test_clock]],
    s_error,
  )

  router.post(
    "postTestHelpersTestClocks",
    "/v1/test_helpers/test_clocks",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTestClocksBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_test_helpers_test_clock>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTestClocks(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTestClocksResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTestHelpersTestClocksTestClockParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteTestHelpersTestClocksTestClockBodySchema = z.never().optional()

  const deleteTestHelpersTestClocksTestClockResponseValidator =
    responseValidationFactory(
      [["200", s_deleted_test_helpers_test_clock]],
      s_error,
    )

  router.delete(
    "deleteTestHelpersTestClocksTestClock",
    "/v1/test_helpers/test_clocks/:test_clock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTestHelpersTestClocksTestClockParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTestHelpersTestClocksTestClockBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_test_helpers_test_clock>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteTestHelpersTestClocksTestClock(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTestHelpersTestClocksTestClockResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTestHelpersTestClocksTestClockParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  const getTestHelpersTestClocksTestClockQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTestHelpersTestClocksTestClockBodySchema = z.never().optional()

  const getTestHelpersTestClocksTestClockResponseValidator =
    responseValidationFactory([["200", s_test_helpers_test_clock]], s_error)

  router.get(
    "getTestHelpersTestClocksTestClock",
    "/v1/test_helpers/test_clocks/:test_clock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTestHelpersTestClocksTestClockParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTestHelpersTestClocksTestClockQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTestHelpersTestClocksTestClockBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_test_helpers_test_clock>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTestHelpersTestClocksTestClock(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTestHelpersTestClocksTestClockResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTestClocksTestClockAdvanceParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTestClocksTestClockAdvanceBodySchema = z.never()

  const postTestHelpersTestClocksTestClockAdvanceResponseValidator =
    responseValidationFactory([["200", s_test_helpers_test_clock]], s_error)

  router.post(
    "postTestHelpersTestClocksTestClockAdvance",
    "/v1/test_helpers/test_clocks/:test_clock/advance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTestClocksTestClockAdvanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTestClocksTestClockAdvanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_test_helpers_test_clock>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTestClocksTestClockAdvance(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTestClocksTestClockAdvanceResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdFailParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryInboundTransfersIdFailBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryInboundTransfersIdFailResponseValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  router.post(
    "postTestHelpersTreasuryInboundTransfersIdFail",
    "/v1/test_helpers/treasury/inbound_transfers/:id/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_inbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryInboundTransfersIdFail(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryInboundTransfersIdFailResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdReturnParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryInboundTransfersIdReturnBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryInboundTransfersIdReturnResponseValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  router.post(
    "postTestHelpersTreasuryInboundTransfersIdReturn",
    "/v1/test_helpers/treasury/inbound_transfers/:id/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_inbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryInboundTransfersIdReturn(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryInboundTransfersIdReturnResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdSucceedParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryInboundTransfersIdSucceedBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryInboundTransfersIdSucceedResponseValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  router.post(
    "postTestHelpersTreasuryInboundTransfersIdSucceed",
    "/v1/test_helpers/treasury/inbound_transfers/:id/succeed",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdSucceedBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_inbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryInboundTransfersIdSucceed(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryInboundTransfersIdSucceedResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdBodySchema = z.never()

  const postTestHelpersTreasuryOutboundPaymentsIdResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsId",
    "/v1/test_helpers/treasury/outbound_payments/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryOutboundPaymentsIdResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdFailParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdFailBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryOutboundPaymentsIdFailResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsIdFail",
    "/v1/test_helpers/treasury/outbound_payments/:id/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsIdFail(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryOutboundPaymentsIdFailResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdPostParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdPostBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryOutboundPaymentsIdPostResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsIdPost",
    "/v1/test_helpers/treasury/outbound_payments/:id/post",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsIdPost(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryOutboundPaymentsIdPostResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema = z
    .never()
    .optional()

  const postTestHelpersTreasuryOutboundPaymentsIdReturnResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsIdReturn",
    "/v1/test_helpers/treasury/outbound_payments/:id/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsIdReturn(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundPaymentsIdReturnResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema =
    z.never()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransfer",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransfer(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransferResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema =
    z.never().optional()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransferFail",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransferFail(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransferFailResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema =
    z.never().optional()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransferPost",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/post",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransferPost(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransferPostResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema =
    z.never().optional()

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryReceivedCreditsBodySchema = z.never()

  const postTestHelpersTreasuryReceivedCreditsResponseValidator =
    responseValidationFactory([["200", s_treasury_received_credit]], s_error)

  router.post(
    "postTestHelpersTreasuryReceivedCredits",
    "/v1/test_helpers/treasury/received_credits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryReceivedCreditsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_received_credit>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryReceivedCredits(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryReceivedCreditsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTestHelpersTreasuryReceivedDebitsBodySchema = z.never()

  const postTestHelpersTreasuryReceivedDebitsResponseValidator =
    responseValidationFactory([["200", s_treasury_received_debit]], s_error)

  router.post(
    "postTestHelpersTreasuryReceivedDebits",
    "/v1/test_helpers/treasury/received_debits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryReceivedDebitsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_received_debit>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTestHelpersTreasuryReceivedDebits(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryReceivedDebitsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTokensBodySchema = z.never().optional()

  const postTokensResponseValidator = responseValidationFactory(
    [["200", s_token]],
    s_error,
  )

  router.post("postTokens", "/v1/tokens", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTokensBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_token>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postTokens(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTokensResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTokensTokenParamSchema = z.object({token: z.string().max(5000)})

  const getTokensTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTokensTokenBodySchema = z.never().optional()

  const getTokensTokenResponseValidator = responseValidationFactory(
    [["200", s_token]],
    s_error,
  )

  router.get("getTokensToken", "/v1/tokens/:token", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTokensTokenParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTokensTokenQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTokensTokenBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_token>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTokensToken(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTokensTokenResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTopupsQuerySchema = z.object({
    amount: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "failed", "pending", "succeeded"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTopupsBodySchema = z.never().optional()

  const getTopupsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_topup)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/topups")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getTopups", "/v1/topups", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTopupsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTopupsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_topup[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTopups(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTopupsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTopupsBodySchema = z.never()

  const postTopupsResponseValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  router.post("postTopups", "/v1/topups", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTopupsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_topup>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postTopups(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTopupsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTopupsTopupParamSchema = z.object({topup: z.string().max(5000)})

  const getTopupsTopupQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTopupsTopupBodySchema = z.never().optional()

  const getTopupsTopupResponseValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  router.get("getTopupsTopup", "/v1/topups/:topup", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTopupsTopupParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTopupsTopupQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTopupsTopupBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_topup>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTopupsTopup(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTopupsTopupResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postTopupsTopupParamSchema = z.object({topup: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTopupsTopupBodySchema = z.never().optional()

  const postTopupsTopupResponseValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  router.post("postTopupsTopup", "/v1/topups/:topup", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postTopupsTopupParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postTopupsTopupBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_topup>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postTopupsTopup(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTopupsTopupResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const postTopupsTopupCancelParamSchema = z.object({
    topup: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTopupsTopupCancelBodySchema = z.never().optional()

  const postTopupsTopupCancelResponseValidator = responseValidationFactory(
    [["200", s_topup]],
    s_error,
  )

  router.post(
    "postTopupsTopupCancel",
    "/v1/topups/:topup/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTopupsTopupCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTopupsTopupCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_topup>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTopupsTopupCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTopupsTopupCancelResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTransfersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    destination: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    transfer_group: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersBodySchema = z.never().optional()

  const getTransfersResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_transfer)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/transfers")),
        }),
      ],
    ],
    s_error,
  )

  router.get("getTransfers", "/v1/transfers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTransfersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTransfersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<{
          data: t_transfer[]
          has_more: boolean
          object: "list"
          url: string
        }>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTransfers(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTransfersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersBodySchema = z.never()

  const postTransfersResponseValidator = responseValidationFactory(
    [["200", s_transfer]],
    s_error,
  )

  router.post("postTransfers", "/v1/transfers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTransfersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_transfer>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .postTransfers(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTransfersResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTransfersIdReversalsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTransfersIdReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersIdReversalsBodySchema = z.never().optional()

  const getTransfersIdReversalsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_transfer_reversal)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTransfersIdReversals",
    "/v1/transfers/:id/reversals",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTransfersIdReversalsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTransfersIdReversalsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTransfersIdReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_transfer_reversal[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTransfersIdReversals(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTransfersIdReversalsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTransfersIdReversalsParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersIdReversalsBodySchema = z.never().optional()

  const postTransfersIdReversalsResponseValidator = responseValidationFactory(
    [["200", s_transfer_reversal]],
    s_error,
  )

  router.post(
    "postTransfersIdReversals",
    "/v1/transfers/:id/reversals",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTransfersIdReversalsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTransfersIdReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_transfer_reversal>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTransfersIdReversals(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTransfersIdReversalsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTransfersTransferParamSchema = z.object({
    transfer: z.string().max(5000),
  })

  const getTransfersTransferQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersTransferBodySchema = z.never().optional()

  const getTransfersTransferResponseValidator = responseValidationFactory(
    [["200", s_transfer]],
    s_error,
  )

  router.get(
    "getTransfersTransfer",
    "/v1/transfers/:transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTransfersTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTransfersTransferQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTransfersTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTransfersTransfer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTransfersTransferResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTransfersTransferParamSchema = z.object({
    transfer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersTransferBodySchema = z.never().optional()

  const postTransfersTransferResponseValidator = responseValidationFactory(
    [["200", s_transfer]],
    s_error,
  )

  router.post(
    "postTransfersTransfer",
    "/v1/transfers/:transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTransfersTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTransfersTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTransfersTransfer(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTransfersTransferResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTransfersTransferReversalsIdParamSchema = z.object({
    id: z.string().max(5000),
    transfer: z.string().max(5000),
  })

  const getTransfersTransferReversalsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTransfersTransferReversalsIdBodySchema = z.never().optional()

  const getTransfersTransferReversalsIdResponseValidator =
    responseValidationFactory([["200", s_transfer_reversal]], s_error)

  router.get(
    "getTransfersTransferReversalsId",
    "/v1/transfers/:transfer/reversals/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTransfersTransferReversalsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTransfersTransferReversalsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTransfersTransferReversalsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_transfer_reversal>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTransfersTransferReversalsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTransfersTransferReversalsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTransfersTransferReversalsIdParamSchema = z.object({
    id: z.string().max(5000),
    transfer: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTransfersTransferReversalsIdBodySchema = z.never().optional()

  const postTransfersTransferReversalsIdResponseValidator =
    responseValidationFactory([["200", s_transfer_reversal]], s_error)

  router.post(
    "postTransfersTransferReversalsId",
    "/v1/transfers/:transfer/reversals/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTransfersTransferReversalsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTransfersTransferReversalsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_transfer_reversal>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTransfersTransferReversalsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTransfersTransferReversalsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryCreditReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    received_credit: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "posted", "processing"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryCreditReversalsBodySchema = z.never().optional()

  const getTreasuryCreditReversalsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_treasury_credit_reversal)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTreasuryCreditReversals",
    "/v1/treasury/credit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryCreditReversalsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryCreditReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_credit_reversal[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryCreditReversals(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryCreditReversalsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryCreditReversalsBodySchema = z.never()

  const postTreasuryCreditReversalsResponseValidator =
    responseValidationFactory([["200", s_treasury_credit_reversal]], s_error)

  router.post(
    "postTreasuryCreditReversals",
    "/v1/treasury/credit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryCreditReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_credit_reversal>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryCreditReversals(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryCreditReversalsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryCreditReversalsCreditReversalParamSchema = z.object({
    credit_reversal: z.string().max(5000),
  })

  const getTreasuryCreditReversalsCreditReversalQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryCreditReversalsCreditReversalBodySchema = z
    .never()
    .optional()

  const getTreasuryCreditReversalsCreditReversalResponseValidator =
    responseValidationFactory([["200", s_treasury_credit_reversal]], s_error)

  router.get(
    "getTreasuryCreditReversalsCreditReversal",
    "/v1/treasury/credit_reversals/:credit_reversal",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryCreditReversalsCreditReversalParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryCreditReversalsCreditReversalQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryCreditReversalsCreditReversalBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_credit_reversal>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryCreditReversalsCreditReversal(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryCreditReversalsCreditReversalResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryDebitReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    received_debit: z.string().max(5000).optional(),
    resolution: z.enum(["lost", "won"]).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "completed", "processing"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryDebitReversalsBodySchema = z.never().optional()

  const getTreasuryDebitReversalsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_treasury_debit_reversal)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTreasuryDebitReversals",
    "/v1/treasury/debit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryDebitReversalsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryDebitReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_debit_reversal[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryDebitReversals(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryDebitReversalsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryDebitReversalsBodySchema = z.never()

  const postTreasuryDebitReversalsResponseValidator = responseValidationFactory(
    [["200", s_treasury_debit_reversal]],
    s_error,
  )

  router.post(
    "postTreasuryDebitReversals",
    "/v1/treasury/debit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryDebitReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_debit_reversal>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryDebitReversals(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryDebitReversalsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryDebitReversalsDebitReversalParamSchema = z.object({
    debit_reversal: z.string().max(5000),
  })

  const getTreasuryDebitReversalsDebitReversalQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryDebitReversalsDebitReversalBodySchema = z.never().optional()

  const getTreasuryDebitReversalsDebitReversalResponseValidator =
    responseValidationFactory([["200", s_treasury_debit_reversal]], s_error)

  router.get(
    "getTreasuryDebitReversalsDebitReversal",
    "/v1/treasury/debit_reversals/:debit_reversal",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryDebitReversalsDebitReversalParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryDebitReversalsDebitReversalQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryDebitReversalsDebitReversalBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_debit_reversal>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryDebitReversalsDebitReversal(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryDebitReversalsDebitReversalResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryFinancialAccountsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["closed", "open"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryFinancialAccountsBodySchema = z.never().optional()

  const getTreasuryFinancialAccountsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(s_treasury_financial_account),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/treasury/financial_accounts")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getTreasuryFinancialAccounts",
    "/v1/treasury/financial_accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryFinancialAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryFinancialAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_financial_account[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryFinancialAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryFinancialAccountsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsBodySchema = z.never()

  const postTreasuryFinancialAccountsResponseValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  router.post(
    "postTreasuryFinancialAccounts",
    "/v1/treasury/financial_accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_financial_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryFinancialAccounts(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryFinancialAccountsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryFinancialAccountsFinancialAccountParamSchema = z.object({
    financial_account: z.string().max(5000),
  })

  const getTreasuryFinancialAccountsFinancialAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryFinancialAccountsFinancialAccountBodySchema = z
    .never()
    .optional()

  const getTreasuryFinancialAccountsFinancialAccountResponseValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  router.get(
    "getTreasuryFinancialAccountsFinancialAccount",
    "/v1/treasury/financial_accounts/:financial_account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_financial_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryFinancialAccountsFinancialAccount(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryFinancialAccountsFinancialAccountResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountParamSchema = z.object({
    financial_account: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsFinancialAccountBodySchema = z
    .never()
    .optional()

  const postTreasuryFinancialAccountsFinancialAccountResponseValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  router.post(
    "postTreasuryFinancialAccountsFinancialAccount",
    "/v1/treasury/financial_accounts/:financial_account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_financial_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryFinancialAccountsFinancialAccount(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryFinancialAccountsFinancialAccountResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountCloseParamSchema =
    z.object({financial_account: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsFinancialAccountCloseBodySchema = z
    .never()
    .optional()

  const postTreasuryFinancialAccountsFinancialAccountCloseResponseValidator =
    responseValidationFactory([["200", s_treasury_financial_account]], s_error)

  router.post(
    "postTreasuryFinancialAccountsFinancialAccountClose",
    "/v1/treasury/financial_accounts/:financial_account/close",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountCloseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_financial_account>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryFinancialAccountsFinancialAccountClose(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTreasuryFinancialAccountsFinancialAccountCloseResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema =
    z.object({financial_account: z.string().max(5000)})

  const getTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema = z
    .never()
    .optional()

  const getTreasuryFinancialAccountsFinancialAccountFeaturesResponseValidator =
    responseValidationFactory(
      [["200", s_treasury_financial_account_features]],
      s_error,
    )

  router.get(
    "getTreasuryFinancialAccountsFinancialAccountFeatures",
    "/v1/treasury/financial_accounts/:financial_account/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_financial_account_features>(
            200,
          )
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryFinancialAccountsFinancialAccountFeatures(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getTreasuryFinancialAccountsFinancialAccountFeaturesResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema =
    z.object({financial_account: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema = z
    .never()
    .optional()

  const postTreasuryFinancialAccountsFinancialAccountFeaturesResponseValidator =
    responseValidationFactory(
      [["200", s_treasury_financial_account_features]],
      s_error,
    )

  router.post(
    "postTreasuryFinancialAccountsFinancialAccountFeatures",
    "/v1/treasury/financial_accounts/:financial_account/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_financial_account_features>(
            200,
          )
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryFinancialAccountsFinancialAccountFeatures(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTreasuryFinancialAccountsFinancialAccountFeaturesResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryInboundTransfersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "processing", "succeeded"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryInboundTransfersBodySchema = z.never().optional()

  const getTreasuryInboundTransfersResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_inbound_transfer)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getTreasuryInboundTransfers",
    "/v1/treasury/inbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryInboundTransfersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryInboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_inbound_transfer[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryInboundTransfers(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryInboundTransfersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryInboundTransfersBodySchema = z.never()

  const postTreasuryInboundTransfersResponseValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  router.post(
    "postTreasuryInboundTransfers",
    "/v1/treasury/inbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryInboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_inbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryInboundTransfers(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryInboundTransfersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryInboundTransfersIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryInboundTransfersIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryInboundTransfersIdBodySchema = z.never().optional()

  const getTreasuryInboundTransfersIdResponseValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  router.get(
    "getTreasuryInboundTransfersId",
    "/v1/treasury/inbound_transfers/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryInboundTransfersIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryInboundTransfersIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryInboundTransfersIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_inbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryInboundTransfersId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryInboundTransfersIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryInboundTransfersInboundTransferCancelParamSchema = z.object(
    {inbound_transfer: z.string().max(5000)},
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryInboundTransfersInboundTransferCancelBodySchema = z
    .never()
    .optional()

  const postTreasuryInboundTransfersInboundTransferCancelResponseValidator =
    responseValidationFactory([["200", s_treasury_inbound_transfer]], s_error)

  router.post(
    "postTreasuryInboundTransfersInboundTransferCancel",
    "/v1/treasury/inbound_transfers/:inbound_transfer/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryInboundTransfersInboundTransferCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryInboundTransfersInboundTransferCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_inbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryInboundTransfersInboundTransferCancel(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTreasuryInboundTransfersInboundTransferCancelResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundPaymentsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "posted", "processing", "returned"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundPaymentsBodySchema = z.never().optional()

  const getTreasuryOutboundPaymentsResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_outbound_payment)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/treasury/outbound_payments")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getTreasuryOutboundPayments",
    "/v1/treasury/outbound_payments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryOutboundPaymentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundPaymentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_outbound_payment[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryOutboundPayments(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundPaymentsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundPaymentsBodySchema = z.never()

  const postTreasuryOutboundPaymentsResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  router.post(
    "postTreasuryOutboundPayments",
    "/v1/treasury/outbound_payments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundPaymentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryOutboundPayments(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryOutboundPaymentsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundPaymentsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryOutboundPaymentsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundPaymentsIdBodySchema = z.never().optional()

  const getTreasuryOutboundPaymentsIdResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  router.get(
    "getTreasuryOutboundPaymentsId",
    "/v1/treasury/outbound_payments/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryOutboundPaymentsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryOutboundPaymentsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundPaymentsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryOutboundPaymentsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundPaymentsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryOutboundPaymentsIdCancelParamSchema = z.object({
    id: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundPaymentsIdCancelBodySchema = z.never().optional()

  const postTreasuryOutboundPaymentsIdCancelResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_payment]], s_error)

  router.post(
    "postTreasuryOutboundPaymentsIdCancel",
    "/v1/treasury/outbound_payments/:id/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryOutboundPaymentsIdCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundPaymentsIdCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_payment>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryOutboundPaymentsIdCancel(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryOutboundPaymentsIdCancelResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundTransfersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "posted", "processing", "returned"])
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundTransfersBodySchema = z.never().optional()

  const getTreasuryOutboundTransfersResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_outbound_transfer)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z.string().max(5000),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getTreasuryOutboundTransfers",
    "/v1/treasury/outbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryOutboundTransfersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_outbound_transfer[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryOutboundTransfers(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundTransfersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundTransfersBodySchema = z.never()

  const postTreasuryOutboundTransfersResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  router.post(
    "postTreasuryOutboundTransfers",
    "/v1/treasury/outbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryOutboundTransfers(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryOutboundTransfersResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundTransfersOutboundTransferParamSchema = z.object({
    outbound_transfer: z.string().max(5000),
  })

  const getTreasuryOutboundTransfersOutboundTransferQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryOutboundTransfersOutboundTransferBodySchema = z
    .never()
    .optional()

  const getTreasuryOutboundTransfersOutboundTransferResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  router.get(
    "getTreasuryOutboundTransfersOutboundTransfer",
    "/v1/treasury/outbound_transfers/:outbound_transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryOutboundTransfersOutboundTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryOutboundTransfersOutboundTransferQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundTransfersOutboundTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryOutboundTransfersOutboundTransfer(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundTransfersOutboundTransferResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryOutboundTransfersOutboundTransferCancelParamSchema =
    z.object({outbound_transfer: z.string().max(5000)})

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postTreasuryOutboundTransfersOutboundTransferCancelBodySchema = z
    .never()
    .optional()

  const postTreasuryOutboundTransfersOutboundTransferCancelResponseValidator =
    responseValidationFactory([["200", s_treasury_outbound_transfer]], s_error)

  router.post(
    "postTreasuryOutboundTransfersOutboundTransferCancel",
    "/v1/treasury/outbound_transfers/:outbound_transfer/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundTransfersOutboundTransferCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_outbound_transfer>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postTreasuryOutboundTransfersOutboundTransferCancel(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTreasuryOutboundTransfersOutboundTransferCancelResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedCreditsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    linked_flows: z
      .object({
        source_flow_type: z.enum([
          "credit_reversal",
          "other",
          "outbound_payment",
          "outbound_transfer",
          "payout",
        ]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["failed", "succeeded"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedCreditsBodySchema = z.never().optional()

  const getTreasuryReceivedCreditsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_treasury_received_credit)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTreasuryReceivedCredits",
    "/v1/treasury/received_credits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryReceivedCreditsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedCreditsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_received_credit[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryReceivedCredits(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedCreditsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedCreditsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryReceivedCreditsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedCreditsIdBodySchema = z.never().optional()

  const getTreasuryReceivedCreditsIdResponseValidator =
    responseValidationFactory([["200", s_treasury_received_credit]], s_error)

  router.get(
    "getTreasuryReceivedCreditsId",
    "/v1/treasury/received_credits/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryReceivedCreditsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryReceivedCreditsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedCreditsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_received_credit>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryReceivedCreditsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedCreditsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedDebitsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["failed", "succeeded"]).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedDebitsBodySchema = z.never().optional()

  const getTreasuryReceivedDebitsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_treasury_received_debit)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTreasuryReceivedDebits",
    "/v1/treasury/received_debits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryReceivedDebitsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedDebitsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_received_debit[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryReceivedDebits(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedDebitsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedDebitsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryReceivedDebitsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryReceivedDebitsIdBodySchema = z.never().optional()

  const getTreasuryReceivedDebitsIdResponseValidator =
    responseValidationFactory([["200", s_treasury_received_debit]], s_error)

  router.get(
    "getTreasuryReceivedDebitsId",
    "/v1/treasury/received_debits/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryReceivedDebitsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryReceivedDebitsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedDebitsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_received_debit>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryReceivedDebitsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedDebitsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionEntriesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    effective_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    order_by: z.enum(["created", "effective_at"]).optional(),
    starting_after: z.string().max(5000).optional(),
    transaction: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionEntriesBodySchema = z.never().optional()

  const getTreasuryTransactionEntriesResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            data: z.array(z.lazy(() => s_treasury_transaction_entry)),
            has_more: PermissiveBoolean,
            object: z.enum(["list"]),
            url: z
              .string()
              .max(5000)
              .regex(new RegExp("^/v1/treasury/transaction_entries")),
          }),
        ],
      ],
      s_error,
    )

  router.get(
    "getTreasuryTransactionEntries",
    "/v1/treasury/transaction_entries",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryTransactionEntriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionEntriesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_transaction_entry[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryTransactionEntries(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactionEntriesResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionEntriesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryTransactionEntriesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionEntriesIdBodySchema = z.never().optional()

  const getTreasuryTransactionEntriesIdResponseValidator =
    responseValidationFactory([["200", s_treasury_transaction_entry]], s_error)

  router.get(
    "getTreasuryTransactionEntriesId",
    "/v1/treasury/transaction_entries/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryTransactionEntriesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryTransactionEntriesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionEntriesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_transaction_entry>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryTransactionEntriesId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactionEntriesIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    order_by: z.enum(["created", "posted_at"]).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["open", "posted", "void"]).optional(),
    status_transitions: z
      .object({
        posted_at: z
          .union([
            z.object({
              gt: z.coerce.number().optional(),
              gte: z.coerce.number().optional(),
              lt: z.coerce.number().optional(),
              lte: z.coerce.number().optional(),
            }),
            z.coerce.number(),
          ])
          .optional(),
      })
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionsBodySchema = z.never().optional()

  const getTreasuryTransactionsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(z.lazy(() => s_treasury_transaction)),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getTreasuryTransactions",
    "/v1/treasury/transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_treasury_transaction[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryTransactions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getTreasuryTransactionsIdBodySchema = z.never().optional()

  const getTreasuryTransactionsIdResponseValidator = responseValidationFactory(
    [["200", s_treasury_transaction]],
    s_error,
  )

  router.get(
    "getTreasuryTransactionsId",
    "/v1/treasury/transactions/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryTransactionsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryTransactionsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_treasury_transaction>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getTreasuryTransactionsId(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactionsIdResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getWebhookEndpointsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getWebhookEndpointsBodySchema = z.never().optional()

  const getWebhookEndpointsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          data: z.array(s_webhook_endpoint),
          has_more: PermissiveBoolean,
          object: z.enum(["list"]),
          url: z.string().max(5000).regex(new RegExp("^/v1/webhook_endpoints")),
        }),
      ],
    ],
    s_error,
  )

  router.get(
    "getWebhookEndpoints",
    "/v1/webhook_endpoints",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getWebhookEndpointsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getWebhookEndpointsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            data: t_webhook_endpoint[]
            has_more: boolean
            object: "list"
            url: string
          }>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getWebhookEndpoints(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWebhookEndpointsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postWebhookEndpointsBodySchema = z.never()

  const postWebhookEndpointsResponseValidator = responseValidationFactory(
    [["200", s_webhook_endpoint]],
    s_error,
  )

  router.post(
    "postWebhookEndpoints",
    "/v1/webhook_endpoints",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postWebhookEndpointsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_webhook_endpoint>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postWebhookEndpoints(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postWebhookEndpointsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const deleteWebhookEndpointsWebhookEndpointBodySchema = z.never().optional()

  const deleteWebhookEndpointsWebhookEndpointResponseValidator =
    responseValidationFactory([["200", s_deleted_webhook_endpoint]], s_error)

  router.delete(
    "deleteWebhookEndpointsWebhookEndpoint",
    "/v1/webhook_endpoints/:webhook_endpoint",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteWebhookEndpointsWebhookEndpointParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteWebhookEndpointsWebhookEndpointBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_deleted_webhook_endpoint>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteWebhookEndpointsWebhookEndpoint(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteWebhookEndpointsWebhookEndpointResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  const getWebhookEndpointsWebhookEndpointQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const getWebhookEndpointsWebhookEndpointBodySchema = z.never().optional()

  const getWebhookEndpointsWebhookEndpointResponseValidator =
    responseValidationFactory([["200", s_webhook_endpoint]], s_error)

  router.get(
    "getWebhookEndpointsWebhookEndpoint",
    "/v1/webhook_endpoints/:webhook_endpoint",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWebhookEndpointsWebhookEndpointParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWebhookEndpointsWebhookEndpointQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getWebhookEndpointsWebhookEndpointBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_webhook_endpoint>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getWebhookEndpointsWebhookEndpoint(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWebhookEndpointsWebhookEndpointResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  // todo: request bodies with content-type 'application/x-www-form-urlencoded' not yet supported

  const postWebhookEndpointsWebhookEndpointBodySchema = z.never().optional()

  const postWebhookEndpointsWebhookEndpointResponseValidator =
    responseValidationFactory([["200", s_webhook_endpoint]], s_error)

  router.post(
    "postWebhookEndpointsWebhookEndpoint",
    "/v1/webhook_endpoints/:webhook_endpoint",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postWebhookEndpointsWebhookEndpointParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postWebhookEndpointsWebhookEndpointBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_webhook_endpoint>(200)
        },
        withDefault(status: StatusCode) {
          return new KoaRuntimeResponse<t_error>(status)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .postWebhookEndpointsWebhookEndpoint(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postWebhookEndpointsWebhookEndpointResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Stripe API
  return startServer(config)
}
