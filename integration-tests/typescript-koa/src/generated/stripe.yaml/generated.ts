/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_DeleteAccountsAccountBankAccountsIdBodySchema,
  t_DeleteAccountsAccountBankAccountsIdParamSchema,
  t_DeleteAccountsAccountBodySchema,
  t_DeleteAccountsAccountExternalAccountsIdBodySchema,
  t_DeleteAccountsAccountExternalAccountsIdParamSchema,
  t_DeleteAccountsAccountParamSchema,
  t_DeleteAccountsAccountPeoplePersonBodySchema,
  t_DeleteAccountsAccountPeoplePersonParamSchema,
  t_DeleteAccountsAccountPersonsPersonBodySchema,
  t_DeleteAccountsAccountPersonsPersonParamSchema,
  t_DeleteApplePayDomainsDomainBodySchema,
  t_DeleteApplePayDomainsDomainParamSchema,
  t_DeleteCouponsCouponBodySchema,
  t_DeleteCouponsCouponParamSchema,
  t_DeleteCustomersCustomerBankAccountsIdBodySchema,
  t_DeleteCustomersCustomerBankAccountsIdParamSchema,
  t_DeleteCustomersCustomerBodySchema,
  t_DeleteCustomersCustomerCardsIdBodySchema,
  t_DeleteCustomersCustomerCardsIdParamSchema,
  t_DeleteCustomersCustomerDiscountBodySchema,
  t_DeleteCustomersCustomerDiscountParamSchema,
  t_DeleteCustomersCustomerParamSchema,
  t_DeleteCustomersCustomerSourcesIdBodySchema,
  t_DeleteCustomersCustomerSourcesIdParamSchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_DeleteCustomersCustomerTaxIdsIdBodySchema,
  t_DeleteCustomersCustomerTaxIdsIdParamSchema,
  t_DeleteEphemeralKeysKeyBodySchema,
  t_DeleteEphemeralKeysKeyParamSchema,
  t_DeleteInvoiceitemsInvoiceitemBodySchema,
  t_DeleteInvoiceitemsInvoiceitemParamSchema,
  t_DeleteInvoicesInvoiceBodySchema,
  t_DeleteInvoicesInvoiceParamSchema,
  t_DeletePlansPlanBodySchema,
  t_DeletePlansPlanParamSchema,
  t_DeleteProductsIdBodySchema,
  t_DeleteProductsIdParamSchema,
  t_DeleteProductsProductFeaturesIdBodySchema,
  t_DeleteProductsProductFeaturesIdParamSchema,
  t_DeleteRadarValueListItemsItemBodySchema,
  t_DeleteRadarValueListItemsItemParamSchema,
  t_DeleteRadarValueListsValueListBodySchema,
  t_DeleteRadarValueListsValueListParamSchema,
  t_DeleteSubscriptionItemsItemBodySchema,
  t_DeleteSubscriptionItemsItemParamSchema,
  t_DeleteSubscriptionsSubscriptionExposedIdBodySchema,
  t_DeleteSubscriptionsSubscriptionExposedIdDiscountBodySchema,
  t_DeleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_DeleteSubscriptionsSubscriptionExposedIdParamSchema,
  t_DeleteTaxIdsIdBodySchema,
  t_DeleteTaxIdsIdParamSchema,
  t_DeleteTerminalConfigurationsConfigurationBodySchema,
  t_DeleteTerminalConfigurationsConfigurationParamSchema,
  t_DeleteTerminalLocationsLocationBodySchema,
  t_DeleteTerminalLocationsLocationParamSchema,
  t_DeleteTerminalReadersReaderBodySchema,
  t_DeleteTerminalReadersReaderParamSchema,
  t_DeleteTestHelpersTestClocksTestClockBodySchema,
  t_DeleteTestHelpersTestClocksTestClockParamSchema,
  t_DeleteWebhookEndpointsWebhookEndpointBodySchema,
  t_DeleteWebhookEndpointsWebhookEndpointParamSchema,
  t_GetAccountBodySchema,
  t_GetAccountQuerySchema,
  t_GetAccountsAccountBankAccountsIdBodySchema,
  t_GetAccountsAccountBankAccountsIdParamSchema,
  t_GetAccountsAccountBankAccountsIdQuerySchema,
  t_GetAccountsAccountBodySchema,
  t_GetAccountsAccountCapabilitiesBodySchema,
  t_GetAccountsAccountCapabilitiesCapabilityBodySchema,
  t_GetAccountsAccountCapabilitiesCapabilityParamSchema,
  t_GetAccountsAccountCapabilitiesCapabilityQuerySchema,
  t_GetAccountsAccountCapabilitiesParamSchema,
  t_GetAccountsAccountCapabilitiesQuerySchema,
  t_GetAccountsAccountExternalAccountsBodySchema,
  t_GetAccountsAccountExternalAccountsIdBodySchema,
  t_GetAccountsAccountExternalAccountsIdParamSchema,
  t_GetAccountsAccountExternalAccountsIdQuerySchema,
  t_GetAccountsAccountExternalAccountsParamSchema,
  t_GetAccountsAccountExternalAccountsQuerySchema,
  t_GetAccountsAccountParamSchema,
  t_GetAccountsAccountPeopleBodySchema,
  t_GetAccountsAccountPeopleParamSchema,
  t_GetAccountsAccountPeoplePersonBodySchema,
  t_GetAccountsAccountPeoplePersonParamSchema,
  t_GetAccountsAccountPeoplePersonQuerySchema,
  t_GetAccountsAccountPeopleQuerySchema,
  t_GetAccountsAccountPersonsBodySchema,
  t_GetAccountsAccountPersonsParamSchema,
  t_GetAccountsAccountPersonsPersonBodySchema,
  t_GetAccountsAccountPersonsPersonParamSchema,
  t_GetAccountsAccountPersonsPersonQuerySchema,
  t_GetAccountsAccountPersonsQuerySchema,
  t_GetAccountsAccountQuerySchema,
  t_GetAccountsBodySchema,
  t_GetAccountsQuerySchema,
  t_GetApplePayDomainsBodySchema,
  t_GetApplePayDomainsDomainBodySchema,
  t_GetApplePayDomainsDomainParamSchema,
  t_GetApplePayDomainsDomainQuerySchema,
  t_GetApplePayDomainsQuerySchema,
  t_GetApplicationFeesBodySchema,
  t_GetApplicationFeesFeeRefundsIdBodySchema,
  t_GetApplicationFeesFeeRefundsIdParamSchema,
  t_GetApplicationFeesFeeRefundsIdQuerySchema,
  t_GetApplicationFeesIdBodySchema,
  t_GetApplicationFeesIdParamSchema,
  t_GetApplicationFeesIdQuerySchema,
  t_GetApplicationFeesIdRefundsBodySchema,
  t_GetApplicationFeesIdRefundsParamSchema,
  t_GetApplicationFeesIdRefundsQuerySchema,
  t_GetApplicationFeesQuerySchema,
  t_GetAppsSecretsBodySchema,
  t_GetAppsSecretsFindBodySchema,
  t_GetAppsSecretsFindQuerySchema,
  t_GetAppsSecretsQuerySchema,
  t_GetBalanceBodySchema,
  t_GetBalanceHistoryBodySchema,
  t_GetBalanceHistoryIdBodySchema,
  t_GetBalanceHistoryIdParamSchema,
  t_GetBalanceHistoryIdQuerySchema,
  t_GetBalanceHistoryQuerySchema,
  t_GetBalanceQuerySchema,
  t_GetBalanceTransactionsBodySchema,
  t_GetBalanceTransactionsIdBodySchema,
  t_GetBalanceTransactionsIdParamSchema,
  t_GetBalanceTransactionsIdQuerySchema,
  t_GetBalanceTransactionsQuerySchema,
  t_GetBillingAlertsBodySchema,
  t_GetBillingAlertsIdBodySchema,
  t_GetBillingAlertsIdParamSchema,
  t_GetBillingAlertsIdQuerySchema,
  t_GetBillingAlertsQuerySchema,
  t_GetBillingCreditBalanceSummaryBodySchema,
  t_GetBillingCreditBalanceSummaryQuerySchema,
  t_GetBillingCreditBalanceTransactionsBodySchema,
  t_GetBillingCreditBalanceTransactionsIdBodySchema,
  t_GetBillingCreditBalanceTransactionsIdParamSchema,
  t_GetBillingCreditBalanceTransactionsIdQuerySchema,
  t_GetBillingCreditBalanceTransactionsQuerySchema,
  t_GetBillingCreditGrantsBodySchema,
  t_GetBillingCreditGrantsIdBodySchema,
  t_GetBillingCreditGrantsIdParamSchema,
  t_GetBillingCreditGrantsIdQuerySchema,
  t_GetBillingCreditGrantsQuerySchema,
  t_GetBillingMetersBodySchema,
  t_GetBillingMetersIdBodySchema,
  t_GetBillingMetersIdEventSummariesBodySchema,
  t_GetBillingMetersIdEventSummariesParamSchema,
  t_GetBillingMetersIdEventSummariesQuerySchema,
  t_GetBillingMetersIdParamSchema,
  t_GetBillingMetersIdQuerySchema,
  t_GetBillingMetersQuerySchema,
  t_GetBillingPortalConfigurationsBodySchema,
  t_GetBillingPortalConfigurationsConfigurationBodySchema,
  t_GetBillingPortalConfigurationsConfigurationParamSchema,
  t_GetBillingPortalConfigurationsConfigurationQuerySchema,
  t_GetBillingPortalConfigurationsQuerySchema,
  t_GetChargesBodySchema,
  t_GetChargesChargeBodySchema,
  t_GetChargesChargeDisputeBodySchema,
  t_GetChargesChargeDisputeParamSchema,
  t_GetChargesChargeDisputeQuerySchema,
  t_GetChargesChargeParamSchema,
  t_GetChargesChargeQuerySchema,
  t_GetChargesChargeRefundsBodySchema,
  t_GetChargesChargeRefundsParamSchema,
  t_GetChargesChargeRefundsQuerySchema,
  t_GetChargesChargeRefundsRefundBodySchema,
  t_GetChargesChargeRefundsRefundParamSchema,
  t_GetChargesChargeRefundsRefundQuerySchema,
  t_GetChargesQuerySchema,
  t_GetChargesSearchBodySchema,
  t_GetChargesSearchQuerySchema,
  t_GetCheckoutSessionsBodySchema,
  t_GetCheckoutSessionsQuerySchema,
  t_GetCheckoutSessionsSessionBodySchema,
  t_GetCheckoutSessionsSessionLineItemsBodySchema,
  t_GetCheckoutSessionsSessionLineItemsParamSchema,
  t_GetCheckoutSessionsSessionLineItemsQuerySchema,
  t_GetCheckoutSessionsSessionParamSchema,
  t_GetCheckoutSessionsSessionQuerySchema,
  t_GetClimateOrdersBodySchema,
  t_GetClimateOrdersOrderBodySchema,
  t_GetClimateOrdersOrderParamSchema,
  t_GetClimateOrdersOrderQuerySchema,
  t_GetClimateOrdersQuerySchema,
  t_GetClimateProductsBodySchema,
  t_GetClimateProductsProductBodySchema,
  t_GetClimateProductsProductParamSchema,
  t_GetClimateProductsProductQuerySchema,
  t_GetClimateProductsQuerySchema,
  t_GetClimateSuppliersBodySchema,
  t_GetClimateSuppliersQuerySchema,
  t_GetClimateSuppliersSupplierBodySchema,
  t_GetClimateSuppliersSupplierParamSchema,
  t_GetClimateSuppliersSupplierQuerySchema,
  t_GetConfirmationTokensConfirmationTokenBodySchema,
  t_GetConfirmationTokensConfirmationTokenParamSchema,
  t_GetConfirmationTokensConfirmationTokenQuerySchema,
  t_GetCountrySpecsBodySchema,
  t_GetCountrySpecsCountryBodySchema,
  t_GetCountrySpecsCountryParamSchema,
  t_GetCountrySpecsCountryQuerySchema,
  t_GetCountrySpecsQuerySchema,
  t_GetCouponsBodySchema,
  t_GetCouponsCouponBodySchema,
  t_GetCouponsCouponParamSchema,
  t_GetCouponsCouponQuerySchema,
  t_GetCouponsQuerySchema,
  t_GetCreditNotesBodySchema,
  t_GetCreditNotesCreditNoteLinesBodySchema,
  t_GetCreditNotesCreditNoteLinesParamSchema,
  t_GetCreditNotesCreditNoteLinesQuerySchema,
  t_GetCreditNotesIdBodySchema,
  t_GetCreditNotesIdParamSchema,
  t_GetCreditNotesIdQuerySchema,
  t_GetCreditNotesPreviewBodySchema,
  t_GetCreditNotesPreviewLinesBodySchema,
  t_GetCreditNotesPreviewLinesQuerySchema,
  t_GetCreditNotesPreviewQuerySchema,
  t_GetCreditNotesQuerySchema,
  t_GetCustomersBodySchema,
  t_GetCustomersCustomerBalanceTransactionsBodySchema,
  t_GetCustomersCustomerBalanceTransactionsParamSchema,
  t_GetCustomersCustomerBalanceTransactionsQuerySchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionBodySchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionParamSchema,
  t_GetCustomersCustomerBalanceTransactionsTransactionQuerySchema,
  t_GetCustomersCustomerBankAccountsBodySchema,
  t_GetCustomersCustomerBankAccountsIdBodySchema,
  t_GetCustomersCustomerBankAccountsIdParamSchema,
  t_GetCustomersCustomerBankAccountsIdQuerySchema,
  t_GetCustomersCustomerBankAccountsParamSchema,
  t_GetCustomersCustomerBankAccountsQuerySchema,
  t_GetCustomersCustomerBodySchema,
  t_GetCustomersCustomerCardsBodySchema,
  t_GetCustomersCustomerCardsIdBodySchema,
  t_GetCustomersCustomerCardsIdParamSchema,
  t_GetCustomersCustomerCardsIdQuerySchema,
  t_GetCustomersCustomerCardsParamSchema,
  t_GetCustomersCustomerCardsQuerySchema,
  t_GetCustomersCustomerCashBalanceBodySchema,
  t_GetCustomersCustomerCashBalanceParamSchema,
  t_GetCustomersCustomerCashBalanceQuerySchema,
  t_GetCustomersCustomerCashBalanceTransactionsBodySchema,
  t_GetCustomersCustomerCashBalanceTransactionsParamSchema,
  t_GetCustomersCustomerCashBalanceTransactionsQuerySchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionBodySchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
  t_GetCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
  t_GetCustomersCustomerDiscountBodySchema,
  t_GetCustomersCustomerDiscountParamSchema,
  t_GetCustomersCustomerDiscountQuerySchema,
  t_GetCustomersCustomerParamSchema,
  t_GetCustomersCustomerPaymentMethodsBodySchema,
  t_GetCustomersCustomerPaymentMethodsParamSchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodBodySchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
  t_GetCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
  t_GetCustomersCustomerPaymentMethodsQuerySchema,
  t_GetCustomersCustomerQuerySchema,
  t_GetCustomersCustomerSourcesBodySchema,
  t_GetCustomersCustomerSourcesIdBodySchema,
  t_GetCustomersCustomerSourcesIdParamSchema,
  t_GetCustomersCustomerSourcesIdQuerySchema,
  t_GetCustomersCustomerSourcesParamSchema,
  t_GetCustomersCustomerSourcesQuerySchema,
  t_GetCustomersCustomerSubscriptionsBodySchema,
  t_GetCustomersCustomerSubscriptionsParamSchema,
  t_GetCustomersCustomerSubscriptionsQuerySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
  t_GetCustomersCustomerTaxIdsBodySchema,
  t_GetCustomersCustomerTaxIdsIdBodySchema,
  t_GetCustomersCustomerTaxIdsIdParamSchema,
  t_GetCustomersCustomerTaxIdsIdQuerySchema,
  t_GetCustomersCustomerTaxIdsParamSchema,
  t_GetCustomersCustomerTaxIdsQuerySchema,
  t_GetCustomersQuerySchema,
  t_GetCustomersSearchBodySchema,
  t_GetCustomersSearchQuerySchema,
  t_GetDisputesBodySchema,
  t_GetDisputesDisputeBodySchema,
  t_GetDisputesDisputeParamSchema,
  t_GetDisputesDisputeQuerySchema,
  t_GetDisputesQuerySchema,
  t_GetEntitlementsActiveEntitlementsBodySchema,
  t_GetEntitlementsActiveEntitlementsIdBodySchema,
  t_GetEntitlementsActiveEntitlementsIdParamSchema,
  t_GetEntitlementsActiveEntitlementsIdQuerySchema,
  t_GetEntitlementsActiveEntitlementsQuerySchema,
  t_GetEntitlementsFeaturesBodySchema,
  t_GetEntitlementsFeaturesIdBodySchema,
  t_GetEntitlementsFeaturesIdParamSchema,
  t_GetEntitlementsFeaturesIdQuerySchema,
  t_GetEntitlementsFeaturesQuerySchema,
  t_GetEventsBodySchema,
  t_GetEventsIdBodySchema,
  t_GetEventsIdParamSchema,
  t_GetEventsIdQuerySchema,
  t_GetEventsQuerySchema,
  t_GetExchangeRatesBodySchema,
  t_GetExchangeRatesQuerySchema,
  t_GetExchangeRatesRateIdBodySchema,
  t_GetExchangeRatesRateIdParamSchema,
  t_GetExchangeRatesRateIdQuerySchema,
  t_GetFileLinksBodySchema,
  t_GetFileLinksLinkBodySchema,
  t_GetFileLinksLinkParamSchema,
  t_GetFileLinksLinkQuerySchema,
  t_GetFileLinksQuerySchema,
  t_GetFilesBodySchema,
  t_GetFilesFileBodySchema,
  t_GetFilesFileParamSchema,
  t_GetFilesFileQuerySchema,
  t_GetFilesQuerySchema,
  t_GetFinancialConnectionsAccountsAccountBodySchema,
  t_GetFinancialConnectionsAccountsAccountOwnersBodySchema,
  t_GetFinancialConnectionsAccountsAccountOwnersParamSchema,
  t_GetFinancialConnectionsAccountsAccountOwnersQuerySchema,
  t_GetFinancialConnectionsAccountsAccountParamSchema,
  t_GetFinancialConnectionsAccountsAccountQuerySchema,
  t_GetFinancialConnectionsAccountsBodySchema,
  t_GetFinancialConnectionsAccountsQuerySchema,
  t_GetFinancialConnectionsSessionsSessionBodySchema,
  t_GetFinancialConnectionsSessionsSessionParamSchema,
  t_GetFinancialConnectionsSessionsSessionQuerySchema,
  t_GetFinancialConnectionsTransactionsBodySchema,
  t_GetFinancialConnectionsTransactionsQuerySchema,
  t_GetFinancialConnectionsTransactionsTransactionBodySchema,
  t_GetFinancialConnectionsTransactionsTransactionParamSchema,
  t_GetFinancialConnectionsTransactionsTransactionQuerySchema,
  t_GetForwardingRequestsBodySchema,
  t_GetForwardingRequestsIdBodySchema,
  t_GetForwardingRequestsIdParamSchema,
  t_GetForwardingRequestsIdQuerySchema,
  t_GetForwardingRequestsQuerySchema,
  t_GetIdentityVerificationReportsBodySchema,
  t_GetIdentityVerificationReportsQuerySchema,
  t_GetIdentityVerificationReportsReportBodySchema,
  t_GetIdentityVerificationReportsReportParamSchema,
  t_GetIdentityVerificationReportsReportQuerySchema,
  t_GetIdentityVerificationSessionsBodySchema,
  t_GetIdentityVerificationSessionsQuerySchema,
  t_GetIdentityVerificationSessionsSessionBodySchema,
  t_GetIdentityVerificationSessionsSessionParamSchema,
  t_GetIdentityVerificationSessionsSessionQuerySchema,
  t_GetInvoicePaymentsBodySchema,
  t_GetInvoicePaymentsInvoicePaymentBodySchema,
  t_GetInvoicePaymentsInvoicePaymentParamSchema,
  t_GetInvoicePaymentsInvoicePaymentQuerySchema,
  t_GetInvoicePaymentsQuerySchema,
  t_GetInvoiceRenderingTemplatesBodySchema,
  t_GetInvoiceRenderingTemplatesQuerySchema,
  t_GetInvoiceRenderingTemplatesTemplateBodySchema,
  t_GetInvoiceRenderingTemplatesTemplateParamSchema,
  t_GetInvoiceRenderingTemplatesTemplateQuerySchema,
  t_GetInvoiceitemsBodySchema,
  t_GetInvoiceitemsInvoiceitemBodySchema,
  t_GetInvoiceitemsInvoiceitemParamSchema,
  t_GetInvoiceitemsInvoiceitemQuerySchema,
  t_GetInvoiceitemsQuerySchema,
  t_GetInvoicesBodySchema,
  t_GetInvoicesInvoiceBodySchema,
  t_GetInvoicesInvoiceLinesBodySchema,
  t_GetInvoicesInvoiceLinesParamSchema,
  t_GetInvoicesInvoiceLinesQuerySchema,
  t_GetInvoicesInvoiceParamSchema,
  t_GetInvoicesInvoiceQuerySchema,
  t_GetInvoicesQuerySchema,
  t_GetInvoicesSearchBodySchema,
  t_GetInvoicesSearchQuerySchema,
  t_GetIssuingAuthorizationsAuthorizationBodySchema,
  t_GetIssuingAuthorizationsAuthorizationParamSchema,
  t_GetIssuingAuthorizationsAuthorizationQuerySchema,
  t_GetIssuingAuthorizationsBodySchema,
  t_GetIssuingAuthorizationsQuerySchema,
  t_GetIssuingCardholdersBodySchema,
  t_GetIssuingCardholdersCardholderBodySchema,
  t_GetIssuingCardholdersCardholderParamSchema,
  t_GetIssuingCardholdersCardholderQuerySchema,
  t_GetIssuingCardholdersQuerySchema,
  t_GetIssuingCardsBodySchema,
  t_GetIssuingCardsCardBodySchema,
  t_GetIssuingCardsCardParamSchema,
  t_GetIssuingCardsCardQuerySchema,
  t_GetIssuingCardsQuerySchema,
  t_GetIssuingDisputesBodySchema,
  t_GetIssuingDisputesDisputeBodySchema,
  t_GetIssuingDisputesDisputeParamSchema,
  t_GetIssuingDisputesDisputeQuerySchema,
  t_GetIssuingDisputesQuerySchema,
  t_GetIssuingPersonalizationDesignsBodySchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
  t_GetIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
  t_GetIssuingPersonalizationDesignsQuerySchema,
  t_GetIssuingPhysicalBundlesBodySchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleBodySchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleParamSchema,
  t_GetIssuingPhysicalBundlesPhysicalBundleQuerySchema,
  t_GetIssuingPhysicalBundlesQuerySchema,
  t_GetIssuingSettlementsSettlementBodySchema,
  t_GetIssuingSettlementsSettlementParamSchema,
  t_GetIssuingSettlementsSettlementQuerySchema,
  t_GetIssuingTokensBodySchema,
  t_GetIssuingTokensQuerySchema,
  t_GetIssuingTokensTokenBodySchema,
  t_GetIssuingTokensTokenParamSchema,
  t_GetIssuingTokensTokenQuerySchema,
  t_GetIssuingTransactionsBodySchema,
  t_GetIssuingTransactionsQuerySchema,
  t_GetIssuingTransactionsTransactionBodySchema,
  t_GetIssuingTransactionsTransactionParamSchema,
  t_GetIssuingTransactionsTransactionQuerySchema,
  t_GetLinkAccountSessionsSessionBodySchema,
  t_GetLinkAccountSessionsSessionParamSchema,
  t_GetLinkAccountSessionsSessionQuerySchema,
  t_GetLinkedAccountsAccountBodySchema,
  t_GetLinkedAccountsAccountOwnersBodySchema,
  t_GetLinkedAccountsAccountOwnersParamSchema,
  t_GetLinkedAccountsAccountOwnersQuerySchema,
  t_GetLinkedAccountsAccountParamSchema,
  t_GetLinkedAccountsAccountQuerySchema,
  t_GetLinkedAccountsBodySchema,
  t_GetLinkedAccountsQuerySchema,
  t_GetMandatesMandateBodySchema,
  t_GetMandatesMandateParamSchema,
  t_GetMandatesMandateQuerySchema,
  t_GetPaymentIntentsBodySchema,
  t_GetPaymentIntentsIntentBodySchema,
  t_GetPaymentIntentsIntentParamSchema,
  t_GetPaymentIntentsIntentQuerySchema,
  t_GetPaymentIntentsQuerySchema,
  t_GetPaymentIntentsSearchBodySchema,
  t_GetPaymentIntentsSearchQuerySchema,
  t_GetPaymentLinksBodySchema,
  t_GetPaymentLinksPaymentLinkBodySchema,
  t_GetPaymentLinksPaymentLinkLineItemsBodySchema,
  t_GetPaymentLinksPaymentLinkLineItemsParamSchema,
  t_GetPaymentLinksPaymentLinkLineItemsQuerySchema,
  t_GetPaymentLinksPaymentLinkParamSchema,
  t_GetPaymentLinksPaymentLinkQuerySchema,
  t_GetPaymentLinksQuerySchema,
  t_GetPaymentMethodConfigurationsBodySchema,
  t_GetPaymentMethodConfigurationsConfigurationBodySchema,
  t_GetPaymentMethodConfigurationsConfigurationParamSchema,
  t_GetPaymentMethodConfigurationsConfigurationQuerySchema,
  t_GetPaymentMethodConfigurationsQuerySchema,
  t_GetPaymentMethodDomainsBodySchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainBodySchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainParamSchema,
  t_GetPaymentMethodDomainsPaymentMethodDomainQuerySchema,
  t_GetPaymentMethodDomainsQuerySchema,
  t_GetPaymentMethodsBodySchema,
  t_GetPaymentMethodsPaymentMethodBodySchema,
  t_GetPaymentMethodsPaymentMethodParamSchema,
  t_GetPaymentMethodsPaymentMethodQuerySchema,
  t_GetPaymentMethodsQuerySchema,
  t_GetPayoutsBodySchema,
  t_GetPayoutsPayoutBodySchema,
  t_GetPayoutsPayoutParamSchema,
  t_GetPayoutsPayoutQuerySchema,
  t_GetPayoutsQuerySchema,
  t_GetPlansBodySchema,
  t_GetPlansPlanBodySchema,
  t_GetPlansPlanParamSchema,
  t_GetPlansPlanQuerySchema,
  t_GetPlansQuerySchema,
  t_GetPricesBodySchema,
  t_GetPricesPriceBodySchema,
  t_GetPricesPriceParamSchema,
  t_GetPricesPriceQuerySchema,
  t_GetPricesQuerySchema,
  t_GetPricesSearchBodySchema,
  t_GetPricesSearchQuerySchema,
  t_GetProductsBodySchema,
  t_GetProductsIdBodySchema,
  t_GetProductsIdParamSchema,
  t_GetProductsIdQuerySchema,
  t_GetProductsProductFeaturesBodySchema,
  t_GetProductsProductFeaturesIdBodySchema,
  t_GetProductsProductFeaturesIdParamSchema,
  t_GetProductsProductFeaturesIdQuerySchema,
  t_GetProductsProductFeaturesParamSchema,
  t_GetProductsProductFeaturesQuerySchema,
  t_GetProductsQuerySchema,
  t_GetProductsSearchBodySchema,
  t_GetProductsSearchQuerySchema,
  t_GetPromotionCodesBodySchema,
  t_GetPromotionCodesPromotionCodeBodySchema,
  t_GetPromotionCodesPromotionCodeParamSchema,
  t_GetPromotionCodesPromotionCodeQuerySchema,
  t_GetPromotionCodesQuerySchema,
  t_GetQuotesBodySchema,
  t_GetQuotesQuerySchema,
  t_GetQuotesQuoteBodySchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsBodySchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsParamSchema,
  t_GetQuotesQuoteComputedUpfrontLineItemsQuerySchema,
  t_GetQuotesQuoteLineItemsBodySchema,
  t_GetQuotesQuoteLineItemsParamSchema,
  t_GetQuotesQuoteLineItemsQuerySchema,
  t_GetQuotesQuoteParamSchema,
  t_GetQuotesQuotePdfBodySchema,
  t_GetQuotesQuotePdfParamSchema,
  t_GetQuotesQuotePdfQuerySchema,
  t_GetQuotesQuoteQuerySchema,
  t_GetRadarEarlyFraudWarningsBodySchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningBodySchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
  t_GetRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
  t_GetRadarEarlyFraudWarningsQuerySchema,
  t_GetRadarValueListItemsBodySchema,
  t_GetRadarValueListItemsItemBodySchema,
  t_GetRadarValueListItemsItemParamSchema,
  t_GetRadarValueListItemsItemQuerySchema,
  t_GetRadarValueListItemsQuerySchema,
  t_GetRadarValueListsBodySchema,
  t_GetRadarValueListsQuerySchema,
  t_GetRadarValueListsValueListBodySchema,
  t_GetRadarValueListsValueListParamSchema,
  t_GetRadarValueListsValueListQuerySchema,
  t_GetRefundsBodySchema,
  t_GetRefundsQuerySchema,
  t_GetRefundsRefundBodySchema,
  t_GetRefundsRefundParamSchema,
  t_GetRefundsRefundQuerySchema,
  t_GetReportingReportRunsBodySchema,
  t_GetReportingReportRunsQuerySchema,
  t_GetReportingReportRunsReportRunBodySchema,
  t_GetReportingReportRunsReportRunParamSchema,
  t_GetReportingReportRunsReportRunQuerySchema,
  t_GetReportingReportTypesBodySchema,
  t_GetReportingReportTypesQuerySchema,
  t_GetReportingReportTypesReportTypeBodySchema,
  t_GetReportingReportTypesReportTypeParamSchema,
  t_GetReportingReportTypesReportTypeQuerySchema,
  t_GetReviewsBodySchema,
  t_GetReviewsQuerySchema,
  t_GetReviewsReviewBodySchema,
  t_GetReviewsReviewParamSchema,
  t_GetReviewsReviewQuerySchema,
  t_GetSetupAttemptsBodySchema,
  t_GetSetupAttemptsQuerySchema,
  t_GetSetupIntentsBodySchema,
  t_GetSetupIntentsIntentBodySchema,
  t_GetSetupIntentsIntentParamSchema,
  t_GetSetupIntentsIntentQuerySchema,
  t_GetSetupIntentsQuerySchema,
  t_GetShippingRatesBodySchema,
  t_GetShippingRatesQuerySchema,
  t_GetShippingRatesShippingRateTokenBodySchema,
  t_GetShippingRatesShippingRateTokenParamSchema,
  t_GetShippingRatesShippingRateTokenQuerySchema,
  t_GetSigmaScheduledQueryRunsBodySchema,
  t_GetSigmaScheduledQueryRunsQuerySchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunBodySchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
  t_GetSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
  t_GetSourcesSourceBodySchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationBodySchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationParamSchema,
  t_GetSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
  t_GetSourcesSourceParamSchema,
  t_GetSourcesSourceQuerySchema,
  t_GetSourcesSourceSourceTransactionsBodySchema,
  t_GetSourcesSourceSourceTransactionsParamSchema,
  t_GetSourcesSourceSourceTransactionsQuerySchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionBodySchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionParamSchema,
  t_GetSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
  t_GetSubscriptionItemsBodySchema,
  t_GetSubscriptionItemsItemBodySchema,
  t_GetSubscriptionItemsItemParamSchema,
  t_GetSubscriptionItemsItemQuerySchema,
  t_GetSubscriptionItemsQuerySchema,
  t_GetSubscriptionSchedulesBodySchema,
  t_GetSubscriptionSchedulesQuerySchema,
  t_GetSubscriptionSchedulesScheduleBodySchema,
  t_GetSubscriptionSchedulesScheduleParamSchema,
  t_GetSubscriptionSchedulesScheduleQuerySchema,
  t_GetSubscriptionsBodySchema,
  t_GetSubscriptionsQuerySchema,
  t_GetSubscriptionsSearchBodySchema,
  t_GetSubscriptionsSearchQuerySchema,
  t_GetSubscriptionsSubscriptionExposedIdBodySchema,
  t_GetSubscriptionsSubscriptionExposedIdParamSchema,
  t_GetSubscriptionsSubscriptionExposedIdQuerySchema,
  t_GetTaxCalculationsCalculationBodySchema,
  t_GetTaxCalculationsCalculationLineItemsBodySchema,
  t_GetTaxCalculationsCalculationLineItemsParamSchema,
  t_GetTaxCalculationsCalculationLineItemsQuerySchema,
  t_GetTaxCalculationsCalculationParamSchema,
  t_GetTaxCalculationsCalculationQuerySchema,
  t_GetTaxCodesBodySchema,
  t_GetTaxCodesIdBodySchema,
  t_GetTaxCodesIdParamSchema,
  t_GetTaxCodesIdQuerySchema,
  t_GetTaxCodesQuerySchema,
  t_GetTaxIdsBodySchema,
  t_GetTaxIdsIdBodySchema,
  t_GetTaxIdsIdParamSchema,
  t_GetTaxIdsIdQuerySchema,
  t_GetTaxIdsQuerySchema,
  t_GetTaxRatesBodySchema,
  t_GetTaxRatesQuerySchema,
  t_GetTaxRatesTaxRateBodySchema,
  t_GetTaxRatesTaxRateParamSchema,
  t_GetTaxRatesTaxRateQuerySchema,
  t_GetTaxRegistrationsBodySchema,
  t_GetTaxRegistrationsIdBodySchema,
  t_GetTaxRegistrationsIdParamSchema,
  t_GetTaxRegistrationsIdQuerySchema,
  t_GetTaxRegistrationsQuerySchema,
  t_GetTaxSettingsBodySchema,
  t_GetTaxSettingsQuerySchema,
  t_GetTaxTransactionsTransactionBodySchema,
  t_GetTaxTransactionsTransactionLineItemsBodySchema,
  t_GetTaxTransactionsTransactionLineItemsParamSchema,
  t_GetTaxTransactionsTransactionLineItemsQuerySchema,
  t_GetTaxTransactionsTransactionParamSchema,
  t_GetTaxTransactionsTransactionQuerySchema,
  t_GetTerminalConfigurationsBodySchema,
  t_GetTerminalConfigurationsConfigurationBodySchema,
  t_GetTerminalConfigurationsConfigurationParamSchema,
  t_GetTerminalConfigurationsConfigurationQuerySchema,
  t_GetTerminalConfigurationsQuerySchema,
  t_GetTerminalLocationsBodySchema,
  t_GetTerminalLocationsLocationBodySchema,
  t_GetTerminalLocationsLocationParamSchema,
  t_GetTerminalLocationsLocationQuerySchema,
  t_GetTerminalLocationsQuerySchema,
  t_GetTerminalReadersBodySchema,
  t_GetTerminalReadersQuerySchema,
  t_GetTerminalReadersReaderBodySchema,
  t_GetTerminalReadersReaderParamSchema,
  t_GetTerminalReadersReaderQuerySchema,
  t_GetTestHelpersTestClocksBodySchema,
  t_GetTestHelpersTestClocksQuerySchema,
  t_GetTestHelpersTestClocksTestClockBodySchema,
  t_GetTestHelpersTestClocksTestClockParamSchema,
  t_GetTestHelpersTestClocksTestClockQuerySchema,
  t_GetTokensTokenBodySchema,
  t_GetTokensTokenParamSchema,
  t_GetTokensTokenQuerySchema,
  t_GetTopupsBodySchema,
  t_GetTopupsQuerySchema,
  t_GetTopupsTopupBodySchema,
  t_GetTopupsTopupParamSchema,
  t_GetTopupsTopupQuerySchema,
  t_GetTransfersBodySchema,
  t_GetTransfersIdReversalsBodySchema,
  t_GetTransfersIdReversalsParamSchema,
  t_GetTransfersIdReversalsQuerySchema,
  t_GetTransfersQuerySchema,
  t_GetTransfersTransferBodySchema,
  t_GetTransfersTransferParamSchema,
  t_GetTransfersTransferQuerySchema,
  t_GetTransfersTransferReversalsIdBodySchema,
  t_GetTransfersTransferReversalsIdParamSchema,
  t_GetTransfersTransferReversalsIdQuerySchema,
  t_GetTreasuryCreditReversalsBodySchema,
  t_GetTreasuryCreditReversalsCreditReversalBodySchema,
  t_GetTreasuryCreditReversalsCreditReversalParamSchema,
  t_GetTreasuryCreditReversalsCreditReversalQuerySchema,
  t_GetTreasuryCreditReversalsQuerySchema,
  t_GetTreasuryDebitReversalsBodySchema,
  t_GetTreasuryDebitReversalsDebitReversalBodySchema,
  t_GetTreasuryDebitReversalsDebitReversalParamSchema,
  t_GetTreasuryDebitReversalsDebitReversalQuerySchema,
  t_GetTreasuryDebitReversalsQuerySchema,
  t_GetTreasuryFinancialAccountsBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
  t_GetTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
  t_GetTreasuryFinancialAccountsFinancialAccountParamSchema,
  t_GetTreasuryFinancialAccountsFinancialAccountQuerySchema,
  t_GetTreasuryFinancialAccountsQuerySchema,
  t_GetTreasuryInboundTransfersBodySchema,
  t_GetTreasuryInboundTransfersIdBodySchema,
  t_GetTreasuryInboundTransfersIdParamSchema,
  t_GetTreasuryInboundTransfersIdQuerySchema,
  t_GetTreasuryInboundTransfersQuerySchema,
  t_GetTreasuryOutboundPaymentsBodySchema,
  t_GetTreasuryOutboundPaymentsIdBodySchema,
  t_GetTreasuryOutboundPaymentsIdParamSchema,
  t_GetTreasuryOutboundPaymentsIdQuerySchema,
  t_GetTreasuryOutboundPaymentsQuerySchema,
  t_GetTreasuryOutboundTransfersBodySchema,
  t_GetTreasuryOutboundTransfersOutboundTransferBodySchema,
  t_GetTreasuryOutboundTransfersOutboundTransferParamSchema,
  t_GetTreasuryOutboundTransfersOutboundTransferQuerySchema,
  t_GetTreasuryOutboundTransfersQuerySchema,
  t_GetTreasuryReceivedCreditsBodySchema,
  t_GetTreasuryReceivedCreditsIdBodySchema,
  t_GetTreasuryReceivedCreditsIdParamSchema,
  t_GetTreasuryReceivedCreditsIdQuerySchema,
  t_GetTreasuryReceivedCreditsQuerySchema,
  t_GetTreasuryReceivedDebitsBodySchema,
  t_GetTreasuryReceivedDebitsIdBodySchema,
  t_GetTreasuryReceivedDebitsIdParamSchema,
  t_GetTreasuryReceivedDebitsIdQuerySchema,
  t_GetTreasuryReceivedDebitsQuerySchema,
  t_GetTreasuryTransactionEntriesBodySchema,
  t_GetTreasuryTransactionEntriesIdBodySchema,
  t_GetTreasuryTransactionEntriesIdParamSchema,
  t_GetTreasuryTransactionEntriesIdQuerySchema,
  t_GetTreasuryTransactionEntriesQuerySchema,
  t_GetTreasuryTransactionsBodySchema,
  t_GetTreasuryTransactionsIdBodySchema,
  t_GetTreasuryTransactionsIdParamSchema,
  t_GetTreasuryTransactionsIdQuerySchema,
  t_GetTreasuryTransactionsQuerySchema,
  t_GetWebhookEndpointsBodySchema,
  t_GetWebhookEndpointsQuerySchema,
  t_GetWebhookEndpointsWebhookEndpointBodySchema,
  t_GetWebhookEndpointsWebhookEndpointParamSchema,
  t_GetWebhookEndpointsWebhookEndpointQuerySchema,
  t_PostAccountLinksBodySchema,
  t_PostAccountSessionsBodySchema,
  t_PostAccountsAccountBankAccountsBodySchema,
  t_PostAccountsAccountBankAccountsIdBodySchema,
  t_PostAccountsAccountBankAccountsIdParamSchema,
  t_PostAccountsAccountBankAccountsParamSchema,
  t_PostAccountsAccountBodySchema,
  t_PostAccountsAccountCapabilitiesCapabilityBodySchema,
  t_PostAccountsAccountCapabilitiesCapabilityParamSchema,
  t_PostAccountsAccountExternalAccountsBodySchema,
  t_PostAccountsAccountExternalAccountsIdBodySchema,
  t_PostAccountsAccountExternalAccountsIdParamSchema,
  t_PostAccountsAccountExternalAccountsParamSchema,
  t_PostAccountsAccountLoginLinksBodySchema,
  t_PostAccountsAccountLoginLinksParamSchema,
  t_PostAccountsAccountParamSchema,
  t_PostAccountsAccountPeopleBodySchema,
  t_PostAccountsAccountPeopleParamSchema,
  t_PostAccountsAccountPeoplePersonBodySchema,
  t_PostAccountsAccountPeoplePersonParamSchema,
  t_PostAccountsAccountPersonsBodySchema,
  t_PostAccountsAccountPersonsParamSchema,
  t_PostAccountsAccountPersonsPersonBodySchema,
  t_PostAccountsAccountPersonsPersonParamSchema,
  t_PostAccountsAccountRejectBodySchema,
  t_PostAccountsAccountRejectParamSchema,
  t_PostAccountsBodySchema,
  t_PostApplePayDomainsBodySchema,
  t_PostApplicationFeesFeeRefundsIdBodySchema,
  t_PostApplicationFeesFeeRefundsIdParamSchema,
  t_PostApplicationFeesIdRefundBodySchema,
  t_PostApplicationFeesIdRefundParamSchema,
  t_PostApplicationFeesIdRefundsBodySchema,
  t_PostApplicationFeesIdRefundsParamSchema,
  t_PostAppsSecretsBodySchema,
  t_PostAppsSecretsDeleteBodySchema,
  t_PostBillingAlertsBodySchema,
  t_PostBillingAlertsIdActivateBodySchema,
  t_PostBillingAlertsIdActivateParamSchema,
  t_PostBillingAlertsIdArchiveBodySchema,
  t_PostBillingAlertsIdArchiveParamSchema,
  t_PostBillingAlertsIdDeactivateBodySchema,
  t_PostBillingAlertsIdDeactivateParamSchema,
  t_PostBillingCreditGrantsBodySchema,
  t_PostBillingCreditGrantsIdBodySchema,
  t_PostBillingCreditGrantsIdExpireBodySchema,
  t_PostBillingCreditGrantsIdExpireParamSchema,
  t_PostBillingCreditGrantsIdParamSchema,
  t_PostBillingCreditGrantsIdVoidBodySchema,
  t_PostBillingCreditGrantsIdVoidParamSchema,
  t_PostBillingMeterEventAdjustmentsBodySchema,
  t_PostBillingMeterEventsBodySchema,
  t_PostBillingMetersBodySchema,
  t_PostBillingMetersIdBodySchema,
  t_PostBillingMetersIdDeactivateBodySchema,
  t_PostBillingMetersIdDeactivateParamSchema,
  t_PostBillingMetersIdParamSchema,
  t_PostBillingMetersIdReactivateBodySchema,
  t_PostBillingMetersIdReactivateParamSchema,
  t_PostBillingPortalConfigurationsBodySchema,
  t_PostBillingPortalConfigurationsConfigurationBodySchema,
  t_PostBillingPortalConfigurationsConfigurationParamSchema,
  t_PostBillingPortalSessionsBodySchema,
  t_PostChargesBodySchema,
  t_PostChargesChargeBodySchema,
  t_PostChargesChargeCaptureBodySchema,
  t_PostChargesChargeCaptureParamSchema,
  t_PostChargesChargeDisputeBodySchema,
  t_PostChargesChargeDisputeCloseBodySchema,
  t_PostChargesChargeDisputeCloseParamSchema,
  t_PostChargesChargeDisputeParamSchema,
  t_PostChargesChargeParamSchema,
  t_PostChargesChargeRefundBodySchema,
  t_PostChargesChargeRefundParamSchema,
  t_PostChargesChargeRefundsBodySchema,
  t_PostChargesChargeRefundsParamSchema,
  t_PostChargesChargeRefundsRefundBodySchema,
  t_PostChargesChargeRefundsRefundParamSchema,
  t_PostCheckoutSessionsBodySchema,
  t_PostCheckoutSessionsSessionBodySchema,
  t_PostCheckoutSessionsSessionExpireBodySchema,
  t_PostCheckoutSessionsSessionExpireParamSchema,
  t_PostCheckoutSessionsSessionParamSchema,
  t_PostClimateOrdersBodySchema,
  t_PostClimateOrdersOrderBodySchema,
  t_PostClimateOrdersOrderCancelBodySchema,
  t_PostClimateOrdersOrderCancelParamSchema,
  t_PostClimateOrdersOrderParamSchema,
  t_PostCouponsBodySchema,
  t_PostCouponsCouponBodySchema,
  t_PostCouponsCouponParamSchema,
  t_PostCreditNotesBodySchema,
  t_PostCreditNotesIdBodySchema,
  t_PostCreditNotesIdParamSchema,
  t_PostCreditNotesIdVoidBodySchema,
  t_PostCreditNotesIdVoidParamSchema,
  t_PostCustomerSessionsBodySchema,
  t_PostCustomersBodySchema,
  t_PostCustomersCustomerBalanceTransactionsBodySchema,
  t_PostCustomersCustomerBalanceTransactionsParamSchema,
  t_PostCustomersCustomerBalanceTransactionsTransactionBodySchema,
  t_PostCustomersCustomerBalanceTransactionsTransactionParamSchema,
  t_PostCustomersCustomerBankAccountsBodySchema,
  t_PostCustomersCustomerBankAccountsIdBodySchema,
  t_PostCustomersCustomerBankAccountsIdParamSchema,
  t_PostCustomersCustomerBankAccountsIdVerifyBodySchema,
  t_PostCustomersCustomerBankAccountsIdVerifyParamSchema,
  t_PostCustomersCustomerBankAccountsParamSchema,
  t_PostCustomersCustomerBodySchema,
  t_PostCustomersCustomerCardsBodySchema,
  t_PostCustomersCustomerCardsIdBodySchema,
  t_PostCustomersCustomerCardsIdParamSchema,
  t_PostCustomersCustomerCardsParamSchema,
  t_PostCustomersCustomerCashBalanceBodySchema,
  t_PostCustomersCustomerCashBalanceParamSchema,
  t_PostCustomersCustomerFundingInstructionsBodySchema,
  t_PostCustomersCustomerFundingInstructionsParamSchema,
  t_PostCustomersCustomerParamSchema,
  t_PostCustomersCustomerSourcesBodySchema,
  t_PostCustomersCustomerSourcesIdBodySchema,
  t_PostCustomersCustomerSourcesIdParamSchema,
  t_PostCustomersCustomerSourcesIdVerifyBodySchema,
  t_PostCustomersCustomerSourcesIdVerifyParamSchema,
  t_PostCustomersCustomerSourcesParamSchema,
  t_PostCustomersCustomerSubscriptionsBodySchema,
  t_PostCustomersCustomerSubscriptionsParamSchema,
  t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
  t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
  t_PostCustomersCustomerTaxIdsBodySchema,
  t_PostCustomersCustomerTaxIdsParamSchema,
  t_PostDisputesDisputeBodySchema,
  t_PostDisputesDisputeCloseBodySchema,
  t_PostDisputesDisputeCloseParamSchema,
  t_PostDisputesDisputeParamSchema,
  t_PostEntitlementsFeaturesBodySchema,
  t_PostEntitlementsFeaturesIdBodySchema,
  t_PostEntitlementsFeaturesIdParamSchema,
  t_PostEphemeralKeysBodySchema,
  t_PostExternalAccountsIdBodySchema,
  t_PostExternalAccountsIdParamSchema,
  t_PostFileLinksBodySchema,
  t_PostFileLinksLinkBodySchema,
  t_PostFileLinksLinkParamSchema,
  t_PostFilesBodySchema,
  t_PostFinancialConnectionsAccountsAccountDisconnectBodySchema,
  t_PostFinancialConnectionsAccountsAccountDisconnectParamSchema,
  t_PostFinancialConnectionsAccountsAccountRefreshBodySchema,
  t_PostFinancialConnectionsAccountsAccountRefreshParamSchema,
  t_PostFinancialConnectionsAccountsAccountSubscribeBodySchema,
  t_PostFinancialConnectionsAccountsAccountSubscribeParamSchema,
  t_PostFinancialConnectionsAccountsAccountUnsubscribeBodySchema,
  t_PostFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
  t_PostFinancialConnectionsSessionsBodySchema,
  t_PostForwardingRequestsBodySchema,
  t_PostIdentityVerificationSessionsBodySchema,
  t_PostIdentityVerificationSessionsSessionBodySchema,
  t_PostIdentityVerificationSessionsSessionCancelBodySchema,
  t_PostIdentityVerificationSessionsSessionCancelParamSchema,
  t_PostIdentityVerificationSessionsSessionParamSchema,
  t_PostIdentityVerificationSessionsSessionRedactBodySchema,
  t_PostIdentityVerificationSessionsSessionRedactParamSchema,
  t_PostInvoiceRenderingTemplatesTemplateArchiveBodySchema,
  t_PostInvoiceRenderingTemplatesTemplateArchiveParamSchema,
  t_PostInvoiceRenderingTemplatesTemplateUnarchiveBodySchema,
  t_PostInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
  t_PostInvoiceitemsBodySchema,
  t_PostInvoiceitemsInvoiceitemBodySchema,
  t_PostInvoiceitemsInvoiceitemParamSchema,
  t_PostInvoicesBodySchema,
  t_PostInvoicesCreatePreviewBodySchema,
  t_PostInvoicesInvoiceAddLinesBodySchema,
  t_PostInvoicesInvoiceAddLinesParamSchema,
  t_PostInvoicesInvoiceBodySchema,
  t_PostInvoicesInvoiceFinalizeBodySchema,
  t_PostInvoicesInvoiceFinalizeParamSchema,
  t_PostInvoicesInvoiceLinesLineItemIdBodySchema,
  t_PostInvoicesInvoiceLinesLineItemIdParamSchema,
  t_PostInvoicesInvoiceMarkUncollectibleBodySchema,
  t_PostInvoicesInvoiceMarkUncollectibleParamSchema,
  t_PostInvoicesInvoiceParamSchema,
  t_PostInvoicesInvoicePayBodySchema,
  t_PostInvoicesInvoicePayParamSchema,
  t_PostInvoicesInvoiceRemoveLinesBodySchema,
  t_PostInvoicesInvoiceRemoveLinesParamSchema,
  t_PostInvoicesInvoiceSendBodySchema,
  t_PostInvoicesInvoiceSendParamSchema,
  t_PostInvoicesInvoiceUpdateLinesBodySchema,
  t_PostInvoicesInvoiceUpdateLinesParamSchema,
  t_PostInvoicesInvoiceVoidBodySchema,
  t_PostInvoicesInvoiceVoidParamSchema,
  t_PostIssuingAuthorizationsAuthorizationApproveBodySchema,
  t_PostIssuingAuthorizationsAuthorizationApproveParamSchema,
  t_PostIssuingAuthorizationsAuthorizationBodySchema,
  t_PostIssuingAuthorizationsAuthorizationDeclineBodySchema,
  t_PostIssuingAuthorizationsAuthorizationDeclineParamSchema,
  t_PostIssuingAuthorizationsAuthorizationParamSchema,
  t_PostIssuingCardholdersBodySchema,
  t_PostIssuingCardholdersCardholderBodySchema,
  t_PostIssuingCardholdersCardholderParamSchema,
  t_PostIssuingCardsBodySchema,
  t_PostIssuingCardsCardBodySchema,
  t_PostIssuingCardsCardParamSchema,
  t_PostIssuingDisputesBodySchema,
  t_PostIssuingDisputesDisputeBodySchema,
  t_PostIssuingDisputesDisputeParamSchema,
  t_PostIssuingDisputesDisputeSubmitBodySchema,
  t_PostIssuingDisputesDisputeSubmitParamSchema,
  t_PostIssuingPersonalizationDesignsBodySchema,
  t_PostIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
  t_PostIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
  t_PostIssuingSettlementsSettlementBodySchema,
  t_PostIssuingSettlementsSettlementParamSchema,
  t_PostIssuingTokensTokenBodySchema,
  t_PostIssuingTokensTokenParamSchema,
  t_PostIssuingTransactionsTransactionBodySchema,
  t_PostIssuingTransactionsTransactionParamSchema,
  t_PostLinkAccountSessionsBodySchema,
  t_PostLinkedAccountsAccountDisconnectBodySchema,
  t_PostLinkedAccountsAccountDisconnectParamSchema,
  t_PostLinkedAccountsAccountRefreshBodySchema,
  t_PostLinkedAccountsAccountRefreshParamSchema,
  t_PostPaymentIntentsBodySchema,
  t_PostPaymentIntentsIntentApplyCustomerBalanceBodySchema,
  t_PostPaymentIntentsIntentApplyCustomerBalanceParamSchema,
  t_PostPaymentIntentsIntentBodySchema,
  t_PostPaymentIntentsIntentCancelBodySchema,
  t_PostPaymentIntentsIntentCancelParamSchema,
  t_PostPaymentIntentsIntentCaptureBodySchema,
  t_PostPaymentIntentsIntentCaptureParamSchema,
  t_PostPaymentIntentsIntentConfirmBodySchema,
  t_PostPaymentIntentsIntentConfirmParamSchema,
  t_PostPaymentIntentsIntentIncrementAuthorizationBodySchema,
  t_PostPaymentIntentsIntentIncrementAuthorizationParamSchema,
  t_PostPaymentIntentsIntentParamSchema,
  t_PostPaymentIntentsIntentVerifyMicrodepositsBodySchema,
  t_PostPaymentIntentsIntentVerifyMicrodepositsParamSchema,
  t_PostPaymentLinksBodySchema,
  t_PostPaymentLinksPaymentLinkBodySchema,
  t_PostPaymentLinksPaymentLinkParamSchema,
  t_PostPaymentMethodConfigurationsBodySchema,
  t_PostPaymentMethodConfigurationsConfigurationBodySchema,
  t_PostPaymentMethodConfigurationsConfigurationParamSchema,
  t_PostPaymentMethodDomainsBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainParamSchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainValidateBodySchema,
  t_PostPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
  t_PostPaymentMethodsBodySchema,
  t_PostPaymentMethodsPaymentMethodAttachBodySchema,
  t_PostPaymentMethodsPaymentMethodAttachParamSchema,
  t_PostPaymentMethodsPaymentMethodBodySchema,
  t_PostPaymentMethodsPaymentMethodDetachBodySchema,
  t_PostPaymentMethodsPaymentMethodDetachParamSchema,
  t_PostPaymentMethodsPaymentMethodParamSchema,
  t_PostPayoutsBodySchema,
  t_PostPayoutsPayoutBodySchema,
  t_PostPayoutsPayoutCancelBodySchema,
  t_PostPayoutsPayoutCancelParamSchema,
  t_PostPayoutsPayoutParamSchema,
  t_PostPayoutsPayoutReverseBodySchema,
  t_PostPayoutsPayoutReverseParamSchema,
  t_PostPlansBodySchema,
  t_PostPlansPlanBodySchema,
  t_PostPlansPlanParamSchema,
  t_PostPricesBodySchema,
  t_PostPricesPriceBodySchema,
  t_PostPricesPriceParamSchema,
  t_PostProductsBodySchema,
  t_PostProductsIdBodySchema,
  t_PostProductsIdParamSchema,
  t_PostProductsProductFeaturesBodySchema,
  t_PostProductsProductFeaturesParamSchema,
  t_PostPromotionCodesBodySchema,
  t_PostPromotionCodesPromotionCodeBodySchema,
  t_PostPromotionCodesPromotionCodeParamSchema,
  t_PostQuotesBodySchema,
  t_PostQuotesQuoteAcceptBodySchema,
  t_PostQuotesQuoteAcceptParamSchema,
  t_PostQuotesQuoteBodySchema,
  t_PostQuotesQuoteCancelBodySchema,
  t_PostQuotesQuoteCancelParamSchema,
  t_PostQuotesQuoteFinalizeBodySchema,
  t_PostQuotesQuoteFinalizeParamSchema,
  t_PostQuotesQuoteParamSchema,
  t_PostRadarValueListItemsBodySchema,
  t_PostRadarValueListsBodySchema,
  t_PostRadarValueListsValueListBodySchema,
  t_PostRadarValueListsValueListParamSchema,
  t_PostRefundsBodySchema,
  t_PostRefundsRefundBodySchema,
  t_PostRefundsRefundCancelBodySchema,
  t_PostRefundsRefundCancelParamSchema,
  t_PostRefundsRefundParamSchema,
  t_PostReportingReportRunsBodySchema,
  t_PostReviewsReviewApproveBodySchema,
  t_PostReviewsReviewApproveParamSchema,
  t_PostSetupIntentsBodySchema,
  t_PostSetupIntentsIntentBodySchema,
  t_PostSetupIntentsIntentCancelBodySchema,
  t_PostSetupIntentsIntentCancelParamSchema,
  t_PostSetupIntentsIntentConfirmBodySchema,
  t_PostSetupIntentsIntentConfirmParamSchema,
  t_PostSetupIntentsIntentParamSchema,
  t_PostSetupIntentsIntentVerifyMicrodepositsBodySchema,
  t_PostSetupIntentsIntentVerifyMicrodepositsParamSchema,
  t_PostShippingRatesBodySchema,
  t_PostShippingRatesShippingRateTokenBodySchema,
  t_PostShippingRatesShippingRateTokenParamSchema,
  t_PostSigmaSavedQueriesIdBodySchema,
  t_PostSigmaSavedQueriesIdParamSchema,
  t_PostSourcesBodySchema,
  t_PostSourcesSourceBodySchema,
  t_PostSourcesSourceParamSchema,
  t_PostSourcesSourceVerifyBodySchema,
  t_PostSourcesSourceVerifyParamSchema,
  t_PostSubscriptionItemsBodySchema,
  t_PostSubscriptionItemsItemBodySchema,
  t_PostSubscriptionItemsItemParamSchema,
  t_PostSubscriptionSchedulesBodySchema,
  t_PostSubscriptionSchedulesScheduleBodySchema,
  t_PostSubscriptionSchedulesScheduleCancelBodySchema,
  t_PostSubscriptionSchedulesScheduleCancelParamSchema,
  t_PostSubscriptionSchedulesScheduleParamSchema,
  t_PostSubscriptionSchedulesScheduleReleaseBodySchema,
  t_PostSubscriptionSchedulesScheduleReleaseParamSchema,
  t_PostSubscriptionsBodySchema,
  t_PostSubscriptionsSubscriptionExposedIdBodySchema,
  t_PostSubscriptionsSubscriptionExposedIdParamSchema,
  t_PostSubscriptionsSubscriptionResumeBodySchema,
  t_PostSubscriptionsSubscriptionResumeParamSchema,
  t_PostTaxCalculationsBodySchema,
  t_PostTaxIdsBodySchema,
  t_PostTaxRatesBodySchema,
  t_PostTaxRatesTaxRateBodySchema,
  t_PostTaxRatesTaxRateParamSchema,
  t_PostTaxRegistrationsBodySchema,
  t_PostTaxRegistrationsIdBodySchema,
  t_PostTaxRegistrationsIdParamSchema,
  t_PostTaxSettingsBodySchema,
  t_PostTaxTransactionsCreateFromCalculationBodySchema,
  t_PostTaxTransactionsCreateReversalBodySchema,
  t_PostTerminalConfigurationsBodySchema,
  t_PostTerminalConfigurationsConfigurationBodySchema,
  t_PostTerminalConfigurationsConfigurationParamSchema,
  t_PostTerminalConnectionTokensBodySchema,
  t_PostTerminalLocationsBodySchema,
  t_PostTerminalLocationsLocationBodySchema,
  t_PostTerminalLocationsLocationParamSchema,
  t_PostTerminalReadersBodySchema,
  t_PostTerminalReadersReaderBodySchema,
  t_PostTerminalReadersReaderCancelActionBodySchema,
  t_PostTerminalReadersReaderCancelActionParamSchema,
  t_PostTerminalReadersReaderParamSchema,
  t_PostTerminalReadersReaderProcessPaymentIntentBodySchema,
  t_PostTerminalReadersReaderProcessPaymentIntentParamSchema,
  t_PostTerminalReadersReaderProcessSetupIntentBodySchema,
  t_PostTerminalReadersReaderProcessSetupIntentParamSchema,
  t_PostTerminalReadersReaderRefundPaymentBodySchema,
  t_PostTerminalReadersReaderRefundPaymentParamSchema,
  t_PostTerminalReadersReaderSetReaderDisplayBodySchema,
  t_PostTerminalReadersReaderSetReaderDisplayParamSchema,
  t_PostTestHelpersConfirmationTokensBodySchema,
  t_PostTestHelpersCustomersCustomerFundCashBalanceBodySchema,
  t_PostTestHelpersCustomersCustomerFundCashBalanceParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema,
  t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
  t_PostTestHelpersIssuingAuthorizationsBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingDeliverBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingDeliverParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingFailBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingFailParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingReturnBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingReturnParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingShipBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingShipParamSchema,
  t_PostTestHelpersIssuingCardsCardShippingSubmitBodySchema,
  t_PostTestHelpersIssuingCardsCardShippingSubmitParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema,
  t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
  t_PostTestHelpersIssuingSettlementsBodySchema,
  t_PostTestHelpersIssuingSettlementsSettlementCompleteBodySchema,
  t_PostTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
  t_PostTestHelpersIssuingTransactionsCreateForceCaptureBodySchema,
  t_PostTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema,
  t_PostTestHelpersIssuingTransactionsTransactionRefundBodySchema,
  t_PostTestHelpersIssuingTransactionsTransactionRefundParamSchema,
  t_PostTestHelpersRefundsRefundExpireBodySchema,
  t_PostTestHelpersRefundsRefundExpireParamSchema,
  t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema,
  t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
  t_PostTestHelpersTestClocksBodySchema,
  t_PostTestHelpersTestClocksTestClockAdvanceBodySchema,
  t_PostTestHelpersTestClocksTestClockAdvanceParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdFailBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdFailParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdReturnBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
  t_PostTestHelpersTreasuryInboundTransfersIdSucceedBodySchema,
  t_PostTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdFailBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdPostBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema,
  t_PostTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema,
  t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
  t_PostTestHelpersTreasuryReceivedCreditsBodySchema,
  t_PostTestHelpersTreasuryReceivedDebitsBodySchema,
  t_PostTokensBodySchema,
  t_PostTopupsBodySchema,
  t_PostTopupsTopupBodySchema,
  t_PostTopupsTopupCancelBodySchema,
  t_PostTopupsTopupCancelParamSchema,
  t_PostTopupsTopupParamSchema,
  t_PostTransfersBodySchema,
  t_PostTransfersIdReversalsBodySchema,
  t_PostTransfersIdReversalsParamSchema,
  t_PostTransfersTransferBodySchema,
  t_PostTransfersTransferParamSchema,
  t_PostTransfersTransferReversalsIdBodySchema,
  t_PostTransfersTransferReversalsIdParamSchema,
  t_PostTreasuryCreditReversalsBodySchema,
  t_PostTreasuryDebitReversalsBodySchema,
  t_PostTreasuryFinancialAccountsBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountCloseBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
  t_PostTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
  t_PostTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
  t_PostTreasuryFinancialAccountsFinancialAccountParamSchema,
  t_PostTreasuryInboundTransfersBodySchema,
  t_PostTreasuryInboundTransfersInboundTransferCancelBodySchema,
  t_PostTreasuryInboundTransfersInboundTransferCancelParamSchema,
  t_PostTreasuryOutboundPaymentsBodySchema,
  t_PostTreasuryOutboundPaymentsIdCancelBodySchema,
  t_PostTreasuryOutboundPaymentsIdCancelParamSchema,
  t_PostTreasuryOutboundTransfersBodySchema,
  t_PostTreasuryOutboundTransfersOutboundTransferCancelBodySchema,
  t_PostTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
  t_PostWebhookEndpointsBodySchema,
  t_PostWebhookEndpointsWebhookEndpointBodySchema,
  t_PostWebhookEndpointsWebhookEndpointParamSchema,
  t_account,
  t_account_link,
  t_account_session,
  t_apple_pay_domain,
  t_application_fee,
  t_apps_secret,
  t_balance,
  t_balance_transaction,
  t_bank_account,
  t_billing_alert,
  t_billing_credit_balance_summary,
  t_billing_credit_balance_transaction,
  t_billing_credit_grant,
  t_billing_meter,
  t_billing_meter_event,
  t_billing_meter_event_adjustment,
  t_billing_meter_event_summary,
  t_billing_portal_configuration,
  t_billing_portal_session,
  t_capability,
  t_card,
  t_cash_balance,
  t_charge,
  t_checkout_session,
  t_climate_order,
  t_climate_product,
  t_climate_supplier,
  t_confirmation_token,
  t_country_spec,
  t_coupon,
  t_credit_note,
  t_credit_note_line_item,
  t_customer,
  t_customer_balance_transaction,
  t_customer_cash_balance_transaction,
  t_customer_session,
  t_deleted_account,
  t_deleted_apple_pay_domain,
  t_deleted_coupon,
  t_deleted_customer,
  t_deleted_discount,
  t_deleted_external_account,
  t_deleted_invoice,
  t_deleted_invoiceitem,
  t_deleted_payment_source,
  t_deleted_person,
  t_deleted_plan,
  t_deleted_product,
  t_deleted_product_feature,
  t_deleted_radar_value_list,
  t_deleted_radar_value_list_item,
  t_deleted_subscription_item,
  t_deleted_tax_id,
  t_deleted_terminal_configuration,
  t_deleted_terminal_location,
  t_deleted_terminal_reader,
  t_deleted_test_helpers_test_clock,
  t_deleted_webhook_endpoint,
  t_discount,
  t_dispute,
  t_entitlements_active_entitlement,
  t_entitlements_feature,
  t_ephemeral_key,
  t_error,
  t_event,
  t_exchange_rate,
  t_external_account,
  t_fee_refund,
  t_file,
  t_file_link,
  t_financial_connections_account,
  t_financial_connections_account_owner,
  t_financial_connections_session,
  t_financial_connections_transaction,
  t_forwarding_request,
  t_funding_instructions,
  t_identity_verification_report,
  t_identity_verification_session,
  t_invoice,
  t_invoice_payment,
  t_invoice_rendering_template,
  t_invoiceitem,
  t_issuing_authorization,
  t_issuing_card,
  t_issuing_cardholder,
  t_issuing_dispute,
  t_issuing_personalization_design,
  t_issuing_physical_bundle,
  t_issuing_settlement,
  t_issuing_token,
  t_issuing_transaction,
  t_item,
  t_line_item,
  t_login_link,
  t_mandate,
  t_payment_intent,
  t_payment_link,
  t_payment_method,
  t_payment_method_configuration,
  t_payment_method_domain,
  t_payment_source,
  t_payout,
  t_person,
  t_plan,
  t_price,
  t_product,
  t_product_feature,
  t_promotion_code,
  t_quote,
  t_radar_early_fraud_warning,
  t_radar_value_list,
  t_radar_value_list_item,
  t_refund,
  t_reporting_report_run,
  t_reporting_report_type,
  t_review,
  t_scheduled_query_run,
  t_setup_attempt,
  t_setup_intent,
  t_shipping_rate,
  t_sigma_sigma_api_query,
  t_source,
  t_source_mandate_notification,
  t_source_transaction,
  t_subscription,
  t_subscription_item,
  t_subscription_schedule,
  t_tax_calculation,
  t_tax_calculation_line_item,
  t_tax_code,
  t_tax_id,
  t_tax_rate,
  t_tax_registration,
  t_tax_settings,
  t_tax_transaction,
  t_tax_transaction_line_item,
  t_terminal_configuration,
  t_terminal_connection_token,
  t_terminal_location,
  t_terminal_reader,
  t_test_helpers_test_clock,
  t_token,
  t_topup,
  t_transfer,
  t_transfer_reversal,
  t_treasury_credit_reversal,
  t_treasury_debit_reversal,
  t_treasury_financial_account,
  t_treasury_financial_account_features,
  t_treasury_inbound_transfer,
  t_treasury_outbound_payment,
  t_treasury_outbound_transfer,
  t_treasury_received_credit,
  t_treasury_received_debit,
  t_treasury_transaction,
  t_treasury_transaction_entry,
  t_webhook_endpoint,
} from "./models"
import {
  PermissiveBoolean,
  s_account,
  s_account_link,
  s_account_session,
  s_apple_pay_domain,
  s_application_fee,
  s_apps_secret,
  s_balance,
  s_balance_transaction,
  s_bank_account,
  s_billing_alert,
  s_billing_credit_balance_summary,
  s_billing_credit_balance_transaction,
  s_billing_credit_grant,
  s_billing_meter,
  s_billing_meter_event,
  s_billing_meter_event_adjustment,
  s_billing_meter_event_summary,
  s_billing_portal_configuration,
  s_billing_portal_session,
  s_capability,
  s_card,
  s_cash_balance,
  s_charge,
  s_checkout_session,
  s_climate_order,
  s_climate_product,
  s_climate_supplier,
  s_confirmation_token,
  s_country_spec,
  s_coupon,
  s_credit_note,
  s_credit_note_line_item,
  s_customer,
  s_customer_balance_transaction,
  s_customer_cash_balance_transaction,
  s_customer_session,
  s_deleted_account,
  s_deleted_apple_pay_domain,
  s_deleted_coupon,
  s_deleted_customer,
  s_deleted_discount,
  s_deleted_external_account,
  s_deleted_invoice,
  s_deleted_invoiceitem,
  s_deleted_payment_source,
  s_deleted_person,
  s_deleted_plan,
  s_deleted_product,
  s_deleted_product_feature,
  s_deleted_radar_value_list,
  s_deleted_radar_value_list_item,
  s_deleted_subscription_item,
  s_deleted_tax_id,
  s_deleted_terminal_configuration,
  s_deleted_terminal_location,
  s_deleted_terminal_reader,
  s_deleted_test_helpers_test_clock,
  s_deleted_webhook_endpoint,
  s_discount,
  s_dispute,
  s_entitlements_active_entitlement,
  s_entitlements_feature,
  s_ephemeral_key,
  s_error,
  s_event,
  s_exchange_rate,
  s_external_account,
  s_fee_refund,
  s_file,
  s_file_link,
  s_financial_connections_account,
  s_financial_connections_account_owner,
  s_financial_connections_session,
  s_financial_connections_transaction,
  s_forwarding_request,
  s_funding_instructions,
  s_identity_verification_report,
  s_identity_verification_session,
  s_invoice,
  s_invoice_payment,
  s_invoice_rendering_template,
  s_invoiceitem,
  s_issuing_authorization,
  s_issuing_card,
  s_issuing_cardholder,
  s_issuing_dispute,
  s_issuing_personalization_design,
  s_issuing_physical_bundle,
  s_issuing_settlement,
  s_issuing_token,
  s_issuing_transaction,
  s_item,
  s_line_item,
  s_login_link,
  s_mandate,
  s_payment_intent,
  s_payment_link,
  s_payment_method,
  s_payment_method_configuration,
  s_payment_method_domain,
  s_payment_source,
  s_payout,
  s_person,
  s_plan,
  s_price,
  s_product,
  s_product_feature,
  s_promotion_code,
  s_quote,
  s_radar_early_fraud_warning,
  s_radar_value_list,
  s_radar_value_list_item,
  s_refund,
  s_reporting_report_run,
  s_reporting_report_type,
  s_review,
  s_scheduled_query_run,
  s_setup_attempt,
  s_setup_intent,
  s_shipping_rate,
  s_sigma_sigma_api_query,
  s_source,
  s_source_mandate_notification,
  s_source_transaction,
  s_subscription,
  s_subscription_item,
  s_subscription_schedule,
  s_tax_calculation,
  s_tax_calculation_line_item,
  s_tax_code,
  s_tax_id,
  s_tax_rate,
  s_tax_registration,
  s_tax_settings,
  s_tax_transaction,
  s_tax_transaction_line_item,
  s_terminal_configuration,
  s_terminal_connection_token,
  s_terminal_location,
  s_terminal_reader,
  s_test_helpers_test_clock,
  s_token,
  s_topup,
  s_transfer,
  s_transfer_reversal,
  s_treasury_credit_reversal,
  s_treasury_debit_reversal,
  s_treasury_financial_account,
  s_treasury_financial_account_features,
  s_treasury_inbound_transfer,
  s_treasury_outbound_payment,
  s_treasury_outbound_transfer,
  s_treasury_received_credit,
  s_treasury_received_debit,
  s_treasury_transaction,
  s_treasury_transaction_entry,
  s_webhook_endpoint,
} from "./schemas"
import KoaRouter, { RouterContext } from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  KoaRuntimeResponse,
  Params,
  Response,
  ServerConfig,
  StatusCode,
  b,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import { parseRequestInput } from "@nahkies/typescript-koa-runtime/zod"
import { z } from "zod"

const getAccount = b((r) => ({
  with200: r.with200<t_account>(s_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccount = (
  params: Params<
    void,
    t_GetAccountQuerySchema,
    t_GetAccountBodySchema | undefined,
    void
  >,
  respond: (typeof getAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
>

const postAccountLinks = b((r) => ({
  with200: r.with200<t_account_link>(s_account_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountLinks = (
  params: Params<void, void, t_PostAccountLinksBodySchema, void>,
  respond: (typeof postAccountLinks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account_link>
  | Response<StatusCode, t_error>
>

const postAccountSessions = b((r) => ({
  with200: r.with200<t_account_session>(s_account_session),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountSessions = (
  params: Params<void, void, t_PostAccountSessionsBodySchema, void>,
  respond: (typeof postAccountSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account_session>
  | Response<StatusCode, t_error>
>

const getAccounts = b((r) => ({
  with200: r.with200<{
    data: t_account[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_account)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/accounts")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccounts = (
  params: Params<
    void,
    t_GetAccountsQuerySchema,
    t_GetAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof getAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postAccounts = b((r) => ({
  with200: r.with200<t_account>(s_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccounts = (
  params: Params<void, void, t_PostAccountsBodySchema | undefined, void>,
  respond: (typeof postAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
>

const deleteAccountsAccount = b((r) => ({
  with200: r.with200<t_deleted_account>(s_deleted_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteAccountsAccount = (
  params: Params<
    t_DeleteAccountsAccountParamSchema,
    void,
    t_DeleteAccountsAccountBodySchema | undefined,
    void
  >,
  respond: (typeof deleteAccountsAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_account>
  | Response<StatusCode, t_error>
>

const getAccountsAccount = b((r) => ({
  with200: r.with200<t_account>(s_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccount = (
  params: Params<
    t_GetAccountsAccountParamSchema,
    t_GetAccountsAccountQuerySchema,
    t_GetAccountsAccountBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
>

const postAccountsAccount = b((r) => ({
  with200: r.with200<t_account>(s_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccount = (
  params: Params<
    t_PostAccountsAccountParamSchema,
    void,
    t_PostAccountsAccountBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
>

const postAccountsAccountBankAccounts = b((r) => ({
  with200: r.with200<t_external_account>(s_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountBankAccounts = (
  params: Params<
    t_PostAccountsAccountBankAccountsParamSchema,
    void,
    t_PostAccountsAccountBankAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountBankAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
>

const deleteAccountsAccountBankAccountsId = b((r) => ({
  with200: r.with200<t_deleted_external_account>(s_deleted_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteAccountsAccountBankAccountsId = (
  params: Params<
    t_DeleteAccountsAccountBankAccountsIdParamSchema,
    void,
    t_DeleteAccountsAccountBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteAccountsAccountBankAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_external_account>
  | Response<StatusCode, t_error>
>

const getAccountsAccountBankAccountsId = b((r) => ({
  with200: r.with200<t_external_account>(s_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountBankAccountsId = (
  params: Params<
    t_GetAccountsAccountBankAccountsIdParamSchema,
    t_GetAccountsAccountBankAccountsIdQuerySchema,
    t_GetAccountsAccountBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountBankAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
>

const postAccountsAccountBankAccountsId = b((r) => ({
  with200: r.with200<t_external_account>(s_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountBankAccountsId = (
  params: Params<
    t_PostAccountsAccountBankAccountsIdParamSchema,
    void,
    t_PostAccountsAccountBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountBankAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
>

const getAccountsAccountCapabilities = b((r) => ({
  with200: r.with200<{
    data: t_capability[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_capability)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountCapabilities = (
  params: Params<
    t_GetAccountsAccountCapabilitiesParamSchema,
    t_GetAccountsAccountCapabilitiesQuerySchema,
    t_GetAccountsAccountCapabilitiesBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountCapabilities)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_capability[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getAccountsAccountCapabilitiesCapability = b((r) => ({
  with200: r.with200<t_capability>(s_capability),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountCapabilitiesCapability = (
  params: Params<
    t_GetAccountsAccountCapabilitiesCapabilityParamSchema,
    t_GetAccountsAccountCapabilitiesCapabilityQuerySchema,
    t_GetAccountsAccountCapabilitiesCapabilityBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountCapabilitiesCapability)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_capability>
  | Response<StatusCode, t_error>
>

const postAccountsAccountCapabilitiesCapability = b((r) => ({
  with200: r.with200<t_capability>(s_capability),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountCapabilitiesCapability = (
  params: Params<
    t_PostAccountsAccountCapabilitiesCapabilityParamSchema,
    void,
    t_PostAccountsAccountCapabilitiesCapabilityBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountCapabilitiesCapability)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_capability>
  | Response<StatusCode, t_error>
>

const getAccountsAccountExternalAccounts = b((r) => ({
  with200: r.with200<{
    data: (t_bank_account | t_card)[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(
        z.union([z.lazy(() => s_bank_account), z.lazy(() => s_card)]),
      ),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountExternalAccounts = (
  params: Params<
    t_GetAccountsAccountExternalAccountsParamSchema,
    t_GetAccountsAccountExternalAccountsQuerySchema,
    t_GetAccountsAccountExternalAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountExternalAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: (t_bank_account | t_card)[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postAccountsAccountExternalAccounts = b((r) => ({
  with200: r.with200<t_external_account>(s_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountExternalAccounts = (
  params: Params<
    t_PostAccountsAccountExternalAccountsParamSchema,
    void,
    t_PostAccountsAccountExternalAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountExternalAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
>

const deleteAccountsAccountExternalAccountsId = b((r) => ({
  with200: r.with200<t_deleted_external_account>(s_deleted_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteAccountsAccountExternalAccountsId = (
  params: Params<
    t_DeleteAccountsAccountExternalAccountsIdParamSchema,
    void,
    t_DeleteAccountsAccountExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteAccountsAccountExternalAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_external_account>
  | Response<StatusCode, t_error>
>

const getAccountsAccountExternalAccountsId = b((r) => ({
  with200: r.with200<t_external_account>(s_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountExternalAccountsId = (
  params: Params<
    t_GetAccountsAccountExternalAccountsIdParamSchema,
    t_GetAccountsAccountExternalAccountsIdQuerySchema,
    t_GetAccountsAccountExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountExternalAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
>

const postAccountsAccountExternalAccountsId = b((r) => ({
  with200: r.with200<t_external_account>(s_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountExternalAccountsId = (
  params: Params<
    t_PostAccountsAccountExternalAccountsIdParamSchema,
    void,
    t_PostAccountsAccountExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountExternalAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
>

const postAccountsAccountLoginLinks = b((r) => ({
  with200: r.with200<t_login_link>(s_login_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountLoginLinks = (
  params: Params<
    t_PostAccountsAccountLoginLinksParamSchema,
    void,
    t_PostAccountsAccountLoginLinksBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountLoginLinks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_login_link>
  | Response<StatusCode, t_error>
>

const getAccountsAccountPeople = b((r) => ({
  with200: r.with200<{
    data: t_person[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_person)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountPeople = (
  params: Params<
    t_GetAccountsAccountPeopleParamSchema,
    t_GetAccountsAccountPeopleQuerySchema,
    t_GetAccountsAccountPeopleBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountPeople)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_person[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postAccountsAccountPeople = b((r) => ({
  with200: r.with200<t_person>(s_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountPeople = (
  params: Params<
    t_PostAccountsAccountPeopleParamSchema,
    void,
    t_PostAccountsAccountPeopleBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountPeople)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
>

const deleteAccountsAccountPeoplePerson = b((r) => ({
  with200: r.with200<t_deleted_person>(s_deleted_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteAccountsAccountPeoplePerson = (
  params: Params<
    t_DeleteAccountsAccountPeoplePersonParamSchema,
    void,
    t_DeleteAccountsAccountPeoplePersonBodySchema | undefined,
    void
  >,
  respond: (typeof deleteAccountsAccountPeoplePerson)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_person>
  | Response<StatusCode, t_error>
>

const getAccountsAccountPeoplePerson = b((r) => ({
  with200: r.with200<t_person>(s_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountPeoplePerson = (
  params: Params<
    t_GetAccountsAccountPeoplePersonParamSchema,
    t_GetAccountsAccountPeoplePersonQuerySchema,
    t_GetAccountsAccountPeoplePersonBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountPeoplePerson)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
>

const postAccountsAccountPeoplePerson = b((r) => ({
  with200: r.with200<t_person>(s_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountPeoplePerson = (
  params: Params<
    t_PostAccountsAccountPeoplePersonParamSchema,
    void,
    t_PostAccountsAccountPeoplePersonBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountPeoplePerson)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
>

const getAccountsAccountPersons = b((r) => ({
  with200: r.with200<{
    data: t_person[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_person)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountPersons = (
  params: Params<
    t_GetAccountsAccountPersonsParamSchema,
    t_GetAccountsAccountPersonsQuerySchema,
    t_GetAccountsAccountPersonsBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountPersons)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_person[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postAccountsAccountPersons = b((r) => ({
  with200: r.with200<t_person>(s_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountPersons = (
  params: Params<
    t_PostAccountsAccountPersonsParamSchema,
    void,
    t_PostAccountsAccountPersonsBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountPersons)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
>

const deleteAccountsAccountPersonsPerson = b((r) => ({
  with200: r.with200<t_deleted_person>(s_deleted_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteAccountsAccountPersonsPerson = (
  params: Params<
    t_DeleteAccountsAccountPersonsPersonParamSchema,
    void,
    t_DeleteAccountsAccountPersonsPersonBodySchema | undefined,
    void
  >,
  respond: (typeof deleteAccountsAccountPersonsPerson)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_person>
  | Response<StatusCode, t_error>
>

const getAccountsAccountPersonsPerson = b((r) => ({
  with200: r.with200<t_person>(s_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAccountsAccountPersonsPerson = (
  params: Params<
    t_GetAccountsAccountPersonsPersonParamSchema,
    t_GetAccountsAccountPersonsPersonQuerySchema,
    t_GetAccountsAccountPersonsPersonBodySchema | undefined,
    void
  >,
  respond: (typeof getAccountsAccountPersonsPerson)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
>

const postAccountsAccountPersonsPerson = b((r) => ({
  with200: r.with200<t_person>(s_person),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountPersonsPerson = (
  params: Params<
    t_PostAccountsAccountPersonsPersonParamSchema,
    void,
    t_PostAccountsAccountPersonsPersonBodySchema | undefined,
    void
  >,
  respond: (typeof postAccountsAccountPersonsPerson)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_person>
  | Response<StatusCode, t_error>
>

const postAccountsAccountReject = b((r) => ({
  with200: r.with200<t_account>(s_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAccountsAccountReject = (
  params: Params<
    t_PostAccountsAccountRejectParamSchema,
    void,
    t_PostAccountsAccountRejectBodySchema,
    void
  >,
  respond: (typeof postAccountsAccountReject)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_account>
  | Response<StatusCode, t_error>
>

const getApplePayDomains = b((r) => ({
  with200: r.with200<{
    data: t_apple_pay_domain[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_apple_pay_domain),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/apple_pay/domains")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetApplePayDomains = (
  params: Params<
    void,
    t_GetApplePayDomainsQuerySchema,
    t_GetApplePayDomainsBodySchema | undefined,
    void
  >,
  respond: (typeof getApplePayDomains)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_apple_pay_domain[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postApplePayDomains = b((r) => ({
  with200: r.with200<t_apple_pay_domain>(s_apple_pay_domain),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostApplePayDomains = (
  params: Params<void, void, t_PostApplePayDomainsBodySchema, void>,
  respond: (typeof postApplePayDomains)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apple_pay_domain>
  | Response<StatusCode, t_error>
>

const deleteApplePayDomainsDomain = b((r) => ({
  with200: r.with200<t_deleted_apple_pay_domain>(s_deleted_apple_pay_domain),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteApplePayDomainsDomain = (
  params: Params<
    t_DeleteApplePayDomainsDomainParamSchema,
    void,
    t_DeleteApplePayDomainsDomainBodySchema | undefined,
    void
  >,
  respond: (typeof deleteApplePayDomainsDomain)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_apple_pay_domain>
  | Response<StatusCode, t_error>
>

const getApplePayDomainsDomain = b((r) => ({
  with200: r.with200<t_apple_pay_domain>(s_apple_pay_domain),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetApplePayDomainsDomain = (
  params: Params<
    t_GetApplePayDomainsDomainParamSchema,
    t_GetApplePayDomainsDomainQuerySchema,
    t_GetApplePayDomainsDomainBodySchema | undefined,
    void
  >,
  respond: (typeof getApplePayDomainsDomain)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apple_pay_domain>
  | Response<StatusCode, t_error>
>

const getApplicationFees = b((r) => ({
  with200: r.with200<{
    data: t_application_fee[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_application_fee)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/application_fees")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetApplicationFees = (
  params: Params<
    void,
    t_GetApplicationFeesQuerySchema,
    t_GetApplicationFeesBodySchema | undefined,
    void
  >,
  respond: (typeof getApplicationFees)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_application_fee[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getApplicationFeesFeeRefundsId = b((r) => ({
  with200: r.with200<t_fee_refund>(s_fee_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetApplicationFeesFeeRefundsId = (
  params: Params<
    t_GetApplicationFeesFeeRefundsIdParamSchema,
    t_GetApplicationFeesFeeRefundsIdQuerySchema,
    t_GetApplicationFeesFeeRefundsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getApplicationFeesFeeRefundsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_fee_refund>
  | Response<StatusCode, t_error>
>

const postApplicationFeesFeeRefundsId = b((r) => ({
  with200: r.with200<t_fee_refund>(s_fee_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostApplicationFeesFeeRefundsId = (
  params: Params<
    t_PostApplicationFeesFeeRefundsIdParamSchema,
    void,
    t_PostApplicationFeesFeeRefundsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postApplicationFeesFeeRefundsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_fee_refund>
  | Response<StatusCode, t_error>
>

const getApplicationFeesId = b((r) => ({
  with200: r.with200<t_application_fee>(s_application_fee),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetApplicationFeesId = (
  params: Params<
    t_GetApplicationFeesIdParamSchema,
    t_GetApplicationFeesIdQuerySchema,
    t_GetApplicationFeesIdBodySchema | undefined,
    void
  >,
  respond: (typeof getApplicationFeesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_application_fee>
  | Response<StatusCode, t_error>
>

const postApplicationFeesIdRefund = b((r) => ({
  with200: r.with200<t_application_fee>(s_application_fee),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostApplicationFeesIdRefund = (
  params: Params<
    t_PostApplicationFeesIdRefundParamSchema,
    void,
    t_PostApplicationFeesIdRefundBodySchema | undefined,
    void
  >,
  respond: (typeof postApplicationFeesIdRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_application_fee>
  | Response<StatusCode, t_error>
>

const getApplicationFeesIdRefunds = b((r) => ({
  with200: r.with200<{
    data: t_fee_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_fee_refund)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetApplicationFeesIdRefunds = (
  params: Params<
    t_GetApplicationFeesIdRefundsParamSchema,
    t_GetApplicationFeesIdRefundsQuerySchema,
    t_GetApplicationFeesIdRefundsBodySchema | undefined,
    void
  >,
  respond: (typeof getApplicationFeesIdRefunds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_fee_refund[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postApplicationFeesIdRefunds = b((r) => ({
  with200: r.with200<t_fee_refund>(s_fee_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostApplicationFeesIdRefunds = (
  params: Params<
    t_PostApplicationFeesIdRefundsParamSchema,
    void,
    t_PostApplicationFeesIdRefundsBodySchema | undefined,
    void
  >,
  respond: (typeof postApplicationFeesIdRefunds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_fee_refund>
  | Response<StatusCode, t_error>
>

const getAppsSecrets = b((r) => ({
  with200: r.with200<{
    data: t_apps_secret[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_apps_secret),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/apps/secrets")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAppsSecrets = (
  params: Params<
    void,
    t_GetAppsSecretsQuerySchema,
    t_GetAppsSecretsBodySchema | undefined,
    void
  >,
  respond: (typeof getAppsSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_apps_secret[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postAppsSecrets = b((r) => ({
  with200: r.with200<t_apps_secret>(s_apps_secret),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAppsSecrets = (
  params: Params<void, void, t_PostAppsSecretsBodySchema, void>,
  respond: (typeof postAppsSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apps_secret>
  | Response<StatusCode, t_error>
>

const postAppsSecretsDelete = b((r) => ({
  with200: r.with200<t_apps_secret>(s_apps_secret),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostAppsSecretsDelete = (
  params: Params<void, void, t_PostAppsSecretsDeleteBodySchema, void>,
  respond: (typeof postAppsSecretsDelete)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apps_secret>
  | Response<StatusCode, t_error>
>

const getAppsSecretsFind = b((r) => ({
  with200: r.with200<t_apps_secret>(s_apps_secret),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetAppsSecretsFind = (
  params: Params<
    void,
    t_GetAppsSecretsFindQuerySchema,
    t_GetAppsSecretsFindBodySchema | undefined,
    void
  >,
  respond: (typeof getAppsSecretsFind)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_apps_secret>
  | Response<StatusCode, t_error>
>

const getBalance = b((r) => ({
  with200: r.with200<t_balance>(s_balance),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBalance = (
  params: Params<
    void,
    t_GetBalanceQuerySchema,
    t_GetBalanceBodySchema | undefined,
    void
  >,
  respond: (typeof getBalance)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_balance>
  | Response<StatusCode, t_error>
>

const getBalanceHistory = b((r) => ({
  with200: r.with200<{
    data: t_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_balance_transaction)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/balance_transactions")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBalanceHistory = (
  params: Params<
    void,
    t_GetBalanceHistoryQuerySchema,
    t_GetBalanceHistoryBodySchema | undefined,
    void
  >,
  respond: (typeof getBalanceHistory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getBalanceHistoryId = b((r) => ({
  with200: r.with200<t_balance_transaction>(s_balance_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBalanceHistoryId = (
  params: Params<
    t_GetBalanceHistoryIdParamSchema,
    t_GetBalanceHistoryIdQuerySchema,
    t_GetBalanceHistoryIdBodySchema | undefined,
    void
  >,
  respond: (typeof getBalanceHistoryId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_balance_transaction>
  | Response<StatusCode, t_error>
>

const getBalanceTransactions = b((r) => ({
  with200: r.with200<{
    data: t_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_balance_transaction)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/balance_transactions")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBalanceTransactions = (
  params: Params<
    void,
    t_GetBalanceTransactionsQuerySchema,
    t_GetBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getBalanceTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getBalanceTransactionsId = b((r) => ({
  with200: r.with200<t_balance_transaction>(s_balance_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBalanceTransactionsId = (
  params: Params<
    t_GetBalanceTransactionsIdParamSchema,
    t_GetBalanceTransactionsIdQuerySchema,
    t_GetBalanceTransactionsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getBalanceTransactionsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_balance_transaction>
  | Response<StatusCode, t_error>
>

const getBillingAlerts = b((r) => ({
  with200: r.with200<{
    data: t_billing_alert[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_billing_alert)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/billing/alerts")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingAlerts = (
  params: Params<
    void,
    t_GetBillingAlertsQuerySchema,
    t_GetBillingAlertsBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingAlerts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_alert[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postBillingAlerts = b((r) => ({
  with200: r.with200<t_billing_alert>(s_billing_alert),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingAlerts = (
  params: Params<void, void, t_PostBillingAlertsBodySchema, void>,
  respond: (typeof postBillingAlerts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
>

const getBillingAlertsId = b((r) => ({
  with200: r.with200<t_billing_alert>(s_billing_alert),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingAlertsId = (
  params: Params<
    t_GetBillingAlertsIdParamSchema,
    t_GetBillingAlertsIdQuerySchema,
    t_GetBillingAlertsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingAlertsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
>

const postBillingAlertsIdActivate = b((r) => ({
  with200: r.with200<t_billing_alert>(s_billing_alert),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingAlertsIdActivate = (
  params: Params<
    t_PostBillingAlertsIdActivateParamSchema,
    void,
    t_PostBillingAlertsIdActivateBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingAlertsIdActivate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
>

const postBillingAlertsIdArchive = b((r) => ({
  with200: r.with200<t_billing_alert>(s_billing_alert),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingAlertsIdArchive = (
  params: Params<
    t_PostBillingAlertsIdArchiveParamSchema,
    void,
    t_PostBillingAlertsIdArchiveBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingAlertsIdArchive)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
>

const postBillingAlertsIdDeactivate = b((r) => ({
  with200: r.with200<t_billing_alert>(s_billing_alert),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingAlertsIdDeactivate = (
  params: Params<
    t_PostBillingAlertsIdDeactivateParamSchema,
    void,
    t_PostBillingAlertsIdDeactivateBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingAlertsIdDeactivate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_alert>
  | Response<StatusCode, t_error>
>

const getBillingCreditBalanceSummary = b((r) => ({
  with200: r.with200<t_billing_credit_balance_summary>(
    s_billing_credit_balance_summary,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingCreditBalanceSummary = (
  params: Params<
    void,
    t_GetBillingCreditBalanceSummaryQuerySchema,
    t_GetBillingCreditBalanceSummaryBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingCreditBalanceSummary)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_balance_summary>
  | Response<StatusCode, t_error>
>

const getBillingCreditBalanceTransactions = b((r) => ({
  with200: r.with200<{
    data: t_billing_credit_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_billing_credit_balance_transaction)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/billing/credit_grants")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingCreditBalanceTransactions = (
  params: Params<
    void,
    t_GetBillingCreditBalanceTransactionsQuerySchema,
    t_GetBillingCreditBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingCreditBalanceTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_credit_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getBillingCreditBalanceTransactionsId = b((r) => ({
  with200: r.with200<t_billing_credit_balance_transaction>(
    s_billing_credit_balance_transaction,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingCreditBalanceTransactionsId = (
  params: Params<
    t_GetBillingCreditBalanceTransactionsIdParamSchema,
    t_GetBillingCreditBalanceTransactionsIdQuerySchema,
    t_GetBillingCreditBalanceTransactionsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingCreditBalanceTransactionsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_balance_transaction>
  | Response<StatusCode, t_error>
>

const getBillingCreditGrants = b((r) => ({
  with200: r.with200<{
    data: t_billing_credit_grant[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_billing_credit_grant)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/billing/credit_grants")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingCreditGrants = (
  params: Params<
    void,
    t_GetBillingCreditGrantsQuerySchema,
    t_GetBillingCreditGrantsBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingCreditGrants)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_credit_grant[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postBillingCreditGrants = b((r) => ({
  with200: r.with200<t_billing_credit_grant>(s_billing_credit_grant),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingCreditGrants = (
  params: Params<void, void, t_PostBillingCreditGrantsBodySchema, void>,
  respond: (typeof postBillingCreditGrants)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
>

const getBillingCreditGrantsId = b((r) => ({
  with200: r.with200<t_billing_credit_grant>(s_billing_credit_grant),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingCreditGrantsId = (
  params: Params<
    t_GetBillingCreditGrantsIdParamSchema,
    t_GetBillingCreditGrantsIdQuerySchema,
    t_GetBillingCreditGrantsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingCreditGrantsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
>

const postBillingCreditGrantsId = b((r) => ({
  with200: r.with200<t_billing_credit_grant>(s_billing_credit_grant),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingCreditGrantsId = (
  params: Params<
    t_PostBillingCreditGrantsIdParamSchema,
    void,
    t_PostBillingCreditGrantsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingCreditGrantsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
>

const postBillingCreditGrantsIdExpire = b((r) => ({
  with200: r.with200<t_billing_credit_grant>(s_billing_credit_grant),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingCreditGrantsIdExpire = (
  params: Params<
    t_PostBillingCreditGrantsIdExpireParamSchema,
    void,
    t_PostBillingCreditGrantsIdExpireBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingCreditGrantsIdExpire)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
>

const postBillingCreditGrantsIdVoid = b((r) => ({
  with200: r.with200<t_billing_credit_grant>(s_billing_credit_grant),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingCreditGrantsIdVoid = (
  params: Params<
    t_PostBillingCreditGrantsIdVoidParamSchema,
    void,
    t_PostBillingCreditGrantsIdVoidBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingCreditGrantsIdVoid)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_credit_grant>
  | Response<StatusCode, t_error>
>

const postBillingMeterEventAdjustments = b((r) => ({
  with200: r.with200<t_billing_meter_event_adjustment>(
    s_billing_meter_event_adjustment,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingMeterEventAdjustments = (
  params: Params<
    void,
    void,
    t_PostBillingMeterEventAdjustmentsBodySchema,
    void
  >,
  respond: (typeof postBillingMeterEventAdjustments)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter_event_adjustment>
  | Response<StatusCode, t_error>
>

const postBillingMeterEvents = b((r) => ({
  with200: r.with200<t_billing_meter_event>(s_billing_meter_event),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingMeterEvents = (
  params: Params<void, void, t_PostBillingMeterEventsBodySchema, void>,
  respond: (typeof postBillingMeterEvents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter_event>
  | Response<StatusCode, t_error>
>

const getBillingMeters = b((r) => ({
  with200: r.with200<{
    data: t_billing_meter[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_billing_meter),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/billing/meters")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingMeters = (
  params: Params<
    void,
    t_GetBillingMetersQuerySchema,
    t_GetBillingMetersBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingMeters)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_meter[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postBillingMeters = b((r) => ({
  with200: r.with200<t_billing_meter>(s_billing_meter),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingMeters = (
  params: Params<void, void, t_PostBillingMetersBodySchema, void>,
  respond: (typeof postBillingMeters)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
>

const getBillingMetersId = b((r) => ({
  with200: r.with200<t_billing_meter>(s_billing_meter),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingMetersId = (
  params: Params<
    t_GetBillingMetersIdParamSchema,
    t_GetBillingMetersIdQuerySchema,
    t_GetBillingMetersIdBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingMetersId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
>

const postBillingMetersId = b((r) => ({
  with200: r.with200<t_billing_meter>(s_billing_meter),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingMetersId = (
  params: Params<
    t_PostBillingMetersIdParamSchema,
    void,
    t_PostBillingMetersIdBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingMetersId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
>

const postBillingMetersIdDeactivate = b((r) => ({
  with200: r.with200<t_billing_meter>(s_billing_meter),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingMetersIdDeactivate = (
  params: Params<
    t_PostBillingMetersIdDeactivateParamSchema,
    void,
    t_PostBillingMetersIdDeactivateBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingMetersIdDeactivate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
>

const getBillingMetersIdEventSummaries = b((r) => ({
  with200: r.with200<{
    data: t_billing_meter_event_summary[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_billing_meter_event_summary),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/billing/meters/[^/]+/event_summaries")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingMetersIdEventSummaries = (
  params: Params<
    t_GetBillingMetersIdEventSummariesParamSchema,
    t_GetBillingMetersIdEventSummariesQuerySchema,
    t_GetBillingMetersIdEventSummariesBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingMetersIdEventSummaries)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_meter_event_summary[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postBillingMetersIdReactivate = b((r) => ({
  with200: r.with200<t_billing_meter>(s_billing_meter),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingMetersIdReactivate = (
  params: Params<
    t_PostBillingMetersIdReactivateParamSchema,
    void,
    t_PostBillingMetersIdReactivateBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingMetersIdReactivate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_meter>
  | Response<StatusCode, t_error>
>

const getBillingPortalConfigurations = b((r) => ({
  with200: r.with200<{
    data: t_billing_portal_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_billing_portal_configuration),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/billing_portal/configurations")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingPortalConfigurations = (
  params: Params<
    void,
    t_GetBillingPortalConfigurationsQuerySchema,
    t_GetBillingPortalConfigurationsBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingPortalConfigurations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_billing_portal_configuration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postBillingPortalConfigurations = b((r) => ({
  with200: r.with200<t_billing_portal_configuration>(
    s_billing_portal_configuration,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingPortalConfigurations = (
  params: Params<void, void, t_PostBillingPortalConfigurationsBodySchema, void>,
  respond: (typeof postBillingPortalConfigurations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_configuration>
  | Response<StatusCode, t_error>
>

const getBillingPortalConfigurationsConfiguration = b((r) => ({
  with200: r.with200<t_billing_portal_configuration>(
    s_billing_portal_configuration,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetBillingPortalConfigurationsConfiguration = (
  params: Params<
    t_GetBillingPortalConfigurationsConfigurationParamSchema,
    t_GetBillingPortalConfigurationsConfigurationQuerySchema,
    t_GetBillingPortalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: (typeof getBillingPortalConfigurationsConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_configuration>
  | Response<StatusCode, t_error>
>

const postBillingPortalConfigurationsConfiguration = b((r) => ({
  with200: r.with200<t_billing_portal_configuration>(
    s_billing_portal_configuration,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingPortalConfigurationsConfiguration = (
  params: Params<
    t_PostBillingPortalConfigurationsConfigurationParamSchema,
    void,
    t_PostBillingPortalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: (typeof postBillingPortalConfigurationsConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_configuration>
  | Response<StatusCode, t_error>
>

const postBillingPortalSessions = b((r) => ({
  with200: r.with200<t_billing_portal_session>(s_billing_portal_session),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostBillingPortalSessions = (
  params: Params<void, void, t_PostBillingPortalSessionsBodySchema, void>,
  respond: (typeof postBillingPortalSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_portal_session>
  | Response<StatusCode, t_error>
>

const getCharges = b((r) => ({
  with200: r.with200<{
    data: t_charge[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_charge)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/charges")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCharges = (
  params: Params<
    void,
    t_GetChargesQuerySchema,
    t_GetChargesBodySchema | undefined,
    void
  >,
  respond: (typeof getCharges)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_charge[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCharges = b((r) => ({
  with200: r.with200<t_charge>(s_charge),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCharges = (
  params: Params<void, void, t_PostChargesBodySchema | undefined, void>,
  respond: (typeof postCharges)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
>

const getChargesSearch = b((r) => ({
  with200: r.with200<{
    data: t_charge[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_charge)),
      has_more: PermissiveBoolean,
      next_page: z.string().max(5000).nullable().optional(),
      object: z.enum(["search_result"]),
      total_count: z.coerce.number().optional(),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetChargesSearch = (
  params: Params<
    void,
    t_GetChargesSearchQuerySchema,
    t_GetChargesSearchBodySchema | undefined,
    void
  >,
  respond: (typeof getChargesSearch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_charge[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getChargesCharge = b((r) => ({
  with200: r.with200<t_charge>(s_charge),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetChargesCharge = (
  params: Params<
    t_GetChargesChargeParamSchema,
    t_GetChargesChargeQuerySchema,
    t_GetChargesChargeBodySchema | undefined,
    void
  >,
  respond: (typeof getChargesCharge)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
>

const postChargesCharge = b((r) => ({
  with200: r.with200<t_charge>(s_charge),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostChargesCharge = (
  params: Params<
    t_PostChargesChargeParamSchema,
    void,
    t_PostChargesChargeBodySchema | undefined,
    void
  >,
  respond: (typeof postChargesCharge)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
>

const postChargesChargeCapture = b((r) => ({
  with200: r.with200<t_charge>(s_charge),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostChargesChargeCapture = (
  params: Params<
    t_PostChargesChargeCaptureParamSchema,
    void,
    t_PostChargesChargeCaptureBodySchema | undefined,
    void
  >,
  respond: (typeof postChargesChargeCapture)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
>

const getChargesChargeDispute = b((r) => ({
  with200: r.with200<t_dispute>(s_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetChargesChargeDispute = (
  params: Params<
    t_GetChargesChargeDisputeParamSchema,
    t_GetChargesChargeDisputeQuerySchema,
    t_GetChargesChargeDisputeBodySchema | undefined,
    void
  >,
  respond: (typeof getChargesChargeDispute)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
>

const postChargesChargeDispute = b((r) => ({
  with200: r.with200<t_dispute>(s_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostChargesChargeDispute = (
  params: Params<
    t_PostChargesChargeDisputeParamSchema,
    void,
    t_PostChargesChargeDisputeBodySchema | undefined,
    void
  >,
  respond: (typeof postChargesChargeDispute)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
>

const postChargesChargeDisputeClose = b((r) => ({
  with200: r.with200<t_dispute>(s_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostChargesChargeDisputeClose = (
  params: Params<
    t_PostChargesChargeDisputeCloseParamSchema,
    void,
    t_PostChargesChargeDisputeCloseBodySchema | undefined,
    void
  >,
  respond: (typeof postChargesChargeDisputeClose)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
>

const postChargesChargeRefund = b((r) => ({
  with200: r.with200<t_charge>(s_charge),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostChargesChargeRefund = (
  params: Params<
    t_PostChargesChargeRefundParamSchema,
    void,
    t_PostChargesChargeRefundBodySchema | undefined,
    void
  >,
  respond: (typeof postChargesChargeRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_charge>
  | Response<StatusCode, t_error>
>

const getChargesChargeRefunds = b((r) => ({
  with200: r.with200<{
    data: t_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_refund)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetChargesChargeRefunds = (
  params: Params<
    t_GetChargesChargeRefundsParamSchema,
    t_GetChargesChargeRefundsQuerySchema,
    t_GetChargesChargeRefundsBodySchema | undefined,
    void
  >,
  respond: (typeof getChargesChargeRefunds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_refund[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postChargesChargeRefunds = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostChargesChargeRefunds = (
  params: Params<
    t_PostChargesChargeRefundsParamSchema,
    void,
    t_PostChargesChargeRefundsBodySchema | undefined,
    void
  >,
  respond: (typeof postChargesChargeRefunds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const getChargesChargeRefundsRefund = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetChargesChargeRefundsRefund = (
  params: Params<
    t_GetChargesChargeRefundsRefundParamSchema,
    t_GetChargesChargeRefundsRefundQuerySchema,
    t_GetChargesChargeRefundsRefundBodySchema | undefined,
    void
  >,
  respond: (typeof getChargesChargeRefundsRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const postChargesChargeRefundsRefund = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostChargesChargeRefundsRefund = (
  params: Params<
    t_PostChargesChargeRefundsRefundParamSchema,
    void,
    t_PostChargesChargeRefundsRefundBodySchema | undefined,
    void
  >,
  respond: (typeof postChargesChargeRefundsRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const getCheckoutSessions = b((r) => ({
  with200: r.with200<{
    data: t_checkout_session[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_checkout_session)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCheckoutSessions = (
  params: Params<
    void,
    t_GetCheckoutSessionsQuerySchema,
    t_GetCheckoutSessionsBodySchema | undefined,
    void
  >,
  respond: (typeof getCheckoutSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_checkout_session[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCheckoutSessions = b((r) => ({
  with200: r.with200<t_checkout_session>(s_checkout_session),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCheckoutSessions = (
  params: Params<
    void,
    void,
    t_PostCheckoutSessionsBodySchema | undefined,
    void
  >,
  respond: (typeof postCheckoutSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
>

const getCheckoutSessionsSession = b((r) => ({
  with200: r.with200<t_checkout_session>(s_checkout_session),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCheckoutSessionsSession = (
  params: Params<
    t_GetCheckoutSessionsSessionParamSchema,
    t_GetCheckoutSessionsSessionQuerySchema,
    t_GetCheckoutSessionsSessionBodySchema | undefined,
    void
  >,
  respond: (typeof getCheckoutSessionsSession)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
>

const postCheckoutSessionsSession = b((r) => ({
  with200: r.with200<t_checkout_session>(s_checkout_session),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCheckoutSessionsSession = (
  params: Params<
    t_PostCheckoutSessionsSessionParamSchema,
    void,
    t_PostCheckoutSessionsSessionBodySchema | undefined,
    void
  >,
  respond: (typeof postCheckoutSessionsSession)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
>

const postCheckoutSessionsSessionExpire = b((r) => ({
  with200: r.with200<t_checkout_session>(s_checkout_session),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCheckoutSessionsSessionExpire = (
  params: Params<
    t_PostCheckoutSessionsSessionExpireParamSchema,
    void,
    t_PostCheckoutSessionsSessionExpireBodySchema | undefined,
    void
  >,
  respond: (typeof postCheckoutSessionsSessionExpire)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_checkout_session>
  | Response<StatusCode, t_error>
>

const getCheckoutSessionsSessionLineItems = b((r) => ({
  with200: r.with200<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCheckoutSessionsSessionLineItems = (
  params: Params<
    t_GetCheckoutSessionsSessionLineItemsParamSchema,
    t_GetCheckoutSessionsSessionLineItemsQuerySchema,
    t_GetCheckoutSessionsSessionLineItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getCheckoutSessionsSessionLineItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getClimateOrders = b((r) => ({
  with200: r.with200<{
    data: t_climate_order[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_climate_order),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/climate/orders")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetClimateOrders = (
  params: Params<
    void,
    t_GetClimateOrdersQuerySchema,
    t_GetClimateOrdersBodySchema | undefined,
    void
  >,
  respond: (typeof getClimateOrders)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_climate_order[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postClimateOrders = b((r) => ({
  with200: r.with200<t_climate_order>(s_climate_order),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostClimateOrders = (
  params: Params<void, void, t_PostClimateOrdersBodySchema, void>,
  respond: (typeof postClimateOrders)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
>

const getClimateOrdersOrder = b((r) => ({
  with200: r.with200<t_climate_order>(s_climate_order),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetClimateOrdersOrder = (
  params: Params<
    t_GetClimateOrdersOrderParamSchema,
    t_GetClimateOrdersOrderQuerySchema,
    t_GetClimateOrdersOrderBodySchema | undefined,
    void
  >,
  respond: (typeof getClimateOrdersOrder)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
>

const postClimateOrdersOrder = b((r) => ({
  with200: r.with200<t_climate_order>(s_climate_order),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostClimateOrdersOrder = (
  params: Params<
    t_PostClimateOrdersOrderParamSchema,
    void,
    t_PostClimateOrdersOrderBodySchema | undefined,
    void
  >,
  respond: (typeof postClimateOrdersOrder)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
>

const postClimateOrdersOrderCancel = b((r) => ({
  with200: r.with200<t_climate_order>(s_climate_order),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostClimateOrdersOrderCancel = (
  params: Params<
    t_PostClimateOrdersOrderCancelParamSchema,
    void,
    t_PostClimateOrdersOrderCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postClimateOrdersOrderCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_order>
  | Response<StatusCode, t_error>
>

const getClimateProducts = b((r) => ({
  with200: r.with200<{
    data: t_climate_product[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_climate_product),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/climate/products")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetClimateProducts = (
  params: Params<
    void,
    t_GetClimateProductsQuerySchema,
    t_GetClimateProductsBodySchema | undefined,
    void
  >,
  respond: (typeof getClimateProducts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_climate_product[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getClimateProductsProduct = b((r) => ({
  with200: r.with200<t_climate_product>(s_climate_product),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetClimateProductsProduct = (
  params: Params<
    t_GetClimateProductsProductParamSchema,
    t_GetClimateProductsProductQuerySchema,
    t_GetClimateProductsProductBodySchema | undefined,
    void
  >,
  respond: (typeof getClimateProductsProduct)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_product>
  | Response<StatusCode, t_error>
>

const getClimateSuppliers = b((r) => ({
  with200: r.with200<{
    data: t_climate_supplier[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_climate_supplier),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/climate/suppliers")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetClimateSuppliers = (
  params: Params<
    void,
    t_GetClimateSuppliersQuerySchema,
    t_GetClimateSuppliersBodySchema | undefined,
    void
  >,
  respond: (typeof getClimateSuppliers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_climate_supplier[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getClimateSuppliersSupplier = b((r) => ({
  with200: r.with200<t_climate_supplier>(s_climate_supplier),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetClimateSuppliersSupplier = (
  params: Params<
    t_GetClimateSuppliersSupplierParamSchema,
    t_GetClimateSuppliersSupplierQuerySchema,
    t_GetClimateSuppliersSupplierBodySchema | undefined,
    void
  >,
  respond: (typeof getClimateSuppliersSupplier)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_climate_supplier>
  | Response<StatusCode, t_error>
>

const getConfirmationTokensConfirmationToken = b((r) => ({
  with200: r.with200<t_confirmation_token>(s_confirmation_token),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetConfirmationTokensConfirmationToken = (
  params: Params<
    t_GetConfirmationTokensConfirmationTokenParamSchema,
    t_GetConfirmationTokensConfirmationTokenQuerySchema,
    t_GetConfirmationTokensConfirmationTokenBodySchema | undefined,
    void
  >,
  respond: (typeof getConfirmationTokensConfirmationToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_confirmation_token>
  | Response<StatusCode, t_error>
>

const getCountrySpecs = b((r) => ({
  with200: r.with200<{
    data: t_country_spec[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_country_spec),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/country_specs")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCountrySpecs = (
  params: Params<
    void,
    t_GetCountrySpecsQuerySchema,
    t_GetCountrySpecsBodySchema | undefined,
    void
  >,
  respond: (typeof getCountrySpecs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_country_spec[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getCountrySpecsCountry = b((r) => ({
  with200: r.with200<t_country_spec>(s_country_spec),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCountrySpecsCountry = (
  params: Params<
    t_GetCountrySpecsCountryParamSchema,
    t_GetCountrySpecsCountryQuerySchema,
    t_GetCountrySpecsCountryBodySchema | undefined,
    void
  >,
  respond: (typeof getCountrySpecsCountry)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_country_spec>
  | Response<StatusCode, t_error>
>

const getCoupons = b((r) => ({
  with200: r.with200<{
    data: t_coupon[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_coupon),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/coupons")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCoupons = (
  params: Params<
    void,
    t_GetCouponsQuerySchema,
    t_GetCouponsBodySchema | undefined,
    void
  >,
  respond: (typeof getCoupons)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_coupon[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCoupons = b((r) => ({
  with200: r.with200<t_coupon>(s_coupon),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCoupons = (
  params: Params<void, void, t_PostCouponsBodySchema | undefined, void>,
  respond: (typeof postCoupons)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_coupon>
  | Response<StatusCode, t_error>
>

const deleteCouponsCoupon = b((r) => ({
  with200: r.with200<t_deleted_coupon>(s_deleted_coupon),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCouponsCoupon = (
  params: Params<
    t_DeleteCouponsCouponParamSchema,
    void,
    t_DeleteCouponsCouponBodySchema | undefined,
    void
  >,
  respond: (typeof deleteCouponsCoupon)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_coupon>
  | Response<StatusCode, t_error>
>

const getCouponsCoupon = b((r) => ({
  with200: r.with200<t_coupon>(s_coupon),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCouponsCoupon = (
  params: Params<
    t_GetCouponsCouponParamSchema,
    t_GetCouponsCouponQuerySchema,
    t_GetCouponsCouponBodySchema | undefined,
    void
  >,
  respond: (typeof getCouponsCoupon)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_coupon>
  | Response<StatusCode, t_error>
>

const postCouponsCoupon = b((r) => ({
  with200: r.with200<t_coupon>(s_coupon),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCouponsCoupon = (
  params: Params<
    t_PostCouponsCouponParamSchema,
    void,
    t_PostCouponsCouponBodySchema | undefined,
    void
  >,
  respond: (typeof postCouponsCoupon)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_coupon>
  | Response<StatusCode, t_error>
>

const getCreditNotes = b((r) => ({
  with200: r.with200<{
    data: t_credit_note[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_credit_note)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCreditNotes = (
  params: Params<
    void,
    t_GetCreditNotesQuerySchema,
    t_GetCreditNotesBodySchema | undefined,
    void
  >,
  respond: (typeof getCreditNotes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_credit_note[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCreditNotes = b((r) => ({
  with200: r.with200<t_credit_note>(s_credit_note),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCreditNotes = (
  params: Params<void, void, t_PostCreditNotesBodySchema, void>,
  respond: (typeof postCreditNotes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
>

const getCreditNotesPreview = b((r) => ({
  with200: r.with200<t_credit_note>(s_credit_note),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCreditNotesPreview = (
  params: Params<
    void,
    t_GetCreditNotesPreviewQuerySchema,
    t_GetCreditNotesPreviewBodySchema | undefined,
    void
  >,
  respond: (typeof getCreditNotesPreview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
>

const getCreditNotesPreviewLines = b((r) => ({
  with200: r.with200<{
    data: t_credit_note_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_credit_note_line_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCreditNotesPreviewLines = (
  params: Params<
    void,
    t_GetCreditNotesPreviewLinesQuerySchema,
    t_GetCreditNotesPreviewLinesBodySchema | undefined,
    void
  >,
  respond: (typeof getCreditNotesPreviewLines)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_credit_note_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getCreditNotesCreditNoteLines = b((r) => ({
  with200: r.with200<{
    data: t_credit_note_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_credit_note_line_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCreditNotesCreditNoteLines = (
  params: Params<
    t_GetCreditNotesCreditNoteLinesParamSchema,
    t_GetCreditNotesCreditNoteLinesQuerySchema,
    t_GetCreditNotesCreditNoteLinesBodySchema | undefined,
    void
  >,
  respond: (typeof getCreditNotesCreditNoteLines)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_credit_note_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getCreditNotesId = b((r) => ({
  with200: r.with200<t_credit_note>(s_credit_note),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCreditNotesId = (
  params: Params<
    t_GetCreditNotesIdParamSchema,
    t_GetCreditNotesIdQuerySchema,
    t_GetCreditNotesIdBodySchema | undefined,
    void
  >,
  respond: (typeof getCreditNotesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
>

const postCreditNotesId = b((r) => ({
  with200: r.with200<t_credit_note>(s_credit_note),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCreditNotesId = (
  params: Params<
    t_PostCreditNotesIdParamSchema,
    void,
    t_PostCreditNotesIdBodySchema | undefined,
    void
  >,
  respond: (typeof postCreditNotesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
>

const postCreditNotesIdVoid = b((r) => ({
  with200: r.with200<t_credit_note>(s_credit_note),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCreditNotesIdVoid = (
  params: Params<
    t_PostCreditNotesIdVoidParamSchema,
    void,
    t_PostCreditNotesIdVoidBodySchema | undefined,
    void
  >,
  respond: (typeof postCreditNotesIdVoid)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_credit_note>
  | Response<StatusCode, t_error>
>

const postCustomerSessions = b((r) => ({
  with200: r.with200<t_customer_session>(s_customer_session),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomerSessions = (
  params: Params<void, void, t_PostCustomerSessionsBodySchema, void>,
  respond: (typeof postCustomerSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_session>
  | Response<StatusCode, t_error>
>

const getCustomers = b((r) => ({
  with200: r.with200<{
    data: t_customer[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_customer)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/customers")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomers = (
  params: Params<
    void,
    t_GetCustomersQuerySchema,
    t_GetCustomersBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCustomers = b((r) => ({
  with200: r.with200<t_customer>(s_customer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomers = (
  params: Params<void, void, t_PostCustomersBodySchema | undefined, void>,
  respond: (typeof postCustomers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer>
  | Response<StatusCode, t_error>
>

const getCustomersSearch = b((r) => ({
  with200: r.with200<{
    data: t_customer[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_customer)),
      has_more: PermissiveBoolean,
      next_page: z.string().max(5000).nullable().optional(),
      object: z.enum(["search_result"]),
      total_count: z.coerce.number().optional(),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersSearch = (
  params: Params<
    void,
    t_GetCustomersSearchQuerySchema,
    t_GetCustomersSearchBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersSearch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomer = b((r) => ({
  with200: r.with200<t_deleted_customer>(s_deleted_customer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCustomersCustomer = (
  params: Params<
    t_DeleteCustomersCustomerParamSchema,
    void,
    t_DeleteCustomersCustomerBodySchema | undefined,
    void
  >,
  respond: (typeof deleteCustomersCustomer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_customer>
  | Response<StatusCode, t_error>
>

const getCustomersCustomer = b((r) => ({
  with200: r.with200<t_customer | t_deleted_customer>(
    z.union([z.lazy(() => s_customer), s_deleted_customer]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomer = (
  params: Params<
    t_GetCustomersCustomerParamSchema,
    t_GetCustomersCustomerQuerySchema,
    t_GetCustomersCustomerBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer | t_deleted_customer>
  | Response<StatusCode, t_error>
>

const postCustomersCustomer = b((r) => ({
  with200: r.with200<t_customer>(s_customer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomer = (
  params: Params<
    t_PostCustomersCustomerParamSchema,
    void,
    t_PostCustomersCustomerBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerBalanceTransactions = b((r) => ({
  with200: r.with200<{
    data: t_customer_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_customer_balance_transaction)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerBalanceTransactions = (
  params: Params<
    t_GetCustomersCustomerBalanceTransactionsParamSchema,
    t_GetCustomersCustomerBalanceTransactionsQuerySchema,
    t_GetCustomersCustomerBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerBalanceTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCustomersCustomerBalanceTransactions = b((r) => ({
  with200: r.with200<t_customer_balance_transaction>(
    s_customer_balance_transaction,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerBalanceTransactions = (
  params: Params<
    t_PostCustomersCustomerBalanceTransactionsParamSchema,
    void,
    t_PostCustomersCustomerBalanceTransactionsBodySchema,
    void
  >,
  respond: (typeof postCustomersCustomerBalanceTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_balance_transaction>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerBalanceTransactionsTransaction = b((r) => ({
  with200: r.with200<t_customer_balance_transaction>(
    s_customer_balance_transaction,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerBalanceTransactionsTransaction = (
  params: Params<
    t_GetCustomersCustomerBalanceTransactionsTransactionParamSchema,
    t_GetCustomersCustomerBalanceTransactionsTransactionQuerySchema,
    t_GetCustomersCustomerBalanceTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerBalanceTransactionsTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_balance_transaction>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerBalanceTransactionsTransaction = b((r) => ({
  with200: r.with200<t_customer_balance_transaction>(
    s_customer_balance_transaction,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerBalanceTransactionsTransaction = (
  params: Params<
    t_PostCustomersCustomerBalanceTransactionsTransactionParamSchema,
    void,
    t_PostCustomersCustomerBalanceTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerBalanceTransactionsTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_balance_transaction>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerBankAccounts = b((r) => ({
  with200: r.with200<{
    data: t_bank_account[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_bank_account)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerBankAccounts = (
  params: Params<
    t_GetCustomersCustomerBankAccountsParamSchema,
    t_GetCustomersCustomerBankAccountsQuerySchema,
    t_GetCustomersCustomerBankAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerBankAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_bank_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCustomersCustomerBankAccounts = b((r) => ({
  with200: r.with200<t_payment_source>(s_payment_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerBankAccounts = (
  params: Params<
    t_PostCustomersCustomerBankAccountsParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerBankAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomerBankAccountsId = b((r) => ({
  with200: r.with200<t_payment_source | t_deleted_payment_source>(
    z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCustomersCustomerBankAccountsId = (
  params: Params<
    t_DeleteCustomersCustomerBankAccountsIdParamSchema,
    void,
    t_DeleteCustomersCustomerBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteCustomersCustomerBankAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source | t_deleted_payment_source>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerBankAccountsId = b((r) => ({
  with200: r.with200<t_bank_account>(s_bank_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerBankAccountsId = (
  params: Params<
    t_GetCustomersCustomerBankAccountsIdParamSchema,
    t_GetCustomersCustomerBankAccountsIdQuerySchema,
    t_GetCustomersCustomerBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerBankAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_bank_account>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerBankAccountsId = b((r) => ({
  with200: r.with200<t_card | t_bank_account | t_source>(
    z.union([z.lazy(() => s_card), z.lazy(() => s_bank_account), s_source]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerBankAccountsId = (
  params: Params<
    t_PostCustomersCustomerBankAccountsIdParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerBankAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card | t_bank_account | t_source>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerBankAccountsIdVerify = b((r) => ({
  with200: r.with200<t_bank_account>(s_bank_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerBankAccountsIdVerify = (
  params: Params<
    t_PostCustomersCustomerBankAccountsIdVerifyParamSchema,
    void,
    t_PostCustomersCustomerBankAccountsIdVerifyBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerBankAccountsIdVerify)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_bank_account>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerCards = b((r) => ({
  with200: r.with200<{
    data: t_card[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_card)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerCards = (
  params: Params<
    t_GetCustomersCustomerCardsParamSchema,
    t_GetCustomersCustomerCardsQuerySchema,
    t_GetCustomersCustomerCardsBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerCards)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_card[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCustomersCustomerCards = b((r) => ({
  with200: r.with200<t_payment_source>(s_payment_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerCards = (
  params: Params<
    t_PostCustomersCustomerCardsParamSchema,
    void,
    t_PostCustomersCustomerCardsBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerCards)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomerCardsId = b((r) => ({
  with200: r.with200<t_payment_source | t_deleted_payment_source>(
    z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCustomersCustomerCardsId = (
  params: Params<
    t_DeleteCustomersCustomerCardsIdParamSchema,
    void,
    t_DeleteCustomersCustomerCardsIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteCustomersCustomerCardsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source | t_deleted_payment_source>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerCardsId = b((r) => ({
  with200: r.with200<t_card>(s_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerCardsId = (
  params: Params<
    t_GetCustomersCustomerCardsIdParamSchema,
    t_GetCustomersCustomerCardsIdQuerySchema,
    t_GetCustomersCustomerCardsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerCardsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerCardsId = b((r) => ({
  with200: r.with200<t_card | t_bank_account | t_source>(
    z.union([z.lazy(() => s_card), z.lazy(() => s_bank_account), s_source]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerCardsId = (
  params: Params<
    t_PostCustomersCustomerCardsIdParamSchema,
    void,
    t_PostCustomersCustomerCardsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerCardsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card | t_bank_account | t_source>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerCashBalance = b((r) => ({
  with200: r.with200<t_cash_balance>(s_cash_balance),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerCashBalance = (
  params: Params<
    t_GetCustomersCustomerCashBalanceParamSchema,
    t_GetCustomersCustomerCashBalanceQuerySchema,
    t_GetCustomersCustomerCashBalanceBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerCashBalance)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_cash_balance>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerCashBalance = b((r) => ({
  with200: r.with200<t_cash_balance>(s_cash_balance),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerCashBalance = (
  params: Params<
    t_PostCustomersCustomerCashBalanceParamSchema,
    void,
    t_PostCustomersCustomerCashBalanceBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerCashBalance)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_cash_balance>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerCashBalanceTransactions = b((r) => ({
  with200: r.with200<{
    data: t_customer_cash_balance_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_customer_cash_balance_transaction)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerCashBalanceTransactions = (
  params: Params<
    t_GetCustomersCustomerCashBalanceTransactionsParamSchema,
    t_GetCustomersCustomerCashBalanceTransactionsQuerySchema,
    t_GetCustomersCustomerCashBalanceTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerCashBalanceTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_customer_cash_balance_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getCustomersCustomerCashBalanceTransactionsTransaction = b((r) => ({
  with200: r.with200<t_customer_cash_balance_transaction>(
    s_customer_cash_balance_transaction,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerCashBalanceTransactionsTransaction = (
  params: Params<
    t_GetCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
    t_GetCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
    | t_GetCustomersCustomerCashBalanceTransactionsTransactionBodySchema
    | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerCashBalanceTransactionsTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_cash_balance_transaction>
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomerDiscount = b((r) => ({
  with200: r.with200<t_deleted_discount>(s_deleted_discount),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCustomersCustomerDiscount = (
  params: Params<
    t_DeleteCustomersCustomerDiscountParamSchema,
    void,
    t_DeleteCustomersCustomerDiscountBodySchema | undefined,
    void
  >,
  respond: (typeof deleteCustomersCustomerDiscount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_discount>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerDiscount = b((r) => ({
  with200: r.with200<t_discount>(s_discount),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerDiscount = (
  params: Params<
    t_GetCustomersCustomerDiscountParamSchema,
    t_GetCustomersCustomerDiscountQuerySchema,
    t_GetCustomersCustomerDiscountBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerDiscount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_discount>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerFundingInstructions = b((r) => ({
  with200: r.with200<t_funding_instructions>(s_funding_instructions),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerFundingInstructions = (
  params: Params<
    t_PostCustomersCustomerFundingInstructionsParamSchema,
    void,
    t_PostCustomersCustomerFundingInstructionsBodySchema,
    void
  >,
  respond: (typeof postCustomersCustomerFundingInstructions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_funding_instructions>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerPaymentMethods = b((r) => ({
  with200: r.with200<{
    data: t_payment_method[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_payment_method)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerPaymentMethods = (
  params: Params<
    t_GetCustomersCustomerPaymentMethodsParamSchema,
    t_GetCustomersCustomerPaymentMethodsQuerySchema,
    t_GetCustomersCustomerPaymentMethodsBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerPaymentMethods)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getCustomersCustomerPaymentMethodsPaymentMethod = b((r) => ({
  with200: r.with200<t_payment_method>(s_payment_method),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerPaymentMethodsPaymentMethod = (
  params: Params<
    t_GetCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
    t_GetCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
    t_GetCustomersCustomerPaymentMethodsPaymentMethodBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerPaymentMethodsPaymentMethod)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerSources = b((r) => ({
  with200: r.with200<{
    data: (t_bank_account | t_card | t_source)[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(
        z.union([z.lazy(() => s_bank_account), z.lazy(() => s_card), s_source]),
      ),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerSources = (
  params: Params<
    t_GetCustomersCustomerSourcesParamSchema,
    t_GetCustomersCustomerSourcesQuerySchema,
    t_GetCustomersCustomerSourcesBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerSources)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: (t_bank_account | t_card | t_source)[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCustomersCustomerSources = b((r) => ({
  with200: r.with200<t_payment_source>(s_payment_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerSources = (
  params: Params<
    t_PostCustomersCustomerSourcesParamSchema,
    void,
    t_PostCustomersCustomerSourcesBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerSources)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomerSourcesId = b((r) => ({
  with200: r.with200<t_payment_source | t_deleted_payment_source>(
    z.union([z.lazy(() => s_payment_source), s_deleted_payment_source]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCustomersCustomerSourcesId = (
  params: Params<
    t_DeleteCustomersCustomerSourcesIdParamSchema,
    void,
    t_DeleteCustomersCustomerSourcesIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteCustomersCustomerSourcesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source | t_deleted_payment_source>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerSourcesId = b((r) => ({
  with200: r.with200<t_payment_source>(s_payment_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerSourcesId = (
  params: Params<
    t_GetCustomersCustomerSourcesIdParamSchema,
    t_GetCustomersCustomerSourcesIdQuerySchema,
    t_GetCustomersCustomerSourcesIdBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerSourcesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_source>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerSourcesId = b((r) => ({
  with200: r.with200<t_card | t_bank_account | t_source>(
    z.union([z.lazy(() => s_card), z.lazy(() => s_bank_account), s_source]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerSourcesId = (
  params: Params<
    t_PostCustomersCustomerSourcesIdParamSchema,
    void,
    t_PostCustomersCustomerSourcesIdBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerSourcesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_card | t_bank_account | t_source>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerSourcesIdVerify = b((r) => ({
  with200: r.with200<t_bank_account>(s_bank_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerSourcesIdVerify = (
  params: Params<
    t_PostCustomersCustomerSourcesIdVerifyParamSchema,
    void,
    t_PostCustomersCustomerSourcesIdVerifyBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerSourcesIdVerify)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_bank_account>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerSubscriptions = b((r) => ({
  with200: r.with200<{
    data: t_subscription[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_subscription)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerSubscriptions = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsParamSchema,
    t_GetCustomersCustomerSubscriptionsQuerySchema,
    t_GetCustomersCustomerSubscriptionsBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerSubscriptions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCustomersCustomerSubscriptions = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerSubscriptions = (
  params: Params<
    t_PostCustomersCustomerSubscriptionsParamSchema,
    void,
    t_PostCustomersCustomerSubscriptionsBodySchema | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerSubscriptions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomerSubscriptionsSubscriptionExposedId = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    | t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema
    | undefined,
    void
  >,
  respond: (typeof deleteCustomersCustomerSubscriptionsSubscriptionExposedId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerSubscriptionsSubscriptionExposedId = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
    | t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema
    | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerSubscriptionsSubscriptionExposedId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const postCustomersCustomerSubscriptionsSubscriptionExposedId = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    | t_PostCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema
    | undefined,
    void
  >,
  respond: (typeof postCustomersCustomerSubscriptionsSubscriptionExposedId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount = b(
  (r) => ({
    with200: r.with200<t_deleted_discount>(s_deleted_discount),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }),
)

export type DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount =
  (
    params: Params<
      t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
      void,
      | t_DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema
      | undefined,
      void
    >,
    respond: (typeof deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount)["responder"],
    ctx: RouterContext,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_deleted_discount>
    | Response<StatusCode, t_error>
  >

const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount = b(
  (r) => ({
    with200: r.with200<t_discount>(s_discount),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }),
)

export type GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount = (
  params: Params<
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
    t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
    | t_GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema
    | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_discount>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerTaxIds = b((r) => ({
  with200: r.with200<{
    data: t_tax_id[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_tax_id)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerTaxIds = (
  params: Params<
    t_GetCustomersCustomerTaxIdsParamSchema,
    t_GetCustomersCustomerTaxIdsQuerySchema,
    t_GetCustomersCustomerTaxIdsBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerTaxIds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_id[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postCustomersCustomerTaxIds = b((r) => ({
  with200: r.with200<t_tax_id>(s_tax_id),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostCustomersCustomerTaxIds = (
  params: Params<
    t_PostCustomersCustomerTaxIdsParamSchema,
    void,
    t_PostCustomersCustomerTaxIdsBodySchema,
    void
  >,
  respond: (typeof postCustomersCustomerTaxIds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
>

const deleteCustomersCustomerTaxIdsId = b((r) => ({
  with200: r.with200<t_deleted_tax_id>(s_deleted_tax_id),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteCustomersCustomerTaxIdsId = (
  params: Params<
    t_DeleteCustomersCustomerTaxIdsIdParamSchema,
    void,
    t_DeleteCustomersCustomerTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteCustomersCustomerTaxIdsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_tax_id>
  | Response<StatusCode, t_error>
>

const getCustomersCustomerTaxIdsId = b((r) => ({
  with200: r.with200<t_tax_id>(s_tax_id),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetCustomersCustomerTaxIdsId = (
  params: Params<
    t_GetCustomersCustomerTaxIdsIdParamSchema,
    t_GetCustomersCustomerTaxIdsIdQuerySchema,
    t_GetCustomersCustomerTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getCustomersCustomerTaxIdsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
>

const getDisputes = b((r) => ({
  with200: r.with200<{
    data: t_dispute[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_dispute)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/disputes")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetDisputes = (
  params: Params<
    void,
    t_GetDisputesQuerySchema,
    t_GetDisputesBodySchema | undefined,
    void
  >,
  respond: (typeof getDisputes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_dispute[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getDisputesDispute = b((r) => ({
  with200: r.with200<t_dispute>(s_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetDisputesDispute = (
  params: Params<
    t_GetDisputesDisputeParamSchema,
    t_GetDisputesDisputeQuerySchema,
    t_GetDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: (typeof getDisputesDispute)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
>

const postDisputesDispute = b((r) => ({
  with200: r.with200<t_dispute>(s_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostDisputesDispute = (
  params: Params<
    t_PostDisputesDisputeParamSchema,
    void,
    t_PostDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: (typeof postDisputesDispute)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
>

const postDisputesDisputeClose = b((r) => ({
  with200: r.with200<t_dispute>(s_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostDisputesDisputeClose = (
  params: Params<
    t_PostDisputesDisputeCloseParamSchema,
    void,
    t_PostDisputesDisputeCloseBodySchema | undefined,
    void
  >,
  respond: (typeof postDisputesDisputeClose)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dispute>
  | Response<StatusCode, t_error>
>

const getEntitlementsActiveEntitlements = b((r) => ({
  with200: r.with200<{
    data: t_entitlements_active_entitlement[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_entitlements_active_entitlement),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetEntitlementsActiveEntitlements = (
  params: Params<
    void,
    t_GetEntitlementsActiveEntitlementsQuerySchema,
    t_GetEntitlementsActiveEntitlementsBodySchema | undefined,
    void
  >,
  respond: (typeof getEntitlementsActiveEntitlements)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_entitlements_active_entitlement[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getEntitlementsActiveEntitlementsId = b((r) => ({
  with200: r.with200<t_entitlements_active_entitlement>(
    s_entitlements_active_entitlement,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetEntitlementsActiveEntitlementsId = (
  params: Params<
    t_GetEntitlementsActiveEntitlementsIdParamSchema,
    t_GetEntitlementsActiveEntitlementsIdQuerySchema,
    t_GetEntitlementsActiveEntitlementsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getEntitlementsActiveEntitlementsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_active_entitlement>
  | Response<StatusCode, t_error>
>

const getEntitlementsFeatures = b((r) => ({
  with200: r.with200<{
    data: t_entitlements_feature[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_entitlements_feature),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/entitlements/features")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetEntitlementsFeatures = (
  params: Params<
    void,
    t_GetEntitlementsFeaturesQuerySchema,
    t_GetEntitlementsFeaturesBodySchema | undefined,
    void
  >,
  respond: (typeof getEntitlementsFeatures)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_entitlements_feature[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postEntitlementsFeatures = b((r) => ({
  with200: r.with200<t_entitlements_feature>(s_entitlements_feature),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostEntitlementsFeatures = (
  params: Params<void, void, t_PostEntitlementsFeaturesBodySchema, void>,
  respond: (typeof postEntitlementsFeatures)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_feature>
  | Response<StatusCode, t_error>
>

const getEntitlementsFeaturesId = b((r) => ({
  with200: r.with200<t_entitlements_feature>(s_entitlements_feature),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetEntitlementsFeaturesId = (
  params: Params<
    t_GetEntitlementsFeaturesIdParamSchema,
    t_GetEntitlementsFeaturesIdQuerySchema,
    t_GetEntitlementsFeaturesIdBodySchema | undefined,
    void
  >,
  respond: (typeof getEntitlementsFeaturesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_feature>
  | Response<StatusCode, t_error>
>

const postEntitlementsFeaturesId = b((r) => ({
  with200: r.with200<t_entitlements_feature>(s_entitlements_feature),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostEntitlementsFeaturesId = (
  params: Params<
    t_PostEntitlementsFeaturesIdParamSchema,
    void,
    t_PostEntitlementsFeaturesIdBodySchema | undefined,
    void
  >,
  respond: (typeof postEntitlementsFeaturesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_entitlements_feature>
  | Response<StatusCode, t_error>
>

const postEphemeralKeys = b((r) => ({
  with200: r.with200<t_ephemeral_key>(s_ephemeral_key),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostEphemeralKeys = (
  params: Params<void, void, t_PostEphemeralKeysBodySchema | undefined, void>,
  respond: (typeof postEphemeralKeys)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ephemeral_key>
  | Response<StatusCode, t_error>
>

const deleteEphemeralKeysKey = b((r) => ({
  with200: r.with200<t_ephemeral_key>(s_ephemeral_key),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteEphemeralKeysKey = (
  params: Params<
    t_DeleteEphemeralKeysKeyParamSchema,
    void,
    t_DeleteEphemeralKeysKeyBodySchema | undefined,
    void
  >,
  respond: (typeof deleteEphemeralKeysKey)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ephemeral_key>
  | Response<StatusCode, t_error>
>

const getEvents = b((r) => ({
  with200: r.with200<{
    data: t_event[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_event),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/events")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetEvents = (
  params: Params<
    void,
    t_GetEventsQuerySchema,
    t_GetEventsBodySchema | undefined,
    void
  >,
  respond: (typeof getEvents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_event[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getEventsId = b((r) => ({
  with200: r.with200<t_event>(s_event),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetEventsId = (
  params: Params<
    t_GetEventsIdParamSchema,
    t_GetEventsIdQuerySchema,
    t_GetEventsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getEventsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_event>
  | Response<StatusCode, t_error>
>

const getExchangeRates = b((r) => ({
  with200: r.with200<{
    data: t_exchange_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_exchange_rate),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/exchange_rates")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetExchangeRates = (
  params: Params<
    void,
    t_GetExchangeRatesQuerySchema,
    t_GetExchangeRatesBodySchema | undefined,
    void
  >,
  respond: (typeof getExchangeRates)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_exchange_rate[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getExchangeRatesRateId = b((r) => ({
  with200: r.with200<t_exchange_rate>(s_exchange_rate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetExchangeRatesRateId = (
  params: Params<
    t_GetExchangeRatesRateIdParamSchema,
    t_GetExchangeRatesRateIdQuerySchema,
    t_GetExchangeRatesRateIdBodySchema | undefined,
    void
  >,
  respond: (typeof getExchangeRatesRateId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_exchange_rate>
  | Response<StatusCode, t_error>
>

const postExternalAccountsId = b((r) => ({
  with200: r.with200<t_external_account>(s_external_account),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostExternalAccountsId = (
  params: Params<
    t_PostExternalAccountsIdParamSchema,
    void,
    t_PostExternalAccountsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postExternalAccountsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_external_account>
  | Response<StatusCode, t_error>
>

const getFileLinks = b((r) => ({
  with200: r.with200<{
    data: t_file_link[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_file_link)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/file_links")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFileLinks = (
  params: Params<
    void,
    t_GetFileLinksQuerySchema,
    t_GetFileLinksBodySchema | undefined,
    void
  >,
  respond: (typeof getFileLinks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_file_link[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postFileLinks = b((r) => ({
  with200: r.with200<t_file_link>(s_file_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFileLinks = (
  params: Params<void, void, t_PostFileLinksBodySchema, void>,
  respond: (typeof postFileLinks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_link>
  | Response<StatusCode, t_error>
>

const getFileLinksLink = b((r) => ({
  with200: r.with200<t_file_link>(s_file_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFileLinksLink = (
  params: Params<
    t_GetFileLinksLinkParamSchema,
    t_GetFileLinksLinkQuerySchema,
    t_GetFileLinksLinkBodySchema | undefined,
    void
  >,
  respond: (typeof getFileLinksLink)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_link>
  | Response<StatusCode, t_error>
>

const postFileLinksLink = b((r) => ({
  with200: r.with200<t_file_link>(s_file_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFileLinksLink = (
  params: Params<
    t_PostFileLinksLinkParamSchema,
    void,
    t_PostFileLinksLinkBodySchema | undefined,
    void
  >,
  respond: (typeof postFileLinksLink)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_link>
  | Response<StatusCode, t_error>
>

const getFiles = b((r) => ({
  with200: r.with200<{
    data: t_file[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_file)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/files")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFiles = (
  params: Params<
    void,
    t_GetFilesQuerySchema,
    t_GetFilesBodySchema | undefined,
    void
  >,
  respond: (typeof getFiles)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_file[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postFiles = b((r) => ({
  with200: r.with200<t_file>(s_file),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFiles = (
  params: Params<void, void, t_PostFilesBodySchema, void>,
  respond: (typeof postFiles)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file>
  | Response<StatusCode, t_error>
>

const getFilesFile = b((r) => ({
  with200: r.with200<t_file>(s_file),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFilesFile = (
  params: Params<
    t_GetFilesFileParamSchema,
    t_GetFilesFileQuerySchema,
    t_GetFilesFileBodySchema | undefined,
    void
  >,
  respond: (typeof getFilesFile)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file>
  | Response<StatusCode, t_error>
>

const getFinancialConnectionsAccounts = b((r) => ({
  with200: r.with200<{
    data: t_financial_connections_account[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_financial_connections_account)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/financial_connections/accounts")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFinancialConnectionsAccounts = (
  params: Params<
    void,
    t_GetFinancialConnectionsAccountsQuerySchema,
    t_GetFinancialConnectionsAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof getFinancialConnectionsAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getFinancialConnectionsAccountsAccount = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFinancialConnectionsAccountsAccount = (
  params: Params<
    t_GetFinancialConnectionsAccountsAccountParamSchema,
    t_GetFinancialConnectionsAccountsAccountQuerySchema,
    t_GetFinancialConnectionsAccountsAccountBodySchema | undefined,
    void
  >,
  respond: (typeof getFinancialConnectionsAccountsAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const postFinancialConnectionsAccountsAccountDisconnect = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFinancialConnectionsAccountsAccountDisconnect = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountDisconnectParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountDisconnectBodySchema | undefined,
    void
  >,
  respond: (typeof postFinancialConnectionsAccountsAccountDisconnect)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const getFinancialConnectionsAccountsAccountOwners = b((r) => ({
  with200: r.with200<{
    data: t_financial_connections_account_owner[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_financial_connections_account_owner),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFinancialConnectionsAccountsAccountOwners = (
  params: Params<
    t_GetFinancialConnectionsAccountsAccountOwnersParamSchema,
    t_GetFinancialConnectionsAccountsAccountOwnersQuerySchema,
    t_GetFinancialConnectionsAccountsAccountOwnersBodySchema | undefined,
    void
  >,
  respond: (typeof getFinancialConnectionsAccountsAccountOwners)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account_owner[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postFinancialConnectionsAccountsAccountRefresh = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFinancialConnectionsAccountsAccountRefresh = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountRefreshParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountRefreshBodySchema,
    void
  >,
  respond: (typeof postFinancialConnectionsAccountsAccountRefresh)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const postFinancialConnectionsAccountsAccountSubscribe = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFinancialConnectionsAccountsAccountSubscribe = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountSubscribeParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountSubscribeBodySchema,
    void
  >,
  respond: (typeof postFinancialConnectionsAccountsAccountSubscribe)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const postFinancialConnectionsAccountsAccountUnsubscribe = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFinancialConnectionsAccountsAccountUnsubscribe = (
  params: Params<
    t_PostFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
    void,
    t_PostFinancialConnectionsAccountsAccountUnsubscribeBodySchema,
    void
  >,
  respond: (typeof postFinancialConnectionsAccountsAccountUnsubscribe)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const postFinancialConnectionsSessions = b((r) => ({
  with200: r.with200<t_financial_connections_session>(
    s_financial_connections_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostFinancialConnectionsSessions = (
  params: Params<
    void,
    void,
    t_PostFinancialConnectionsSessionsBodySchema,
    void
  >,
  respond: (typeof postFinancialConnectionsSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
>

const getFinancialConnectionsSessionsSession = b((r) => ({
  with200: r.with200<t_financial_connections_session>(
    s_financial_connections_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFinancialConnectionsSessionsSession = (
  params: Params<
    t_GetFinancialConnectionsSessionsSessionParamSchema,
    t_GetFinancialConnectionsSessionsSessionQuerySchema,
    t_GetFinancialConnectionsSessionsSessionBodySchema | undefined,
    void
  >,
  respond: (typeof getFinancialConnectionsSessionsSession)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
>

const getFinancialConnectionsTransactions = b((r) => ({
  with200: r.with200<{
    data: t_financial_connections_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_financial_connections_transaction),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/financial_connections/transactions")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFinancialConnectionsTransactions = (
  params: Params<
    void,
    t_GetFinancialConnectionsTransactionsQuerySchema,
    t_GetFinancialConnectionsTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getFinancialConnectionsTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getFinancialConnectionsTransactionsTransaction = b((r) => ({
  with200: r.with200<t_financial_connections_transaction>(
    s_financial_connections_transaction,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetFinancialConnectionsTransactionsTransaction = (
  params: Params<
    t_GetFinancialConnectionsTransactionsTransactionParamSchema,
    t_GetFinancialConnectionsTransactionsTransactionQuerySchema,
    t_GetFinancialConnectionsTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: (typeof getFinancialConnectionsTransactionsTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_transaction>
  | Response<StatusCode, t_error>
>

const getForwardingRequests = b((r) => ({
  with200: r.with200<{
    data: t_forwarding_request[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_forwarding_request),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetForwardingRequests = (
  params: Params<
    void,
    t_GetForwardingRequestsQuerySchema,
    t_GetForwardingRequestsBodySchema | undefined,
    void
  >,
  respond: (typeof getForwardingRequests)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_forwarding_request[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postForwardingRequests = b((r) => ({
  with200: r.with200<t_forwarding_request>(s_forwarding_request),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostForwardingRequests = (
  params: Params<void, void, t_PostForwardingRequestsBodySchema, void>,
  respond: (typeof postForwardingRequests)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_forwarding_request>
  | Response<StatusCode, t_error>
>

const getForwardingRequestsId = b((r) => ({
  with200: r.with200<t_forwarding_request>(s_forwarding_request),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetForwardingRequestsId = (
  params: Params<
    t_GetForwardingRequestsIdParamSchema,
    t_GetForwardingRequestsIdQuerySchema,
    t_GetForwardingRequestsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getForwardingRequestsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_forwarding_request>
  | Response<StatusCode, t_error>
>

const getIdentityVerificationReports = b((r) => ({
  with200: r.with200<{
    data: t_identity_verification_report[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_identity_verification_report),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/identity/verification_reports")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIdentityVerificationReports = (
  params: Params<
    void,
    t_GetIdentityVerificationReportsQuerySchema,
    t_GetIdentityVerificationReportsBodySchema | undefined,
    void
  >,
  respond: (typeof getIdentityVerificationReports)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_identity_verification_report[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getIdentityVerificationReportsReport = b((r) => ({
  with200: r.with200<t_identity_verification_report>(
    s_identity_verification_report,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIdentityVerificationReportsReport = (
  params: Params<
    t_GetIdentityVerificationReportsReportParamSchema,
    t_GetIdentityVerificationReportsReportQuerySchema,
    t_GetIdentityVerificationReportsReportBodySchema | undefined,
    void
  >,
  respond: (typeof getIdentityVerificationReportsReport)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_report>
  | Response<StatusCode, t_error>
>

const getIdentityVerificationSessions = b((r) => ({
  with200: r.with200<{
    data: t_identity_verification_session[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_identity_verification_session),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/identity/verification_sessions")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIdentityVerificationSessions = (
  params: Params<
    void,
    t_GetIdentityVerificationSessionsQuerySchema,
    t_GetIdentityVerificationSessionsBodySchema | undefined,
    void
  >,
  respond: (typeof getIdentityVerificationSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_identity_verification_session[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postIdentityVerificationSessions = b((r) => ({
  with200: r.with200<t_identity_verification_session>(
    s_identity_verification_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIdentityVerificationSessions = (
  params: Params<
    void,
    void,
    t_PostIdentityVerificationSessionsBodySchema | undefined,
    void
  >,
  respond: (typeof postIdentityVerificationSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
>

const getIdentityVerificationSessionsSession = b((r) => ({
  with200: r.with200<t_identity_verification_session>(
    s_identity_verification_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIdentityVerificationSessionsSession = (
  params: Params<
    t_GetIdentityVerificationSessionsSessionParamSchema,
    t_GetIdentityVerificationSessionsSessionQuerySchema,
    t_GetIdentityVerificationSessionsSessionBodySchema | undefined,
    void
  >,
  respond: (typeof getIdentityVerificationSessionsSession)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
>

const postIdentityVerificationSessionsSession = b((r) => ({
  with200: r.with200<t_identity_verification_session>(
    s_identity_verification_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIdentityVerificationSessionsSession = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionParamSchema,
    void,
    t_PostIdentityVerificationSessionsSessionBodySchema | undefined,
    void
  >,
  respond: (typeof postIdentityVerificationSessionsSession)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
>

const postIdentityVerificationSessionsSessionCancel = b((r) => ({
  with200: r.with200<t_identity_verification_session>(
    s_identity_verification_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIdentityVerificationSessionsSessionCancel = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionCancelParamSchema,
    void,
    t_PostIdentityVerificationSessionsSessionCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postIdentityVerificationSessionsSessionCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
>

const postIdentityVerificationSessionsSessionRedact = b((r) => ({
  with200: r.with200<t_identity_verification_session>(
    s_identity_verification_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIdentityVerificationSessionsSessionRedact = (
  params: Params<
    t_PostIdentityVerificationSessionsSessionRedactParamSchema,
    void,
    t_PostIdentityVerificationSessionsSessionRedactBodySchema | undefined,
    void
  >,
  respond: (typeof postIdentityVerificationSessionsSessionRedact)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_identity_verification_session>
  | Response<StatusCode, t_error>
>

const getInvoicePayments = b((r) => ({
  with200: r.with200<{
    data: t_invoice_payment[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_invoice_payment)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoicePayments = (
  params: Params<
    void,
    t_GetInvoicePaymentsQuerySchema,
    t_GetInvoicePaymentsBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoicePayments)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice_payment[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getInvoicePaymentsInvoicePayment = b((r) => ({
  with200: r.with200<t_invoice_payment>(s_invoice_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoicePaymentsInvoicePayment = (
  params: Params<
    t_GetInvoicePaymentsInvoicePaymentParamSchema,
    t_GetInvoicePaymentsInvoicePaymentQuerySchema,
    t_GetInvoicePaymentsInvoicePaymentBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoicePaymentsInvoicePayment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_payment>
  | Response<StatusCode, t_error>
>

const getInvoiceRenderingTemplates = b((r) => ({
  with200: r.with200<{
    data: t_invoice_rendering_template[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_invoice_rendering_template),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoiceRenderingTemplates = (
  params: Params<
    void,
    t_GetInvoiceRenderingTemplatesQuerySchema,
    t_GetInvoiceRenderingTemplatesBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoiceRenderingTemplates)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice_rendering_template[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getInvoiceRenderingTemplatesTemplate = b((r) => ({
  with200: r.with200<t_invoice_rendering_template>(
    s_invoice_rendering_template,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoiceRenderingTemplatesTemplate = (
  params: Params<
    t_GetInvoiceRenderingTemplatesTemplateParamSchema,
    t_GetInvoiceRenderingTemplatesTemplateQuerySchema,
    t_GetInvoiceRenderingTemplatesTemplateBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoiceRenderingTemplatesTemplate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_rendering_template>
  | Response<StatusCode, t_error>
>

const postInvoiceRenderingTemplatesTemplateArchive = b((r) => ({
  with200: r.with200<t_invoice_rendering_template>(
    s_invoice_rendering_template,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoiceRenderingTemplatesTemplateArchive = (
  params: Params<
    t_PostInvoiceRenderingTemplatesTemplateArchiveParamSchema,
    void,
    t_PostInvoiceRenderingTemplatesTemplateArchiveBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoiceRenderingTemplatesTemplateArchive)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_rendering_template>
  | Response<StatusCode, t_error>
>

const postInvoiceRenderingTemplatesTemplateUnarchive = b((r) => ({
  with200: r.with200<t_invoice_rendering_template>(
    s_invoice_rendering_template,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoiceRenderingTemplatesTemplateUnarchive = (
  params: Params<
    t_PostInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
    void,
    t_PostInvoiceRenderingTemplatesTemplateUnarchiveBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoiceRenderingTemplatesTemplateUnarchive)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice_rendering_template>
  | Response<StatusCode, t_error>
>

const getInvoiceitems = b((r) => ({
  with200: r.with200<{
    data: t_invoiceitem[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_invoiceitem)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/invoiceitems")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoiceitems = (
  params: Params<
    void,
    t_GetInvoiceitemsQuerySchema,
    t_GetInvoiceitemsBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoiceitems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoiceitem[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postInvoiceitems = b((r) => ({
  with200: r.with200<t_invoiceitem>(s_invoiceitem),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoiceitems = (
  params: Params<void, void, t_PostInvoiceitemsBodySchema, void>,
  respond: (typeof postInvoiceitems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoiceitem>
  | Response<StatusCode, t_error>
>

const deleteInvoiceitemsInvoiceitem = b((r) => ({
  with200: r.with200<t_deleted_invoiceitem>(s_deleted_invoiceitem),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteInvoiceitemsInvoiceitem = (
  params: Params<
    t_DeleteInvoiceitemsInvoiceitemParamSchema,
    void,
    t_DeleteInvoiceitemsInvoiceitemBodySchema | undefined,
    void
  >,
  respond: (typeof deleteInvoiceitemsInvoiceitem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_invoiceitem>
  | Response<StatusCode, t_error>
>

const getInvoiceitemsInvoiceitem = b((r) => ({
  with200: r.with200<t_invoiceitem>(s_invoiceitem),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoiceitemsInvoiceitem = (
  params: Params<
    t_GetInvoiceitemsInvoiceitemParamSchema,
    t_GetInvoiceitemsInvoiceitemQuerySchema,
    t_GetInvoiceitemsInvoiceitemBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoiceitemsInvoiceitem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoiceitem>
  | Response<StatusCode, t_error>
>

const postInvoiceitemsInvoiceitem = b((r) => ({
  with200: r.with200<t_invoiceitem>(s_invoiceitem),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoiceitemsInvoiceitem = (
  params: Params<
    t_PostInvoiceitemsInvoiceitemParamSchema,
    void,
    t_PostInvoiceitemsInvoiceitemBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoiceitemsInvoiceitem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoiceitem>
  | Response<StatusCode, t_error>
>

const getInvoices = b((r) => ({
  with200: r.with200<{
    data: t_invoice[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_invoice)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/invoices")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoices = (
  params: Params<
    void,
    t_GetInvoicesQuerySchema,
    t_GetInvoicesBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoices)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postInvoices = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoices = (
  params: Params<void, void, t_PostInvoicesBodySchema | undefined, void>,
  respond: (typeof postInvoices)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesCreatePreview = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesCreatePreview = (
  params: Params<
    void,
    void,
    t_PostInvoicesCreatePreviewBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesCreatePreview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const getInvoicesSearch = b((r) => ({
  with200: r.with200<{
    data: t_invoice[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_invoice)),
      has_more: PermissiveBoolean,
      next_page: z.string().max(5000).nullable().optional(),
      object: z.enum(["search_result"]),
      total_count: z.coerce.number().optional(),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoicesSearch = (
  params: Params<
    void,
    t_GetInvoicesSearchQuerySchema,
    t_GetInvoicesSearchBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoicesSearch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_invoice[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const deleteInvoicesInvoice = b((r) => ({
  with200: r.with200<t_deleted_invoice>(s_deleted_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteInvoicesInvoice = (
  params: Params<
    t_DeleteInvoicesInvoiceParamSchema,
    void,
    t_DeleteInvoicesInvoiceBodySchema | undefined,
    void
  >,
  respond: (typeof deleteInvoicesInvoice)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_invoice>
  | Response<StatusCode, t_error>
>

const getInvoicesInvoice = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoicesInvoice = (
  params: Params<
    t_GetInvoicesInvoiceParamSchema,
    t_GetInvoicesInvoiceQuerySchema,
    t_GetInvoicesInvoiceBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoicesInvoice)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoice = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoice = (
  params: Params<
    t_PostInvoicesInvoiceParamSchema,
    void,
    t_PostInvoicesInvoiceBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesInvoice)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceAddLines = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceAddLines = (
  params: Params<
    t_PostInvoicesInvoiceAddLinesParamSchema,
    void,
    t_PostInvoicesInvoiceAddLinesBodySchema,
    void
  >,
  respond: (typeof postInvoicesInvoiceAddLines)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceFinalize = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceFinalize = (
  params: Params<
    t_PostInvoicesInvoiceFinalizeParamSchema,
    void,
    t_PostInvoicesInvoiceFinalizeBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesInvoiceFinalize)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const getInvoicesInvoiceLines = b((r) => ({
  with200: r.with200<{
    data: t_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_line_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetInvoicesInvoiceLines = (
  params: Params<
    t_GetInvoicesInvoiceLinesParamSchema,
    t_GetInvoicesInvoiceLinesQuerySchema,
    t_GetInvoicesInvoiceLinesBodySchema | undefined,
    void
  >,
  respond: (typeof getInvoicesInvoiceLines)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceLinesLineItemId = b((r) => ({
  with200: r.with200<t_line_item>(s_line_item),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceLinesLineItemId = (
  params: Params<
    t_PostInvoicesInvoiceLinesLineItemIdParamSchema,
    void,
    t_PostInvoicesInvoiceLinesLineItemIdBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesInvoiceLinesLineItemId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_line_item>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceMarkUncollectible = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceMarkUncollectible = (
  params: Params<
    t_PostInvoicesInvoiceMarkUncollectibleParamSchema,
    void,
    t_PostInvoicesInvoiceMarkUncollectibleBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesInvoiceMarkUncollectible)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoicePay = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoicePay = (
  params: Params<
    t_PostInvoicesInvoicePayParamSchema,
    void,
    t_PostInvoicesInvoicePayBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesInvoicePay)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceRemoveLines = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceRemoveLines = (
  params: Params<
    t_PostInvoicesInvoiceRemoveLinesParamSchema,
    void,
    t_PostInvoicesInvoiceRemoveLinesBodySchema,
    void
  >,
  respond: (typeof postInvoicesInvoiceRemoveLines)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceSend = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceSend = (
  params: Params<
    t_PostInvoicesInvoiceSendParamSchema,
    void,
    t_PostInvoicesInvoiceSendBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesInvoiceSend)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceUpdateLines = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceUpdateLines = (
  params: Params<
    t_PostInvoicesInvoiceUpdateLinesParamSchema,
    void,
    t_PostInvoicesInvoiceUpdateLinesBodySchema,
    void
  >,
  respond: (typeof postInvoicesInvoiceUpdateLines)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const postInvoicesInvoiceVoid = b((r) => ({
  with200: r.with200<t_invoice>(s_invoice),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostInvoicesInvoiceVoid = (
  params: Params<
    t_PostInvoicesInvoiceVoidParamSchema,
    void,
    t_PostInvoicesInvoiceVoidBodySchema | undefined,
    void
  >,
  respond: (typeof postInvoicesInvoiceVoid)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_invoice>
  | Response<StatusCode, t_error>
>

const getIssuingAuthorizations = b((r) => ({
  with200: r.with200<{
    data: t_issuing_authorization[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_issuing_authorization)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/issuing/authorizations")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingAuthorizations = (
  params: Params<
    void,
    t_GetIssuingAuthorizationsQuerySchema,
    t_GetIssuingAuthorizationsBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingAuthorizations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_authorization[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getIssuingAuthorizationsAuthorization = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingAuthorizationsAuthorization = (
  params: Params<
    t_GetIssuingAuthorizationsAuthorizationParamSchema,
    t_GetIssuingAuthorizationsAuthorizationQuerySchema,
    t_GetIssuingAuthorizationsAuthorizationBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingAuthorizationsAuthorization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postIssuingAuthorizationsAuthorization = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingAuthorizationsAuthorization = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationParamSchema,
    void,
    t_PostIssuingAuthorizationsAuthorizationBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingAuthorizationsAuthorization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postIssuingAuthorizationsAuthorizationApprove = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingAuthorizationsAuthorizationApprove = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationApproveParamSchema,
    void,
    t_PostIssuingAuthorizationsAuthorizationApproveBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingAuthorizationsAuthorizationApprove)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postIssuingAuthorizationsAuthorizationDecline = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingAuthorizationsAuthorizationDecline = (
  params: Params<
    t_PostIssuingAuthorizationsAuthorizationDeclineParamSchema,
    void,
    t_PostIssuingAuthorizationsAuthorizationDeclineBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingAuthorizationsAuthorizationDecline)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const getIssuingCardholders = b((r) => ({
  with200: r.with200<{
    data: t_issuing_cardholder[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_issuing_cardholder)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/issuing/cardholders")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingCardholders = (
  params: Params<
    void,
    t_GetIssuingCardholdersQuerySchema,
    t_GetIssuingCardholdersBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingCardholders)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_cardholder[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postIssuingCardholders = b((r) => ({
  with200: r.with200<t_issuing_cardholder>(s_issuing_cardholder),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingCardholders = (
  params: Params<void, void, t_PostIssuingCardholdersBodySchema, void>,
  respond: (typeof postIssuingCardholders)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_cardholder>
  | Response<StatusCode, t_error>
>

const getIssuingCardholdersCardholder = b((r) => ({
  with200: r.with200<t_issuing_cardholder>(s_issuing_cardholder),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingCardholdersCardholder = (
  params: Params<
    t_GetIssuingCardholdersCardholderParamSchema,
    t_GetIssuingCardholdersCardholderQuerySchema,
    t_GetIssuingCardholdersCardholderBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingCardholdersCardholder)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_cardholder>
  | Response<StatusCode, t_error>
>

const postIssuingCardholdersCardholder = b((r) => ({
  with200: r.with200<t_issuing_cardholder>(s_issuing_cardholder),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingCardholdersCardholder = (
  params: Params<
    t_PostIssuingCardholdersCardholderParamSchema,
    void,
    t_PostIssuingCardholdersCardholderBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingCardholdersCardholder)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_cardholder>
  | Response<StatusCode, t_error>
>

const getIssuingCards = b((r) => ({
  with200: r.with200<{
    data: t_issuing_card[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_issuing_card)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/issuing/cards")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingCards = (
  params: Params<
    void,
    t_GetIssuingCardsQuerySchema,
    t_GetIssuingCardsBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingCards)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_card[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postIssuingCards = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingCards = (
  params: Params<void, void, t_PostIssuingCardsBodySchema, void>,
  respond: (typeof postIssuingCards)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const getIssuingCardsCard = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingCardsCard = (
  params: Params<
    t_GetIssuingCardsCardParamSchema,
    t_GetIssuingCardsCardQuerySchema,
    t_GetIssuingCardsCardBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingCardsCard)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const postIssuingCardsCard = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingCardsCard = (
  params: Params<
    t_PostIssuingCardsCardParamSchema,
    void,
    t_PostIssuingCardsCardBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingCardsCard)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const getIssuingDisputes = b((r) => ({
  with200: r.with200<{
    data: t_issuing_dispute[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_issuing_dispute)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/issuing/disputes")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingDisputes = (
  params: Params<
    void,
    t_GetIssuingDisputesQuerySchema,
    t_GetIssuingDisputesBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingDisputes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_dispute[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postIssuingDisputes = b((r) => ({
  with200: r.with200<t_issuing_dispute>(s_issuing_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingDisputes = (
  params: Params<void, void, t_PostIssuingDisputesBodySchema | undefined, void>,
  respond: (typeof postIssuingDisputes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
>

const getIssuingDisputesDispute = b((r) => ({
  with200: r.with200<t_issuing_dispute>(s_issuing_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingDisputesDispute = (
  params: Params<
    t_GetIssuingDisputesDisputeParamSchema,
    t_GetIssuingDisputesDisputeQuerySchema,
    t_GetIssuingDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingDisputesDispute)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
>

const postIssuingDisputesDispute = b((r) => ({
  with200: r.with200<t_issuing_dispute>(s_issuing_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingDisputesDispute = (
  params: Params<
    t_PostIssuingDisputesDisputeParamSchema,
    void,
    t_PostIssuingDisputesDisputeBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingDisputesDispute)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
>

const postIssuingDisputesDisputeSubmit = b((r) => ({
  with200: r.with200<t_issuing_dispute>(s_issuing_dispute),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingDisputesDisputeSubmit = (
  params: Params<
    t_PostIssuingDisputesDisputeSubmitParamSchema,
    void,
    t_PostIssuingDisputesDisputeSubmitBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingDisputesDisputeSubmit)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_dispute>
  | Response<StatusCode, t_error>
>

const getIssuingPersonalizationDesigns = b((r) => ({
  with200: r.with200<{
    data: t_issuing_personalization_design[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_issuing_personalization_design)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/issuing/personalization_designs")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingPersonalizationDesigns = (
  params: Params<
    void,
    t_GetIssuingPersonalizationDesignsQuerySchema,
    t_GetIssuingPersonalizationDesignsBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingPersonalizationDesigns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_personalization_design[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postIssuingPersonalizationDesigns = b((r) => ({
  with200: r.with200<t_issuing_personalization_design>(
    s_issuing_personalization_design,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingPersonalizationDesigns = (
  params: Params<
    void,
    void,
    t_PostIssuingPersonalizationDesignsBodySchema,
    void
  >,
  respond: (typeof postIssuingPersonalizationDesigns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_personalization_design>
  | Response<StatusCode, t_error>
>

const getIssuingPersonalizationDesignsPersonalizationDesign = b((r) => ({
  with200: r.with200<t_issuing_personalization_design>(
    s_issuing_personalization_design,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingPersonalizationDesignsPersonalizationDesign = (
  params: Params<
    t_GetIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
    t_GetIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
    | t_GetIssuingPersonalizationDesignsPersonalizationDesignBodySchema
    | undefined,
    void
  >,
  respond: (typeof getIssuingPersonalizationDesignsPersonalizationDesign)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_personalization_design>
  | Response<StatusCode, t_error>
>

const postIssuingPersonalizationDesignsPersonalizationDesign = b((r) => ({
  with200: r.with200<t_issuing_personalization_design>(
    s_issuing_personalization_design,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingPersonalizationDesignsPersonalizationDesign = (
  params: Params<
    t_PostIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
    void,
    | t_PostIssuingPersonalizationDesignsPersonalizationDesignBodySchema
    | undefined,
    void
  >,
  respond: (typeof postIssuingPersonalizationDesignsPersonalizationDesign)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_personalization_design>
  | Response<StatusCode, t_error>
>

const getIssuingPhysicalBundles = b((r) => ({
  with200: r.with200<{
    data: t_issuing_physical_bundle[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_issuing_physical_bundle),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/issuing/physical_bundles")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingPhysicalBundles = (
  params: Params<
    void,
    t_GetIssuingPhysicalBundlesQuerySchema,
    t_GetIssuingPhysicalBundlesBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingPhysicalBundles)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_physical_bundle[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getIssuingPhysicalBundlesPhysicalBundle = b((r) => ({
  with200: r.with200<t_issuing_physical_bundle>(s_issuing_physical_bundle),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingPhysicalBundlesPhysicalBundle = (
  params: Params<
    t_GetIssuingPhysicalBundlesPhysicalBundleParamSchema,
    t_GetIssuingPhysicalBundlesPhysicalBundleQuerySchema,
    t_GetIssuingPhysicalBundlesPhysicalBundleBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingPhysicalBundlesPhysicalBundle)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_physical_bundle>
  | Response<StatusCode, t_error>
>

const getIssuingSettlementsSettlement = b((r) => ({
  with200: r.with200<t_issuing_settlement>(s_issuing_settlement),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingSettlementsSettlement = (
  params: Params<
    t_GetIssuingSettlementsSettlementParamSchema,
    t_GetIssuingSettlementsSettlementQuerySchema,
    t_GetIssuingSettlementsSettlementBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingSettlementsSettlement)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
>

const postIssuingSettlementsSettlement = b((r) => ({
  with200: r.with200<t_issuing_settlement>(s_issuing_settlement),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingSettlementsSettlement = (
  params: Params<
    t_PostIssuingSettlementsSettlementParamSchema,
    void,
    t_PostIssuingSettlementsSettlementBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingSettlementsSettlement)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
>

const getIssuingTokens = b((r) => ({
  with200: r.with200<{
    data: t_issuing_token[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_issuing_token)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingTokens = (
  params: Params<
    void,
    t_GetIssuingTokensQuerySchema,
    t_GetIssuingTokensBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingTokens)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_token[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getIssuingTokensToken = b((r) => ({
  with200: r.with200<t_issuing_token>(s_issuing_token),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingTokensToken = (
  params: Params<
    t_GetIssuingTokensTokenParamSchema,
    t_GetIssuingTokensTokenQuerySchema,
    t_GetIssuingTokensTokenBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingTokensToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_token>
  | Response<StatusCode, t_error>
>

const postIssuingTokensToken = b((r) => ({
  with200: r.with200<t_issuing_token>(s_issuing_token),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingTokensToken = (
  params: Params<
    t_PostIssuingTokensTokenParamSchema,
    void,
    t_PostIssuingTokensTokenBodySchema,
    void
  >,
  respond: (typeof postIssuingTokensToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_token>
  | Response<StatusCode, t_error>
>

const getIssuingTransactions = b((r) => ({
  with200: r.with200<{
    data: t_issuing_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_issuing_transaction)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/issuing/transactions")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingTransactions = (
  params: Params<
    void,
    t_GetIssuingTransactionsQuerySchema,
    t_GetIssuingTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_issuing_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getIssuingTransactionsTransaction = b((r) => ({
  with200: r.with200<t_issuing_transaction>(s_issuing_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetIssuingTransactionsTransaction = (
  params: Params<
    t_GetIssuingTransactionsTransactionParamSchema,
    t_GetIssuingTransactionsTransactionQuerySchema,
    t_GetIssuingTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: (typeof getIssuingTransactionsTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
>

const postIssuingTransactionsTransaction = b((r) => ({
  with200: r.with200<t_issuing_transaction>(s_issuing_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostIssuingTransactionsTransaction = (
  params: Params<
    t_PostIssuingTransactionsTransactionParamSchema,
    void,
    t_PostIssuingTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: (typeof postIssuingTransactionsTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
>

const postLinkAccountSessions = b((r) => ({
  with200: r.with200<t_financial_connections_session>(
    s_financial_connections_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostLinkAccountSessions = (
  params: Params<void, void, t_PostLinkAccountSessionsBodySchema, void>,
  respond: (typeof postLinkAccountSessions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
>

const getLinkAccountSessionsSession = b((r) => ({
  with200: r.with200<t_financial_connections_session>(
    s_financial_connections_session,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetLinkAccountSessionsSession = (
  params: Params<
    t_GetLinkAccountSessionsSessionParamSchema,
    t_GetLinkAccountSessionsSessionQuerySchema,
    t_GetLinkAccountSessionsSessionBodySchema | undefined,
    void
  >,
  respond: (typeof getLinkAccountSessionsSession)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_session>
  | Response<StatusCode, t_error>
>

const getLinkedAccounts = b((r) => ({
  with200: r.with200<{
    data: t_financial_connections_account[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_financial_connections_account)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/financial_connections/accounts")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetLinkedAccounts = (
  params: Params<
    void,
    t_GetLinkedAccountsQuerySchema,
    t_GetLinkedAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof getLinkedAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getLinkedAccountsAccount = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetLinkedAccountsAccount = (
  params: Params<
    t_GetLinkedAccountsAccountParamSchema,
    t_GetLinkedAccountsAccountQuerySchema,
    t_GetLinkedAccountsAccountBodySchema | undefined,
    void
  >,
  respond: (typeof getLinkedAccountsAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const postLinkedAccountsAccountDisconnect = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostLinkedAccountsAccountDisconnect = (
  params: Params<
    t_PostLinkedAccountsAccountDisconnectParamSchema,
    void,
    t_PostLinkedAccountsAccountDisconnectBodySchema | undefined,
    void
  >,
  respond: (typeof postLinkedAccountsAccountDisconnect)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const getLinkedAccountsAccountOwners = b((r) => ({
  with200: r.with200<{
    data: t_financial_connections_account_owner[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_financial_connections_account_owner),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetLinkedAccountsAccountOwners = (
  params: Params<
    t_GetLinkedAccountsAccountOwnersParamSchema,
    t_GetLinkedAccountsAccountOwnersQuerySchema,
    t_GetLinkedAccountsAccountOwnersBodySchema | undefined,
    void
  >,
  respond: (typeof getLinkedAccountsAccountOwners)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_financial_connections_account_owner[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postLinkedAccountsAccountRefresh = b((r) => ({
  with200: r.with200<t_financial_connections_account>(
    s_financial_connections_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostLinkedAccountsAccountRefresh = (
  params: Params<
    t_PostLinkedAccountsAccountRefreshParamSchema,
    void,
    t_PostLinkedAccountsAccountRefreshBodySchema,
    void
  >,
  respond: (typeof postLinkedAccountsAccountRefresh)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_financial_connections_account>
  | Response<StatusCode, t_error>
>

const getMandatesMandate = b((r) => ({
  with200: r.with200<t_mandate>(s_mandate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetMandatesMandate = (
  params: Params<
    t_GetMandatesMandateParamSchema,
    t_GetMandatesMandateQuerySchema,
    t_GetMandatesMandateBodySchema | undefined,
    void
  >,
  respond: (typeof getMandatesMandate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_mandate>
  | Response<StatusCode, t_error>
>

const getPaymentIntents = b((r) => ({
  with200: r.with200<{
    data: t_payment_intent[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_payment_intent)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/payment_intents")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentIntents = (
  params: Params<
    void,
    t_GetPaymentIntentsQuerySchema,
    t_GetPaymentIntentsBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentIntents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_intent[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPaymentIntents = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntents = (
  params: Params<void, void, t_PostPaymentIntentsBodySchema, void>,
  respond: (typeof postPaymentIntents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const getPaymentIntentsSearch = b((r) => ({
  with200: r.with200<{
    data: t_payment_intent[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_payment_intent)),
      has_more: PermissiveBoolean,
      next_page: z.string().max(5000).nullable().optional(),
      object: z.enum(["search_result"]),
      total_count: z.coerce.number().optional(),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentIntentsSearch = (
  params: Params<
    void,
    t_GetPaymentIntentsSearchQuerySchema,
    t_GetPaymentIntentsSearchBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentIntentsSearch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_intent[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getPaymentIntentsIntent = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentIntentsIntent = (
  params: Params<
    t_GetPaymentIntentsIntentParamSchema,
    t_GetPaymentIntentsIntentQuerySchema,
    t_GetPaymentIntentsIntentBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentIntentsIntent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const postPaymentIntentsIntent = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntentsIntent = (
  params: Params<
    t_PostPaymentIntentsIntentParamSchema,
    void,
    t_PostPaymentIntentsIntentBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentIntentsIntent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const postPaymentIntentsIntentApplyCustomerBalance = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntentsIntentApplyCustomerBalance = (
  params: Params<
    t_PostPaymentIntentsIntentApplyCustomerBalanceParamSchema,
    void,
    t_PostPaymentIntentsIntentApplyCustomerBalanceBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentIntentsIntentApplyCustomerBalance)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const postPaymentIntentsIntentCancel = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntentsIntentCancel = (
  params: Params<
    t_PostPaymentIntentsIntentCancelParamSchema,
    void,
    t_PostPaymentIntentsIntentCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentIntentsIntentCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const postPaymentIntentsIntentCapture = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntentsIntentCapture = (
  params: Params<
    t_PostPaymentIntentsIntentCaptureParamSchema,
    void,
    t_PostPaymentIntentsIntentCaptureBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentIntentsIntentCapture)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const postPaymentIntentsIntentConfirm = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntentsIntentConfirm = (
  params: Params<
    t_PostPaymentIntentsIntentConfirmParamSchema,
    void,
    t_PostPaymentIntentsIntentConfirmBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentIntentsIntentConfirm)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const postPaymentIntentsIntentIncrementAuthorization = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntentsIntentIncrementAuthorization = (
  params: Params<
    t_PostPaymentIntentsIntentIncrementAuthorizationParamSchema,
    void,
    t_PostPaymentIntentsIntentIncrementAuthorizationBodySchema,
    void
  >,
  respond: (typeof postPaymentIntentsIntentIncrementAuthorization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const postPaymentIntentsIntentVerifyMicrodeposits = b((r) => ({
  with200: r.with200<t_payment_intent>(s_payment_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentIntentsIntentVerifyMicrodeposits = (
  params: Params<
    t_PostPaymentIntentsIntentVerifyMicrodepositsParamSchema,
    void,
    t_PostPaymentIntentsIntentVerifyMicrodepositsBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentIntentsIntentVerifyMicrodeposits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_intent>
  | Response<StatusCode, t_error>
>

const getPaymentLinks = b((r) => ({
  with200: r.with200<{
    data: t_payment_link[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_payment_link)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/payment_links")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentLinks = (
  params: Params<
    void,
    t_GetPaymentLinksQuerySchema,
    t_GetPaymentLinksBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentLinks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_link[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPaymentLinks = b((r) => ({
  with200: r.with200<t_payment_link>(s_payment_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentLinks = (
  params: Params<void, void, t_PostPaymentLinksBodySchema, void>,
  respond: (typeof postPaymentLinks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_link>
  | Response<StatusCode, t_error>
>

const getPaymentLinksPaymentLink = b((r) => ({
  with200: r.with200<t_payment_link>(s_payment_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentLinksPaymentLink = (
  params: Params<
    t_GetPaymentLinksPaymentLinkParamSchema,
    t_GetPaymentLinksPaymentLinkQuerySchema,
    t_GetPaymentLinksPaymentLinkBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentLinksPaymentLink)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_link>
  | Response<StatusCode, t_error>
>

const postPaymentLinksPaymentLink = b((r) => ({
  with200: r.with200<t_payment_link>(s_payment_link),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentLinksPaymentLink = (
  params: Params<
    t_PostPaymentLinksPaymentLinkParamSchema,
    void,
    t_PostPaymentLinksPaymentLinkBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentLinksPaymentLink)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_link>
  | Response<StatusCode, t_error>
>

const getPaymentLinksPaymentLinkLineItems = b((r) => ({
  with200: r.with200<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentLinksPaymentLinkLineItems = (
  params: Params<
    t_GetPaymentLinksPaymentLinkLineItemsParamSchema,
    t_GetPaymentLinksPaymentLinkLineItemsQuerySchema,
    t_GetPaymentLinksPaymentLinkLineItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentLinksPaymentLinkLineItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getPaymentMethodConfigurations = b((r) => ({
  with200: r.with200<{
    data: t_payment_method_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_payment_method_configuration),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/payment_method_configurations")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentMethodConfigurations = (
  params: Params<
    void,
    t_GetPaymentMethodConfigurationsQuerySchema,
    t_GetPaymentMethodConfigurationsBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentMethodConfigurations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method_configuration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPaymentMethodConfigurations = b((r) => ({
  with200: r.with200<t_payment_method_configuration>(
    s_payment_method_configuration,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodConfigurations = (
  params: Params<
    void,
    void,
    t_PostPaymentMethodConfigurationsBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentMethodConfigurations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_configuration>
  | Response<StatusCode, t_error>
>

const getPaymentMethodConfigurationsConfiguration = b((r) => ({
  with200: r.with200<t_payment_method_configuration>(
    s_payment_method_configuration,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentMethodConfigurationsConfiguration = (
  params: Params<
    t_GetPaymentMethodConfigurationsConfigurationParamSchema,
    t_GetPaymentMethodConfigurationsConfigurationQuerySchema,
    t_GetPaymentMethodConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentMethodConfigurationsConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_configuration>
  | Response<StatusCode, t_error>
>

const postPaymentMethodConfigurationsConfiguration = b((r) => ({
  with200: r.with200<t_payment_method_configuration>(
    s_payment_method_configuration,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodConfigurationsConfiguration = (
  params: Params<
    t_PostPaymentMethodConfigurationsConfigurationParamSchema,
    void,
    t_PostPaymentMethodConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentMethodConfigurationsConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_configuration>
  | Response<StatusCode, t_error>
>

const getPaymentMethodDomains = b((r) => ({
  with200: r.with200<{
    data: t_payment_method_domain[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_payment_method_domain),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/payment_method_domains")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentMethodDomains = (
  params: Params<
    void,
    t_GetPaymentMethodDomainsQuerySchema,
    t_GetPaymentMethodDomainsBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentMethodDomains)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method_domain[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPaymentMethodDomains = b((r) => ({
  with200: r.with200<t_payment_method_domain>(s_payment_method_domain),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodDomains = (
  params: Params<void, void, t_PostPaymentMethodDomainsBodySchema, void>,
  respond: (typeof postPaymentMethodDomains)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
>

const getPaymentMethodDomainsPaymentMethodDomain = b((r) => ({
  with200: r.with200<t_payment_method_domain>(s_payment_method_domain),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentMethodDomainsPaymentMethodDomain = (
  params: Params<
    t_GetPaymentMethodDomainsPaymentMethodDomainParamSchema,
    t_GetPaymentMethodDomainsPaymentMethodDomainQuerySchema,
    t_GetPaymentMethodDomainsPaymentMethodDomainBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentMethodDomainsPaymentMethodDomain)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
>

const postPaymentMethodDomainsPaymentMethodDomain = b((r) => ({
  with200: r.with200<t_payment_method_domain>(s_payment_method_domain),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodDomainsPaymentMethodDomain = (
  params: Params<
    t_PostPaymentMethodDomainsPaymentMethodDomainParamSchema,
    void,
    t_PostPaymentMethodDomainsPaymentMethodDomainBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentMethodDomainsPaymentMethodDomain)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
>

const postPaymentMethodDomainsPaymentMethodDomainValidate = b((r) => ({
  with200: r.with200<t_payment_method_domain>(s_payment_method_domain),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodDomainsPaymentMethodDomainValidate = (
  params: Params<
    t_PostPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
    void,
    t_PostPaymentMethodDomainsPaymentMethodDomainValidateBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentMethodDomainsPaymentMethodDomainValidate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method_domain>
  | Response<StatusCode, t_error>
>

const getPaymentMethods = b((r) => ({
  with200: r.with200<{
    data: t_payment_method[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_payment_method)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/payment_methods")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentMethods = (
  params: Params<
    void,
    t_GetPaymentMethodsQuerySchema,
    t_GetPaymentMethodsBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentMethods)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payment_method[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPaymentMethods = b((r) => ({
  with200: r.with200<t_payment_method>(s_payment_method),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethods = (
  params: Params<void, void, t_PostPaymentMethodsBodySchema | undefined, void>,
  respond: (typeof postPaymentMethods)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
>

const getPaymentMethodsPaymentMethod = b((r) => ({
  with200: r.with200<t_payment_method>(s_payment_method),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPaymentMethodsPaymentMethod = (
  params: Params<
    t_GetPaymentMethodsPaymentMethodParamSchema,
    t_GetPaymentMethodsPaymentMethodQuerySchema,
    t_GetPaymentMethodsPaymentMethodBodySchema | undefined,
    void
  >,
  respond: (typeof getPaymentMethodsPaymentMethod)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
>

const postPaymentMethodsPaymentMethod = b((r) => ({
  with200: r.with200<t_payment_method>(s_payment_method),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodsPaymentMethod = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentMethodsPaymentMethod)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
>

const postPaymentMethodsPaymentMethodAttach = b((r) => ({
  with200: r.with200<t_payment_method>(s_payment_method),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodsPaymentMethodAttach = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodAttachParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodAttachBodySchema,
    void
  >,
  respond: (typeof postPaymentMethodsPaymentMethodAttach)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
>

const postPaymentMethodsPaymentMethodDetach = b((r) => ({
  with200: r.with200<t_payment_method>(s_payment_method),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPaymentMethodsPaymentMethodDetach = (
  params: Params<
    t_PostPaymentMethodsPaymentMethodDetachParamSchema,
    void,
    t_PostPaymentMethodsPaymentMethodDetachBodySchema | undefined,
    void
  >,
  respond: (typeof postPaymentMethodsPaymentMethodDetach)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payment_method>
  | Response<StatusCode, t_error>
>

const getPayouts = b((r) => ({
  with200: r.with200<{
    data: t_payout[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_payout)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/payouts")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPayouts = (
  params: Params<
    void,
    t_GetPayoutsQuerySchema,
    t_GetPayoutsBodySchema | undefined,
    void
  >,
  respond: (typeof getPayouts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_payout[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPayouts = b((r) => ({
  with200: r.with200<t_payout>(s_payout),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPayouts = (
  params: Params<void, void, t_PostPayoutsBodySchema, void>,
  respond: (typeof postPayouts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
>

const getPayoutsPayout = b((r) => ({
  with200: r.with200<t_payout>(s_payout),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPayoutsPayout = (
  params: Params<
    t_GetPayoutsPayoutParamSchema,
    t_GetPayoutsPayoutQuerySchema,
    t_GetPayoutsPayoutBodySchema | undefined,
    void
  >,
  respond: (typeof getPayoutsPayout)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
>

const postPayoutsPayout = b((r) => ({
  with200: r.with200<t_payout>(s_payout),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPayoutsPayout = (
  params: Params<
    t_PostPayoutsPayoutParamSchema,
    void,
    t_PostPayoutsPayoutBodySchema | undefined,
    void
  >,
  respond: (typeof postPayoutsPayout)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
>

const postPayoutsPayoutCancel = b((r) => ({
  with200: r.with200<t_payout>(s_payout),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPayoutsPayoutCancel = (
  params: Params<
    t_PostPayoutsPayoutCancelParamSchema,
    void,
    t_PostPayoutsPayoutCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postPayoutsPayoutCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
>

const postPayoutsPayoutReverse = b((r) => ({
  with200: r.with200<t_payout>(s_payout),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPayoutsPayoutReverse = (
  params: Params<
    t_PostPayoutsPayoutReverseParamSchema,
    void,
    t_PostPayoutsPayoutReverseBodySchema | undefined,
    void
  >,
  respond: (typeof postPayoutsPayoutReverse)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_payout>
  | Response<StatusCode, t_error>
>

const getPlans = b((r) => ({
  with200: r.with200<{
    data: t_plan[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_plan)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/plans")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPlans = (
  params: Params<
    void,
    t_GetPlansQuerySchema,
    t_GetPlansBodySchema | undefined,
    void
  >,
  respond: (typeof getPlans)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_plan[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPlans = b((r) => ({
  with200: r.with200<t_plan>(s_plan),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPlans = (
  params: Params<void, void, t_PostPlansBodySchema, void>,
  respond: (typeof postPlans)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_plan>
  | Response<StatusCode, t_error>
>

const deletePlansPlan = b((r) => ({
  with200: r.with200<t_deleted_plan>(s_deleted_plan),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeletePlansPlan = (
  params: Params<
    t_DeletePlansPlanParamSchema,
    void,
    t_DeletePlansPlanBodySchema | undefined,
    void
  >,
  respond: (typeof deletePlansPlan)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_plan>
  | Response<StatusCode, t_error>
>

const getPlansPlan = b((r) => ({
  with200: r.with200<t_plan>(s_plan),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPlansPlan = (
  params: Params<
    t_GetPlansPlanParamSchema,
    t_GetPlansPlanQuerySchema,
    t_GetPlansPlanBodySchema | undefined,
    void
  >,
  respond: (typeof getPlansPlan)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_plan>
  | Response<StatusCode, t_error>
>

const postPlansPlan = b((r) => ({
  with200: r.with200<t_plan>(s_plan),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPlansPlan = (
  params: Params<
    t_PostPlansPlanParamSchema,
    void,
    t_PostPlansPlanBodySchema | undefined,
    void
  >,
  respond: (typeof postPlansPlan)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_plan>
  | Response<StatusCode, t_error>
>

const getPrices = b((r) => ({
  with200: r.with200<{
    data: t_price[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_price)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/prices")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPrices = (
  params: Params<
    void,
    t_GetPricesQuerySchema,
    t_GetPricesBodySchema | undefined,
    void
  >,
  respond: (typeof getPrices)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_price[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPrices = b((r) => ({
  with200: r.with200<t_price>(s_price),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPrices = (
  params: Params<void, void, t_PostPricesBodySchema, void>,
  respond: (typeof postPrices)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_price>
  | Response<StatusCode, t_error>
>

const getPricesSearch = b((r) => ({
  with200: r.with200<{
    data: t_price[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_price)),
      has_more: PermissiveBoolean,
      next_page: z.string().max(5000).nullable().optional(),
      object: z.enum(["search_result"]),
      total_count: z.coerce.number().optional(),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPricesSearch = (
  params: Params<
    void,
    t_GetPricesSearchQuerySchema,
    t_GetPricesSearchBodySchema | undefined,
    void
  >,
  respond: (typeof getPricesSearch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_price[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getPricesPrice = b((r) => ({
  with200: r.with200<t_price>(s_price),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPricesPrice = (
  params: Params<
    t_GetPricesPriceParamSchema,
    t_GetPricesPriceQuerySchema,
    t_GetPricesPriceBodySchema | undefined,
    void
  >,
  respond: (typeof getPricesPrice)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_price>
  | Response<StatusCode, t_error>
>

const postPricesPrice = b((r) => ({
  with200: r.with200<t_price>(s_price),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPricesPrice = (
  params: Params<
    t_PostPricesPriceParamSchema,
    void,
    t_PostPricesPriceBodySchema | undefined,
    void
  >,
  respond: (typeof postPricesPrice)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_price>
  | Response<StatusCode, t_error>
>

const getProducts = b((r) => ({
  with200: r.with200<{
    data: t_product[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_product)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/products")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetProducts = (
  params: Params<
    void,
    t_GetProductsQuerySchema,
    t_GetProductsBodySchema | undefined,
    void
  >,
  respond: (typeof getProducts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_product[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postProducts = b((r) => ({
  with200: r.with200<t_product>(s_product),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostProducts = (
  params: Params<void, void, t_PostProductsBodySchema, void>,
  respond: (typeof postProducts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product>
  | Response<StatusCode, t_error>
>

const getProductsSearch = b((r) => ({
  with200: r.with200<{
    data: t_product[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_product)),
      has_more: PermissiveBoolean,
      next_page: z.string().max(5000).nullable().optional(),
      object: z.enum(["search_result"]),
      total_count: z.coerce.number().optional(),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetProductsSearch = (
  params: Params<
    void,
    t_GetProductsSearchQuerySchema,
    t_GetProductsSearchBodySchema | undefined,
    void
  >,
  respond: (typeof getProductsSearch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_product[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const deleteProductsId = b((r) => ({
  with200: r.with200<t_deleted_product>(s_deleted_product),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteProductsId = (
  params: Params<
    t_DeleteProductsIdParamSchema,
    void,
    t_DeleteProductsIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteProductsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_product>
  | Response<StatusCode, t_error>
>

const getProductsId = b((r) => ({
  with200: r.with200<t_product>(s_product),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetProductsId = (
  params: Params<
    t_GetProductsIdParamSchema,
    t_GetProductsIdQuerySchema,
    t_GetProductsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getProductsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product>
  | Response<StatusCode, t_error>
>

const postProductsId = b((r) => ({
  with200: r.with200<t_product>(s_product),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostProductsId = (
  params: Params<
    t_PostProductsIdParamSchema,
    void,
    t_PostProductsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postProductsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product>
  | Response<StatusCode, t_error>
>

const getProductsProductFeatures = b((r) => ({
  with200: r.with200<{
    data: t_product_feature[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_product_feature),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetProductsProductFeatures = (
  params: Params<
    t_GetProductsProductFeaturesParamSchema,
    t_GetProductsProductFeaturesQuerySchema,
    t_GetProductsProductFeaturesBodySchema | undefined,
    void
  >,
  respond: (typeof getProductsProductFeatures)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_product_feature[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postProductsProductFeatures = b((r) => ({
  with200: r.with200<t_product_feature>(s_product_feature),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostProductsProductFeatures = (
  params: Params<
    t_PostProductsProductFeaturesParamSchema,
    void,
    t_PostProductsProductFeaturesBodySchema,
    void
  >,
  respond: (typeof postProductsProductFeatures)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product_feature>
  | Response<StatusCode, t_error>
>

const deleteProductsProductFeaturesId = b((r) => ({
  with200: r.with200<t_deleted_product_feature>(s_deleted_product_feature),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteProductsProductFeaturesId = (
  params: Params<
    t_DeleteProductsProductFeaturesIdParamSchema,
    void,
    t_DeleteProductsProductFeaturesIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteProductsProductFeaturesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_product_feature>
  | Response<StatusCode, t_error>
>

const getProductsProductFeaturesId = b((r) => ({
  with200: r.with200<t_product_feature>(s_product_feature),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetProductsProductFeaturesId = (
  params: Params<
    t_GetProductsProductFeaturesIdParamSchema,
    t_GetProductsProductFeaturesIdQuerySchema,
    t_GetProductsProductFeaturesIdBodySchema | undefined,
    void
  >,
  respond: (typeof getProductsProductFeaturesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_product_feature>
  | Response<StatusCode, t_error>
>

const getPromotionCodes = b((r) => ({
  with200: r.with200<{
    data: t_promotion_code[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_promotion_code)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/promotion_codes")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPromotionCodes = (
  params: Params<
    void,
    t_GetPromotionCodesQuerySchema,
    t_GetPromotionCodesBodySchema | undefined,
    void
  >,
  respond: (typeof getPromotionCodes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_promotion_code[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postPromotionCodes = b((r) => ({
  with200: r.with200<t_promotion_code>(s_promotion_code),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPromotionCodes = (
  params: Params<void, void, t_PostPromotionCodesBodySchema, void>,
  respond: (typeof postPromotionCodes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_promotion_code>
  | Response<StatusCode, t_error>
>

const getPromotionCodesPromotionCode = b((r) => ({
  with200: r.with200<t_promotion_code>(s_promotion_code),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetPromotionCodesPromotionCode = (
  params: Params<
    t_GetPromotionCodesPromotionCodeParamSchema,
    t_GetPromotionCodesPromotionCodeQuerySchema,
    t_GetPromotionCodesPromotionCodeBodySchema | undefined,
    void
  >,
  respond: (typeof getPromotionCodesPromotionCode)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_promotion_code>
  | Response<StatusCode, t_error>
>

const postPromotionCodesPromotionCode = b((r) => ({
  with200: r.with200<t_promotion_code>(s_promotion_code),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostPromotionCodesPromotionCode = (
  params: Params<
    t_PostPromotionCodesPromotionCodeParamSchema,
    void,
    t_PostPromotionCodesPromotionCodeBodySchema | undefined,
    void
  >,
  respond: (typeof postPromotionCodesPromotionCode)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_promotion_code>
  | Response<StatusCode, t_error>
>

const getQuotes = b((r) => ({
  with200: r.with200<{
    data: t_quote[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_quote)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/quotes")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetQuotes = (
  params: Params<
    void,
    t_GetQuotesQuerySchema,
    t_GetQuotesBodySchema | undefined,
    void
  >,
  respond: (typeof getQuotes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_quote[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postQuotes = b((r) => ({
  with200: r.with200<t_quote>(s_quote),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostQuotes = (
  params: Params<void, void, t_PostQuotesBodySchema | undefined, void>,
  respond: (typeof postQuotes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
>

const getQuotesQuote = b((r) => ({
  with200: r.with200<t_quote>(s_quote),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetQuotesQuote = (
  params: Params<
    t_GetQuotesQuoteParamSchema,
    t_GetQuotesQuoteQuerySchema,
    t_GetQuotesQuoteBodySchema | undefined,
    void
  >,
  respond: (typeof getQuotesQuote)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
>

const postQuotesQuote = b((r) => ({
  with200: r.with200<t_quote>(s_quote),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostQuotesQuote = (
  params: Params<
    t_PostQuotesQuoteParamSchema,
    void,
    t_PostQuotesQuoteBodySchema | undefined,
    void
  >,
  respond: (typeof postQuotesQuote)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
>

const postQuotesQuoteAccept = b((r) => ({
  with200: r.with200<t_quote>(s_quote),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostQuotesQuoteAccept = (
  params: Params<
    t_PostQuotesQuoteAcceptParamSchema,
    void,
    t_PostQuotesQuoteAcceptBodySchema | undefined,
    void
  >,
  respond: (typeof postQuotesQuoteAccept)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
>

const postQuotesQuoteCancel = b((r) => ({
  with200: r.with200<t_quote>(s_quote),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostQuotesQuoteCancel = (
  params: Params<
    t_PostQuotesQuoteCancelParamSchema,
    void,
    t_PostQuotesQuoteCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postQuotesQuoteCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
>

const getQuotesQuoteComputedUpfrontLineItems = b((r) => ({
  with200: r.with200<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetQuotesQuoteComputedUpfrontLineItems = (
  params: Params<
    t_GetQuotesQuoteComputedUpfrontLineItemsParamSchema,
    t_GetQuotesQuoteComputedUpfrontLineItemsQuerySchema,
    t_GetQuotesQuoteComputedUpfrontLineItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getQuotesQuoteComputedUpfrontLineItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postQuotesQuoteFinalize = b((r) => ({
  with200: r.with200<t_quote>(s_quote),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostQuotesQuoteFinalize = (
  params: Params<
    t_PostQuotesQuoteFinalizeParamSchema,
    void,
    t_PostQuotesQuoteFinalizeBodySchema | undefined,
    void
  >,
  respond: (typeof postQuotesQuoteFinalize)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_quote>
  | Response<StatusCode, t_error>
>

const getQuotesQuoteLineItems = b((r) => ({
  with200: r.with200<{
    data: t_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetQuotesQuoteLineItems = (
  params: Params<
    t_GetQuotesQuoteLineItemsParamSchema,
    t_GetQuotesQuoteLineItemsQuerySchema,
    t_GetQuotesQuoteLineItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getQuotesQuoteLineItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getQuotesQuotePdf = b((r) => ({
  with200: r.with200<string>(z.string()),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetQuotesQuotePdf = (
  params: Params<
    t_GetQuotesQuotePdfParamSchema,
    t_GetQuotesQuotePdfQuerySchema,
    t_GetQuotesQuotePdfBodySchema | undefined,
    void
  >,
  respond: (typeof getQuotesQuotePdf)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, string>
  | Response<StatusCode, t_error>
>

const getRadarEarlyFraudWarnings = b((r) => ({
  with200: r.with200<{
    data: t_radar_early_fraud_warning[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_radar_early_fraud_warning)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/radar/early_fraud_warnings")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRadarEarlyFraudWarnings = (
  params: Params<
    void,
    t_GetRadarEarlyFraudWarningsQuerySchema,
    t_GetRadarEarlyFraudWarningsBodySchema | undefined,
    void
  >,
  respond: (typeof getRadarEarlyFraudWarnings)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_radar_early_fraud_warning[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getRadarEarlyFraudWarningsEarlyFraudWarning = b((r) => ({
  with200: r.with200<t_radar_early_fraud_warning>(s_radar_early_fraud_warning),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRadarEarlyFraudWarningsEarlyFraudWarning = (
  params: Params<
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
    t_GetRadarEarlyFraudWarningsEarlyFraudWarningBodySchema | undefined,
    void
  >,
  respond: (typeof getRadarEarlyFraudWarningsEarlyFraudWarning)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_early_fraud_warning>
  | Response<StatusCode, t_error>
>

const getRadarValueListItems = b((r) => ({
  with200: r.with200<{
    data: t_radar_value_list_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_radar_value_list_item),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/radar/value_list_items")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRadarValueListItems = (
  params: Params<
    void,
    t_GetRadarValueListItemsQuerySchema,
    t_GetRadarValueListItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getRadarValueListItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_radar_value_list_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postRadarValueListItems = b((r) => ({
  with200: r.with200<t_radar_value_list_item>(s_radar_value_list_item),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostRadarValueListItems = (
  params: Params<void, void, t_PostRadarValueListItemsBodySchema, void>,
  respond: (typeof postRadarValueListItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list_item>
  | Response<StatusCode, t_error>
>

const deleteRadarValueListItemsItem = b((r) => ({
  with200: r.with200<t_deleted_radar_value_list_item>(
    s_deleted_radar_value_list_item,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteRadarValueListItemsItem = (
  params: Params<
    t_DeleteRadarValueListItemsItemParamSchema,
    void,
    t_DeleteRadarValueListItemsItemBodySchema | undefined,
    void
  >,
  respond: (typeof deleteRadarValueListItemsItem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_radar_value_list_item>
  | Response<StatusCode, t_error>
>

const getRadarValueListItemsItem = b((r) => ({
  with200: r.with200<t_radar_value_list_item>(s_radar_value_list_item),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRadarValueListItemsItem = (
  params: Params<
    t_GetRadarValueListItemsItemParamSchema,
    t_GetRadarValueListItemsItemQuerySchema,
    t_GetRadarValueListItemsItemBodySchema | undefined,
    void
  >,
  respond: (typeof getRadarValueListItemsItem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list_item>
  | Response<StatusCode, t_error>
>

const getRadarValueLists = b((r) => ({
  with200: r.with200<{
    data: t_radar_value_list[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_radar_value_list),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/radar/value_lists")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRadarValueLists = (
  params: Params<
    void,
    t_GetRadarValueListsQuerySchema,
    t_GetRadarValueListsBodySchema | undefined,
    void
  >,
  respond: (typeof getRadarValueLists)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_radar_value_list[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postRadarValueLists = b((r) => ({
  with200: r.with200<t_radar_value_list>(s_radar_value_list),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostRadarValueLists = (
  params: Params<void, void, t_PostRadarValueListsBodySchema, void>,
  respond: (typeof postRadarValueLists)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list>
  | Response<StatusCode, t_error>
>

const deleteRadarValueListsValueList = b((r) => ({
  with200: r.with200<t_deleted_radar_value_list>(s_deleted_radar_value_list),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteRadarValueListsValueList = (
  params: Params<
    t_DeleteRadarValueListsValueListParamSchema,
    void,
    t_DeleteRadarValueListsValueListBodySchema | undefined,
    void
  >,
  respond: (typeof deleteRadarValueListsValueList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_radar_value_list>
  | Response<StatusCode, t_error>
>

const getRadarValueListsValueList = b((r) => ({
  with200: r.with200<t_radar_value_list>(s_radar_value_list),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRadarValueListsValueList = (
  params: Params<
    t_GetRadarValueListsValueListParamSchema,
    t_GetRadarValueListsValueListQuerySchema,
    t_GetRadarValueListsValueListBodySchema | undefined,
    void
  >,
  respond: (typeof getRadarValueListsValueList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list>
  | Response<StatusCode, t_error>
>

const postRadarValueListsValueList = b((r) => ({
  with200: r.with200<t_radar_value_list>(s_radar_value_list),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostRadarValueListsValueList = (
  params: Params<
    t_PostRadarValueListsValueListParamSchema,
    void,
    t_PostRadarValueListsValueListBodySchema | undefined,
    void
  >,
  respond: (typeof postRadarValueListsValueList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_radar_value_list>
  | Response<StatusCode, t_error>
>

const getRefunds = b((r) => ({
  with200: r.with200<{
    data: t_refund[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_refund)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/refunds")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRefunds = (
  params: Params<
    void,
    t_GetRefundsQuerySchema,
    t_GetRefundsBodySchema | undefined,
    void
  >,
  respond: (typeof getRefunds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_refund[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postRefunds = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostRefunds = (
  params: Params<void, void, t_PostRefundsBodySchema | undefined, void>,
  respond: (typeof postRefunds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const getRefundsRefund = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetRefundsRefund = (
  params: Params<
    t_GetRefundsRefundParamSchema,
    t_GetRefundsRefundQuerySchema,
    t_GetRefundsRefundBodySchema | undefined,
    void
  >,
  respond: (typeof getRefundsRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const postRefundsRefund = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostRefundsRefund = (
  params: Params<
    t_PostRefundsRefundParamSchema,
    void,
    t_PostRefundsRefundBodySchema | undefined,
    void
  >,
  respond: (typeof postRefundsRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const postRefundsRefundCancel = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostRefundsRefundCancel = (
  params: Params<
    t_PostRefundsRefundCancelParamSchema,
    void,
    t_PostRefundsRefundCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postRefundsRefundCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const getReportingReportRuns = b((r) => ({
  with200: r.with200<{
    data: t_reporting_report_run[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_reporting_report_run)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/reporting/report_runs")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetReportingReportRuns = (
  params: Params<
    void,
    t_GetReportingReportRunsQuerySchema,
    t_GetReportingReportRunsBodySchema | undefined,
    void
  >,
  respond: (typeof getReportingReportRuns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_reporting_report_run[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postReportingReportRuns = b((r) => ({
  with200: r.with200<t_reporting_report_run>(s_reporting_report_run),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostReportingReportRuns = (
  params: Params<void, void, t_PostReportingReportRunsBodySchema, void>,
  respond: (typeof postReportingReportRuns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reporting_report_run>
  | Response<StatusCode, t_error>
>

const getReportingReportRunsReportRun = b((r) => ({
  with200: r.with200<t_reporting_report_run>(s_reporting_report_run),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetReportingReportRunsReportRun = (
  params: Params<
    t_GetReportingReportRunsReportRunParamSchema,
    t_GetReportingReportRunsReportRunQuerySchema,
    t_GetReportingReportRunsReportRunBodySchema | undefined,
    void
  >,
  respond: (typeof getReportingReportRunsReportRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reporting_report_run>
  | Response<StatusCode, t_error>
>

const getReportingReportTypes = b((r) => ({
  with200: r.with200<{
    data: t_reporting_report_type[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_reporting_report_type),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetReportingReportTypes = (
  params: Params<
    void,
    t_GetReportingReportTypesQuerySchema,
    t_GetReportingReportTypesBodySchema | undefined,
    void
  >,
  respond: (typeof getReportingReportTypes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_reporting_report_type[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getReportingReportTypesReportType = b((r) => ({
  with200: r.with200<t_reporting_report_type>(s_reporting_report_type),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetReportingReportTypesReportType = (
  params: Params<
    t_GetReportingReportTypesReportTypeParamSchema,
    t_GetReportingReportTypesReportTypeQuerySchema,
    t_GetReportingReportTypesReportTypeBodySchema | undefined,
    void
  >,
  respond: (typeof getReportingReportTypesReportType)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reporting_report_type>
  | Response<StatusCode, t_error>
>

const getReviews = b((r) => ({
  with200: r.with200<{
    data: t_review[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_review)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetReviews = (
  params: Params<
    void,
    t_GetReviewsQuerySchema,
    t_GetReviewsBodySchema | undefined,
    void
  >,
  respond: (typeof getReviews)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_review[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getReviewsReview = b((r) => ({
  with200: r.with200<t_review>(s_review),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetReviewsReview = (
  params: Params<
    t_GetReviewsReviewParamSchema,
    t_GetReviewsReviewQuerySchema,
    t_GetReviewsReviewBodySchema | undefined,
    void
  >,
  respond: (typeof getReviewsReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_review>
  | Response<StatusCode, t_error>
>

const postReviewsReviewApprove = b((r) => ({
  with200: r.with200<t_review>(s_review),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostReviewsReviewApprove = (
  params: Params<
    t_PostReviewsReviewApproveParamSchema,
    void,
    t_PostReviewsReviewApproveBodySchema | undefined,
    void
  >,
  respond: (typeof postReviewsReviewApprove)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_review>
  | Response<StatusCode, t_error>
>

const getSetupAttempts = b((r) => ({
  with200: r.with200<{
    data: t_setup_attempt[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_setup_attempt)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/setup_attempts")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSetupAttempts = (
  params: Params<
    void,
    t_GetSetupAttemptsQuerySchema,
    t_GetSetupAttemptsBodySchema | undefined,
    void
  >,
  respond: (typeof getSetupAttempts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_setup_attempt[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getSetupIntents = b((r) => ({
  with200: r.with200<{
    data: t_setup_intent[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_setup_intent)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/setup_intents")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSetupIntents = (
  params: Params<
    void,
    t_GetSetupIntentsQuerySchema,
    t_GetSetupIntentsBodySchema | undefined,
    void
  >,
  respond: (typeof getSetupIntents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_setup_intent[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postSetupIntents = b((r) => ({
  with200: r.with200<t_setup_intent>(s_setup_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSetupIntents = (
  params: Params<void, void, t_PostSetupIntentsBodySchema | undefined, void>,
  respond: (typeof postSetupIntents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
>

const getSetupIntentsIntent = b((r) => ({
  with200: r.with200<t_setup_intent>(s_setup_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSetupIntentsIntent = (
  params: Params<
    t_GetSetupIntentsIntentParamSchema,
    t_GetSetupIntentsIntentQuerySchema,
    t_GetSetupIntentsIntentBodySchema | undefined,
    void
  >,
  respond: (typeof getSetupIntentsIntent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
>

const postSetupIntentsIntent = b((r) => ({
  with200: r.with200<t_setup_intent>(s_setup_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSetupIntentsIntent = (
  params: Params<
    t_PostSetupIntentsIntentParamSchema,
    void,
    t_PostSetupIntentsIntentBodySchema | undefined,
    void
  >,
  respond: (typeof postSetupIntentsIntent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
>

const postSetupIntentsIntentCancel = b((r) => ({
  with200: r.with200<t_setup_intent>(s_setup_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSetupIntentsIntentCancel = (
  params: Params<
    t_PostSetupIntentsIntentCancelParamSchema,
    void,
    t_PostSetupIntentsIntentCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postSetupIntentsIntentCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
>

const postSetupIntentsIntentConfirm = b((r) => ({
  with200: r.with200<t_setup_intent>(s_setup_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSetupIntentsIntentConfirm = (
  params: Params<
    t_PostSetupIntentsIntentConfirmParamSchema,
    void,
    t_PostSetupIntentsIntentConfirmBodySchema | undefined,
    void
  >,
  respond: (typeof postSetupIntentsIntentConfirm)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
>

const postSetupIntentsIntentVerifyMicrodeposits = b((r) => ({
  with200: r.with200<t_setup_intent>(s_setup_intent),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSetupIntentsIntentVerifyMicrodeposits = (
  params: Params<
    t_PostSetupIntentsIntentVerifyMicrodepositsParamSchema,
    void,
    t_PostSetupIntentsIntentVerifyMicrodepositsBodySchema | undefined,
    void
  >,
  respond: (typeof postSetupIntentsIntentVerifyMicrodeposits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_setup_intent>
  | Response<StatusCode, t_error>
>

const getShippingRates = b((r) => ({
  with200: r.with200<{
    data: t_shipping_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_shipping_rate),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/shipping_rates")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetShippingRates = (
  params: Params<
    void,
    t_GetShippingRatesQuerySchema,
    t_GetShippingRatesBodySchema | undefined,
    void
  >,
  respond: (typeof getShippingRates)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_shipping_rate[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postShippingRates = b((r) => ({
  with200: r.with200<t_shipping_rate>(s_shipping_rate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostShippingRates = (
  params: Params<void, void, t_PostShippingRatesBodySchema, void>,
  respond: (typeof postShippingRates)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_shipping_rate>
  | Response<StatusCode, t_error>
>

const getShippingRatesShippingRateToken = b((r) => ({
  with200: r.with200<t_shipping_rate>(s_shipping_rate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetShippingRatesShippingRateToken = (
  params: Params<
    t_GetShippingRatesShippingRateTokenParamSchema,
    t_GetShippingRatesShippingRateTokenQuerySchema,
    t_GetShippingRatesShippingRateTokenBodySchema | undefined,
    void
  >,
  respond: (typeof getShippingRatesShippingRateToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_shipping_rate>
  | Response<StatusCode, t_error>
>

const postShippingRatesShippingRateToken = b((r) => ({
  with200: r.with200<t_shipping_rate>(s_shipping_rate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostShippingRatesShippingRateToken = (
  params: Params<
    t_PostShippingRatesShippingRateTokenParamSchema,
    void,
    t_PostShippingRatesShippingRateTokenBodySchema | undefined,
    void
  >,
  respond: (typeof postShippingRatesShippingRateToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_shipping_rate>
  | Response<StatusCode, t_error>
>

const postSigmaSavedQueriesId = b((r) => ({
  with200: r.with200<t_sigma_sigma_api_query>(s_sigma_sigma_api_query),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSigmaSavedQueriesId = (
  params: Params<
    t_PostSigmaSavedQueriesIdParamSchema,
    void,
    t_PostSigmaSavedQueriesIdBodySchema | undefined,
    void
  >,
  respond: (typeof postSigmaSavedQueriesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_sigma_sigma_api_query>
  | Response<StatusCode, t_error>
>

const getSigmaScheduledQueryRuns = b((r) => ({
  with200: r.with200<{
    data: t_scheduled_query_run[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_scheduled_query_run)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/sigma/scheduled_query_runs")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSigmaScheduledQueryRuns = (
  params: Params<
    void,
    t_GetSigmaScheduledQueryRunsQuerySchema,
    t_GetSigmaScheduledQueryRunsBodySchema | undefined,
    void
  >,
  respond: (typeof getSigmaScheduledQueryRuns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_scheduled_query_run[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getSigmaScheduledQueryRunsScheduledQueryRun = b((r) => ({
  with200: r.with200<t_scheduled_query_run>(s_scheduled_query_run),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSigmaScheduledQueryRunsScheduledQueryRun = (
  params: Params<
    t_GetSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
    t_GetSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
    t_GetSigmaScheduledQueryRunsScheduledQueryRunBodySchema | undefined,
    void
  >,
  respond: (typeof getSigmaScheduledQueryRunsScheduledQueryRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_scheduled_query_run>
  | Response<StatusCode, t_error>
>

const postSources = b((r) => ({
  with200: r.with200<t_source>(s_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSources = (
  params: Params<void, void, t_PostSourcesBodySchema | undefined, void>,
  respond: (typeof postSources)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
>

const getSourcesSource = b((r) => ({
  with200: r.with200<t_source>(s_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSourcesSource = (
  params: Params<
    t_GetSourcesSourceParamSchema,
    t_GetSourcesSourceQuerySchema,
    t_GetSourcesSourceBodySchema | undefined,
    void
  >,
  respond: (typeof getSourcesSource)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
>

const postSourcesSource = b((r) => ({
  with200: r.with200<t_source>(s_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSourcesSource = (
  params: Params<
    t_PostSourcesSourceParamSchema,
    void,
    t_PostSourcesSourceBodySchema | undefined,
    void
  >,
  respond: (typeof postSourcesSource)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
>

const getSourcesSourceMandateNotificationsMandateNotification = b((r) => ({
  with200: r.with200<t_source_mandate_notification>(
    s_source_mandate_notification,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSourcesSourceMandateNotificationsMandateNotification = (
  params: Params<
    t_GetSourcesSourceMandateNotificationsMandateNotificationParamSchema,
    t_GetSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
    | t_GetSourcesSourceMandateNotificationsMandateNotificationBodySchema
    | undefined,
    void
  >,
  respond: (typeof getSourcesSourceMandateNotificationsMandateNotification)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source_mandate_notification>
  | Response<StatusCode, t_error>
>

const getSourcesSourceSourceTransactions = b((r) => ({
  with200: r.with200<{
    data: t_source_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_source_transaction),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSourcesSourceSourceTransactions = (
  params: Params<
    t_GetSourcesSourceSourceTransactionsParamSchema,
    t_GetSourcesSourceSourceTransactionsQuerySchema,
    t_GetSourcesSourceSourceTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getSourcesSourceSourceTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_source_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getSourcesSourceSourceTransactionsSourceTransaction = b((r) => ({
  with200: r.with200<t_source_transaction>(s_source_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSourcesSourceSourceTransactionsSourceTransaction = (
  params: Params<
    t_GetSourcesSourceSourceTransactionsSourceTransactionParamSchema,
    t_GetSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
    t_GetSourcesSourceSourceTransactionsSourceTransactionBodySchema | undefined,
    void
  >,
  respond: (typeof getSourcesSourceSourceTransactionsSourceTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source_transaction>
  | Response<StatusCode, t_error>
>

const postSourcesSourceVerify = b((r) => ({
  with200: r.with200<t_source>(s_source),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSourcesSourceVerify = (
  params: Params<
    t_PostSourcesSourceVerifyParamSchema,
    void,
    t_PostSourcesSourceVerifyBodySchema,
    void
  >,
  respond: (typeof postSourcesSourceVerify)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_source>
  | Response<StatusCode, t_error>
>

const getSubscriptionItems = b((r) => ({
  with200: r.with200<{
    data: t_subscription_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_subscription_item)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/subscription_items")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSubscriptionItems = (
  params: Params<
    void,
    t_GetSubscriptionItemsQuerySchema,
    t_GetSubscriptionItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getSubscriptionItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postSubscriptionItems = b((r) => ({
  with200: r.with200<t_subscription_item>(s_subscription_item),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionItems = (
  params: Params<void, void, t_PostSubscriptionItemsBodySchema, void>,
  respond: (typeof postSubscriptionItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_item>
  | Response<StatusCode, t_error>
>

const deleteSubscriptionItemsItem = b((r) => ({
  with200: r.with200<t_deleted_subscription_item>(s_deleted_subscription_item),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteSubscriptionItemsItem = (
  params: Params<
    t_DeleteSubscriptionItemsItemParamSchema,
    void,
    t_DeleteSubscriptionItemsItemBodySchema | undefined,
    void
  >,
  respond: (typeof deleteSubscriptionItemsItem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_subscription_item>
  | Response<StatusCode, t_error>
>

const getSubscriptionItemsItem = b((r) => ({
  with200: r.with200<t_subscription_item>(s_subscription_item),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSubscriptionItemsItem = (
  params: Params<
    t_GetSubscriptionItemsItemParamSchema,
    t_GetSubscriptionItemsItemQuerySchema,
    t_GetSubscriptionItemsItemBodySchema | undefined,
    void
  >,
  respond: (typeof getSubscriptionItemsItem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_item>
  | Response<StatusCode, t_error>
>

const postSubscriptionItemsItem = b((r) => ({
  with200: r.with200<t_subscription_item>(s_subscription_item),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionItemsItem = (
  params: Params<
    t_PostSubscriptionItemsItemParamSchema,
    void,
    t_PostSubscriptionItemsItemBodySchema | undefined,
    void
  >,
  respond: (typeof postSubscriptionItemsItem)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_item>
  | Response<StatusCode, t_error>
>

const getSubscriptionSchedules = b((r) => ({
  with200: r.with200<{
    data: t_subscription_schedule[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_subscription_schedule)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/subscription_schedules")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSubscriptionSchedules = (
  params: Params<
    void,
    t_GetSubscriptionSchedulesQuerySchema,
    t_GetSubscriptionSchedulesBodySchema | undefined,
    void
  >,
  respond: (typeof getSubscriptionSchedules)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription_schedule[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postSubscriptionSchedules = b((r) => ({
  with200: r.with200<t_subscription_schedule>(s_subscription_schedule),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionSchedules = (
  params: Params<
    void,
    void,
    t_PostSubscriptionSchedulesBodySchema | undefined,
    void
  >,
  respond: (typeof postSubscriptionSchedules)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
>

const getSubscriptionSchedulesSchedule = b((r) => ({
  with200: r.with200<t_subscription_schedule>(s_subscription_schedule),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSubscriptionSchedulesSchedule = (
  params: Params<
    t_GetSubscriptionSchedulesScheduleParamSchema,
    t_GetSubscriptionSchedulesScheduleQuerySchema,
    t_GetSubscriptionSchedulesScheduleBodySchema | undefined,
    void
  >,
  respond: (typeof getSubscriptionSchedulesSchedule)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
>

const postSubscriptionSchedulesSchedule = b((r) => ({
  with200: r.with200<t_subscription_schedule>(s_subscription_schedule),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionSchedulesSchedule = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleBodySchema | undefined,
    void
  >,
  respond: (typeof postSubscriptionSchedulesSchedule)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
>

const postSubscriptionSchedulesScheduleCancel = b((r) => ({
  with200: r.with200<t_subscription_schedule>(s_subscription_schedule),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionSchedulesScheduleCancel = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleCancelParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postSubscriptionSchedulesScheduleCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
>

const postSubscriptionSchedulesScheduleRelease = b((r) => ({
  with200: r.with200<t_subscription_schedule>(s_subscription_schedule),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionSchedulesScheduleRelease = (
  params: Params<
    t_PostSubscriptionSchedulesScheduleReleaseParamSchema,
    void,
    t_PostSubscriptionSchedulesScheduleReleaseBodySchema | undefined,
    void
  >,
  respond: (typeof postSubscriptionSchedulesScheduleRelease)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription_schedule>
  | Response<StatusCode, t_error>
>

const getSubscriptions = b((r) => ({
  with200: r.with200<{
    data: t_subscription[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_subscription)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/subscriptions")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSubscriptions = (
  params: Params<
    void,
    t_GetSubscriptionsQuerySchema,
    t_GetSubscriptionsBodySchema | undefined,
    void
  >,
  respond: (typeof getSubscriptions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postSubscriptions = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptions = (
  params: Params<void, void, t_PostSubscriptionsBodySchema, void>,
  respond: (typeof postSubscriptions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const getSubscriptionsSearch = b((r) => ({
  with200: r.with200<{
    data: t_subscription[]
    has_more: boolean
    next_page?: string | null
    object: "search_result"
    total_count?: number
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_subscription)),
      has_more: PermissiveBoolean,
      next_page: z.string().max(5000).nullable().optional(),
      object: z.enum(["search_result"]),
      total_count: z.coerce.number().optional(),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSubscriptionsSearch = (
  params: Params<
    void,
    t_GetSubscriptionsSearchQuerySchema,
    t_GetSubscriptionsSearchBodySchema | undefined,
    void
  >,
  respond: (typeof getSubscriptionsSearch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_subscription[]
        has_more: boolean
        next_page?: string | null
        object: "search_result"
        total_count?: number
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const deleteSubscriptionsSubscriptionExposedId = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_DeleteSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    t_DeleteSubscriptionsSubscriptionExposedIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteSubscriptionsSubscriptionExposedId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const getSubscriptionsSubscriptionExposedId = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_GetSubscriptionsSubscriptionExposedIdParamSchema,
    t_GetSubscriptionsSubscriptionExposedIdQuerySchema,
    t_GetSubscriptionsSubscriptionExposedIdBodySchema | undefined,
    void
  >,
  respond: (typeof getSubscriptionsSubscriptionExposedId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const postSubscriptionsSubscriptionExposedId = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionsSubscriptionExposedId = (
  params: Params<
    t_PostSubscriptionsSubscriptionExposedIdParamSchema,
    void,
    t_PostSubscriptionsSubscriptionExposedIdBodySchema | undefined,
    void
  >,
  respond: (typeof postSubscriptionsSubscriptionExposedId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const deleteSubscriptionsSubscriptionExposedIdDiscount = b((r) => ({
  with200: r.with200<t_deleted_discount>(s_deleted_discount),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteSubscriptionsSubscriptionExposedIdDiscount = (
  params: Params<
    t_DeleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
    void,
    t_DeleteSubscriptionsSubscriptionExposedIdDiscountBodySchema | undefined,
    void
  >,
  respond: (typeof deleteSubscriptionsSubscriptionExposedIdDiscount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_discount>
  | Response<StatusCode, t_error>
>

const postSubscriptionsSubscriptionResume = b((r) => ({
  with200: r.with200<t_subscription>(s_subscription),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostSubscriptionsSubscriptionResume = (
  params: Params<
    t_PostSubscriptionsSubscriptionResumeParamSchema,
    void,
    t_PostSubscriptionsSubscriptionResumeBodySchema | undefined,
    void
  >,
  respond: (typeof postSubscriptionsSubscriptionResume)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_subscription>
  | Response<StatusCode, t_error>
>

const postTaxCalculations = b((r) => ({
  with200: r.with200<t_tax_calculation>(s_tax_calculation),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxCalculations = (
  params: Params<void, void, t_PostTaxCalculationsBodySchema, void>,
  respond: (typeof postTaxCalculations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_calculation>
  | Response<StatusCode, t_error>
>

const getTaxCalculationsCalculation = b((r) => ({
  with200: r.with200<t_tax_calculation>(s_tax_calculation),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxCalculationsCalculation = (
  params: Params<
    t_GetTaxCalculationsCalculationParamSchema,
    t_GetTaxCalculationsCalculationQuerySchema,
    t_GetTaxCalculationsCalculationBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxCalculationsCalculation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_calculation>
  | Response<StatusCode, t_error>
>

const getTaxCalculationsCalculationLineItems = b((r) => ({
  with200: r.with200<{
    data: t_tax_calculation_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_tax_calculation_line_item),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/tax/calculations/[^/]+/line_items")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxCalculationsCalculationLineItems = (
  params: Params<
    t_GetTaxCalculationsCalculationLineItemsParamSchema,
    t_GetTaxCalculationsCalculationLineItemsQuerySchema,
    t_GetTaxCalculationsCalculationLineItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxCalculationsCalculationLineItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_calculation_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getTaxRegistrations = b((r) => ({
  with200: r.with200<{
    data: t_tax_registration[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_tax_registration),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/tax/registrations")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxRegistrations = (
  params: Params<
    void,
    t_GetTaxRegistrationsQuerySchema,
    t_GetTaxRegistrationsBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxRegistrations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_registration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTaxRegistrations = b((r) => ({
  with200: r.with200<t_tax_registration>(s_tax_registration),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxRegistrations = (
  params: Params<void, void, t_PostTaxRegistrationsBodySchema, void>,
  respond: (typeof postTaxRegistrations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_registration>
  | Response<StatusCode, t_error>
>

const getTaxRegistrationsId = b((r) => ({
  with200: r.with200<t_tax_registration>(s_tax_registration),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxRegistrationsId = (
  params: Params<
    t_GetTaxRegistrationsIdParamSchema,
    t_GetTaxRegistrationsIdQuerySchema,
    t_GetTaxRegistrationsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxRegistrationsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_registration>
  | Response<StatusCode, t_error>
>

const postTaxRegistrationsId = b((r) => ({
  with200: r.with200<t_tax_registration>(s_tax_registration),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxRegistrationsId = (
  params: Params<
    t_PostTaxRegistrationsIdParamSchema,
    void,
    t_PostTaxRegistrationsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postTaxRegistrationsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_registration>
  | Response<StatusCode, t_error>
>

const getTaxSettings = b((r) => ({
  with200: r.with200<t_tax_settings>(s_tax_settings),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxSettings = (
  params: Params<
    void,
    t_GetTaxSettingsQuerySchema,
    t_GetTaxSettingsBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxSettings)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_settings>
  | Response<StatusCode, t_error>
>

const postTaxSettings = b((r) => ({
  with200: r.with200<t_tax_settings>(s_tax_settings),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxSettings = (
  params: Params<void, void, t_PostTaxSettingsBodySchema | undefined, void>,
  respond: (typeof postTaxSettings)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_settings>
  | Response<StatusCode, t_error>
>

const postTaxTransactionsCreateFromCalculation = b((r) => ({
  with200: r.with200<t_tax_transaction>(s_tax_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxTransactionsCreateFromCalculation = (
  params: Params<
    void,
    void,
    t_PostTaxTransactionsCreateFromCalculationBodySchema,
    void
  >,
  respond: (typeof postTaxTransactionsCreateFromCalculation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_transaction>
  | Response<StatusCode, t_error>
>

const postTaxTransactionsCreateReversal = b((r) => ({
  with200: r.with200<t_tax_transaction>(s_tax_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxTransactionsCreateReversal = (
  params: Params<
    void,
    void,
    t_PostTaxTransactionsCreateReversalBodySchema,
    void
  >,
  respond: (typeof postTaxTransactionsCreateReversal)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_transaction>
  | Response<StatusCode, t_error>
>

const getTaxTransactionsTransaction = b((r) => ({
  with200: r.with200<t_tax_transaction>(s_tax_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxTransactionsTransaction = (
  params: Params<
    t_GetTaxTransactionsTransactionParamSchema,
    t_GetTaxTransactionsTransactionQuerySchema,
    t_GetTaxTransactionsTransactionBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxTransactionsTransaction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_transaction>
  | Response<StatusCode, t_error>
>

const getTaxTransactionsTransactionLineItems = b((r) => ({
  with200: r.with200<{
    data: t_tax_transaction_line_item[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_tax_transaction_line_item),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/tax/transactions/[^/]+/line_items")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxTransactionsTransactionLineItems = (
  params: Params<
    t_GetTaxTransactionsTransactionLineItemsParamSchema,
    t_GetTaxTransactionsTransactionLineItemsQuerySchema,
    t_GetTaxTransactionsTransactionLineItemsBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxTransactionsTransactionLineItems)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_transaction_line_item[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getTaxCodes = b((r) => ({
  with200: r.with200<{
    data: t_tax_code[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_tax_code),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxCodes = (
  params: Params<
    void,
    t_GetTaxCodesQuerySchema,
    t_GetTaxCodesBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxCodes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_code[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getTaxCodesId = b((r) => ({
  with200: r.with200<t_tax_code>(s_tax_code),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxCodesId = (
  params: Params<
    t_GetTaxCodesIdParamSchema,
    t_GetTaxCodesIdQuerySchema,
    t_GetTaxCodesIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxCodesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_code>
  | Response<StatusCode, t_error>
>

const getTaxIds = b((r) => ({
  with200: r.with200<{
    data: t_tax_id[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_tax_id)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxIds = (
  params: Params<
    void,
    t_GetTaxIdsQuerySchema,
    t_GetTaxIdsBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxIds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_id[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTaxIds = b((r) => ({
  with200: r.with200<t_tax_id>(s_tax_id),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxIds = (
  params: Params<void, void, t_PostTaxIdsBodySchema, void>,
  respond: (typeof postTaxIds)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
>

const deleteTaxIdsId = b((r) => ({
  with200: r.with200<t_deleted_tax_id>(s_deleted_tax_id),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteTaxIdsId = (
  params: Params<
    t_DeleteTaxIdsIdParamSchema,
    void,
    t_DeleteTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: (typeof deleteTaxIdsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_tax_id>
  | Response<StatusCode, t_error>
>

const getTaxIdsId = b((r) => ({
  with200: r.with200<t_tax_id>(s_tax_id),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxIdsId = (
  params: Params<
    t_GetTaxIdsIdParamSchema,
    t_GetTaxIdsIdQuerySchema,
    t_GetTaxIdsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxIdsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_id>
  | Response<StatusCode, t_error>
>

const getTaxRates = b((r) => ({
  with200: r.with200<{
    data: t_tax_rate[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_tax_rate),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/tax_rates")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxRates = (
  params: Params<
    void,
    t_GetTaxRatesQuerySchema,
    t_GetTaxRatesBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxRates)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_tax_rate[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTaxRates = b((r) => ({
  with200: r.with200<t_tax_rate>(s_tax_rate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxRates = (
  params: Params<void, void, t_PostTaxRatesBodySchema, void>,
  respond: (typeof postTaxRates)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_rate>
  | Response<StatusCode, t_error>
>

const getTaxRatesTaxRate = b((r) => ({
  with200: r.with200<t_tax_rate>(s_tax_rate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTaxRatesTaxRate = (
  params: Params<
    t_GetTaxRatesTaxRateParamSchema,
    t_GetTaxRatesTaxRateQuerySchema,
    t_GetTaxRatesTaxRateBodySchema | undefined,
    void
  >,
  respond: (typeof getTaxRatesTaxRate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_rate>
  | Response<StatusCode, t_error>
>

const postTaxRatesTaxRate = b((r) => ({
  with200: r.with200<t_tax_rate>(s_tax_rate),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTaxRatesTaxRate = (
  params: Params<
    t_PostTaxRatesTaxRateParamSchema,
    void,
    t_PostTaxRatesTaxRateBodySchema | undefined,
    void
  >,
  respond: (typeof postTaxRatesTaxRate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tax_rate>
  | Response<StatusCode, t_error>
>

const getTerminalConfigurations = b((r) => ({
  with200: r.with200<{
    data: t_terminal_configuration[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_terminal_configuration)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/terminal/configurations")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTerminalConfigurations = (
  params: Params<
    void,
    t_GetTerminalConfigurationsQuerySchema,
    t_GetTerminalConfigurationsBodySchema | undefined,
    void
  >,
  respond: (typeof getTerminalConfigurations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_terminal_configuration[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTerminalConfigurations = b((r) => ({
  with200: r.with200<t_terminal_configuration>(s_terminal_configuration),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalConfigurations = (
  params: Params<
    void,
    void,
    t_PostTerminalConfigurationsBodySchema | undefined,
    void
  >,
  respond: (typeof postTerminalConfigurations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_configuration>
  | Response<StatusCode, t_error>
>

const deleteTerminalConfigurationsConfiguration = b((r) => ({
  with200: r.with200<t_deleted_terminal_configuration>(
    s_deleted_terminal_configuration,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteTerminalConfigurationsConfiguration = (
  params: Params<
    t_DeleteTerminalConfigurationsConfigurationParamSchema,
    void,
    t_DeleteTerminalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: (typeof deleteTerminalConfigurationsConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_terminal_configuration>
  | Response<StatusCode, t_error>
>

const getTerminalConfigurationsConfiguration = b((r) => ({
  with200: r.with200<
    t_terminal_configuration | t_deleted_terminal_configuration
  >(
    z.union([
      z.lazy(() => s_terminal_configuration),
      s_deleted_terminal_configuration,
    ]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTerminalConfigurationsConfiguration = (
  params: Params<
    t_GetTerminalConfigurationsConfigurationParamSchema,
    t_GetTerminalConfigurationsConfigurationQuerySchema,
    t_GetTerminalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: (typeof getTerminalConfigurationsConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_configuration | t_deleted_terminal_configuration>
  | Response<StatusCode, t_error>
>

const postTerminalConfigurationsConfiguration = b((r) => ({
  with200: r.with200<
    t_terminal_configuration | t_deleted_terminal_configuration
  >(
    z.union([
      z.lazy(() => s_terminal_configuration),
      s_deleted_terminal_configuration,
    ]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalConfigurationsConfiguration = (
  params: Params<
    t_PostTerminalConfigurationsConfigurationParamSchema,
    void,
    t_PostTerminalConfigurationsConfigurationBodySchema | undefined,
    void
  >,
  respond: (typeof postTerminalConfigurationsConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_configuration | t_deleted_terminal_configuration>
  | Response<StatusCode, t_error>
>

const postTerminalConnectionTokens = b((r) => ({
  with200: r.with200<t_terminal_connection_token>(s_terminal_connection_token),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalConnectionTokens = (
  params: Params<
    void,
    void,
    t_PostTerminalConnectionTokensBodySchema | undefined,
    void
  >,
  respond: (typeof postTerminalConnectionTokens)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_connection_token>
  | Response<StatusCode, t_error>
>

const getTerminalLocations = b((r) => ({
  with200: r.with200<{
    data: t_terminal_location[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_terminal_location),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/terminal/locations")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTerminalLocations = (
  params: Params<
    void,
    t_GetTerminalLocationsQuerySchema,
    t_GetTerminalLocationsBodySchema | undefined,
    void
  >,
  respond: (typeof getTerminalLocations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_terminal_location[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTerminalLocations = b((r) => ({
  with200: r.with200<t_terminal_location>(s_terminal_location),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalLocations = (
  params: Params<void, void, t_PostTerminalLocationsBodySchema, void>,
  respond: (typeof postTerminalLocations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_location>
  | Response<StatusCode, t_error>
>

const deleteTerminalLocationsLocation = b((r) => ({
  with200: r.with200<t_deleted_terminal_location>(s_deleted_terminal_location),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteTerminalLocationsLocation = (
  params: Params<
    t_DeleteTerminalLocationsLocationParamSchema,
    void,
    t_DeleteTerminalLocationsLocationBodySchema | undefined,
    void
  >,
  respond: (typeof deleteTerminalLocationsLocation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_terminal_location>
  | Response<StatusCode, t_error>
>

const getTerminalLocationsLocation = b((r) => ({
  with200: r.with200<t_terminal_location | t_deleted_terminal_location>(
    z.union([s_terminal_location, s_deleted_terminal_location]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTerminalLocationsLocation = (
  params: Params<
    t_GetTerminalLocationsLocationParamSchema,
    t_GetTerminalLocationsLocationQuerySchema,
    t_GetTerminalLocationsLocationBodySchema | undefined,
    void
  >,
  respond: (typeof getTerminalLocationsLocation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_location | t_deleted_terminal_location>
  | Response<StatusCode, t_error>
>

const postTerminalLocationsLocation = b((r) => ({
  with200: r.with200<t_terminal_location | t_deleted_terminal_location>(
    z.union([s_terminal_location, s_deleted_terminal_location]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalLocationsLocation = (
  params: Params<
    t_PostTerminalLocationsLocationParamSchema,
    void,
    t_PostTerminalLocationsLocationBodySchema | undefined,
    void
  >,
  respond: (typeof postTerminalLocationsLocation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_location | t_deleted_terminal_location>
  | Response<StatusCode, t_error>
>

const getTerminalReaders = b((r) => ({
  with200: r.with200<{
    data: t_terminal_reader[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_terminal_reader)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTerminalReaders = (
  params: Params<
    void,
    t_GetTerminalReadersQuerySchema,
    t_GetTerminalReadersBodySchema | undefined,
    void
  >,
  respond: (typeof getTerminalReaders)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_terminal_reader[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTerminalReaders = b((r) => ({
  with200: r.with200<t_terminal_reader>(s_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalReaders = (
  params: Params<void, void, t_PostTerminalReadersBodySchema, void>,
  respond: (typeof postTerminalReaders)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
>

const deleteTerminalReadersReader = b((r) => ({
  with200: r.with200<t_deleted_terminal_reader>(s_deleted_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteTerminalReadersReader = (
  params: Params<
    t_DeleteTerminalReadersReaderParamSchema,
    void,
    t_DeleteTerminalReadersReaderBodySchema | undefined,
    void
  >,
  respond: (typeof deleteTerminalReadersReader)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_terminal_reader>
  | Response<StatusCode, t_error>
>

const getTerminalReadersReader = b((r) => ({
  with200: r.with200<t_terminal_reader | t_deleted_terminal_reader>(
    z.union([z.lazy(() => s_terminal_reader), s_deleted_terminal_reader]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTerminalReadersReader = (
  params: Params<
    t_GetTerminalReadersReaderParamSchema,
    t_GetTerminalReadersReaderQuerySchema,
    t_GetTerminalReadersReaderBodySchema | undefined,
    void
  >,
  respond: (typeof getTerminalReadersReader)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader | t_deleted_terminal_reader>
  | Response<StatusCode, t_error>
>

const postTerminalReadersReader = b((r) => ({
  with200: r.with200<t_terminal_reader | t_deleted_terminal_reader>(
    z.union([z.lazy(() => s_terminal_reader), s_deleted_terminal_reader]),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalReadersReader = (
  params: Params<
    t_PostTerminalReadersReaderParamSchema,
    void,
    t_PostTerminalReadersReaderBodySchema | undefined,
    void
  >,
  respond: (typeof postTerminalReadersReader)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader | t_deleted_terminal_reader>
  | Response<StatusCode, t_error>
>

const postTerminalReadersReaderCancelAction = b((r) => ({
  with200: r.with200<t_terminal_reader>(s_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalReadersReaderCancelAction = (
  params: Params<
    t_PostTerminalReadersReaderCancelActionParamSchema,
    void,
    t_PostTerminalReadersReaderCancelActionBodySchema | undefined,
    void
  >,
  respond: (typeof postTerminalReadersReaderCancelAction)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
>

const postTerminalReadersReaderProcessPaymentIntent = b((r) => ({
  with200: r.with200<t_terminal_reader>(s_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalReadersReaderProcessPaymentIntent = (
  params: Params<
    t_PostTerminalReadersReaderProcessPaymentIntentParamSchema,
    void,
    t_PostTerminalReadersReaderProcessPaymentIntentBodySchema,
    void
  >,
  respond: (typeof postTerminalReadersReaderProcessPaymentIntent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
>

const postTerminalReadersReaderProcessSetupIntent = b((r) => ({
  with200: r.with200<t_terminal_reader>(s_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalReadersReaderProcessSetupIntent = (
  params: Params<
    t_PostTerminalReadersReaderProcessSetupIntentParamSchema,
    void,
    t_PostTerminalReadersReaderProcessSetupIntentBodySchema,
    void
  >,
  respond: (typeof postTerminalReadersReaderProcessSetupIntent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
>

const postTerminalReadersReaderRefundPayment = b((r) => ({
  with200: r.with200<t_terminal_reader>(s_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalReadersReaderRefundPayment = (
  params: Params<
    t_PostTerminalReadersReaderRefundPaymentParamSchema,
    void,
    t_PostTerminalReadersReaderRefundPaymentBodySchema | undefined,
    void
  >,
  respond: (typeof postTerminalReadersReaderRefundPayment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
>

const postTerminalReadersReaderSetReaderDisplay = b((r) => ({
  with200: r.with200<t_terminal_reader>(s_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTerminalReadersReaderSetReaderDisplay = (
  params: Params<
    t_PostTerminalReadersReaderSetReaderDisplayParamSchema,
    void,
    t_PostTerminalReadersReaderSetReaderDisplayBodySchema,
    void
  >,
  respond: (typeof postTerminalReadersReaderSetReaderDisplay)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
>

const postTestHelpersConfirmationTokens = b((r) => ({
  with200: r.with200<t_confirmation_token>(s_confirmation_token),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersConfirmationTokens = (
  params: Params<
    void,
    void,
    t_PostTestHelpersConfirmationTokensBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersConfirmationTokens)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_confirmation_token>
  | Response<StatusCode, t_error>
>

const postTestHelpersCustomersCustomerFundCashBalance = b((r) => ({
  with200: r.with200<t_customer_cash_balance_transaction>(
    s_customer_cash_balance_transaction,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersCustomersCustomerFundCashBalance = (
  params: Params<
    t_PostTestHelpersCustomersCustomerFundCashBalanceParamSchema,
    void,
    t_PostTestHelpersCustomersCustomerFundCashBalanceBodySchema,
    void
  >,
  respond: (typeof postTestHelpersCustomersCustomerFundCashBalance)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_customer_cash_balance_transaction>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingAuthorizations = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingAuthorizations = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingAuthorizationsBodySchema,
    void
  >,
  respond: (typeof postTestHelpersIssuingAuthorizations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingAuthorizationsAuthorizationCapture = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingAuthorizationsAuthorizationCapture = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingAuthorizationsAuthorizationCapture)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingAuthorizationsAuthorizationExpire = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingAuthorizationsAuthorizationExpire = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingAuthorizationsAuthorizationExpire)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount = b(
  (r) => ({
    with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }),
)

export type PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
    void,
    t_PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema,
    void
  >,
  respond: (typeof postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond =
  b((r) => ({
    with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }))

export type PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond =
  (
    params: Params<
      t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
      void,
      t_PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema,
      void
    >,
    respond: (typeof postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond)["responder"],
    ctx: RouterContext,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_authorization>
    | Response<StatusCode, t_error>
  >

const postTestHelpersIssuingAuthorizationsAuthorizationIncrement = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingAuthorizationsAuthorizationIncrement = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
    void,
    t_PostTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema,
    void
  >,
  respond: (typeof postTestHelpersIssuingAuthorizationsAuthorizationIncrement)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingAuthorizationsAuthorizationReverse = b((r) => ({
  with200: r.with200<t_issuing_authorization>(s_issuing_authorization),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingAuthorizationsAuthorizationReverse = (
  params: Params<
    t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
    void,
    | t_PostTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingAuthorizationsAuthorizationReverse)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_authorization>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingCardsCardShippingDeliver = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingCardsCardShippingDeliver = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingDeliverParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingDeliverBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingCardsCardShippingDeliver)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingCardsCardShippingFail = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingCardsCardShippingFail = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingFailParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingFailBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingCardsCardShippingFail)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingCardsCardShippingReturn = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingCardsCardShippingReturn = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingReturnParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingReturnBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingCardsCardShippingReturn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingCardsCardShippingShip = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingCardsCardShippingShip = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingShipParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingShipBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingCardsCardShippingShip)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingCardsCardShippingSubmit = b((r) => ({
  with200: r.with200<t_issuing_card>(s_issuing_card),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingCardsCardShippingSubmit = (
  params: Params<
    t_PostTestHelpersIssuingCardsCardShippingSubmitParamSchema,
    void,
    t_PostTestHelpersIssuingCardsCardShippingSubmitBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingCardsCardShippingSubmit)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_card>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate =
  b((r) => ({
    with200: r.with200<t_issuing_personalization_design>(
      s_issuing_personalization_design,
    ),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }))

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
      void,
      | t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema
      | undefined,
      void
    >,
    respond: (typeof postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate)["responder"],
    ctx: RouterContext,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_personalization_design>
    | Response<StatusCode, t_error>
  >

const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate =
  b((r) => ({
    with200: r.with200<t_issuing_personalization_design>(
      s_issuing_personalization_design,
    ),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }))

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
      void,
      | t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema
      | undefined,
      void
    >,
    respond: (typeof postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate)["responder"],
    ctx: RouterContext,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_personalization_design>
    | Response<StatusCode, t_error>
  >

const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject =
  b((r) => ({
    with200: r.with200<t_issuing_personalization_design>(
      s_issuing_personalization_design,
    ),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }))

export type PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject =
  (
    params: Params<
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
      void,
      t_PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema,
      void
    >,
    respond: (typeof postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject)["responder"],
    ctx: RouterContext,
  ) => Promise<
    | KoaRuntimeResponse<unknown>
    | Response<200, t_issuing_personalization_design>
    | Response<StatusCode, t_error>
  >

const postTestHelpersIssuingSettlements = b((r) => ({
  with200: r.with200<t_issuing_settlement>(s_issuing_settlement),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingSettlements = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingSettlementsBodySchema,
    void
  >,
  respond: (typeof postTestHelpersIssuingSettlements)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingSettlementsSettlementComplete = b((r) => ({
  with200: r.with200<t_issuing_settlement>(s_issuing_settlement),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingSettlementsSettlementComplete = (
  params: Params<
    t_PostTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
    void,
    t_PostTestHelpersIssuingSettlementsSettlementCompleteBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingSettlementsSettlementComplete)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_settlement>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingTransactionsCreateForceCapture = b((r) => ({
  with200: r.with200<t_issuing_transaction>(s_issuing_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingTransactionsCreateForceCapture = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingTransactionsCreateForceCaptureBodySchema,
    void
  >,
  respond: (typeof postTestHelpersIssuingTransactionsCreateForceCapture)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingTransactionsCreateUnlinkedRefund = b((r) => ({
  with200: r.with200<t_issuing_transaction>(s_issuing_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingTransactionsCreateUnlinkedRefund = (
  params: Params<
    void,
    void,
    t_PostTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema,
    void
  >,
  respond: (typeof postTestHelpersIssuingTransactionsCreateUnlinkedRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
>

const postTestHelpersIssuingTransactionsTransactionRefund = b((r) => ({
  with200: r.with200<t_issuing_transaction>(s_issuing_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersIssuingTransactionsTransactionRefund = (
  params: Params<
    t_PostTestHelpersIssuingTransactionsTransactionRefundParamSchema,
    void,
    t_PostTestHelpersIssuingTransactionsTransactionRefundBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersIssuingTransactionsTransactionRefund)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issuing_transaction>
  | Response<StatusCode, t_error>
>

const postTestHelpersRefundsRefundExpire = b((r) => ({
  with200: r.with200<t_refund>(s_refund),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersRefundsRefundExpire = (
  params: Params<
    t_PostTestHelpersRefundsRefundExpireParamSchema,
    void,
    t_PostTestHelpersRefundsRefundExpireBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersRefundsRefundExpire)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_refund>
  | Response<StatusCode, t_error>
>

const postTestHelpersTerminalReadersReaderPresentPaymentMethod = b((r) => ({
  with200: r.with200<t_terminal_reader>(s_terminal_reader),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTerminalReadersReaderPresentPaymentMethod = (
  params: Params<
    t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
    void,
    | t_PostTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTestHelpersTerminalReadersReaderPresentPaymentMethod)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_terminal_reader>
  | Response<StatusCode, t_error>
>

const getTestHelpersTestClocks = b((r) => ({
  with200: r.with200<{
    data: t_test_helpers_test_clock[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_test_helpers_test_clock),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/test_helpers/test_clocks")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTestHelpersTestClocks = (
  params: Params<
    void,
    t_GetTestHelpersTestClocksQuerySchema,
    t_GetTestHelpersTestClocksBodySchema | undefined,
    void
  >,
  respond: (typeof getTestHelpersTestClocks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_test_helpers_test_clock[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTestHelpersTestClocks = b((r) => ({
  with200: r.with200<t_test_helpers_test_clock>(s_test_helpers_test_clock),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTestClocks = (
  params: Params<void, void, t_PostTestHelpersTestClocksBodySchema, void>,
  respond: (typeof postTestHelpersTestClocks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_test_helpers_test_clock>
  | Response<StatusCode, t_error>
>

const deleteTestHelpersTestClocksTestClock = b((r) => ({
  with200: r.with200<t_deleted_test_helpers_test_clock>(
    s_deleted_test_helpers_test_clock,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteTestHelpersTestClocksTestClock = (
  params: Params<
    t_DeleteTestHelpersTestClocksTestClockParamSchema,
    void,
    t_DeleteTestHelpersTestClocksTestClockBodySchema | undefined,
    void
  >,
  respond: (typeof deleteTestHelpersTestClocksTestClock)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_test_helpers_test_clock>
  | Response<StatusCode, t_error>
>

const getTestHelpersTestClocksTestClock = b((r) => ({
  with200: r.with200<t_test_helpers_test_clock>(s_test_helpers_test_clock),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTestHelpersTestClocksTestClock = (
  params: Params<
    t_GetTestHelpersTestClocksTestClockParamSchema,
    t_GetTestHelpersTestClocksTestClockQuerySchema,
    t_GetTestHelpersTestClocksTestClockBodySchema | undefined,
    void
  >,
  respond: (typeof getTestHelpersTestClocksTestClock)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_test_helpers_test_clock>
  | Response<StatusCode, t_error>
>

const postTestHelpersTestClocksTestClockAdvance = b((r) => ({
  with200: r.with200<t_test_helpers_test_clock>(s_test_helpers_test_clock),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTestClocksTestClockAdvance = (
  params: Params<
    t_PostTestHelpersTestClocksTestClockAdvanceParamSchema,
    void,
    t_PostTestHelpersTestClocksTestClockAdvanceBodySchema,
    void
  >,
  respond: (typeof postTestHelpersTestClocksTestClockAdvance)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_test_helpers_test_clock>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryInboundTransfersIdFail = b((r) => ({
  with200: r.with200<t_treasury_inbound_transfer>(s_treasury_inbound_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryInboundTransfersIdFail = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdFailParamSchema,
    void,
    t_PostTestHelpersTreasuryInboundTransfersIdFailBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryInboundTransfersIdFail)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryInboundTransfersIdReturn = b((r) => ({
  with200: r.with200<t_treasury_inbound_transfer>(s_treasury_inbound_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryInboundTransfersIdReturn = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
    void,
    t_PostTestHelpersTreasuryInboundTransfersIdReturnBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryInboundTransfersIdReturn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryInboundTransfersIdSucceed = b((r) => ({
  with200: r.with200<t_treasury_inbound_transfer>(s_treasury_inbound_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryInboundTransfersIdSucceed = (
  params: Params<
    t_PostTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
    void,
    t_PostTestHelpersTreasuryInboundTransfersIdSucceedBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryInboundTransfersIdSucceed)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundPaymentsId = b((r) => ({
  with200: r.with200<t_treasury_outbound_payment>(s_treasury_outbound_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryOutboundPaymentsId = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdBodySchema,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundPaymentsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundPaymentsIdFail = b((r) => ({
  with200: r.with200<t_treasury_outbound_payment>(s_treasury_outbound_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryOutboundPaymentsIdFail = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdFailBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundPaymentsIdFail)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundPaymentsIdPost = b((r) => ({
  with200: r.with200<t_treasury_outbound_payment>(s_treasury_outbound_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryOutboundPaymentsIdPost = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdPostBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundPaymentsIdPost)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundPaymentsIdReturn = b((r) => ({
  with200: r.with200<t_treasury_outbound_payment>(s_treasury_outbound_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryOutboundPaymentsIdReturn = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundPaymentsIdReturn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundTransfersOutboundTransfer = b((r) => ({
  with200: r.with200<t_treasury_outbound_transfer>(
    s_treasury_outbound_transfer,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransfer = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
    void,
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundTransfersOutboundTransfer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundTransfersOutboundTransferFail = b((r) => ({
  with200: r.with200<t_treasury_outbound_transfer>(
    s_treasury_outbound_transfer,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferFail = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundTransfersOutboundTransferFail)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundTransfersOutboundTransferPost = b((r) => ({
  with200: r.with200<t_treasury_outbound_transfer>(
    s_treasury_outbound_transfer,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferPost = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundTransfersOutboundTransferPost)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn = b(
  (r) => ({
    with200: r.with200<t_treasury_outbound_transfer>(
      s_treasury_outbound_transfer,
    ),
    withDefault: r.withDefault<t_error>(s_error),
    withStatus: r.withStatus,
  }),
)

export type PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturn = (
  params: Params<
    t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
    void,
    | t_PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryReceivedCredits = b((r) => ({
  with200: r.with200<t_treasury_received_credit>(s_treasury_received_credit),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryReceivedCredits = (
  params: Params<
    void,
    void,
    t_PostTestHelpersTreasuryReceivedCreditsBodySchema,
    void
  >,
  respond: (typeof postTestHelpersTreasuryReceivedCredits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_credit>
  | Response<StatusCode, t_error>
>

const postTestHelpersTreasuryReceivedDebits = b((r) => ({
  with200: r.with200<t_treasury_received_debit>(s_treasury_received_debit),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTestHelpersTreasuryReceivedDebits = (
  params: Params<
    void,
    void,
    t_PostTestHelpersTreasuryReceivedDebitsBodySchema,
    void
  >,
  respond: (typeof postTestHelpersTreasuryReceivedDebits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_debit>
  | Response<StatusCode, t_error>
>

const postTokens = b((r) => ({
  with200: r.with200<t_token>(s_token),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTokens = (
  params: Params<void, void, t_PostTokensBodySchema | undefined, void>,
  respond: (typeof postTokens)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_token>
  | Response<StatusCode, t_error>
>

const getTokensToken = b((r) => ({
  with200: r.with200<t_token>(s_token),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTokensToken = (
  params: Params<
    t_GetTokensTokenParamSchema,
    t_GetTokensTokenQuerySchema,
    t_GetTokensTokenBodySchema | undefined,
    void
  >,
  respond: (typeof getTokensToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_token>
  | Response<StatusCode, t_error>
>

const getTopups = b((r) => ({
  with200: r.with200<{
    data: t_topup[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_topup)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/topups")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTopups = (
  params: Params<
    void,
    t_GetTopupsQuerySchema,
    t_GetTopupsBodySchema | undefined,
    void
  >,
  respond: (typeof getTopups)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_topup[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTopups = b((r) => ({
  with200: r.with200<t_topup>(s_topup),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTopups = (
  params: Params<void, void, t_PostTopupsBodySchema, void>,
  respond: (typeof postTopups)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
>

const getTopupsTopup = b((r) => ({
  with200: r.with200<t_topup>(s_topup),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTopupsTopup = (
  params: Params<
    t_GetTopupsTopupParamSchema,
    t_GetTopupsTopupQuerySchema,
    t_GetTopupsTopupBodySchema | undefined,
    void
  >,
  respond: (typeof getTopupsTopup)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
>

const postTopupsTopup = b((r) => ({
  with200: r.with200<t_topup>(s_topup),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTopupsTopup = (
  params: Params<
    t_PostTopupsTopupParamSchema,
    void,
    t_PostTopupsTopupBodySchema | undefined,
    void
  >,
  respond: (typeof postTopupsTopup)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
>

const postTopupsTopupCancel = b((r) => ({
  with200: r.with200<t_topup>(s_topup),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTopupsTopupCancel = (
  params: Params<
    t_PostTopupsTopupCancelParamSchema,
    void,
    t_PostTopupsTopupCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postTopupsTopupCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topup>
  | Response<StatusCode, t_error>
>

const getTransfers = b((r) => ({
  with200: r.with200<{
    data: t_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_transfer)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/transfers")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTransfers = (
  params: Params<
    void,
    t_GetTransfersQuerySchema,
    t_GetTransfersBodySchema | undefined,
    void
  >,
  respond: (typeof getTransfers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_transfer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTransfers = b((r) => ({
  with200: r.with200<t_transfer>(s_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTransfers = (
  params: Params<void, void, t_PostTransfersBodySchema, void>,
  respond: (typeof postTransfers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer>
  | Response<StatusCode, t_error>
>

const getTransfersIdReversals = b((r) => ({
  with200: r.with200<{
    data: t_transfer_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_transfer_reversal)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTransfersIdReversals = (
  params: Params<
    t_GetTransfersIdReversalsParamSchema,
    t_GetTransfersIdReversalsQuerySchema,
    t_GetTransfersIdReversalsBodySchema | undefined,
    void
  >,
  respond: (typeof getTransfersIdReversals)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_transfer_reversal[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTransfersIdReversals = b((r) => ({
  with200: r.with200<t_transfer_reversal>(s_transfer_reversal),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTransfersIdReversals = (
  params: Params<
    t_PostTransfersIdReversalsParamSchema,
    void,
    t_PostTransfersIdReversalsBodySchema | undefined,
    void
  >,
  respond: (typeof postTransfersIdReversals)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer_reversal>
  | Response<StatusCode, t_error>
>

const getTransfersTransfer = b((r) => ({
  with200: r.with200<t_transfer>(s_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTransfersTransfer = (
  params: Params<
    t_GetTransfersTransferParamSchema,
    t_GetTransfersTransferQuerySchema,
    t_GetTransfersTransferBodySchema | undefined,
    void
  >,
  respond: (typeof getTransfersTransfer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer>
  | Response<StatusCode, t_error>
>

const postTransfersTransfer = b((r) => ({
  with200: r.with200<t_transfer>(s_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTransfersTransfer = (
  params: Params<
    t_PostTransfersTransferParamSchema,
    void,
    t_PostTransfersTransferBodySchema | undefined,
    void
  >,
  respond: (typeof postTransfersTransfer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer>
  | Response<StatusCode, t_error>
>

const getTransfersTransferReversalsId = b((r) => ({
  with200: r.with200<t_transfer_reversal>(s_transfer_reversal),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTransfersTransferReversalsId = (
  params: Params<
    t_GetTransfersTransferReversalsIdParamSchema,
    t_GetTransfersTransferReversalsIdQuerySchema,
    t_GetTransfersTransferReversalsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTransfersTransferReversalsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer_reversal>
  | Response<StatusCode, t_error>
>

const postTransfersTransferReversalsId = b((r) => ({
  with200: r.with200<t_transfer_reversal>(s_transfer_reversal),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTransfersTransferReversalsId = (
  params: Params<
    t_PostTransfersTransferReversalsIdParamSchema,
    void,
    t_PostTransfersTransferReversalsIdBodySchema | undefined,
    void
  >,
  respond: (typeof postTransfersTransferReversalsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_transfer_reversal>
  | Response<StatusCode, t_error>
>

const getTreasuryCreditReversals = b((r) => ({
  with200: r.with200<{
    data: t_treasury_credit_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_credit_reversal)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryCreditReversals = (
  params: Params<
    void,
    t_GetTreasuryCreditReversalsQuerySchema,
    t_GetTreasuryCreditReversalsBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryCreditReversals)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_credit_reversal[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTreasuryCreditReversals = b((r) => ({
  with200: r.with200<t_treasury_credit_reversal>(s_treasury_credit_reversal),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryCreditReversals = (
  params: Params<void, void, t_PostTreasuryCreditReversalsBodySchema, void>,
  respond: (typeof postTreasuryCreditReversals)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_credit_reversal>
  | Response<StatusCode, t_error>
>

const getTreasuryCreditReversalsCreditReversal = b((r) => ({
  with200: r.with200<t_treasury_credit_reversal>(s_treasury_credit_reversal),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryCreditReversalsCreditReversal = (
  params: Params<
    t_GetTreasuryCreditReversalsCreditReversalParamSchema,
    t_GetTreasuryCreditReversalsCreditReversalQuerySchema,
    t_GetTreasuryCreditReversalsCreditReversalBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryCreditReversalsCreditReversal)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_credit_reversal>
  | Response<StatusCode, t_error>
>

const getTreasuryDebitReversals = b((r) => ({
  with200: r.with200<{
    data: t_treasury_debit_reversal[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_debit_reversal)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryDebitReversals = (
  params: Params<
    void,
    t_GetTreasuryDebitReversalsQuerySchema,
    t_GetTreasuryDebitReversalsBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryDebitReversals)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_debit_reversal[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTreasuryDebitReversals = b((r) => ({
  with200: r.with200<t_treasury_debit_reversal>(s_treasury_debit_reversal),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryDebitReversals = (
  params: Params<void, void, t_PostTreasuryDebitReversalsBodySchema, void>,
  respond: (typeof postTreasuryDebitReversals)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_debit_reversal>
  | Response<StatusCode, t_error>
>

const getTreasuryDebitReversalsDebitReversal = b((r) => ({
  with200: r.with200<t_treasury_debit_reversal>(s_treasury_debit_reversal),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryDebitReversalsDebitReversal = (
  params: Params<
    t_GetTreasuryDebitReversalsDebitReversalParamSchema,
    t_GetTreasuryDebitReversalsDebitReversalQuerySchema,
    t_GetTreasuryDebitReversalsDebitReversalBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryDebitReversalsDebitReversal)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_debit_reversal>
  | Response<StatusCode, t_error>
>

const getTreasuryFinancialAccounts = b((r) => ({
  with200: r.with200<{
    data: t_treasury_financial_account[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_treasury_financial_account),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/treasury/financial_accounts")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryFinancialAccounts = (
  params: Params<
    void,
    t_GetTreasuryFinancialAccountsQuerySchema,
    t_GetTreasuryFinancialAccountsBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryFinancialAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_financial_account[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTreasuryFinancialAccounts = b((r) => ({
  with200: r.with200<t_treasury_financial_account>(
    s_treasury_financial_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryFinancialAccounts = (
  params: Params<void, void, t_PostTreasuryFinancialAccountsBodySchema, void>,
  respond: (typeof postTreasuryFinancialAccounts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
>

const getTreasuryFinancialAccountsFinancialAccount = b((r) => ({
  with200: r.with200<t_treasury_financial_account>(
    s_treasury_financial_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryFinancialAccountsFinancialAccount = (
  params: Params<
    t_GetTreasuryFinancialAccountsFinancialAccountParamSchema,
    t_GetTreasuryFinancialAccountsFinancialAccountQuerySchema,
    t_GetTreasuryFinancialAccountsFinancialAccountBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryFinancialAccountsFinancialAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
>

const postTreasuryFinancialAccountsFinancialAccount = b((r) => ({
  with200: r.with200<t_treasury_financial_account>(
    s_treasury_financial_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryFinancialAccountsFinancialAccount = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountParamSchema,
    void,
    t_PostTreasuryFinancialAccountsFinancialAccountBodySchema | undefined,
    void
  >,
  respond: (typeof postTreasuryFinancialAccountsFinancialAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
>

const postTreasuryFinancialAccountsFinancialAccountClose = b((r) => ({
  with200: r.with200<t_treasury_financial_account>(
    s_treasury_financial_account,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryFinancialAccountsFinancialAccountClose = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
    void,
    t_PostTreasuryFinancialAccountsFinancialAccountCloseBodySchema | undefined,
    void
  >,
  respond: (typeof postTreasuryFinancialAccountsFinancialAccountClose)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account>
  | Response<StatusCode, t_error>
>

const getTreasuryFinancialAccountsFinancialAccountFeatures = b((r) => ({
  with200: r.with200<t_treasury_financial_account_features>(
    s_treasury_financial_account_features,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryFinancialAccountsFinancialAccountFeatures = (
  params: Params<
    t_GetTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
    t_GetTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
    | t_GetTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema
    | undefined,
    void
  >,
  respond: (typeof getTreasuryFinancialAccountsFinancialAccountFeatures)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account_features>
  | Response<StatusCode, t_error>
>

const postTreasuryFinancialAccountsFinancialAccountFeatures = b((r) => ({
  with200: r.with200<t_treasury_financial_account_features>(
    s_treasury_financial_account_features,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryFinancialAccountsFinancialAccountFeatures = (
  params: Params<
    t_PostTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
    void,
    | t_PostTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema
    | undefined,
    void
  >,
  respond: (typeof postTreasuryFinancialAccountsFinancialAccountFeatures)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_financial_account_features>
  | Response<StatusCode, t_error>
>

const getTreasuryInboundTransfers = b((r) => ({
  with200: r.with200<{
    data: t_treasury_inbound_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_inbound_transfer)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryInboundTransfers = (
  params: Params<
    void,
    t_GetTreasuryInboundTransfersQuerySchema,
    t_GetTreasuryInboundTransfersBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryInboundTransfers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_inbound_transfer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTreasuryInboundTransfers = b((r) => ({
  with200: r.with200<t_treasury_inbound_transfer>(s_treasury_inbound_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryInboundTransfers = (
  params: Params<void, void, t_PostTreasuryInboundTransfersBodySchema, void>,
  respond: (typeof postTreasuryInboundTransfers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
>

const getTreasuryInboundTransfersId = b((r) => ({
  with200: r.with200<t_treasury_inbound_transfer>(s_treasury_inbound_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryInboundTransfersId = (
  params: Params<
    t_GetTreasuryInboundTransfersIdParamSchema,
    t_GetTreasuryInboundTransfersIdQuerySchema,
    t_GetTreasuryInboundTransfersIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryInboundTransfersId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
>

const postTreasuryInboundTransfersInboundTransferCancel = b((r) => ({
  with200: r.with200<t_treasury_inbound_transfer>(s_treasury_inbound_transfer),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryInboundTransfersInboundTransferCancel = (
  params: Params<
    t_PostTreasuryInboundTransfersInboundTransferCancelParamSchema,
    void,
    t_PostTreasuryInboundTransfersInboundTransferCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postTreasuryInboundTransfersInboundTransferCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_inbound_transfer>
  | Response<StatusCode, t_error>
>

const getTreasuryOutboundPayments = b((r) => ({
  with200: r.with200<{
    data: t_treasury_outbound_payment[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_outbound_payment)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/treasury/outbound_payments")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryOutboundPayments = (
  params: Params<
    void,
    t_GetTreasuryOutboundPaymentsQuerySchema,
    t_GetTreasuryOutboundPaymentsBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryOutboundPayments)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_outbound_payment[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTreasuryOutboundPayments = b((r) => ({
  with200: r.with200<t_treasury_outbound_payment>(s_treasury_outbound_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryOutboundPayments = (
  params: Params<void, void, t_PostTreasuryOutboundPaymentsBodySchema, void>,
  respond: (typeof postTreasuryOutboundPayments)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
>

const getTreasuryOutboundPaymentsId = b((r) => ({
  with200: r.with200<t_treasury_outbound_payment>(s_treasury_outbound_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryOutboundPaymentsId = (
  params: Params<
    t_GetTreasuryOutboundPaymentsIdParamSchema,
    t_GetTreasuryOutboundPaymentsIdQuerySchema,
    t_GetTreasuryOutboundPaymentsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryOutboundPaymentsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
>

const postTreasuryOutboundPaymentsIdCancel = b((r) => ({
  with200: r.with200<t_treasury_outbound_payment>(s_treasury_outbound_payment),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryOutboundPaymentsIdCancel = (
  params: Params<
    t_PostTreasuryOutboundPaymentsIdCancelParamSchema,
    void,
    t_PostTreasuryOutboundPaymentsIdCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postTreasuryOutboundPaymentsIdCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_payment>
  | Response<StatusCode, t_error>
>

const getTreasuryOutboundTransfers = b((r) => ({
  with200: r.with200<{
    data: t_treasury_outbound_transfer[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_outbound_transfer)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryOutboundTransfers = (
  params: Params<
    void,
    t_GetTreasuryOutboundTransfersQuerySchema,
    t_GetTreasuryOutboundTransfersBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryOutboundTransfers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_outbound_transfer[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postTreasuryOutboundTransfers = b((r) => ({
  with200: r.with200<t_treasury_outbound_transfer>(
    s_treasury_outbound_transfer,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryOutboundTransfers = (
  params: Params<void, void, t_PostTreasuryOutboundTransfersBodySchema, void>,
  respond: (typeof postTreasuryOutboundTransfers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
>

const getTreasuryOutboundTransfersOutboundTransfer = b((r) => ({
  with200: r.with200<t_treasury_outbound_transfer>(
    s_treasury_outbound_transfer,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryOutboundTransfersOutboundTransfer = (
  params: Params<
    t_GetTreasuryOutboundTransfersOutboundTransferParamSchema,
    t_GetTreasuryOutboundTransfersOutboundTransferQuerySchema,
    t_GetTreasuryOutboundTransfersOutboundTransferBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryOutboundTransfersOutboundTransfer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
>

const postTreasuryOutboundTransfersOutboundTransferCancel = b((r) => ({
  with200: r.with200<t_treasury_outbound_transfer>(
    s_treasury_outbound_transfer,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostTreasuryOutboundTransfersOutboundTransferCancel = (
  params: Params<
    t_PostTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
    void,
    t_PostTreasuryOutboundTransfersOutboundTransferCancelBodySchema | undefined,
    void
  >,
  respond: (typeof postTreasuryOutboundTransfersOutboundTransferCancel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_outbound_transfer>
  | Response<StatusCode, t_error>
>

const getTreasuryReceivedCredits = b((r) => ({
  with200: r.with200<{
    data: t_treasury_received_credit[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_received_credit)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryReceivedCredits = (
  params: Params<
    void,
    t_GetTreasuryReceivedCreditsQuerySchema,
    t_GetTreasuryReceivedCreditsBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryReceivedCredits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_received_credit[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getTreasuryReceivedCreditsId = b((r) => ({
  with200: r.with200<t_treasury_received_credit>(s_treasury_received_credit),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryReceivedCreditsId = (
  params: Params<
    t_GetTreasuryReceivedCreditsIdParamSchema,
    t_GetTreasuryReceivedCreditsIdQuerySchema,
    t_GetTreasuryReceivedCreditsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryReceivedCreditsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_credit>
  | Response<StatusCode, t_error>
>

const getTreasuryReceivedDebits = b((r) => ({
  with200: r.with200<{
    data: t_treasury_received_debit[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_received_debit)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryReceivedDebits = (
  params: Params<
    void,
    t_GetTreasuryReceivedDebitsQuerySchema,
    t_GetTreasuryReceivedDebitsBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryReceivedDebits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_received_debit[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getTreasuryReceivedDebitsId = b((r) => ({
  with200: r.with200<t_treasury_received_debit>(s_treasury_received_debit),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryReceivedDebitsId = (
  params: Params<
    t_GetTreasuryReceivedDebitsIdParamSchema,
    t_GetTreasuryReceivedDebitsIdQuerySchema,
    t_GetTreasuryReceivedDebitsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryReceivedDebitsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_received_debit>
  | Response<StatusCode, t_error>
>

const getTreasuryTransactionEntries = b((r) => ({
  with200: r.with200<{
    data: t_treasury_transaction_entry[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_transaction_entry)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z
        .string()
        .max(5000)
        .regex(new RegExp("^/v1/treasury/transaction_entries")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryTransactionEntries = (
  params: Params<
    void,
    t_GetTreasuryTransactionEntriesQuerySchema,
    t_GetTreasuryTransactionEntriesBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryTransactionEntries)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_transaction_entry[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getTreasuryTransactionEntriesId = b((r) => ({
  with200: r.with200<t_treasury_transaction_entry>(
    s_treasury_transaction_entry,
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryTransactionEntriesId = (
  params: Params<
    t_GetTreasuryTransactionEntriesIdParamSchema,
    t_GetTreasuryTransactionEntriesIdQuerySchema,
    t_GetTreasuryTransactionEntriesIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryTransactionEntriesId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_transaction_entry>
  | Response<StatusCode, t_error>
>

const getTreasuryTransactions = b((r) => ({
  with200: r.with200<{
    data: t_treasury_transaction[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(z.lazy(() => s_treasury_transaction)),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryTransactions = (
  params: Params<
    void,
    t_GetTreasuryTransactionsQuerySchema,
    t_GetTreasuryTransactionsBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryTransactions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_treasury_transaction[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const getTreasuryTransactionsId = b((r) => ({
  with200: r.with200<t_treasury_transaction>(s_treasury_transaction),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetTreasuryTransactionsId = (
  params: Params<
    t_GetTreasuryTransactionsIdParamSchema,
    t_GetTreasuryTransactionsIdQuerySchema,
    t_GetTreasuryTransactionsIdBodySchema | undefined,
    void
  >,
  respond: (typeof getTreasuryTransactionsId)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_treasury_transaction>
  | Response<StatusCode, t_error>
>

const getWebhookEndpoints = b((r) => ({
  with200: r.with200<{
    data: t_webhook_endpoint[]
    has_more: boolean
    object: "list"
    url: string
  }>(
    z.object({
      data: z.array(s_webhook_endpoint),
      has_more: PermissiveBoolean,
      object: z.enum(["list"]),
      url: z.string().max(5000).regex(new RegExp("^/v1/webhook_endpoints")),
    }),
  ),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetWebhookEndpoints = (
  params: Params<
    void,
    t_GetWebhookEndpointsQuerySchema,
    t_GetWebhookEndpointsBodySchema | undefined,
    void
  >,
  respond: (typeof getWebhookEndpoints)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        data: t_webhook_endpoint[]
        has_more: boolean
        object: "list"
        url: string
      }
    >
  | Response<StatusCode, t_error>
>

const postWebhookEndpoints = b((r) => ({
  with200: r.with200<t_webhook_endpoint>(s_webhook_endpoint),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostWebhookEndpoints = (
  params: Params<void, void, t_PostWebhookEndpointsBodySchema, void>,
  respond: (typeof postWebhookEndpoints)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_webhook_endpoint>
  | Response<StatusCode, t_error>
>

const deleteWebhookEndpointsWebhookEndpoint = b((r) => ({
  with200: r.with200<t_deleted_webhook_endpoint>(s_deleted_webhook_endpoint),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type DeleteWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_DeleteWebhookEndpointsWebhookEndpointParamSchema,
    void,
    t_DeleteWebhookEndpointsWebhookEndpointBodySchema | undefined,
    void
  >,
  respond: (typeof deleteWebhookEndpointsWebhookEndpoint)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deleted_webhook_endpoint>
  | Response<StatusCode, t_error>
>

const getWebhookEndpointsWebhookEndpoint = b((r) => ({
  with200: r.with200<t_webhook_endpoint>(s_webhook_endpoint),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type GetWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_GetWebhookEndpointsWebhookEndpointParamSchema,
    t_GetWebhookEndpointsWebhookEndpointQuerySchema,
    t_GetWebhookEndpointsWebhookEndpointBodySchema | undefined,
    void
  >,
  respond: (typeof getWebhookEndpointsWebhookEndpoint)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_webhook_endpoint>
  | Response<StatusCode, t_error>
>

const postWebhookEndpointsWebhookEndpoint = b((r) => ({
  with200: r.with200<t_webhook_endpoint>(s_webhook_endpoint),
  withDefault: r.withDefault<t_error>(s_error),
  withStatus: r.withStatus,
}))

export type PostWebhookEndpointsWebhookEndpoint = (
  params: Params<
    t_PostWebhookEndpointsWebhookEndpointParamSchema,
    void,
    t_PostWebhookEndpointsWebhookEndpointBodySchema | undefined,
    void
  >,
  respond: (typeof postWebhookEndpointsWebhookEndpoint)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_webhook_endpoint>
  | Response<StatusCode, t_error>
>

export type Implementation = {
  getAccount: GetAccount
  postAccountLinks: PostAccountLinks
  postAccountSessions: PostAccountSessions
  getAccounts: GetAccounts
  postAccounts: PostAccounts
  deleteAccountsAccount: DeleteAccountsAccount
  getAccountsAccount: GetAccountsAccount
  postAccountsAccount: PostAccountsAccount
  postAccountsAccountBankAccounts: PostAccountsAccountBankAccounts
  deleteAccountsAccountBankAccountsId: DeleteAccountsAccountBankAccountsId
  getAccountsAccountBankAccountsId: GetAccountsAccountBankAccountsId
  postAccountsAccountBankAccountsId: PostAccountsAccountBankAccountsId
  getAccountsAccountCapabilities: GetAccountsAccountCapabilities
  getAccountsAccountCapabilitiesCapability: GetAccountsAccountCapabilitiesCapability
  postAccountsAccountCapabilitiesCapability: PostAccountsAccountCapabilitiesCapability
  getAccountsAccountExternalAccounts: GetAccountsAccountExternalAccounts
  postAccountsAccountExternalAccounts: PostAccountsAccountExternalAccounts
  deleteAccountsAccountExternalAccountsId: DeleteAccountsAccountExternalAccountsId
  getAccountsAccountExternalAccountsId: GetAccountsAccountExternalAccountsId
  postAccountsAccountExternalAccountsId: PostAccountsAccountExternalAccountsId
  postAccountsAccountLoginLinks: PostAccountsAccountLoginLinks
  getAccountsAccountPeople: GetAccountsAccountPeople
  postAccountsAccountPeople: PostAccountsAccountPeople
  deleteAccountsAccountPeoplePerson: DeleteAccountsAccountPeoplePerson
  getAccountsAccountPeoplePerson: GetAccountsAccountPeoplePerson
  postAccountsAccountPeoplePerson: PostAccountsAccountPeoplePerson
  getAccountsAccountPersons: GetAccountsAccountPersons
  postAccountsAccountPersons: PostAccountsAccountPersons
  deleteAccountsAccountPersonsPerson: DeleteAccountsAccountPersonsPerson
  getAccountsAccountPersonsPerson: GetAccountsAccountPersonsPerson
  postAccountsAccountPersonsPerson: PostAccountsAccountPersonsPerson
  postAccountsAccountReject: PostAccountsAccountReject
  getApplePayDomains: GetApplePayDomains
  postApplePayDomains: PostApplePayDomains
  deleteApplePayDomainsDomain: DeleteApplePayDomainsDomain
  getApplePayDomainsDomain: GetApplePayDomainsDomain
  getApplicationFees: GetApplicationFees
  getApplicationFeesFeeRefundsId: GetApplicationFeesFeeRefundsId
  postApplicationFeesFeeRefundsId: PostApplicationFeesFeeRefundsId
  getApplicationFeesId: GetApplicationFeesId
  postApplicationFeesIdRefund: PostApplicationFeesIdRefund
  getApplicationFeesIdRefunds: GetApplicationFeesIdRefunds
  postApplicationFeesIdRefunds: PostApplicationFeesIdRefunds
  getAppsSecrets: GetAppsSecrets
  postAppsSecrets: PostAppsSecrets
  postAppsSecretsDelete: PostAppsSecretsDelete
  getAppsSecretsFind: GetAppsSecretsFind
  getBalance: GetBalance
  getBalanceHistory: GetBalanceHistory
  getBalanceHistoryId: GetBalanceHistoryId
  getBalanceTransactions: GetBalanceTransactions
  getBalanceTransactionsId: GetBalanceTransactionsId
  getBillingAlerts: GetBillingAlerts
  postBillingAlerts: PostBillingAlerts
  getBillingAlertsId: GetBillingAlertsId
  postBillingAlertsIdActivate: PostBillingAlertsIdActivate
  postBillingAlertsIdArchive: PostBillingAlertsIdArchive
  postBillingAlertsIdDeactivate: PostBillingAlertsIdDeactivate
  getBillingCreditBalanceSummary: GetBillingCreditBalanceSummary
  getBillingCreditBalanceTransactions: GetBillingCreditBalanceTransactions
  getBillingCreditBalanceTransactionsId: GetBillingCreditBalanceTransactionsId
  getBillingCreditGrants: GetBillingCreditGrants
  postBillingCreditGrants: PostBillingCreditGrants
  getBillingCreditGrantsId: GetBillingCreditGrantsId
  postBillingCreditGrantsId: PostBillingCreditGrantsId
  postBillingCreditGrantsIdExpire: PostBillingCreditGrantsIdExpire
  postBillingCreditGrantsIdVoid: PostBillingCreditGrantsIdVoid
  postBillingMeterEventAdjustments: PostBillingMeterEventAdjustments
  postBillingMeterEvents: PostBillingMeterEvents
  getBillingMeters: GetBillingMeters
  postBillingMeters: PostBillingMeters
  getBillingMetersId: GetBillingMetersId
  postBillingMetersId: PostBillingMetersId
  postBillingMetersIdDeactivate: PostBillingMetersIdDeactivate
  getBillingMetersIdEventSummaries: GetBillingMetersIdEventSummaries
  postBillingMetersIdReactivate: PostBillingMetersIdReactivate
  getBillingPortalConfigurations: GetBillingPortalConfigurations
  postBillingPortalConfigurations: PostBillingPortalConfigurations
  getBillingPortalConfigurationsConfiguration: GetBillingPortalConfigurationsConfiguration
  postBillingPortalConfigurationsConfiguration: PostBillingPortalConfigurationsConfiguration
  postBillingPortalSessions: PostBillingPortalSessions
  getCharges: GetCharges
  postCharges: PostCharges
  getChargesSearch: GetChargesSearch
  getChargesCharge: GetChargesCharge
  postChargesCharge: PostChargesCharge
  postChargesChargeCapture: PostChargesChargeCapture
  getChargesChargeDispute: GetChargesChargeDispute
  postChargesChargeDispute: PostChargesChargeDispute
  postChargesChargeDisputeClose: PostChargesChargeDisputeClose
  postChargesChargeRefund: PostChargesChargeRefund
  getChargesChargeRefunds: GetChargesChargeRefunds
  postChargesChargeRefunds: PostChargesChargeRefunds
  getChargesChargeRefundsRefund: GetChargesChargeRefundsRefund
  postChargesChargeRefundsRefund: PostChargesChargeRefundsRefund
  getCheckoutSessions: GetCheckoutSessions
  postCheckoutSessions: PostCheckoutSessions
  getCheckoutSessionsSession: GetCheckoutSessionsSession
  postCheckoutSessionsSession: PostCheckoutSessionsSession
  postCheckoutSessionsSessionExpire: PostCheckoutSessionsSessionExpire
  getCheckoutSessionsSessionLineItems: GetCheckoutSessionsSessionLineItems
  getClimateOrders: GetClimateOrders
  postClimateOrders: PostClimateOrders
  getClimateOrdersOrder: GetClimateOrdersOrder
  postClimateOrdersOrder: PostClimateOrdersOrder
  postClimateOrdersOrderCancel: PostClimateOrdersOrderCancel
  getClimateProducts: GetClimateProducts
  getClimateProductsProduct: GetClimateProductsProduct
  getClimateSuppliers: GetClimateSuppliers
  getClimateSuppliersSupplier: GetClimateSuppliersSupplier
  getConfirmationTokensConfirmationToken: GetConfirmationTokensConfirmationToken
  getCountrySpecs: GetCountrySpecs
  getCountrySpecsCountry: GetCountrySpecsCountry
  getCoupons: GetCoupons
  postCoupons: PostCoupons
  deleteCouponsCoupon: DeleteCouponsCoupon
  getCouponsCoupon: GetCouponsCoupon
  postCouponsCoupon: PostCouponsCoupon
  getCreditNotes: GetCreditNotes
  postCreditNotes: PostCreditNotes
  getCreditNotesPreview: GetCreditNotesPreview
  getCreditNotesPreviewLines: GetCreditNotesPreviewLines
  getCreditNotesCreditNoteLines: GetCreditNotesCreditNoteLines
  getCreditNotesId: GetCreditNotesId
  postCreditNotesId: PostCreditNotesId
  postCreditNotesIdVoid: PostCreditNotesIdVoid
  postCustomerSessions: PostCustomerSessions
  getCustomers: GetCustomers
  postCustomers: PostCustomers
  getCustomersSearch: GetCustomersSearch
  deleteCustomersCustomer: DeleteCustomersCustomer
  getCustomersCustomer: GetCustomersCustomer
  postCustomersCustomer: PostCustomersCustomer
  getCustomersCustomerBalanceTransactions: GetCustomersCustomerBalanceTransactions
  postCustomersCustomerBalanceTransactions: PostCustomersCustomerBalanceTransactions
  getCustomersCustomerBalanceTransactionsTransaction: GetCustomersCustomerBalanceTransactionsTransaction
  postCustomersCustomerBalanceTransactionsTransaction: PostCustomersCustomerBalanceTransactionsTransaction
  getCustomersCustomerBankAccounts: GetCustomersCustomerBankAccounts
  postCustomersCustomerBankAccounts: PostCustomersCustomerBankAccounts
  deleteCustomersCustomerBankAccountsId: DeleteCustomersCustomerBankAccountsId
  getCustomersCustomerBankAccountsId: GetCustomersCustomerBankAccountsId
  postCustomersCustomerBankAccountsId: PostCustomersCustomerBankAccountsId
  postCustomersCustomerBankAccountsIdVerify: PostCustomersCustomerBankAccountsIdVerify
  getCustomersCustomerCards: GetCustomersCustomerCards
  postCustomersCustomerCards: PostCustomersCustomerCards
  deleteCustomersCustomerCardsId: DeleteCustomersCustomerCardsId
  getCustomersCustomerCardsId: GetCustomersCustomerCardsId
  postCustomersCustomerCardsId: PostCustomersCustomerCardsId
  getCustomersCustomerCashBalance: GetCustomersCustomerCashBalance
  postCustomersCustomerCashBalance: PostCustomersCustomerCashBalance
  getCustomersCustomerCashBalanceTransactions: GetCustomersCustomerCashBalanceTransactions
  getCustomersCustomerCashBalanceTransactionsTransaction: GetCustomersCustomerCashBalanceTransactionsTransaction
  deleteCustomersCustomerDiscount: DeleteCustomersCustomerDiscount
  getCustomersCustomerDiscount: GetCustomersCustomerDiscount
  postCustomersCustomerFundingInstructions: PostCustomersCustomerFundingInstructions
  getCustomersCustomerPaymentMethods: GetCustomersCustomerPaymentMethods
  getCustomersCustomerPaymentMethodsPaymentMethod: GetCustomersCustomerPaymentMethodsPaymentMethod
  getCustomersCustomerSources: GetCustomersCustomerSources
  postCustomersCustomerSources: PostCustomersCustomerSources
  deleteCustomersCustomerSourcesId: DeleteCustomersCustomerSourcesId
  getCustomersCustomerSourcesId: GetCustomersCustomerSourcesId
  postCustomersCustomerSourcesId: PostCustomersCustomerSourcesId
  postCustomersCustomerSourcesIdVerify: PostCustomersCustomerSourcesIdVerify
  getCustomersCustomerSubscriptions: GetCustomersCustomerSubscriptions
  postCustomersCustomerSubscriptions: PostCustomersCustomerSubscriptions
  deleteCustomersCustomerSubscriptionsSubscriptionExposedId: DeleteCustomersCustomerSubscriptionsSubscriptionExposedId
  getCustomersCustomerSubscriptionsSubscriptionExposedId: GetCustomersCustomerSubscriptionsSubscriptionExposedId
  postCustomersCustomerSubscriptionsSubscriptionExposedId: PostCustomersCustomerSubscriptionsSubscriptionExposedId
  deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount: DeleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount: GetCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount
  getCustomersCustomerTaxIds: GetCustomersCustomerTaxIds
  postCustomersCustomerTaxIds: PostCustomersCustomerTaxIds
  deleteCustomersCustomerTaxIdsId: DeleteCustomersCustomerTaxIdsId
  getCustomersCustomerTaxIdsId: GetCustomersCustomerTaxIdsId
  getDisputes: GetDisputes
  getDisputesDispute: GetDisputesDispute
  postDisputesDispute: PostDisputesDispute
  postDisputesDisputeClose: PostDisputesDisputeClose
  getEntitlementsActiveEntitlements: GetEntitlementsActiveEntitlements
  getEntitlementsActiveEntitlementsId: GetEntitlementsActiveEntitlementsId
  getEntitlementsFeatures: GetEntitlementsFeatures
  postEntitlementsFeatures: PostEntitlementsFeatures
  getEntitlementsFeaturesId: GetEntitlementsFeaturesId
  postEntitlementsFeaturesId: PostEntitlementsFeaturesId
  postEphemeralKeys: PostEphemeralKeys
  deleteEphemeralKeysKey: DeleteEphemeralKeysKey
  getEvents: GetEvents
  getEventsId: GetEventsId
  getExchangeRates: GetExchangeRates
  getExchangeRatesRateId: GetExchangeRatesRateId
  postExternalAccountsId: PostExternalAccountsId
  getFileLinks: GetFileLinks
  postFileLinks: PostFileLinks
  getFileLinksLink: GetFileLinksLink
  postFileLinksLink: PostFileLinksLink
  getFiles: GetFiles
  postFiles: PostFiles
  getFilesFile: GetFilesFile
  getFinancialConnectionsAccounts: GetFinancialConnectionsAccounts
  getFinancialConnectionsAccountsAccount: GetFinancialConnectionsAccountsAccount
  postFinancialConnectionsAccountsAccountDisconnect: PostFinancialConnectionsAccountsAccountDisconnect
  getFinancialConnectionsAccountsAccountOwners: GetFinancialConnectionsAccountsAccountOwners
  postFinancialConnectionsAccountsAccountRefresh: PostFinancialConnectionsAccountsAccountRefresh
  postFinancialConnectionsAccountsAccountSubscribe: PostFinancialConnectionsAccountsAccountSubscribe
  postFinancialConnectionsAccountsAccountUnsubscribe: PostFinancialConnectionsAccountsAccountUnsubscribe
  postFinancialConnectionsSessions: PostFinancialConnectionsSessions
  getFinancialConnectionsSessionsSession: GetFinancialConnectionsSessionsSession
  getFinancialConnectionsTransactions: GetFinancialConnectionsTransactions
  getFinancialConnectionsTransactionsTransaction: GetFinancialConnectionsTransactionsTransaction
  getForwardingRequests: GetForwardingRequests
  postForwardingRequests: PostForwardingRequests
  getForwardingRequestsId: GetForwardingRequestsId
  getIdentityVerificationReports: GetIdentityVerificationReports
  getIdentityVerificationReportsReport: GetIdentityVerificationReportsReport
  getIdentityVerificationSessions: GetIdentityVerificationSessions
  postIdentityVerificationSessions: PostIdentityVerificationSessions
  getIdentityVerificationSessionsSession: GetIdentityVerificationSessionsSession
  postIdentityVerificationSessionsSession: PostIdentityVerificationSessionsSession
  postIdentityVerificationSessionsSessionCancel: PostIdentityVerificationSessionsSessionCancel
  postIdentityVerificationSessionsSessionRedact: PostIdentityVerificationSessionsSessionRedact
  getInvoicePayments: GetInvoicePayments
  getInvoicePaymentsInvoicePayment: GetInvoicePaymentsInvoicePayment
  getInvoiceRenderingTemplates: GetInvoiceRenderingTemplates
  getInvoiceRenderingTemplatesTemplate: GetInvoiceRenderingTemplatesTemplate
  postInvoiceRenderingTemplatesTemplateArchive: PostInvoiceRenderingTemplatesTemplateArchive
  postInvoiceRenderingTemplatesTemplateUnarchive: PostInvoiceRenderingTemplatesTemplateUnarchive
  getInvoiceitems: GetInvoiceitems
  postInvoiceitems: PostInvoiceitems
  deleteInvoiceitemsInvoiceitem: DeleteInvoiceitemsInvoiceitem
  getInvoiceitemsInvoiceitem: GetInvoiceitemsInvoiceitem
  postInvoiceitemsInvoiceitem: PostInvoiceitemsInvoiceitem
  getInvoices: GetInvoices
  postInvoices: PostInvoices
  postInvoicesCreatePreview: PostInvoicesCreatePreview
  getInvoicesSearch: GetInvoicesSearch
  deleteInvoicesInvoice: DeleteInvoicesInvoice
  getInvoicesInvoice: GetInvoicesInvoice
  postInvoicesInvoice: PostInvoicesInvoice
  postInvoicesInvoiceAddLines: PostInvoicesInvoiceAddLines
  postInvoicesInvoiceFinalize: PostInvoicesInvoiceFinalize
  getInvoicesInvoiceLines: GetInvoicesInvoiceLines
  postInvoicesInvoiceLinesLineItemId: PostInvoicesInvoiceLinesLineItemId
  postInvoicesInvoiceMarkUncollectible: PostInvoicesInvoiceMarkUncollectible
  postInvoicesInvoicePay: PostInvoicesInvoicePay
  postInvoicesInvoiceRemoveLines: PostInvoicesInvoiceRemoveLines
  postInvoicesInvoiceSend: PostInvoicesInvoiceSend
  postInvoicesInvoiceUpdateLines: PostInvoicesInvoiceUpdateLines
  postInvoicesInvoiceVoid: PostInvoicesInvoiceVoid
  getIssuingAuthorizations: GetIssuingAuthorizations
  getIssuingAuthorizationsAuthorization: GetIssuingAuthorizationsAuthorization
  postIssuingAuthorizationsAuthorization: PostIssuingAuthorizationsAuthorization
  postIssuingAuthorizationsAuthorizationApprove: PostIssuingAuthorizationsAuthorizationApprove
  postIssuingAuthorizationsAuthorizationDecline: PostIssuingAuthorizationsAuthorizationDecline
  getIssuingCardholders: GetIssuingCardholders
  postIssuingCardholders: PostIssuingCardholders
  getIssuingCardholdersCardholder: GetIssuingCardholdersCardholder
  postIssuingCardholdersCardholder: PostIssuingCardholdersCardholder
  getIssuingCards: GetIssuingCards
  postIssuingCards: PostIssuingCards
  getIssuingCardsCard: GetIssuingCardsCard
  postIssuingCardsCard: PostIssuingCardsCard
  getIssuingDisputes: GetIssuingDisputes
  postIssuingDisputes: PostIssuingDisputes
  getIssuingDisputesDispute: GetIssuingDisputesDispute
  postIssuingDisputesDispute: PostIssuingDisputesDispute
  postIssuingDisputesDisputeSubmit: PostIssuingDisputesDisputeSubmit
  getIssuingPersonalizationDesigns: GetIssuingPersonalizationDesigns
  postIssuingPersonalizationDesigns: PostIssuingPersonalizationDesigns
  getIssuingPersonalizationDesignsPersonalizationDesign: GetIssuingPersonalizationDesignsPersonalizationDesign
  postIssuingPersonalizationDesignsPersonalizationDesign: PostIssuingPersonalizationDesignsPersonalizationDesign
  getIssuingPhysicalBundles: GetIssuingPhysicalBundles
  getIssuingPhysicalBundlesPhysicalBundle: GetIssuingPhysicalBundlesPhysicalBundle
  getIssuingSettlementsSettlement: GetIssuingSettlementsSettlement
  postIssuingSettlementsSettlement: PostIssuingSettlementsSettlement
  getIssuingTokens: GetIssuingTokens
  getIssuingTokensToken: GetIssuingTokensToken
  postIssuingTokensToken: PostIssuingTokensToken
  getIssuingTransactions: GetIssuingTransactions
  getIssuingTransactionsTransaction: GetIssuingTransactionsTransaction
  postIssuingTransactionsTransaction: PostIssuingTransactionsTransaction
  postLinkAccountSessions: PostLinkAccountSessions
  getLinkAccountSessionsSession: GetLinkAccountSessionsSession
  getLinkedAccounts: GetLinkedAccounts
  getLinkedAccountsAccount: GetLinkedAccountsAccount
  postLinkedAccountsAccountDisconnect: PostLinkedAccountsAccountDisconnect
  getLinkedAccountsAccountOwners: GetLinkedAccountsAccountOwners
  postLinkedAccountsAccountRefresh: PostLinkedAccountsAccountRefresh
  getMandatesMandate: GetMandatesMandate
  getPaymentIntents: GetPaymentIntents
  postPaymentIntents: PostPaymentIntents
  getPaymentIntentsSearch: GetPaymentIntentsSearch
  getPaymentIntentsIntent: GetPaymentIntentsIntent
  postPaymentIntentsIntent: PostPaymentIntentsIntent
  postPaymentIntentsIntentApplyCustomerBalance: PostPaymentIntentsIntentApplyCustomerBalance
  postPaymentIntentsIntentCancel: PostPaymentIntentsIntentCancel
  postPaymentIntentsIntentCapture: PostPaymentIntentsIntentCapture
  postPaymentIntentsIntentConfirm: PostPaymentIntentsIntentConfirm
  postPaymentIntentsIntentIncrementAuthorization: PostPaymentIntentsIntentIncrementAuthorization
  postPaymentIntentsIntentVerifyMicrodeposits: PostPaymentIntentsIntentVerifyMicrodeposits
  getPaymentLinks: GetPaymentLinks
  postPaymentLinks: PostPaymentLinks
  getPaymentLinksPaymentLink: GetPaymentLinksPaymentLink
  postPaymentLinksPaymentLink: PostPaymentLinksPaymentLink
  getPaymentLinksPaymentLinkLineItems: GetPaymentLinksPaymentLinkLineItems
  getPaymentMethodConfigurations: GetPaymentMethodConfigurations
  postPaymentMethodConfigurations: PostPaymentMethodConfigurations
  getPaymentMethodConfigurationsConfiguration: GetPaymentMethodConfigurationsConfiguration
  postPaymentMethodConfigurationsConfiguration: PostPaymentMethodConfigurationsConfiguration
  getPaymentMethodDomains: GetPaymentMethodDomains
  postPaymentMethodDomains: PostPaymentMethodDomains
  getPaymentMethodDomainsPaymentMethodDomain: GetPaymentMethodDomainsPaymentMethodDomain
  postPaymentMethodDomainsPaymentMethodDomain: PostPaymentMethodDomainsPaymentMethodDomain
  postPaymentMethodDomainsPaymentMethodDomainValidate: PostPaymentMethodDomainsPaymentMethodDomainValidate
  getPaymentMethods: GetPaymentMethods
  postPaymentMethods: PostPaymentMethods
  getPaymentMethodsPaymentMethod: GetPaymentMethodsPaymentMethod
  postPaymentMethodsPaymentMethod: PostPaymentMethodsPaymentMethod
  postPaymentMethodsPaymentMethodAttach: PostPaymentMethodsPaymentMethodAttach
  postPaymentMethodsPaymentMethodDetach: PostPaymentMethodsPaymentMethodDetach
  getPayouts: GetPayouts
  postPayouts: PostPayouts
  getPayoutsPayout: GetPayoutsPayout
  postPayoutsPayout: PostPayoutsPayout
  postPayoutsPayoutCancel: PostPayoutsPayoutCancel
  postPayoutsPayoutReverse: PostPayoutsPayoutReverse
  getPlans: GetPlans
  postPlans: PostPlans
  deletePlansPlan: DeletePlansPlan
  getPlansPlan: GetPlansPlan
  postPlansPlan: PostPlansPlan
  getPrices: GetPrices
  postPrices: PostPrices
  getPricesSearch: GetPricesSearch
  getPricesPrice: GetPricesPrice
  postPricesPrice: PostPricesPrice
  getProducts: GetProducts
  postProducts: PostProducts
  getProductsSearch: GetProductsSearch
  deleteProductsId: DeleteProductsId
  getProductsId: GetProductsId
  postProductsId: PostProductsId
  getProductsProductFeatures: GetProductsProductFeatures
  postProductsProductFeatures: PostProductsProductFeatures
  deleteProductsProductFeaturesId: DeleteProductsProductFeaturesId
  getProductsProductFeaturesId: GetProductsProductFeaturesId
  getPromotionCodes: GetPromotionCodes
  postPromotionCodes: PostPromotionCodes
  getPromotionCodesPromotionCode: GetPromotionCodesPromotionCode
  postPromotionCodesPromotionCode: PostPromotionCodesPromotionCode
  getQuotes: GetQuotes
  postQuotes: PostQuotes
  getQuotesQuote: GetQuotesQuote
  postQuotesQuote: PostQuotesQuote
  postQuotesQuoteAccept: PostQuotesQuoteAccept
  postQuotesQuoteCancel: PostQuotesQuoteCancel
  getQuotesQuoteComputedUpfrontLineItems: GetQuotesQuoteComputedUpfrontLineItems
  postQuotesQuoteFinalize: PostQuotesQuoteFinalize
  getQuotesQuoteLineItems: GetQuotesQuoteLineItems
  getQuotesQuotePdf: GetQuotesQuotePdf
  getRadarEarlyFraudWarnings: GetRadarEarlyFraudWarnings
  getRadarEarlyFraudWarningsEarlyFraudWarning: GetRadarEarlyFraudWarningsEarlyFraudWarning
  getRadarValueListItems: GetRadarValueListItems
  postRadarValueListItems: PostRadarValueListItems
  deleteRadarValueListItemsItem: DeleteRadarValueListItemsItem
  getRadarValueListItemsItem: GetRadarValueListItemsItem
  getRadarValueLists: GetRadarValueLists
  postRadarValueLists: PostRadarValueLists
  deleteRadarValueListsValueList: DeleteRadarValueListsValueList
  getRadarValueListsValueList: GetRadarValueListsValueList
  postRadarValueListsValueList: PostRadarValueListsValueList
  getRefunds: GetRefunds
  postRefunds: PostRefunds
  getRefundsRefund: GetRefundsRefund
  postRefundsRefund: PostRefundsRefund
  postRefundsRefundCancel: PostRefundsRefundCancel
  getReportingReportRuns: GetReportingReportRuns
  postReportingReportRuns: PostReportingReportRuns
  getReportingReportRunsReportRun: GetReportingReportRunsReportRun
  getReportingReportTypes: GetReportingReportTypes
  getReportingReportTypesReportType: GetReportingReportTypesReportType
  getReviews: GetReviews
  getReviewsReview: GetReviewsReview
  postReviewsReviewApprove: PostReviewsReviewApprove
  getSetupAttempts: GetSetupAttempts
  getSetupIntents: GetSetupIntents
  postSetupIntents: PostSetupIntents
  getSetupIntentsIntent: GetSetupIntentsIntent
  postSetupIntentsIntent: PostSetupIntentsIntent
  postSetupIntentsIntentCancel: PostSetupIntentsIntentCancel
  postSetupIntentsIntentConfirm: PostSetupIntentsIntentConfirm
  postSetupIntentsIntentVerifyMicrodeposits: PostSetupIntentsIntentVerifyMicrodeposits
  getShippingRates: GetShippingRates
  postShippingRates: PostShippingRates
  getShippingRatesShippingRateToken: GetShippingRatesShippingRateToken
  postShippingRatesShippingRateToken: PostShippingRatesShippingRateToken
  postSigmaSavedQueriesId: PostSigmaSavedQueriesId
  getSigmaScheduledQueryRuns: GetSigmaScheduledQueryRuns
  getSigmaScheduledQueryRunsScheduledQueryRun: GetSigmaScheduledQueryRunsScheduledQueryRun
  postSources: PostSources
  getSourcesSource: GetSourcesSource
  postSourcesSource: PostSourcesSource
  getSourcesSourceMandateNotificationsMandateNotification: GetSourcesSourceMandateNotificationsMandateNotification
  getSourcesSourceSourceTransactions: GetSourcesSourceSourceTransactions
  getSourcesSourceSourceTransactionsSourceTransaction: GetSourcesSourceSourceTransactionsSourceTransaction
  postSourcesSourceVerify: PostSourcesSourceVerify
  getSubscriptionItems: GetSubscriptionItems
  postSubscriptionItems: PostSubscriptionItems
  deleteSubscriptionItemsItem: DeleteSubscriptionItemsItem
  getSubscriptionItemsItem: GetSubscriptionItemsItem
  postSubscriptionItemsItem: PostSubscriptionItemsItem
  getSubscriptionSchedules: GetSubscriptionSchedules
  postSubscriptionSchedules: PostSubscriptionSchedules
  getSubscriptionSchedulesSchedule: GetSubscriptionSchedulesSchedule
  postSubscriptionSchedulesSchedule: PostSubscriptionSchedulesSchedule
  postSubscriptionSchedulesScheduleCancel: PostSubscriptionSchedulesScheduleCancel
  postSubscriptionSchedulesScheduleRelease: PostSubscriptionSchedulesScheduleRelease
  getSubscriptions: GetSubscriptions
  postSubscriptions: PostSubscriptions
  getSubscriptionsSearch: GetSubscriptionsSearch
  deleteSubscriptionsSubscriptionExposedId: DeleteSubscriptionsSubscriptionExposedId
  getSubscriptionsSubscriptionExposedId: GetSubscriptionsSubscriptionExposedId
  postSubscriptionsSubscriptionExposedId: PostSubscriptionsSubscriptionExposedId
  deleteSubscriptionsSubscriptionExposedIdDiscount: DeleteSubscriptionsSubscriptionExposedIdDiscount
  postSubscriptionsSubscriptionResume: PostSubscriptionsSubscriptionResume
  postTaxCalculations: PostTaxCalculations
  getTaxCalculationsCalculation: GetTaxCalculationsCalculation
  getTaxCalculationsCalculationLineItems: GetTaxCalculationsCalculationLineItems
  getTaxRegistrations: GetTaxRegistrations
  postTaxRegistrations: PostTaxRegistrations
  getTaxRegistrationsId: GetTaxRegistrationsId
  postTaxRegistrationsId: PostTaxRegistrationsId
  getTaxSettings: GetTaxSettings
  postTaxSettings: PostTaxSettings
  postTaxTransactionsCreateFromCalculation: PostTaxTransactionsCreateFromCalculation
  postTaxTransactionsCreateReversal: PostTaxTransactionsCreateReversal
  getTaxTransactionsTransaction: GetTaxTransactionsTransaction
  getTaxTransactionsTransactionLineItems: GetTaxTransactionsTransactionLineItems
  getTaxCodes: GetTaxCodes
  getTaxCodesId: GetTaxCodesId
  getTaxIds: GetTaxIds
  postTaxIds: PostTaxIds
  deleteTaxIdsId: DeleteTaxIdsId
  getTaxIdsId: GetTaxIdsId
  getTaxRates: GetTaxRates
  postTaxRates: PostTaxRates
  getTaxRatesTaxRate: GetTaxRatesTaxRate
  postTaxRatesTaxRate: PostTaxRatesTaxRate
  getTerminalConfigurations: GetTerminalConfigurations
  postTerminalConfigurations: PostTerminalConfigurations
  deleteTerminalConfigurationsConfiguration: DeleteTerminalConfigurationsConfiguration
  getTerminalConfigurationsConfiguration: GetTerminalConfigurationsConfiguration
  postTerminalConfigurationsConfiguration: PostTerminalConfigurationsConfiguration
  postTerminalConnectionTokens: PostTerminalConnectionTokens
  getTerminalLocations: GetTerminalLocations
  postTerminalLocations: PostTerminalLocations
  deleteTerminalLocationsLocation: DeleteTerminalLocationsLocation
  getTerminalLocationsLocation: GetTerminalLocationsLocation
  postTerminalLocationsLocation: PostTerminalLocationsLocation
  getTerminalReaders: GetTerminalReaders
  postTerminalReaders: PostTerminalReaders
  deleteTerminalReadersReader: DeleteTerminalReadersReader
  getTerminalReadersReader: GetTerminalReadersReader
  postTerminalReadersReader: PostTerminalReadersReader
  postTerminalReadersReaderCancelAction: PostTerminalReadersReaderCancelAction
  postTerminalReadersReaderProcessPaymentIntent: PostTerminalReadersReaderProcessPaymentIntent
  postTerminalReadersReaderProcessSetupIntent: PostTerminalReadersReaderProcessSetupIntent
  postTerminalReadersReaderRefundPayment: PostTerminalReadersReaderRefundPayment
  postTerminalReadersReaderSetReaderDisplay: PostTerminalReadersReaderSetReaderDisplay
  postTestHelpersConfirmationTokens: PostTestHelpersConfirmationTokens
  postTestHelpersCustomersCustomerFundCashBalance: PostTestHelpersCustomersCustomerFundCashBalance
  postTestHelpersIssuingAuthorizations: PostTestHelpersIssuingAuthorizations
  postTestHelpersIssuingAuthorizationsAuthorizationCapture: PostTestHelpersIssuingAuthorizationsAuthorizationCapture
  postTestHelpersIssuingAuthorizationsAuthorizationExpire: PostTestHelpersIssuingAuthorizationsAuthorizationExpire
  postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount: PostTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount
  postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond: PostTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond
  postTestHelpersIssuingAuthorizationsAuthorizationIncrement: PostTestHelpersIssuingAuthorizationsAuthorizationIncrement
  postTestHelpersIssuingAuthorizationsAuthorizationReverse: PostTestHelpersIssuingAuthorizationsAuthorizationReverse
  postTestHelpersIssuingCardsCardShippingDeliver: PostTestHelpersIssuingCardsCardShippingDeliver
  postTestHelpersIssuingCardsCardShippingFail: PostTestHelpersIssuingCardsCardShippingFail
  postTestHelpersIssuingCardsCardShippingReturn: PostTestHelpersIssuingCardsCardShippingReturn
  postTestHelpersIssuingCardsCardShippingShip: PostTestHelpersIssuingCardsCardShippingShip
  postTestHelpersIssuingCardsCardShippingSubmit: PostTestHelpersIssuingCardsCardShippingSubmit
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate
  postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject: PostTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject
  postTestHelpersIssuingSettlements: PostTestHelpersIssuingSettlements
  postTestHelpersIssuingSettlementsSettlementComplete: PostTestHelpersIssuingSettlementsSettlementComplete
  postTestHelpersIssuingTransactionsCreateForceCapture: PostTestHelpersIssuingTransactionsCreateForceCapture
  postTestHelpersIssuingTransactionsCreateUnlinkedRefund: PostTestHelpersIssuingTransactionsCreateUnlinkedRefund
  postTestHelpersIssuingTransactionsTransactionRefund: PostTestHelpersIssuingTransactionsTransactionRefund
  postTestHelpersRefundsRefundExpire: PostTestHelpersRefundsRefundExpire
  postTestHelpersTerminalReadersReaderPresentPaymentMethod: PostTestHelpersTerminalReadersReaderPresentPaymentMethod
  getTestHelpersTestClocks: GetTestHelpersTestClocks
  postTestHelpersTestClocks: PostTestHelpersTestClocks
  deleteTestHelpersTestClocksTestClock: DeleteTestHelpersTestClocksTestClock
  getTestHelpersTestClocksTestClock: GetTestHelpersTestClocksTestClock
  postTestHelpersTestClocksTestClockAdvance: PostTestHelpersTestClocksTestClockAdvance
  postTestHelpersTreasuryInboundTransfersIdFail: PostTestHelpersTreasuryInboundTransfersIdFail
  postTestHelpersTreasuryInboundTransfersIdReturn: PostTestHelpersTreasuryInboundTransfersIdReturn
  postTestHelpersTreasuryInboundTransfersIdSucceed: PostTestHelpersTreasuryInboundTransfersIdSucceed
  postTestHelpersTreasuryOutboundPaymentsId: PostTestHelpersTreasuryOutboundPaymentsId
  postTestHelpersTreasuryOutboundPaymentsIdFail: PostTestHelpersTreasuryOutboundPaymentsIdFail
  postTestHelpersTreasuryOutboundPaymentsIdPost: PostTestHelpersTreasuryOutboundPaymentsIdPost
  postTestHelpersTreasuryOutboundPaymentsIdReturn: PostTestHelpersTreasuryOutboundPaymentsIdReturn
  postTestHelpersTreasuryOutboundTransfersOutboundTransfer: PostTestHelpersTreasuryOutboundTransfersOutboundTransfer
  postTestHelpersTreasuryOutboundTransfersOutboundTransferFail: PostTestHelpersTreasuryOutboundTransfersOutboundTransferFail
  postTestHelpersTreasuryOutboundTransfersOutboundTransferPost: PostTestHelpersTreasuryOutboundTransfersOutboundTransferPost
  postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn: PostTestHelpersTreasuryOutboundTransfersOutboundTransferReturn
  postTestHelpersTreasuryReceivedCredits: PostTestHelpersTreasuryReceivedCredits
  postTestHelpersTreasuryReceivedDebits: PostTestHelpersTreasuryReceivedDebits
  postTokens: PostTokens
  getTokensToken: GetTokensToken
  getTopups: GetTopups
  postTopups: PostTopups
  getTopupsTopup: GetTopupsTopup
  postTopupsTopup: PostTopupsTopup
  postTopupsTopupCancel: PostTopupsTopupCancel
  getTransfers: GetTransfers
  postTransfers: PostTransfers
  getTransfersIdReversals: GetTransfersIdReversals
  postTransfersIdReversals: PostTransfersIdReversals
  getTransfersTransfer: GetTransfersTransfer
  postTransfersTransfer: PostTransfersTransfer
  getTransfersTransferReversalsId: GetTransfersTransferReversalsId
  postTransfersTransferReversalsId: PostTransfersTransferReversalsId
  getTreasuryCreditReversals: GetTreasuryCreditReversals
  postTreasuryCreditReversals: PostTreasuryCreditReversals
  getTreasuryCreditReversalsCreditReversal: GetTreasuryCreditReversalsCreditReversal
  getTreasuryDebitReversals: GetTreasuryDebitReversals
  postTreasuryDebitReversals: PostTreasuryDebitReversals
  getTreasuryDebitReversalsDebitReversal: GetTreasuryDebitReversalsDebitReversal
  getTreasuryFinancialAccounts: GetTreasuryFinancialAccounts
  postTreasuryFinancialAccounts: PostTreasuryFinancialAccounts
  getTreasuryFinancialAccountsFinancialAccount: GetTreasuryFinancialAccountsFinancialAccount
  postTreasuryFinancialAccountsFinancialAccount: PostTreasuryFinancialAccountsFinancialAccount
  postTreasuryFinancialAccountsFinancialAccountClose: PostTreasuryFinancialAccountsFinancialAccountClose
  getTreasuryFinancialAccountsFinancialAccountFeatures: GetTreasuryFinancialAccountsFinancialAccountFeatures
  postTreasuryFinancialAccountsFinancialAccountFeatures: PostTreasuryFinancialAccountsFinancialAccountFeatures
  getTreasuryInboundTransfers: GetTreasuryInboundTransfers
  postTreasuryInboundTransfers: PostTreasuryInboundTransfers
  getTreasuryInboundTransfersId: GetTreasuryInboundTransfersId
  postTreasuryInboundTransfersInboundTransferCancel: PostTreasuryInboundTransfersInboundTransferCancel
  getTreasuryOutboundPayments: GetTreasuryOutboundPayments
  postTreasuryOutboundPayments: PostTreasuryOutboundPayments
  getTreasuryOutboundPaymentsId: GetTreasuryOutboundPaymentsId
  postTreasuryOutboundPaymentsIdCancel: PostTreasuryOutboundPaymentsIdCancel
  getTreasuryOutboundTransfers: GetTreasuryOutboundTransfers
  postTreasuryOutboundTransfers: PostTreasuryOutboundTransfers
  getTreasuryOutboundTransfersOutboundTransfer: GetTreasuryOutboundTransfersOutboundTransfer
  postTreasuryOutboundTransfersOutboundTransferCancel: PostTreasuryOutboundTransfersOutboundTransferCancel
  getTreasuryReceivedCredits: GetTreasuryReceivedCredits
  getTreasuryReceivedCreditsId: GetTreasuryReceivedCreditsId
  getTreasuryReceivedDebits: GetTreasuryReceivedDebits
  getTreasuryReceivedDebitsId: GetTreasuryReceivedDebitsId
  getTreasuryTransactionEntries: GetTreasuryTransactionEntries
  getTreasuryTransactionEntriesId: GetTreasuryTransactionEntriesId
  getTreasuryTransactions: GetTreasuryTransactions
  getTreasuryTransactionsId: GetTreasuryTransactionsId
  getWebhookEndpoints: GetWebhookEndpoints
  postWebhookEndpoints: PostWebhookEndpoints
  deleteWebhookEndpointsWebhookEndpoint: DeleteWebhookEndpointsWebhookEndpoint
  getWebhookEndpointsWebhookEndpoint: GetWebhookEndpointsWebhookEndpoint
  postWebhookEndpointsWebhookEndpoint: PostWebhookEndpointsWebhookEndpoint
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const getAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountBodySchema = z.object({}).optional()

  router.get("getAccount", "/v1/account", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getAccountQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getAccountBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getAccount(input, getAccount.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getAccount.validator(status, body)
    ctx.status = status
    return next()
  })

  const postAccountLinksBodySchema = z.object({
    account: z.string().max(5000),
    collect: z.enum(["currently_due", "eventually_due"]).optional(),
    collection_options: z
      .object({
        fields: z.enum(["currently_due", "eventually_due"]).optional(),
        future_requirements: z.enum(["include", "omit"]).optional(),
      })
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    refresh_url: z.string().optional(),
    return_url: z.string().optional(),
    type: z.enum(["account_onboarding", "account_update"]),
  })

  router.post("postAccountLinks", "/v1/account_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postAccountLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postAccountLinks(input, postAccountLinks.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postAccountLinks.validator(status, body)
    ctx.status = status
    return next()
  })

  const postAccountSessionsBodySchema = z.object({
    account: z.string(),
    components: z.object({
      account_management: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              disable_stripe_user_authentication: PermissiveBoolean.optional(),
              external_account_collection: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      account_onboarding: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              disable_stripe_user_authentication: PermissiveBoolean.optional(),
              external_account_collection: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      balances: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              disable_stripe_user_authentication: PermissiveBoolean.optional(),
              edit_payout_schedule: PermissiveBoolean.optional(),
              external_account_collection: PermissiveBoolean.optional(),
              instant_payouts: PermissiveBoolean.optional(),
              standard_payouts: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      documents: z
        .object({
          enabled: PermissiveBoolean,
          features: z.object({}).optional(),
        })
        .optional(),
      financial_account: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              disable_stripe_user_authentication: PermissiveBoolean.optional(),
              external_account_collection: PermissiveBoolean.optional(),
              send_money: PermissiveBoolean.optional(),
              transfer_balance: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      financial_account_transactions: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              card_spend_dispute_management: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      issuing_card: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              card_management: PermissiveBoolean.optional(),
              card_spend_dispute_management: PermissiveBoolean.optional(),
              cardholder_management: PermissiveBoolean.optional(),
              spend_control_management: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      issuing_cards_list: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              card_management: PermissiveBoolean.optional(),
              card_spend_dispute_management: PermissiveBoolean.optional(),
              cardholder_management: PermissiveBoolean.optional(),
              disable_stripe_user_authentication: PermissiveBoolean.optional(),
              spend_control_management: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      notification_banner: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              disable_stripe_user_authentication: PermissiveBoolean.optional(),
              external_account_collection: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      payment_details: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              capture_payments: PermissiveBoolean.optional(),
              destination_on_behalf_of_charge_management:
                PermissiveBoolean.optional(),
              dispute_management: PermissiveBoolean.optional(),
              refund_management: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      payments: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              capture_payments: PermissiveBoolean.optional(),
              destination_on_behalf_of_charge_management:
                PermissiveBoolean.optional(),
              dispute_management: PermissiveBoolean.optional(),
              refund_management: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      payouts: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              disable_stripe_user_authentication: PermissiveBoolean.optional(),
              edit_payout_schedule: PermissiveBoolean.optional(),
              external_account_collection: PermissiveBoolean.optional(),
              instant_payouts: PermissiveBoolean.optional(),
              standard_payouts: PermissiveBoolean.optional(),
            })
            .optional(),
        })
        .optional(),
      payouts_list: z
        .object({
          enabled: PermissiveBoolean,
          features: z.object({}).optional(),
        })
        .optional(),
      tax_registrations: z
        .object({
          enabled: PermissiveBoolean,
          features: z.object({}).optional(),
        })
        .optional(),
      tax_settings: z
        .object({
          enabled: PermissiveBoolean,
          features: z.object({}).optional(),
        })
        .optional(),
    }),
    expand: z.array(z.string().max(5000)).optional(),
  })

  router.post(
    "postAccountSessions",
    "/v1/account_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postAccountSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountSessions(input, postAccountSessions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  const getAccountsBodySchema = z.object({}).optional()

  router.get("getAccounts", "/v1/accounts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getAccountsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getAccountsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getAccounts(input, getAccounts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getAccounts.validator(status, body)
    ctx.status = status
    return next()
  })

  const postAccountsBodySchema = z
    .object({
      account_token: z.string().max(5000).optional(),
      bank_account: z
        .union([
          z.object({
            account_holder_name: z.string().max(5000).optional(),
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000),
            account_type: z
              .enum(["checking", "futsu", "savings", "toza"])
              .optional(),
            country: z.string().max(5000),
            currency: z.string().optional(),
            documents: z
              .object({
                bank_account_ownership_verification: z
                  .object({ files: z.array(z.string().max(500)).optional() })
                  .optional(),
              })
              .optional(),
            object: z.enum(["bank_account"]).optional(),
            routing_number: z.string().max(5000).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      business_profile: z
        .object({
          annual_revenue: z
            .object({
              amount: z.coerce.number(),
              currency: z.string(),
              fiscal_year_end: z.string().max(5000),
            })
            .optional(),
          estimated_worker_count: z.coerce.number().optional(),
          mcc: z.string().max(4).optional(),
          monthly_estimated_revenue: z
            .object({ amount: z.coerce.number(), currency: z.string() })
            .optional(),
          name: z.string().max(5000).optional(),
          product_description: z.string().max(40000).optional(),
          support_address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          support_email: z.string().optional(),
          support_phone: z.string().max(5000).optional(),
          support_url: z.union([z.string(), z.enum([""])]).optional(),
          url: z.string().optional(),
        })
        .optional(),
      business_type: z
        .enum(["company", "government_entity", "individual", "non_profit"])
        .optional(),
      capabilities: z
        .object({
          acss_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          affirm_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          afterpay_clearpay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          alma_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          amazon_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          au_becs_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          bacs_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          bancontact_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          billie_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          blik_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          boleto_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          card_issuing: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          card_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          cartes_bancaires_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          cashapp_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          eps_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          fpx_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          gb_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          giropay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          grabpay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          ideal_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          india_international_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          jcb_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          jp_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          kakao_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          klarna_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          konbini_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          kr_card_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          legacy_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          link_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          mobilepay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          multibanco_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          mx_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          naver_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          nz_bank_account_becs_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          oxxo_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          p24_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          pay_by_bank_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          payco_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          paynow_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          promptpay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          revolut_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          samsung_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          satispay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          sepa_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          sepa_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          sofort_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          swish_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          tax_reporting_us_1099_k: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          tax_reporting_us_1099_misc: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          transfers: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          treasury: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          twint_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          us_bank_account_ach_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          us_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          zip_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
        })
        .optional(),
      company: z
        .object({
          address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          address_kana: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          address_kanji: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          directors_provided: PermissiveBoolean.optional(),
          directorship_declaration: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z.string().max(5000).optional(),
            })
            .optional(),
          executives_provided: PermissiveBoolean.optional(),
          export_license_id: z.string().max(5000).optional(),
          export_purpose_code: z.string().max(5000).optional(),
          name: z.string().max(100).optional(),
          name_kana: z.string().max(100).optional(),
          name_kanji: z.string().max(100).optional(),
          owners_provided: PermissiveBoolean.optional(),
          ownership_declaration: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z.string().max(5000).optional(),
            })
            .optional(),
          ownership_exemption_reason: z
            .enum([
              "",
              "qualified_entity_exceeds_ownership_threshold",
              "qualifies_as_financial_institution",
            ])
            .optional(),
          phone: z.string().max(5000).optional(),
          registration_number: z.string().max(5000).optional(),
          structure: z
            .enum([
              "",
              "free_zone_establishment",
              "free_zone_llc",
              "government_instrumentality",
              "governmental_unit",
              "incorporated_non_profit",
              "incorporated_partnership",
              "limited_liability_partnership",
              "llc",
              "multi_member_llc",
              "private_company",
              "private_corporation",
              "private_partnership",
              "public_company",
              "public_corporation",
              "public_partnership",
              "registered_charity",
              "single_member_llc",
              "sole_establishment",
              "sole_proprietorship",
              "tax_exempt_government_instrumentality",
              "unincorporated_association",
              "unincorporated_non_profit",
              "unincorporated_partnership",
            ])
            .optional(),
          tax_id: z.string().max(5000).optional(),
          tax_id_registrar: z.string().max(5000).optional(),
          vat_id: z.string().max(5000).optional(),
          verification: z
            .object({
              document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      controller: z
        .object({
          fees: z
            .object({ payer: z.enum(["account", "application"]).optional() })
            .optional(),
          losses: z
            .object({ payments: z.enum(["application", "stripe"]).optional() })
            .optional(),
          requirement_collection: z.enum(["application", "stripe"]).optional(),
          stripe_dashboard: z
            .object({ type: z.enum(["express", "full", "none"]).optional() })
            .optional(),
        })
        .optional(),
      country: z.string().max(5000).optional(),
      default_currency: z.string().optional(),
      documents: z
        .object({
          bank_account_ownership_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_license: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_memorandum_of_association: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_ministerial_decree: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_registration_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_tax_id_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          proof_of_registration: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          proof_of_ultimate_beneficial_ownership: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
        })
        .optional(),
      email: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      external_account: z.string().max(5000).optional(),
      groups: z
        .object({
          payments_pricing: z
            .union([z.string().max(5000), z.enum([""])])
            .optional(),
        })
        .optional(),
      individual: z
        .object({
          address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          address_kana: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          address_kanji: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          dob: z
            .union([
              z.object({
                day: z.coerce.number(),
                month: z.coerce.number(),
                year: z.coerce.number(),
              }),
              z.enum([""]),
            ])
            .optional(),
          email: z.string().optional(),
          first_name: z.string().max(100).optional(),
          first_name_kana: z.string().max(5000).optional(),
          first_name_kanji: z.string().max(5000).optional(),
          full_name_aliases: z
            .union([z.array(z.string().max(300)), z.enum([""])])
            .optional(),
          gender: z.string().optional(),
          id_number: z.string().max(5000).optional(),
          id_number_secondary: z.string().max(5000).optional(),
          last_name: z.string().max(100).optional(),
          last_name_kana: z.string().max(5000).optional(),
          last_name_kanji: z.string().max(5000).optional(),
          maiden_name: z.string().max(5000).optional(),
          metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
          phone: z.string().optional(),
          political_exposure: z.enum(["existing", "none"]).optional(),
          registered_address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          relationship: z
            .object({
              director: PermissiveBoolean.optional(),
              executive: PermissiveBoolean.optional(),
              owner: PermissiveBoolean.optional(),
              percent_ownership: z
                .union([z.coerce.number(), z.enum([""])])
                .optional(),
              title: z.string().max(5000).optional(),
            })
            .optional(),
          ssn_last_4: z.string().max(5000).optional(),
          verification: z
            .object({
              additional_document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
              document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      settings: z
        .object({
          bacs_debit_payments: z
            .object({ display_name: z.string().optional() })
            .optional(),
          branding: z
            .object({
              icon: z.string().max(5000).optional(),
              logo: z.string().max(5000).optional(),
              primary_color: z.string().max(5000).optional(),
              secondary_color: z.string().max(5000).optional(),
            })
            .optional(),
          card_issuing: z
            .object({
              tos_acceptance: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z
                    .union([z.string().max(5000), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          card_payments: z
            .object({
              decline_on: z
                .object({
                  avs_failure: PermissiveBoolean.optional(),
                  cvc_failure: PermissiveBoolean.optional(),
                })
                .optional(),
              statement_descriptor_prefix: z.string().max(10).optional(),
              statement_descriptor_prefix_kana: z
                .union([z.string().max(10), z.enum([""])])
                .optional(),
              statement_descriptor_prefix_kanji: z
                .union([z.string().max(10), z.enum([""])])
                .optional(),
            })
            .optional(),
          invoices: z
            .object({
              hosted_payment_method_save: z
                .enum(["always", "never", "offer"])
                .optional(),
            })
            .optional(),
          payments: z
            .object({
              statement_descriptor: z.string().max(22).optional(),
              statement_descriptor_kana: z.string().max(22).optional(),
              statement_descriptor_kanji: z.string().max(22).optional(),
            })
            .optional(),
          payouts: z
            .object({
              debit_negative_balances: PermissiveBoolean.optional(),
              schedule: z
                .object({
                  delay_days: z
                    .union([z.enum(["minimum"]), z.coerce.number()])
                    .optional(),
                  interval: z
                    .enum(["daily", "manual", "monthly", "weekly"])
                    .optional(),
                  monthly_anchor: z.coerce.number().optional(),
                  weekly_anchor: z
                    .enum([
                      "friday",
                      "monday",
                      "saturday",
                      "sunday",
                      "thursday",
                      "tuesday",
                      "wednesday",
                    ])
                    .optional(),
                })
                .optional(),
              statement_descriptor: z.string().max(22).optional(),
            })
            .optional(),
          treasury: z
            .object({
              tos_acceptance: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z
                    .union([z.string().max(5000), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      tos_acceptance: z
        .object({
          date: z.coerce.number().optional(),
          ip: z.string().optional(),
          service_agreement: z.string().max(5000).optional(),
          user_agent: z.string().max(5000).optional(),
        })
        .optional(),
      type: z.enum(["custom", "express", "standard"]).optional(),
    })
    .optional()

  router.post("postAccounts", "/v1/accounts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postAccountsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postAccounts(input, postAccounts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postAccounts.validator(status, body)
    ctx.status = status
    return next()
  })

  const deleteAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const deleteAccountsAccountBodySchema = z.object({}).optional()

  router.delete(
    "deleteAccountsAccount",
    "/v1/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteAccountsAccount(input, deleteAccountsAccount.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountsAccountBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccount",
    "/v1/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccount(input, getAccountsAccount.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postAccountsAccountBodySchema = z
    .object({
      account_token: z.string().max(5000).optional(),
      business_profile: z
        .object({
          annual_revenue: z
            .object({
              amount: z.coerce.number(),
              currency: z.string(),
              fiscal_year_end: z.string().max(5000),
            })
            .optional(),
          estimated_worker_count: z.coerce.number().optional(),
          mcc: z.string().max(4).optional(),
          monthly_estimated_revenue: z
            .object({ amount: z.coerce.number(), currency: z.string() })
            .optional(),
          name: z.string().max(5000).optional(),
          product_description: z.string().max(40000).optional(),
          support_address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          support_email: z.string().optional(),
          support_phone: z.string().max(5000).optional(),
          support_url: z.union([z.string(), z.enum([""])]).optional(),
          url: z.string().optional(),
        })
        .optional(),
      business_type: z
        .enum(["company", "government_entity", "individual", "non_profit"])
        .optional(),
      capabilities: z
        .object({
          acss_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          affirm_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          afterpay_clearpay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          alma_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          amazon_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          au_becs_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          bacs_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          bancontact_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          billie_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          blik_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          boleto_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          card_issuing: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          card_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          cartes_bancaires_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          cashapp_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          eps_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          fpx_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          gb_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          giropay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          grabpay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          ideal_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          india_international_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          jcb_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          jp_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          kakao_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          klarna_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          konbini_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          kr_card_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          legacy_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          link_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          mobilepay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          multibanco_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          mx_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          naver_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          nz_bank_account_becs_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          oxxo_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          p24_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          pay_by_bank_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          payco_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          paynow_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          promptpay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          revolut_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          samsung_pay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          satispay_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          sepa_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          sepa_debit_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          sofort_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          swish_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          tax_reporting_us_1099_k: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          tax_reporting_us_1099_misc: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          transfers: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          treasury: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          twint_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          us_bank_account_ach_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          us_bank_transfer_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
          zip_payments: z
            .object({ requested: PermissiveBoolean.optional() })
            .optional(),
        })
        .optional(),
      company: z
        .object({
          address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          address_kana: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          address_kanji: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          directors_provided: PermissiveBoolean.optional(),
          directorship_declaration: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z.string().max(5000).optional(),
            })
            .optional(),
          executives_provided: PermissiveBoolean.optional(),
          export_license_id: z.string().max(5000).optional(),
          export_purpose_code: z.string().max(5000).optional(),
          name: z.string().max(100).optional(),
          name_kana: z.string().max(100).optional(),
          name_kanji: z.string().max(100).optional(),
          owners_provided: PermissiveBoolean.optional(),
          ownership_declaration: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z.string().max(5000).optional(),
            })
            .optional(),
          ownership_exemption_reason: z
            .enum([
              "",
              "qualified_entity_exceeds_ownership_threshold",
              "qualifies_as_financial_institution",
            ])
            .optional(),
          phone: z.string().max(5000).optional(),
          registration_number: z.string().max(5000).optional(),
          structure: z
            .enum([
              "",
              "free_zone_establishment",
              "free_zone_llc",
              "government_instrumentality",
              "governmental_unit",
              "incorporated_non_profit",
              "incorporated_partnership",
              "limited_liability_partnership",
              "llc",
              "multi_member_llc",
              "private_company",
              "private_corporation",
              "private_partnership",
              "public_company",
              "public_corporation",
              "public_partnership",
              "registered_charity",
              "single_member_llc",
              "sole_establishment",
              "sole_proprietorship",
              "tax_exempt_government_instrumentality",
              "unincorporated_association",
              "unincorporated_non_profit",
              "unincorporated_partnership",
            ])
            .optional(),
          tax_id: z.string().max(5000).optional(),
          tax_id_registrar: z.string().max(5000).optional(),
          vat_id: z.string().max(5000).optional(),
          verification: z
            .object({
              document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      default_currency: z.string().optional(),
      documents: z
        .object({
          bank_account_ownership_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_license: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_memorandum_of_association: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_ministerial_decree: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_registration_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          company_tax_id_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          proof_of_registration: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
          proof_of_ultimate_beneficial_ownership: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
        })
        .optional(),
      email: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      external_account: z.string().max(5000).optional(),
      groups: z
        .object({
          payments_pricing: z
            .union([z.string().max(5000), z.enum([""])])
            .optional(),
        })
        .optional(),
      individual: z
        .object({
          address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          address_kana: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          address_kanji: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          dob: z
            .union([
              z.object({
                day: z.coerce.number(),
                month: z.coerce.number(),
                year: z.coerce.number(),
              }),
              z.enum([""]),
            ])
            .optional(),
          email: z.string().optional(),
          first_name: z.string().max(100).optional(),
          first_name_kana: z.string().max(5000).optional(),
          first_name_kanji: z.string().max(5000).optional(),
          full_name_aliases: z
            .union([z.array(z.string().max(300)), z.enum([""])])
            .optional(),
          gender: z.string().optional(),
          id_number: z.string().max(5000).optional(),
          id_number_secondary: z.string().max(5000).optional(),
          last_name: z.string().max(100).optional(),
          last_name_kana: z.string().max(5000).optional(),
          last_name_kanji: z.string().max(5000).optional(),
          maiden_name: z.string().max(5000).optional(),
          metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
          phone: z.string().optional(),
          political_exposure: z.enum(["existing", "none"]).optional(),
          registered_address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          relationship: z
            .object({
              director: PermissiveBoolean.optional(),
              executive: PermissiveBoolean.optional(),
              owner: PermissiveBoolean.optional(),
              percent_ownership: z
                .union([z.coerce.number(), z.enum([""])])
                .optional(),
              title: z.string().max(5000).optional(),
            })
            .optional(),
          ssn_last_4: z.string().max(5000).optional(),
          verification: z
            .object({
              additional_document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
              document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      settings: z
        .object({
          bacs_debit_payments: z
            .object({ display_name: z.string().optional() })
            .optional(),
          branding: z
            .object({
              icon: z.string().max(5000).optional(),
              logo: z.string().max(5000).optional(),
              primary_color: z.string().max(5000).optional(),
              secondary_color: z.string().max(5000).optional(),
            })
            .optional(),
          card_issuing: z
            .object({
              tos_acceptance: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z
                    .union([z.string().max(5000), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          card_payments: z
            .object({
              decline_on: z
                .object({
                  avs_failure: PermissiveBoolean.optional(),
                  cvc_failure: PermissiveBoolean.optional(),
                })
                .optional(),
              statement_descriptor_prefix: z.string().max(10).optional(),
              statement_descriptor_prefix_kana: z
                .union([z.string().max(10), z.enum([""])])
                .optional(),
              statement_descriptor_prefix_kanji: z
                .union([z.string().max(10), z.enum([""])])
                .optional(),
            })
            .optional(),
          invoices: z
            .object({
              default_account_tax_ids: z
                .union([z.array(z.string().max(5000)), z.enum([""])])
                .optional(),
              hosted_payment_method_save: z
                .enum(["always", "never", "offer"])
                .optional(),
            })
            .optional(),
          payments: z
            .object({
              statement_descriptor: z.string().max(22).optional(),
              statement_descriptor_kana: z.string().max(22).optional(),
              statement_descriptor_kanji: z.string().max(22).optional(),
            })
            .optional(),
          payouts: z
            .object({
              debit_negative_balances: PermissiveBoolean.optional(),
              schedule: z
                .object({
                  delay_days: z
                    .union([z.enum(["minimum"]), z.coerce.number()])
                    .optional(),
                  interval: z
                    .enum(["daily", "manual", "monthly", "weekly"])
                    .optional(),
                  monthly_anchor: z.coerce.number().optional(),
                  weekly_anchor: z
                    .enum([
                      "friday",
                      "monday",
                      "saturday",
                      "sunday",
                      "thursday",
                      "tuesday",
                      "wednesday",
                    ])
                    .optional(),
                })
                .optional(),
              statement_descriptor: z.string().max(22).optional(),
            })
            .optional(),
          treasury: z
            .object({
              tos_acceptance: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z
                    .union([z.string().max(5000), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      tos_acceptance: z
        .object({
          date: z.coerce.number().optional(),
          ip: z.string().optional(),
          service_agreement: z.string().max(5000).optional(),
          user_agent: z.string().max(5000).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postAccountsAccount",
    "/v1/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccount(input, postAccountsAccount.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountBankAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postAccountsAccountBankAccountsBodySchema = z
    .object({
      bank_account: z
        .union([
          z.object({
            account_holder_name: z.string().max(5000).optional(),
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000),
            account_type: z
              .enum(["checking", "futsu", "savings", "toza"])
              .optional(),
            country: z.string().max(5000),
            currency: z.string().optional(),
            documents: z
              .object({
                bank_account_ownership_verification: z
                  .object({ files: z.array(z.string().max(500)).optional() })
                  .optional(),
              })
              .optional(),
            object: z.enum(["bank_account"]).optional(),
            routing_number: z.string().max(5000).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      default_for_currency: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      external_account: z.string().max(5000).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountBankAccounts",
    "/v1/accounts/:account/bank_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountBankAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountBankAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountBankAccounts(
          input,
          postAccountsAccountBankAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountBankAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const deleteAccountsAccountBankAccountsIdBodySchema = z.object({}).optional()

  router.delete(
    "deleteAccountsAccountBankAccountsId",
    "/v1/accounts/:account/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteAccountsAccountBankAccountsId(
          input,
          deleteAccountsAccountBankAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountBankAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const getAccountsAccountBankAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountsAccountBankAccountsIdBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountBankAccountsId",
    "/v1/accounts/:account/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountBankAccountsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountBankAccountsId(
          input,
          getAccountsAccountBankAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountBankAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountBankAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const postAccountsAccountBankAccountsIdBodySchema = z
    .object({
      account_holder_name: z.string().max(5000).optional(),
      account_holder_type: z.enum(["", "company", "individual"]).optional(),
      account_type: z.enum(["checking", "futsu", "savings", "toza"]).optional(),
      address_city: z.string().max(5000).optional(),
      address_country: z.string().max(5000).optional(),
      address_line1: z.string().max(5000).optional(),
      address_line2: z.string().max(5000).optional(),
      address_state: z.string().max(5000).optional(),
      address_zip: z.string().max(5000).optional(),
      default_for_currency: PermissiveBoolean.optional(),
      documents: z
        .object({
          bank_account_ownership_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
        })
        .optional(),
      exp_month: z.string().max(5000).optional(),
      exp_year: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountBankAccountsId",
    "/v1/accounts/:account/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountBankAccountsId(
          input,
          postAccountsAccountBankAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountBankAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountCapabilitiesParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountCapabilitiesQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountsAccountCapabilitiesBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountCapabilities",
    "/v1/accounts/:account/capabilities",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountCapabilitiesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountCapabilitiesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountCapabilitiesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountCapabilities(
          input,
          getAccountsAccountCapabilities.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountCapabilities.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountCapabilitiesCapabilityParamSchema = z.object({
    account: z.string().max(5000),
    capability: z.string(),
  })

  const getAccountsAccountCapabilitiesCapabilityQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountsAccountCapabilitiesCapabilityBodySchema = z
    .object({})
    .optional()

  router.get(
    "getAccountsAccountCapabilitiesCapability",
    "/v1/accounts/:account/capabilities/:capability",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountCapabilitiesCapabilityParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountCapabilitiesCapabilityQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountCapabilitiesCapabilityBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountCapabilitiesCapability(
          input,
          getAccountsAccountCapabilitiesCapability.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountCapabilitiesCapability.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountCapabilitiesCapabilityParamSchema = z.object({
    account: z.string().max(5000),
    capability: z.string(),
  })

  const postAccountsAccountCapabilitiesCapabilityBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      requested: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountCapabilitiesCapability",
    "/v1/accounts/:account/capabilities/:capability",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountCapabilitiesCapabilityParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountCapabilitiesCapabilityBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountCapabilitiesCapability(
          input,
          postAccountsAccountCapabilitiesCapability.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountCapabilitiesCapability.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountExternalAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountExternalAccountsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    object: z.enum(["bank_account", "card"]).optional(),
    starting_after: z.string().optional(),
  })

  const getAccountsAccountExternalAccountsBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountExternalAccounts",
    "/v1/accounts/:account/external_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountExternalAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountExternalAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountExternalAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountExternalAccounts(
          input,
          getAccountsAccountExternalAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountExternalAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountExternalAccountsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postAccountsAccountExternalAccountsBodySchema = z
    .object({
      bank_account: z
        .union([
          z.object({
            account_holder_name: z.string().max(5000).optional(),
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000),
            account_type: z
              .enum(["checking", "futsu", "savings", "toza"])
              .optional(),
            country: z.string().max(5000),
            currency: z.string().optional(),
            documents: z
              .object({
                bank_account_ownership_verification: z
                  .object({ files: z.array(z.string().max(500)).optional() })
                  .optional(),
              })
              .optional(),
            object: z.enum(["bank_account"]).optional(),
            routing_number: z.string().max(5000).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      default_for_currency: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      external_account: z.string().max(5000).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountExternalAccounts",
    "/v1/accounts/:account/external_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountExternalAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountExternalAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountExternalAccounts(
          input,
          postAccountsAccountExternalAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountExternalAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const deleteAccountsAccountExternalAccountsIdBodySchema = z
    .object({})
    .optional()

  router.delete(
    "deleteAccountsAccountExternalAccountsId",
    "/v1/accounts/:account/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteAccountsAccountExternalAccountsId(
          input,
          deleteAccountsAccountExternalAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountExternalAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const getAccountsAccountExternalAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountsAccountExternalAccountsIdBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountExternalAccountsId",
    "/v1/accounts/:account/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountExternalAccountsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountExternalAccountsId(
          input,
          getAccountsAccountExternalAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountExternalAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountExternalAccountsIdParamSchema = z.object({
    account: z.string().max(5000),
    id: z.string(),
  })

  const postAccountsAccountExternalAccountsIdBodySchema = z
    .object({
      account_holder_name: z.string().max(5000).optional(),
      account_holder_type: z.enum(["", "company", "individual"]).optional(),
      account_type: z.enum(["checking", "futsu", "savings", "toza"]).optional(),
      address_city: z.string().max(5000).optional(),
      address_country: z.string().max(5000).optional(),
      address_line1: z.string().max(5000).optional(),
      address_line2: z.string().max(5000).optional(),
      address_state: z.string().max(5000).optional(),
      address_zip: z.string().max(5000).optional(),
      default_for_currency: PermissiveBoolean.optional(),
      documents: z
        .object({
          bank_account_ownership_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
        })
        .optional(),
      exp_month: z.string().max(5000).optional(),
      exp_year: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountExternalAccountsId",
    "/v1/accounts/:account/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountExternalAccountsId(
          input,
          postAccountsAccountExternalAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountExternalAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountLoginLinksParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postAccountsAccountLoginLinksBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postAccountsAccountLoginLinks",
    "/v1/accounts/:account/login_links",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountLoginLinksParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountLoginLinksBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountLoginLinks(
          input,
          postAccountsAccountLoginLinks.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountLoginLinks.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPeopleParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountPeopleQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    relationship: z
      .object({
        authorizer: PermissiveBoolean.optional(),
        director: PermissiveBoolean.optional(),
        executive: PermissiveBoolean.optional(),
        legal_guardian: PermissiveBoolean.optional(),
        owner: PermissiveBoolean.optional(),
        representative: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getAccountsAccountPeopleBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountPeople",
    "/v1/accounts/:account/people",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPeopleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPeopleQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPeopleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountPeople(
          input,
          getAccountsAccountPeople.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPeople.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPeopleParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postAccountsAccountPeopleBodySchema = z
    .object({
      additional_tos_acceptances: z
        .object({
          account: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z
                .union([z.string().max(5000), z.enum([""])])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      address_kana: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      address_kanji: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      dob: z
        .union([
          z.object({
            day: z.coerce.number(),
            month: z.coerce.number(),
            year: z.coerce.number(),
          }),
          z.enum([""]),
        ])
        .optional(),
      documents: z
        .object({
          company_authorization: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          passport: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          visa: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
        })
        .optional(),
      email: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      first_name: z.string().max(5000).optional(),
      first_name_kana: z.string().max(5000).optional(),
      first_name_kanji: z.string().max(5000).optional(),
      full_name_aliases: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      gender: z.string().optional(),
      id_number: z.string().max(5000).optional(),
      id_number_secondary: z.string().max(5000).optional(),
      last_name: z.string().max(5000).optional(),
      last_name_kana: z.string().max(5000).optional(),
      last_name_kanji: z.string().max(5000).optional(),
      maiden_name: z.string().max(5000).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      nationality: z.string().max(5000).optional(),
      person_token: z.string().max(5000).optional(),
      phone: z.string().optional(),
      political_exposure: z.enum(["existing", "none"]).optional(),
      registered_address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      relationship: z
        .object({
          authorizer: PermissiveBoolean.optional(),
          director: PermissiveBoolean.optional(),
          executive: PermissiveBoolean.optional(),
          legal_guardian: PermissiveBoolean.optional(),
          owner: PermissiveBoolean.optional(),
          percent_ownership: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
          representative: PermissiveBoolean.optional(),
          title: z.string().max(5000).optional(),
        })
        .optional(),
      ssn_last_4: z.string().optional(),
      verification: z
        .object({
          additional_document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
          document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountPeople",
    "/v1/accounts/:account/people",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPeopleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPeopleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountPeople(
          input,
          postAccountsAccountPeople.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPeople.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const deleteAccountsAccountPeoplePersonBodySchema = z.object({}).optional()

  router.delete(
    "deleteAccountsAccountPeoplePerson",
    "/v1/accounts/:account/people/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountPeoplePersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountPeoplePersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteAccountsAccountPeoplePerson(
          input,
          deleteAccountsAccountPeoplePerson.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountPeoplePerson.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const getAccountsAccountPeoplePersonQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountsAccountPeoplePersonBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountPeoplePerson",
    "/v1/accounts/:account/people/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPeoplePersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPeoplePersonQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPeoplePersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountPeoplePerson(
          input,
          getAccountsAccountPeoplePerson.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPeoplePerson.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPeoplePersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const postAccountsAccountPeoplePersonBodySchema = z
    .object({
      additional_tos_acceptances: z
        .object({
          account: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z
                .union([z.string().max(5000), z.enum([""])])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      address_kana: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      address_kanji: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      dob: z
        .union([
          z.object({
            day: z.coerce.number(),
            month: z.coerce.number(),
            year: z.coerce.number(),
          }),
          z.enum([""]),
        ])
        .optional(),
      documents: z
        .object({
          company_authorization: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          passport: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          visa: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
        })
        .optional(),
      email: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      first_name: z.string().max(5000).optional(),
      first_name_kana: z.string().max(5000).optional(),
      first_name_kanji: z.string().max(5000).optional(),
      full_name_aliases: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      gender: z.string().optional(),
      id_number: z.string().max(5000).optional(),
      id_number_secondary: z.string().max(5000).optional(),
      last_name: z.string().max(5000).optional(),
      last_name_kana: z.string().max(5000).optional(),
      last_name_kanji: z.string().max(5000).optional(),
      maiden_name: z.string().max(5000).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      nationality: z.string().max(5000).optional(),
      person_token: z.string().max(5000).optional(),
      phone: z.string().optional(),
      political_exposure: z.enum(["existing", "none"]).optional(),
      registered_address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      relationship: z
        .object({
          authorizer: PermissiveBoolean.optional(),
          director: PermissiveBoolean.optional(),
          executive: PermissiveBoolean.optional(),
          legal_guardian: PermissiveBoolean.optional(),
          owner: PermissiveBoolean.optional(),
          percent_ownership: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
          representative: PermissiveBoolean.optional(),
          title: z.string().max(5000).optional(),
        })
        .optional(),
      ssn_last_4: z.string().optional(),
      verification: z
        .object({
          additional_document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
          document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountPeoplePerson",
    "/v1/accounts/:account/people/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPeoplePersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPeoplePersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountPeoplePerson(
          input,
          postAccountsAccountPeoplePerson.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPeoplePerson.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPersonsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getAccountsAccountPersonsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    relationship: z
      .object({
        authorizer: PermissiveBoolean.optional(),
        director: PermissiveBoolean.optional(),
        executive: PermissiveBoolean.optional(),
        legal_guardian: PermissiveBoolean.optional(),
        owner: PermissiveBoolean.optional(),
        representative: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getAccountsAccountPersonsBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountPersons",
    "/v1/accounts/:account/persons",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPersonsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPersonsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPersonsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountPersons(
          input,
          getAccountsAccountPersons.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPersons.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPersonsParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postAccountsAccountPersonsBodySchema = z
    .object({
      additional_tos_acceptances: z
        .object({
          account: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z
                .union([z.string().max(5000), z.enum([""])])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      address_kana: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      address_kanji: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      dob: z
        .union([
          z.object({
            day: z.coerce.number(),
            month: z.coerce.number(),
            year: z.coerce.number(),
          }),
          z.enum([""]),
        ])
        .optional(),
      documents: z
        .object({
          company_authorization: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          passport: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          visa: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
        })
        .optional(),
      email: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      first_name: z.string().max(5000).optional(),
      first_name_kana: z.string().max(5000).optional(),
      first_name_kanji: z.string().max(5000).optional(),
      full_name_aliases: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      gender: z.string().optional(),
      id_number: z.string().max(5000).optional(),
      id_number_secondary: z.string().max(5000).optional(),
      last_name: z.string().max(5000).optional(),
      last_name_kana: z.string().max(5000).optional(),
      last_name_kanji: z.string().max(5000).optional(),
      maiden_name: z.string().max(5000).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      nationality: z.string().max(5000).optional(),
      person_token: z.string().max(5000).optional(),
      phone: z.string().optional(),
      political_exposure: z.enum(["existing", "none"]).optional(),
      registered_address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      relationship: z
        .object({
          authorizer: PermissiveBoolean.optional(),
          director: PermissiveBoolean.optional(),
          executive: PermissiveBoolean.optional(),
          legal_guardian: PermissiveBoolean.optional(),
          owner: PermissiveBoolean.optional(),
          percent_ownership: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
          representative: PermissiveBoolean.optional(),
          title: z.string().max(5000).optional(),
        })
        .optional(),
      ssn_last_4: z.string().optional(),
      verification: z
        .object({
          additional_document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
          document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountPersons",
    "/v1/accounts/:account/persons",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPersonsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPersonsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountPersons(
          input,
          postAccountsAccountPersons.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPersons.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const deleteAccountsAccountPersonsPersonBodySchema = z.object({}).optional()

  router.delete(
    "deleteAccountsAccountPersonsPerson",
    "/v1/accounts/:account/persons/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAccountsAccountPersonsPersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteAccountsAccountPersonsPersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteAccountsAccountPersonsPerson(
          input,
          deleteAccountsAccountPersonsPerson.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAccountsAccountPersonsPerson.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const getAccountsAccountPersonsPersonQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getAccountsAccountPersonsPersonBodySchema = z.object({}).optional()

  router.get(
    "getAccountsAccountPersonsPerson",
    "/v1/accounts/:account/persons/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAccountsAccountPersonsPersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAccountsAccountPersonsPersonQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAccountsAccountPersonsPersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAccountsAccountPersonsPerson(
          input,
          getAccountsAccountPersonsPerson.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAccountsAccountPersonsPerson.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountPersonsPersonParamSchema = z.object({
    account: z.string().max(5000),
    person: z.string().max(5000),
  })

  const postAccountsAccountPersonsPersonBodySchema = z
    .object({
      additional_tos_acceptances: z
        .object({
          account: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              user_agent: z
                .union([z.string().max(5000), z.enum([""])])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      address_kana: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      address_kanji: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          town: z.string().max(5000).optional(),
        })
        .optional(),
      dob: z
        .union([
          z.object({
            day: z.coerce.number(),
            month: z.coerce.number(),
            year: z.coerce.number(),
          }),
          z.enum([""]),
        ])
        .optional(),
      documents: z
        .object({
          company_authorization: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          passport: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
          visa: z
            .object({
              files: z
                .array(z.union([z.string().max(500), z.enum([""])]))
                .optional(),
            })
            .optional(),
        })
        .optional(),
      email: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      first_name: z.string().max(5000).optional(),
      first_name_kana: z.string().max(5000).optional(),
      first_name_kanji: z.string().max(5000).optional(),
      full_name_aliases: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      gender: z.string().optional(),
      id_number: z.string().max(5000).optional(),
      id_number_secondary: z.string().max(5000).optional(),
      last_name: z.string().max(5000).optional(),
      last_name_kana: z.string().max(5000).optional(),
      last_name_kanji: z.string().max(5000).optional(),
      maiden_name: z.string().max(5000).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      nationality: z.string().max(5000).optional(),
      person_token: z.string().max(5000).optional(),
      phone: z.string().optional(),
      political_exposure: z.enum(["existing", "none"]).optional(),
      registered_address: z
        .object({
          city: z.string().max(100).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(200).optional(),
          line2: z.string().max(200).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      relationship: z
        .object({
          authorizer: PermissiveBoolean.optional(),
          director: PermissiveBoolean.optional(),
          executive: PermissiveBoolean.optional(),
          legal_guardian: PermissiveBoolean.optional(),
          owner: PermissiveBoolean.optional(),
          percent_ownership: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
          representative: PermissiveBoolean.optional(),
          title: z.string().max(5000).optional(),
        })
        .optional(),
      ssn_last_4: z.string().optional(),
      verification: z
        .object({
          additional_document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
          document: z
            .object({
              back: z.string().max(500).optional(),
              front: z.string().max(500).optional(),
            })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postAccountsAccountPersonsPerson",
    "/v1/accounts/:account/persons/:person",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountPersonsPersonParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountPersonsPersonBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountPersonsPerson(
          input,
          postAccountsAccountPersonsPerson.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountPersonsPerson.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postAccountsAccountRejectParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postAccountsAccountRejectBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    reason: z.string().max(5000),
  })

  router.post(
    "postAccountsAccountReject",
    "/v1/accounts/:account/reject",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postAccountsAccountRejectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postAccountsAccountRejectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAccountsAccountReject(
          input,
          postAccountsAccountReject.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAccountsAccountReject.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplePayDomainsQuerySchema = z.object({
    domain_name: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getApplePayDomainsBodySchema = z.object({}).optional()

  router.get(
    "getApplePayDomains",
    "/v1/apple_pay/domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getApplePayDomainsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplePayDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getApplePayDomains(input, getApplePayDomains.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplePayDomains.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postApplePayDomainsBodySchema = z.object({
    domain_name: z.string(),
    expand: z.array(z.string().max(5000)).optional(),
  })

  router.post(
    "postApplePayDomains",
    "/v1/apple_pay/domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postApplePayDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postApplePayDomains(input, postApplePayDomains.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplePayDomains.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteApplePayDomainsDomainParamSchema = z.object({
    domain: z.string().max(5000),
  })

  const deleteApplePayDomainsDomainBodySchema = z.object({}).optional()

  router.delete(
    "deleteApplePayDomainsDomain",
    "/v1/apple_pay/domains/:domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteApplePayDomainsDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteApplePayDomainsDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteApplePayDomainsDomain(
          input,
          deleteApplePayDomainsDomain.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteApplePayDomainsDomain.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplePayDomainsDomainParamSchema = z.object({
    domain: z.string().max(5000),
  })

  const getApplePayDomainsDomainQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getApplePayDomainsDomainBodySchema = z.object({}).optional()

  router.get(
    "getApplePayDomainsDomain",
    "/v1/apple_pay/domains/:domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplePayDomainsDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplePayDomainsDomainQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplePayDomainsDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getApplePayDomainsDomain(
          input,
          getApplePayDomainsDomain.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplePayDomainsDomain.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesQuerySchema = z.object({
    charge: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getApplicationFeesBodySchema = z.object({}).optional()

  router.get(
    "getApplicationFees",
    "/v1/application_fees",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getApplicationFeesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getApplicationFees(input, getApplicationFees.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFees.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesFeeRefundsIdParamSchema = z.object({
    fee: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getApplicationFeesFeeRefundsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getApplicationFeesFeeRefundsIdBodySchema = z.object({}).optional()

  router.get(
    "getApplicationFeesFeeRefundsId",
    "/v1/application_fees/:fee/refunds/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplicationFeesFeeRefundsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplicationFeesFeeRefundsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesFeeRefundsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getApplicationFeesFeeRefundsId(
          input,
          getApplicationFeesFeeRefundsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFeesFeeRefundsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postApplicationFeesFeeRefundsIdParamSchema = z.object({
    fee: z.string().max(5000),
    id: z.string().max(5000),
  })

  const postApplicationFeesFeeRefundsIdBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postApplicationFeesFeeRefundsId",
    "/v1/application_fees/:fee/refunds/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postApplicationFeesFeeRefundsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postApplicationFeesFeeRefundsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postApplicationFeesFeeRefundsId(
          input,
          postApplicationFeesFeeRefundsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplicationFeesFeeRefundsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesIdParamSchema = z.object({ id: z.string().max(5000) })

  const getApplicationFeesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getApplicationFeesIdBodySchema = z.object({}).optional()

  router.get(
    "getApplicationFeesId",
    "/v1/application_fees/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplicationFeesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplicationFeesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getApplicationFeesId(input, getApplicationFeesId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFeesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postApplicationFeesIdRefundParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postApplicationFeesIdRefundBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      directive: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postApplicationFeesIdRefund",
    "/v1/application_fees/:id/refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postApplicationFeesIdRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postApplicationFeesIdRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postApplicationFeesIdRefund(
          input,
          postApplicationFeesIdRefund.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplicationFeesIdRefund.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getApplicationFeesIdRefundsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getApplicationFeesIdRefundsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getApplicationFeesIdRefundsBodySchema = z.object({}).optional()

  router.get(
    "getApplicationFeesIdRefunds",
    "/v1/application_fees/:id/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getApplicationFeesIdRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getApplicationFeesIdRefundsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getApplicationFeesIdRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getApplicationFeesIdRefunds(
          input,
          getApplicationFeesIdRefunds.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getApplicationFeesIdRefunds.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postApplicationFeesIdRefundsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postApplicationFeesIdRefundsBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postApplicationFeesIdRefunds",
    "/v1/application_fees/:id/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postApplicationFeesIdRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postApplicationFeesIdRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postApplicationFeesIdRefunds(
          input,
          postApplicationFeesIdRefunds.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postApplicationFeesIdRefunds.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAppsSecretsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
    starting_after: z.string().max(5000).optional(),
  })

  const getAppsSecretsBodySchema = z.object({}).optional()

  router.get("getAppsSecrets", "/v1/apps/secrets", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getAppsSecretsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getAppsSecretsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getAppsSecrets(input, getAppsSecrets.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getAppsSecrets.validator(status, body)
    ctx.status = status
    return next()
  })

  const postAppsSecretsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    expires_at: z.coerce.number().optional(),
    name: z.string().max(5000),
    payload: z.string().max(5000),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
  })

  router.post("postAppsSecrets", "/v1/apps/secrets", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postAppsSecretsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postAppsSecrets(input, postAppsSecrets.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postAppsSecrets.validator(status, body)
    ctx.status = status
    return next()
  })

  const postAppsSecretsDeleteBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    name: z.string().max(5000),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
  })

  router.post(
    "postAppsSecretsDelete",
    "/v1/apps/secrets/delete",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postAppsSecretsDeleteBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postAppsSecretsDelete(input, postAppsSecretsDelete.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postAppsSecretsDelete.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAppsSecretsFindQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    name: z.string().max(5000),
    scope: z.object({
      type: z.enum(["account", "user"]),
      user: z.string().max(5000).optional(),
    }),
  })

  const getAppsSecretsFindBodySchema = z.object({}).optional()

  router.get(
    "getAppsSecretsFind",
    "/v1/apps/secrets/find",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getAppsSecretsFindQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getAppsSecretsFindBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getAppsSecretsFind(input, getAppsSecretsFind.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAppsSecretsFind.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBalanceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBalanceBodySchema = z.object({}).optional()

  router.get("getBalance", "/v1/balance", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBalanceQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBalanceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getBalance(input, getBalance.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBalance.validator(status, body)
    ctx.status = status
    return next()
  })

  const getBalanceHistoryQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payout: z.string().max(5000).optional(),
    source: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
  })

  const getBalanceHistoryBodySchema = z.object({}).optional()

  router.get("getBalanceHistory", "/v1/balance/history", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBalanceHistoryQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBalanceHistoryBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getBalanceHistory(input, getBalanceHistory.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBalanceHistory.validator(status, body)
    ctx.status = status
    return next()
  })

  const getBalanceHistoryIdParamSchema = z.object({ id: z.string().max(5000) })

  const getBalanceHistoryIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBalanceHistoryIdBodySchema = z.object({}).optional()

  router.get(
    "getBalanceHistoryId",
    "/v1/balance/history/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBalanceHistoryIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBalanceHistoryIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBalanceHistoryIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBalanceHistoryId(input, getBalanceHistoryId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBalanceHistoryId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBalanceTransactionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payout: z.string().max(5000).optional(),
    source: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
  })

  const getBalanceTransactionsBodySchema = z.object({}).optional()

  router.get(
    "getBalanceTransactions",
    "/v1/balance_transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBalanceTransactions(input, getBalanceTransactions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBalanceTransactions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBalanceTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBalanceTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBalanceTransactionsIdBodySchema = z.object({}).optional()

  router.get(
    "getBalanceTransactionsId",
    "/v1/balance_transactions/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBalanceTransactionsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBalanceTransactionsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBalanceTransactionsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBalanceTransactionsId(
          input,
          getBalanceTransactionsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBalanceTransactionsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingAlertsQuerySchema = z.object({
    alert_type: z.enum(["usage_threshold"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    meter: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getBillingAlertsBodySchema = z.object({}).optional()

  router.get("getBillingAlerts", "/v1/billing/alerts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBillingAlertsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBillingAlertsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getBillingAlerts(input, getBillingAlerts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBillingAlerts.validator(status, body)
    ctx.status = status
    return next()
  })

  const postBillingAlertsBodySchema = z.object({
    alert_type: z.enum(["usage_threshold"]),
    expand: z.array(z.string().max(5000)).optional(),
    title: z.string().max(256),
    usage_threshold: z
      .object({
        filters: z
          .array(
            z.object({
              customer: z.string().max(5000).optional(),
              type: z.enum(["customer"]),
            }),
          )
          .optional(),
        gte: z.coerce.number(),
        meter: z.string().max(5000).optional(),
        recurrence: z.enum(["one_time"]),
      })
      .optional(),
  })

  router.post("postBillingAlerts", "/v1/billing/alerts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postBillingAlertsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postBillingAlerts(input, postBillingAlerts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postBillingAlerts.validator(status, body)
    ctx.status = status
    return next()
  })

  const getBillingAlertsIdParamSchema = z.object({ id: z.string().max(5000) })

  const getBillingAlertsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBillingAlertsIdBodySchema = z.object({}).optional()

  router.get(
    "getBillingAlertsId",
    "/v1/billing/alerts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingAlertsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingAlertsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingAlertsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingAlertsId(input, getBillingAlertsId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingAlertsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingAlertsIdActivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingAlertsIdActivateBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postBillingAlertsIdActivate",
    "/v1/billing/alerts/:id/activate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingAlertsIdActivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingAlertsIdActivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingAlertsIdActivate(
          input,
          postBillingAlertsIdActivate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingAlertsIdActivate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingAlertsIdArchiveParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingAlertsIdArchiveBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postBillingAlertsIdArchive",
    "/v1/billing/alerts/:id/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingAlertsIdArchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingAlertsIdArchiveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingAlertsIdArchive(
          input,
          postBillingAlertsIdArchive.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingAlertsIdArchive.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingAlertsIdDeactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingAlertsIdDeactivateBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postBillingAlertsIdDeactivate",
    "/v1/billing/alerts/:id/deactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingAlertsIdDeactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingAlertsIdDeactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingAlertsIdDeactivate(
          input,
          postBillingAlertsIdDeactivate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingAlertsIdDeactivate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditBalanceSummaryQuerySchema = z.object({
    customer: z.string().max(5000),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    filter: z.object({
      applicability_scope: z
        .object({
          price_type: z.enum(["metered"]).optional(),
          prices: z.array(z.object({ id: z.string().max(5000) })).optional(),
        })
        .optional(),
      credit_grant: z.string().max(5000).optional(),
      type: z.enum(["applicability_scope", "credit_grant"]),
    }),
  })

  const getBillingCreditBalanceSummaryBodySchema = z.object({}).optional()

  router.get(
    "getBillingCreditBalanceSummary",
    "/v1/billing/credit_balance_summary",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingCreditBalanceSummaryQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditBalanceSummaryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingCreditBalanceSummary(
          input,
          getBillingCreditBalanceSummary.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditBalanceSummary.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditBalanceTransactionsQuerySchema = z.object({
    credit_grant: z.string().max(5000).optional(),
    customer: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getBillingCreditBalanceTransactionsBodySchema = z.object({}).optional()

  router.get(
    "getBillingCreditBalanceTransactions",
    "/v1/billing/credit_balance_transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingCreditBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingCreditBalanceTransactions(
          input,
          getBillingCreditBalanceTransactions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditBalanceTransactions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditBalanceTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingCreditBalanceTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBillingCreditBalanceTransactionsIdBodySchema = z
    .object({})
    .optional()

  router.get(
    "getBillingCreditBalanceTransactionsId",
    "/v1/billing/credit_balance_transactions/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingCreditBalanceTransactionsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingCreditBalanceTransactionsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditBalanceTransactionsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingCreditBalanceTransactionsId(
          input,
          getBillingCreditBalanceTransactionsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditBalanceTransactionsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditGrantsQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getBillingCreditGrantsBodySchema = z.object({}).optional()

  router.get(
    "getBillingCreditGrants",
    "/v1/billing/credit_grants",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingCreditGrantsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditGrantsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingCreditGrants(input, getBillingCreditGrants.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditGrants.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingCreditGrantsBodySchema = z.object({
    amount: z.object({
      monetary: z
        .object({ currency: z.string(), value: z.coerce.number() })
        .optional(),
      type: z.enum(["monetary"]),
    }),
    applicability_config: z.object({
      scope: z.object({
        price_type: z.enum(["metered"]).optional(),
        prices: z.array(z.object({ id: z.string().max(5000) })).optional(),
      }),
    }),
    category: z.enum(["paid", "promotional"]),
    customer: z.string().max(5000),
    effective_at: z.coerce.number().optional(),
    expand: z.array(z.string().max(5000)).optional(),
    expires_at: z.coerce.number().optional(),
    metadata: z.record(z.string()).optional(),
    name: z.string().max(100).optional(),
    priority: z.coerce.number().optional(),
  })

  router.post(
    "postBillingCreditGrants",
    "/v1/billing/credit_grants",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingCreditGrants(input, postBillingCreditGrants.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrants.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingCreditGrantsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingCreditGrantsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBillingCreditGrantsIdBodySchema = z.object({}).optional()

  router.get(
    "getBillingCreditGrantsId",
    "/v1/billing/credit_grants/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingCreditGrantsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingCreditGrantsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingCreditGrantsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingCreditGrantsId(
          input,
          getBillingCreditGrantsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingCreditGrantsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingCreditGrantsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingCreditGrantsIdBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      expires_at: z.union([z.coerce.number(), z.enum([""])]).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postBillingCreditGrantsId",
    "/v1/billing/credit_grants/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingCreditGrantsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingCreditGrantsId(
          input,
          postBillingCreditGrantsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrantsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingCreditGrantsIdExpireParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingCreditGrantsIdExpireBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postBillingCreditGrantsIdExpire",
    "/v1/billing/credit_grants/:id/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingCreditGrantsIdExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsIdExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingCreditGrantsIdExpire(
          input,
          postBillingCreditGrantsIdExpire.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrantsIdExpire.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingCreditGrantsIdVoidParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingCreditGrantsIdVoidBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postBillingCreditGrantsIdVoid",
    "/v1/billing/credit_grants/:id/void",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingCreditGrantsIdVoidParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingCreditGrantsIdVoidBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingCreditGrantsIdVoid(
          input,
          postBillingCreditGrantsIdVoid.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingCreditGrantsIdVoid.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMeterEventAdjustmentsBodySchema = z.object({
    cancel: z.object({ identifier: z.string().max(100).optional() }).optional(),
    event_name: z.string().max(100),
    expand: z.array(z.string().max(5000)).optional(),
    type: z.enum(["cancel"]),
  })

  router.post(
    "postBillingMeterEventAdjustments",
    "/v1/billing/meter_event_adjustments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingMeterEventAdjustmentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingMeterEventAdjustments(
          input,
          postBillingMeterEventAdjustments.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMeterEventAdjustments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMeterEventsBodySchema = z.object({
    event_name: z.string().max(100),
    expand: z.array(z.string().max(5000)).optional(),
    identifier: z.string().max(100).optional(),
    payload: z.record(z.string()),
    timestamp: z.coerce.number().optional(),
  })

  router.post(
    "postBillingMeterEvents",
    "/v1/billing/meter_events",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingMeterEventsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingMeterEvents(input, postBillingMeterEvents.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMeterEvents.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingMetersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive"]).optional(),
  })

  const getBillingMetersBodySchema = z.object({}).optional()

  router.get("getBillingMeters", "/v1/billing/meters", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBillingMetersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getBillingMetersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getBillingMeters(input, getBillingMeters.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBillingMeters.validator(status, body)
    ctx.status = status
    return next()
  })

  const postBillingMetersBodySchema = z.object({
    customer_mapping: z
      .object({
        event_payload_key: z.string().max(100),
        type: z.enum(["by_id"]),
      })
      .optional(),
    default_aggregation: z.object({
      formula: z.enum(["count", "last", "sum"]),
    }),
    display_name: z.string().max(250),
    event_name: z.string().max(100),
    event_time_window: z.enum(["day", "hour"]).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    value_settings: z
      .object({ event_payload_key: z.string().max(100) })
      .optional(),
  })

  router.post("postBillingMeters", "/v1/billing/meters", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postBillingMetersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postBillingMeters(input, postBillingMeters.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postBillingMeters.validator(status, body)
    ctx.status = status
    return next()
  })

  const getBillingMetersIdParamSchema = z.object({ id: z.string().max(5000) })

  const getBillingMetersIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBillingMetersIdBodySchema = z.object({}).optional()

  router.get(
    "getBillingMetersId",
    "/v1/billing/meters/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingMetersIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingMetersIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingMetersIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingMetersId(input, getBillingMetersId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingMetersId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMetersIdParamSchema = z.object({ id: z.string().max(5000) })

  const postBillingMetersIdBodySchema = z
    .object({
      display_name: z.string().max(250).optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postBillingMetersId",
    "/v1/billing/meters/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingMetersIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingMetersIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingMetersId(input, postBillingMetersId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMetersId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMetersIdDeactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingMetersIdDeactivateBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postBillingMetersIdDeactivate",
    "/v1/billing/meters/:id/deactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingMetersIdDeactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingMetersIdDeactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingMetersIdDeactivate(
          input,
          postBillingMetersIdDeactivate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMetersIdDeactivate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingMetersIdEventSummariesParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getBillingMetersIdEventSummariesQuerySchema = z.object({
    customer: z.string().max(5000),
    end_time: z.coerce.number(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    start_time: z.coerce.number(),
    starting_after: z.string().max(5000).optional(),
    value_grouping_window: z.enum(["day", "hour"]).optional(),
  })

  const getBillingMetersIdEventSummariesBodySchema = z.object({}).optional()

  router.get(
    "getBillingMetersIdEventSummaries",
    "/v1/billing/meters/:id/event_summaries",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingMetersIdEventSummariesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingMetersIdEventSummariesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingMetersIdEventSummariesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingMetersIdEventSummaries(
          input,
          getBillingMetersIdEventSummaries.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingMetersIdEventSummaries.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingMetersIdReactivateParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postBillingMetersIdReactivateBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postBillingMetersIdReactivate",
    "/v1/billing/meters/:id/reactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingMetersIdReactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingMetersIdReactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingMetersIdReactivate(
          input,
          postBillingMetersIdReactivate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingMetersIdReactivate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingPortalConfigurationsQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    is_default: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getBillingPortalConfigurationsBodySchema = z.object({}).optional()

  router.get(
    "getBillingPortalConfigurations",
    "/v1/billing_portal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getBillingPortalConfigurationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingPortalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingPortalConfigurations(
          input,
          getBillingPortalConfigurations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingPortalConfigurations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postBillingPortalConfigurationsBodySchema = z.object({
    business_profile: z
      .object({
        headline: z.union([z.string().max(60), z.enum([""])]).optional(),
        privacy_policy_url: z.string().optional(),
        terms_of_service_url: z.string().optional(),
      })
      .optional(),
    default_return_url: z.union([z.string(), z.enum([""])]).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    features: z.object({
      customer_update: z
        .object({
          allowed_updates: z
            .union([
              z.array(
                z.enum([
                  "address",
                  "email",
                  "name",
                  "phone",
                  "shipping",
                  "tax_id",
                ]),
              ),
              z.enum([""]),
            ])
            .optional(),
          enabled: PermissiveBoolean,
        })
        .optional(),
      invoice_history: z.object({ enabled: PermissiveBoolean }).optional(),
      payment_method_update: z
        .object({ enabled: PermissiveBoolean })
        .optional(),
      subscription_cancel: z
        .object({
          cancellation_reason: z
            .object({
              enabled: PermissiveBoolean,
              options: z.union([
                z.array(
                  z.enum([
                    "customer_service",
                    "low_quality",
                    "missing_features",
                    "other",
                    "switched_service",
                    "too_complex",
                    "too_expensive",
                    "unused",
                  ]),
                ),
                z.enum([""]),
              ]),
            })
            .optional(),
          enabled: PermissiveBoolean,
          mode: z.enum(["at_period_end", "immediately"]).optional(),
          proration_behavior: z
            .enum(["always_invoice", "create_prorations", "none"])
            .optional(),
        })
        .optional(),
      subscription_update: z
        .object({
          default_allowed_updates: z
            .union([
              z.array(z.enum(["price", "promotion_code", "quantity"])),
              z.enum([""]),
            ])
            .optional(),
          enabled: PermissiveBoolean,
          products: z
            .union([
              z.array(
                z.object({
                  prices: z.array(z.string().max(5000)),
                  product: z.string().max(5000),
                }),
              ),
              z.enum([""]),
            ])
            .optional(),
          proration_behavior: z
            .enum(["always_invoice", "create_prorations", "none"])
            .optional(),
          schedule_at_period_end: z
            .object({
              conditions: z
                .array(
                  z.object({
                    type: z.enum([
                      "decreasing_item_amount",
                      "shortening_interval",
                    ]),
                  }),
                )
                .optional(),
            })
            .optional(),
        })
        .optional(),
    }),
    login_page: z.object({ enabled: PermissiveBoolean }).optional(),
    metadata: z.record(z.string()).optional(),
  })

  router.post(
    "postBillingPortalConfigurations",
    "/v1/billing_portal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingPortalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingPortalConfigurations(
          input,
          postBillingPortalConfigurations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingPortalConfigurations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getBillingPortalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getBillingPortalConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getBillingPortalConfigurationsConfigurationBodySchema = z
    .object({})
    .optional()

  router.get(
    "getBillingPortalConfigurationsConfiguration",
    "/v1/billing_portal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getBillingPortalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getBillingPortalConfigurationsConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getBillingPortalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getBillingPortalConfigurationsConfiguration(
          input,
          getBillingPortalConfigurationsConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getBillingPortalConfigurationsConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postBillingPortalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const postBillingPortalConfigurationsConfigurationBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      business_profile: z
        .object({
          headline: z.union([z.string().max(60), z.enum([""])]).optional(),
          privacy_policy_url: z.union([z.string(), z.enum([""])]).optional(),
          terms_of_service_url: z.union([z.string(), z.enum([""])]).optional(),
        })
        .optional(),
      default_return_url: z.union([z.string(), z.enum([""])]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      features: z
        .object({
          customer_update: z
            .object({
              allowed_updates: z
                .union([
                  z.array(
                    z.enum([
                      "address",
                      "email",
                      "name",
                      "phone",
                      "shipping",
                      "tax_id",
                    ]),
                  ),
                  z.enum([""]),
                ])
                .optional(),
              enabled: PermissiveBoolean.optional(),
            })
            .optional(),
          invoice_history: z.object({ enabled: PermissiveBoolean }).optional(),
          payment_method_update: z
            .object({ enabled: PermissiveBoolean })
            .optional(),
          subscription_cancel: z
            .object({
              cancellation_reason: z
                .object({
                  enabled: PermissiveBoolean,
                  options: z
                    .union([
                      z.array(
                        z.enum([
                          "customer_service",
                          "low_quality",
                          "missing_features",
                          "other",
                          "switched_service",
                          "too_complex",
                          "too_expensive",
                          "unused",
                        ]),
                      ),
                      z.enum([""]),
                    ])
                    .optional(),
                })
                .optional(),
              enabled: PermissiveBoolean.optional(),
              mode: z.enum(["at_period_end", "immediately"]).optional(),
              proration_behavior: z
                .enum(["always_invoice", "create_prorations", "none"])
                .optional(),
            })
            .optional(),
          subscription_update: z
            .object({
              default_allowed_updates: z
                .union([
                  z.array(z.enum(["price", "promotion_code", "quantity"])),
                  z.enum([""]),
                ])
                .optional(),
              enabled: PermissiveBoolean.optional(),
              products: z
                .union([
                  z.array(
                    z.object({
                      prices: z.array(z.string().max(5000)),
                      product: z.string().max(5000),
                    }),
                  ),
                  z.enum([""]),
                ])
                .optional(),
              proration_behavior: z
                .enum(["always_invoice", "create_prorations", "none"])
                .optional(),
              schedule_at_period_end: z
                .object({
                  conditions: z
                    .union([
                      z.array(
                        z.object({
                          type: z.enum([
                            "decreasing_item_amount",
                            "shortening_interval",
                          ]),
                        }),
                      ),
                      z.enum([""]),
                    ])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      login_page: z.object({ enabled: PermissiveBoolean }).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postBillingPortalConfigurationsConfiguration",
    "/v1/billing_portal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postBillingPortalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postBillingPortalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingPortalConfigurationsConfiguration(
          input,
          postBillingPortalConfigurationsConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingPortalConfigurationsConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postBillingPortalSessionsBodySchema = z.object({
    configuration: z.string().max(5000).optional(),
    customer: z.string().max(5000),
    expand: z.array(z.string().max(5000)).optional(),
    flow_data: z
      .object({
        after_completion: z
          .object({
            hosted_confirmation: z
              .object({ custom_message: z.string().max(500).optional() })
              .optional(),
            redirect: z.object({ return_url: z.string() }).optional(),
            type: z.enum([
              "hosted_confirmation",
              "portal_homepage",
              "redirect",
            ]),
          })
          .optional(),
        subscription_cancel: z
          .object({
            retention: z
              .object({
                coupon_offer: z.object({ coupon: z.string().max(5000) }),
                type: z.enum(["coupon_offer"]),
              })
              .optional(),
            subscription: z.string().max(5000),
          })
          .optional(),
        subscription_update: z
          .object({ subscription: z.string().max(5000) })
          .optional(),
        subscription_update_confirm: z
          .object({
            discounts: z
              .array(
                z.object({
                  coupon: z.string().max(5000).optional(),
                  promotion_code: z.string().max(5000).optional(),
                }),
              )
              .optional(),
            items: z.array(
              z.object({
                id: z.string().max(5000),
                price: z.string().max(5000).optional(),
                quantity: z.coerce.number().optional(),
              }),
            ),
            subscription: z.string().max(5000),
          })
          .optional(),
        type: z.enum([
          "payment_method_update",
          "subscription_cancel",
          "subscription_update",
          "subscription_update_confirm",
        ]),
      })
      .optional(),
    locale: z
      .enum([
        "auto",
        "bg",
        "cs",
        "da",
        "de",
        "el",
        "en",
        "en-AU",
        "en-CA",
        "en-GB",
        "en-IE",
        "en-IN",
        "en-NZ",
        "en-SG",
        "es",
        "es-419",
        "et",
        "fi",
        "fil",
        "fr",
        "fr-CA",
        "hr",
        "hu",
        "id",
        "it",
        "ja",
        "ko",
        "lt",
        "lv",
        "ms",
        "mt",
        "nb",
        "nl",
        "pl",
        "pt",
        "pt-BR",
        "ro",
        "ru",
        "sk",
        "sl",
        "sv",
        "th",
        "tr",
        "vi",
        "zh",
        "zh-HK",
        "zh-TW",
      ])
      .optional(),
    on_behalf_of: z.string().optional(),
    return_url: z.string().optional(),
  })

  router.post(
    "postBillingPortalSessions",
    "/v1/billing_portal/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postBillingPortalSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postBillingPortalSessions(
          input,
          postBillingPortalSessions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postBillingPortalSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
    transfer_group: z.string().max(5000).optional(),
  })

  const getChargesBodySchema = z.object({}).optional()

  router.get("getCharges", "/v1/charges", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getChargesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getChargesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getCharges(input, getCharges.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCharges.validator(status, body)
    ctx.status = status
    return next()
  })

  const postChargesBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      application_fee: z.coerce.number().optional(),
      application_fee_amount: z.coerce.number().optional(),
      capture: PermissiveBoolean.optional(),
      card: z
        .union([
          z.object({
            address_city: z.string().max(5000).optional(),
            address_country: z.string().max(5000).optional(),
            address_line1: z.string().max(5000).optional(),
            address_line2: z.string().max(5000).optional(),
            address_state: z.string().max(5000).optional(),
            address_zip: z.string().max(5000).optional(),
            cvc: z.string().max(5000).optional(),
            exp_month: z.coerce.number(),
            exp_year: z.coerce.number(),
            metadata: z.record(z.string()).optional(),
            name: z.string().max(5000).optional(),
            number: z.string().max(5000),
            object: z.enum(["card"]).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      currency: z.string().optional(),
      customer: z.string().max(500).optional(),
      description: z.string().max(40000).optional(),
      destination: z
        .union([
          z.object({
            account: z.string().max(5000),
            amount: z.coerce.number().optional(),
          }),
          z.string(),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      on_behalf_of: z.string().max(5000).optional(),
      radar_options: z
        .object({ session: z.string().max(5000).optional() })
        .optional(),
      receipt_email: z.string().optional(),
      shipping: z
        .object({
          address: z.object({
            city: z.string().max(5000).optional(),
            country: z.string().max(5000).optional(),
            line1: z.string().max(5000).optional(),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000).optional(),
            state: z.string().max(5000).optional(),
          }),
          carrier: z.string().max(5000).optional(),
          name: z.string().max(5000),
          phone: z.string().max(5000).optional(),
          tracking_number: z.string().max(5000).optional(),
        })
        .optional(),
      source: z.string().max(5000).optional(),
      statement_descriptor: z.string().max(22).optional(),
      statement_descriptor_suffix: z.string().max(22).optional(),
      transfer_data: z
        .object({
          amount: z.coerce.number().optional(),
          destination: z.string().max(5000),
        })
        .optional(),
      transfer_group: z.string().optional(),
    })
    .optional()

  router.post("postCharges", "/v1/charges", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postChargesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postCharges(input, postCharges.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCharges.validator(status, body)
    ctx.status = status
    return next()
  })

  const getChargesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  const getChargesSearchBodySchema = z.object({}).optional()

  router.get("getChargesSearch", "/v1/charges/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getChargesSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getChargesSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getChargesSearch(input, getChargesSearch.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getChargesSearch.validator(status, body)
    ctx.status = status
    return next()
  })

  const getChargesChargeParamSchema = z.object({ charge: z.string().max(5000) })

  const getChargesChargeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getChargesChargeBodySchema = z.object({}).optional()

  router.get("getChargesCharge", "/v1/charges/:charge", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getChargesChargeParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getChargesChargeQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getChargesChargeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getChargesCharge(input, getChargesCharge.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getChargesCharge.validator(status, body)
    ctx.status = status
    return next()
  })

  const postChargesChargeParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const postChargesChargeBodySchema = z
    .object({
      customer: z.string().max(5000).optional(),
      description: z.string().max(40000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      fraud_details: z
        .object({ user_report: z.enum(["", "fraudulent", "safe"]) })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      receipt_email: z.string().max(5000).optional(),
      shipping: z
        .object({
          address: z.object({
            city: z.string().max(5000).optional(),
            country: z.string().max(5000).optional(),
            line1: z.string().max(5000).optional(),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000).optional(),
            state: z.string().max(5000).optional(),
          }),
          carrier: z.string().max(5000).optional(),
          name: z.string().max(5000),
          phone: z.string().max(5000).optional(),
          tracking_number: z.string().max(5000).optional(),
        })
        .optional(),
      transfer_group: z.string().optional(),
    })
    .optional()

  router.post("postChargesCharge", "/v1/charges/:charge", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postChargesChargeParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postChargesChargeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postChargesCharge(input, postChargesCharge.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postChargesCharge.validator(status, body)
    ctx.status = status
    return next()
  })

  const postChargesChargeCaptureParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const postChargesChargeCaptureBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      application_fee: z.coerce.number().optional(),
      application_fee_amount: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      receipt_email: z.string().optional(),
      statement_descriptor: z.string().max(22).optional(),
      statement_descriptor_suffix: z.string().max(22).optional(),
      transfer_data: z
        .object({ amount: z.coerce.number().optional() })
        .optional(),
      transfer_group: z.string().optional(),
    })
    .optional()

  router.post(
    "postChargesChargeCapture",
    "/v1/charges/:charge/capture",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeCaptureParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postChargesChargeCapture(
          input,
          postChargesChargeCapture.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeCapture.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesChargeDisputeParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const getChargesChargeDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getChargesChargeDisputeBodySchema = z.object({}).optional()

  router.get(
    "getChargesChargeDispute",
    "/v1/charges/:charge/dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getChargesChargeDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getChargesChargeDisputeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getChargesChargeDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getChargesChargeDispute(input, getChargesChargeDispute.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getChargesChargeDispute.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeDisputeParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const postChargesChargeDisputeBodySchema = z
    .object({
      evidence: z
        .object({
          access_activity_log: z.string().max(20000).optional(),
          billing_address: z.string().max(5000).optional(),
          cancellation_policy: z.string().optional(),
          cancellation_policy_disclosure: z.string().max(20000).optional(),
          cancellation_rebuttal: z.string().max(20000).optional(),
          customer_communication: z.string().optional(),
          customer_email_address: z.string().max(5000).optional(),
          customer_name: z.string().max(5000).optional(),
          customer_purchase_ip: z.string().max(5000).optional(),
          customer_signature: z.string().optional(),
          duplicate_charge_documentation: z.string().optional(),
          duplicate_charge_explanation: z.string().max(20000).optional(),
          duplicate_charge_id: z.string().max(5000).optional(),
          enhanced_evidence: z
            .union([
              z.object({
                visa_compelling_evidence_3: z
                  .object({
                    disputed_transaction: z
                      .object({
                        customer_account_id: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_device_fingerprint: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_device_id: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_email_address: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_purchase_ip: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        merchandise_or_services: z
                          .enum(["merchandise", "services"])
                          .optional(),
                        product_description: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        shipping_address: z
                          .object({
                            city: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            country: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            line1: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            line2: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            postal_code: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            state: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                          })
                          .optional(),
                      })
                      .optional(),
                    prior_undisputed_transactions: z
                      .array(
                        z.object({
                          charge: z.string().max(5000),
                          customer_account_id: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_device_fingerprint: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_device_id: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_email_address: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_purchase_ip: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          product_description: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          shipping_address: z
                            .object({
                              city: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              country: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              line1: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              line2: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              postal_code: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              state: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                            })
                            .optional(),
                        }),
                      )
                      .optional(),
                  })
                  .optional(),
                visa_compliance: z
                  .object({ fee_acknowledged: PermissiveBoolean.optional() })
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          product_description: z.string().max(20000).optional(),
          receipt: z.string().optional(),
          refund_policy: z.string().optional(),
          refund_policy_disclosure: z.string().max(20000).optional(),
          refund_refusal_explanation: z.string().max(20000).optional(),
          service_date: z.string().max(5000).optional(),
          service_documentation: z.string().optional(),
          shipping_address: z.string().max(5000).optional(),
          shipping_carrier: z.string().max(5000).optional(),
          shipping_date: z.string().max(5000).optional(),
          shipping_documentation: z.string().optional(),
          shipping_tracking_number: z.string().max(5000).optional(),
          uncategorized_file: z.string().optional(),
          uncategorized_text: z.string().max(20000).optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      submit: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postChargesChargeDispute",
    "/v1/charges/:charge/dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postChargesChargeDispute(
          input,
          postChargesChargeDispute.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeDispute.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeDisputeCloseParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const postChargesChargeDisputeCloseBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postChargesChargeDisputeClose",
    "/v1/charges/:charge/dispute/close",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeDisputeCloseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeDisputeCloseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postChargesChargeDisputeClose(
          input,
          postChargesChargeDisputeClose.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeDisputeClose.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeRefundParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const postChargesChargeRefundBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      instructions_email: z.string().optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      payment_intent: z.string().max(5000).optional(),
      reason: z
        .enum(["duplicate", "fraudulent", "requested_by_customer"])
        .optional(),
      refund_application_fee: PermissiveBoolean.optional(),
      reverse_transfer: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postChargesChargeRefund",
    "/v1/charges/:charge/refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postChargesChargeRefund(input, postChargesChargeRefund.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeRefund.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesChargeRefundsParamSchema = z.object({ charge: z.string() })

  const getChargesChargeRefundsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  const getChargesChargeRefundsBodySchema = z.object({}).optional()

  router.get(
    "getChargesChargeRefunds",
    "/v1/charges/:charge/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getChargesChargeRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getChargesChargeRefundsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getChargesChargeRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getChargesChargeRefunds(input, getChargesChargeRefunds.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getChargesChargeRefunds.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeRefundsParamSchema = z.object({
    charge: z.string().max(5000),
  })

  const postChargesChargeRefundsBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      currency: z.string().optional(),
      customer: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      instructions_email: z.string().optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      origin: z.enum(["customer_balance"]).optional(),
      payment_intent: z.string().max(5000).optional(),
      reason: z
        .enum(["duplicate", "fraudulent", "requested_by_customer"])
        .optional(),
      refund_application_fee: PermissiveBoolean.optional(),
      reverse_transfer: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postChargesChargeRefunds",
    "/v1/charges/:charge/refunds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeRefundsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeRefundsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postChargesChargeRefunds(
          input,
          postChargesChargeRefunds.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeRefunds.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getChargesChargeRefundsRefundParamSchema = z.object({
    charge: z.string(),
    refund: z.string(),
  })

  const getChargesChargeRefundsRefundQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getChargesChargeRefundsRefundBodySchema = z.object({}).optional()

  router.get(
    "getChargesChargeRefundsRefund",
    "/v1/charges/:charge/refunds/:refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getChargesChargeRefundsRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getChargesChargeRefundsRefundQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getChargesChargeRefundsRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getChargesChargeRefundsRefund(
          input,
          getChargesChargeRefundsRefund.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getChargesChargeRefundsRefund.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postChargesChargeRefundsRefundParamSchema = z.object({
    charge: z.string(),
    refund: z.string(),
  })

  const postChargesChargeRefundsRefundBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postChargesChargeRefundsRefund",
    "/v1/charges/:charge/refunds/:refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postChargesChargeRefundsRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postChargesChargeRefundsRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postChargesChargeRefundsRefund(
          input,
          postChargesChargeRefundsRefund.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postChargesChargeRefundsRefund.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCheckoutSessionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    customer_details: z.object({ email: z.string() }).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    payment_link: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["complete", "expired", "open"]).optional(),
    subscription: z.string().max(5000).optional(),
  })

  const getCheckoutSessionsBodySchema = z.object({}).optional()

  router.get(
    "getCheckoutSessions",
    "/v1/checkout/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCheckoutSessionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCheckoutSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCheckoutSessions(input, getCheckoutSessions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCheckoutSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCheckoutSessionsBodySchema = z
    .object({
      adaptive_pricing: z
        .object({ enabled: PermissiveBoolean.optional() })
        .optional(),
      after_expiration: z
        .object({
          recovery: z
            .object({
              allow_promotion_codes: PermissiveBoolean.optional(),
              enabled: PermissiveBoolean,
            })
            .optional(),
        })
        .optional(),
      allow_promotion_codes: PermissiveBoolean.optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      billing_address_collection: z.enum(["auto", "required"]).optional(),
      cancel_url: z.string().max(5000).optional(),
      client_reference_id: z.string().max(200).optional(),
      consent_collection: z
        .object({
          payment_method_reuse_agreement: z
            .object({ position: z.enum(["auto", "hidden"]) })
            .optional(),
          promotions: z.enum(["auto", "none"]).optional(),
          terms_of_service: z.enum(["none", "required"]).optional(),
        })
        .optional(),
      currency: z.string().optional(),
      custom_fields: z
        .array(
          z.object({
            dropdown: z
              .object({
                default_value: z.string().max(100).optional(),
                options: z.array(
                  z.object({
                    label: z.string().max(100),
                    value: z.string().max(100),
                  }),
                ),
              })
              .optional(),
            key: z.string().max(200),
            label: z.object({
              custom: z.string().max(50),
              type: z.enum(["custom"]),
            }),
            numeric: z
              .object({
                default_value: z.string().max(255).optional(),
                maximum_length: z.coerce.number().optional(),
                minimum_length: z.coerce.number().optional(),
              })
              .optional(),
            optional: PermissiveBoolean.optional(),
            text: z
              .object({
                default_value: z.string().max(255).optional(),
                maximum_length: z.coerce.number().optional(),
                minimum_length: z.coerce.number().optional(),
              })
              .optional(),
            type: z.enum(["dropdown", "numeric", "text"]),
          }),
        )
        .optional(),
      custom_text: z
        .object({
          after_submit: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
          shipping_address: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
          submit: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
          terms_of_service_acceptance: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
        })
        .optional(),
      customer: z.string().max(5000).optional(),
      customer_creation: z.enum(["always", "if_required"]).optional(),
      customer_email: z.string().optional(),
      customer_update: z
        .object({
          address: z.enum(["auto", "never"]).optional(),
          name: z.enum(["auto", "never"]).optional(),
          shipping: z.enum(["auto", "never"]).optional(),
        })
        .optional(),
      discounts: z
        .array(
          z.object({
            coupon: z.string().max(5000).optional(),
            promotion_code: z.string().max(5000).optional(),
          }),
        )
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      expires_at: z.coerce.number().optional(),
      invoice_creation: z
        .object({
          enabled: PermissiveBoolean,
          invoice_data: z
            .object({
              account_tax_ids: z
                .union([z.array(z.string().max(5000)), z.enum([""])])
                .optional(),
              custom_fields: z
                .union([
                  z.array(
                    z.object({
                      name: z.string().max(40),
                      value: z.string().max(140),
                    }),
                  ),
                  z.enum([""]),
                ])
                .optional(),
              description: z.string().max(1500).optional(),
              footer: z.string().max(5000).optional(),
              issuer: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
              metadata: z.record(z.string()).optional(),
              rendering_options: z
                .union([
                  z.object({
                    amount_tax_display: z
                      .enum(["", "exclude_tax", "include_inclusive_tax"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      line_items: z
        .array(
          z.object({
            adjustable_quantity: z
              .object({
                enabled: PermissiveBoolean,
                maximum: z.coerce.number().optional(),
                minimum: z.coerce.number().optional(),
              })
              .optional(),
            dynamic_tax_rates: z.array(z.string().max(5000)).optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000).optional(),
                product_data: z
                  .object({
                    description: z.string().max(40000).optional(),
                    images: z.array(z.string()).optional(),
                    metadata: z.record(z.string()).optional(),
                    name: z.string().max(5000),
                    tax_code: z.string().max(5000).optional(),
                  })
                  .optional(),
                recurring: z
                  .object({
                    interval: z.enum(["day", "month", "week", "year"]),
                    interval_count: z.coerce.number().optional(),
                  })
                  .optional(),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z.array(z.string().max(5000)).optional(),
          }),
        )
        .optional(),
      locale: z
        .enum([
          "auto",
          "bg",
          "cs",
          "da",
          "de",
          "el",
          "en",
          "en-GB",
          "es",
          "es-419",
          "et",
          "fi",
          "fil",
          "fr",
          "fr-CA",
          "hr",
          "hu",
          "id",
          "it",
          "ja",
          "ko",
          "lt",
          "lv",
          "ms",
          "mt",
          "nb",
          "nl",
          "pl",
          "pt",
          "pt-BR",
          "ro",
          "ru",
          "sk",
          "sl",
          "sv",
          "th",
          "tr",
          "vi",
          "zh",
          "zh-HK",
          "zh-TW",
        ])
        .optional(),
      metadata: z.record(z.string()).optional(),
      mode: z.enum(["payment", "setup", "subscription"]).optional(),
      optional_items: z
        .array(
          z.object({
            adjustable_quantity: z
              .object({
                enabled: PermissiveBoolean,
                maximum: z.coerce.number().optional(),
                minimum: z.coerce.number().optional(),
              })
              .optional(),
            price: z.string().max(5000),
            quantity: z.coerce.number(),
          }),
        )
        .optional(),
      payment_intent_data: z
        .object({
          application_fee_amount: z.coerce.number().optional(),
          capture_method: z
            .enum(["automatic", "automatic_async", "manual"])
            .optional(),
          description: z.string().max(1000).optional(),
          metadata: z.record(z.string()).optional(),
          on_behalf_of: z.string().optional(),
          receipt_email: z.string().optional(),
          setup_future_usage: z.enum(["off_session", "on_session"]).optional(),
          shipping: z
            .object({
              address: z.object({
                city: z.string().max(5000).optional(),
                country: z.string().max(5000).optional(),
                line1: z.string().max(5000),
                line2: z.string().max(5000).optional(),
                postal_code: z.string().max(5000).optional(),
                state: z.string().max(5000).optional(),
              }),
              carrier: z.string().max(5000).optional(),
              name: z.string().max(5000),
              phone: z.string().max(5000).optional(),
              tracking_number: z.string().max(5000).optional(),
            })
            .optional(),
          statement_descriptor: z.string().max(22).optional(),
          statement_descriptor_suffix: z.string().max(22).optional(),
          transfer_data: z
            .object({
              amount: z.coerce.number().optional(),
              destination: z.string(),
            })
            .optional(),
          transfer_group: z.string().optional(),
        })
        .optional(),
      payment_method_collection: z.enum(["always", "if_required"]).optional(),
      payment_method_configuration: z.string().max(100).optional(),
      payment_method_data: z
        .object({
          allow_redisplay: z
            .enum(["always", "limited", "unspecified"])
            .optional(),
        })
        .optional(),
      payment_method_options: z
        .object({
          acss_debit: z
            .object({
              currency: z.enum(["cad", "usd"]).optional(),
              mandate_options: z
                .object({
                  custom_mandate_url: z
                    .union([z.string(), z.enum([""])])
                    .optional(),
                  default_for: z
                    .array(z.enum(["invoice", "subscription"]))
                    .optional(),
                  interval_description: z.string().max(500).optional(),
                  payment_schedule: z
                    .enum(["combined", "interval", "sporadic"])
                    .optional(),
                  transaction_type: z.enum(["business", "personal"]).optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            })
            .optional(),
          affirm: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          afterpay_clearpay: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          alipay: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          amazon_pay: z
            .object({
              setup_future_usage: z.enum(["none", "off_session"]).optional(),
            })
            .optional(),
          au_becs_debit: z
            .object({
              setup_future_usage: z.enum(["none"]).optional(),
              target_date: z.string().max(5000).optional(),
            })
            .optional(),
          bacs_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
            })
            .optional(),
          bancontact: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          boleto: z
            .object({
              expires_after_days: z.coerce.number().optional(),
              setup_future_usage: z
                .enum(["none", "off_session", "on_session"])
                .optional(),
            })
            .optional(),
          card: z
            .object({
              installments: z
                .object({ enabled: PermissiveBoolean.optional() })
                .optional(),
              request_extended_authorization: z
                .enum(["if_available", "never"])
                .optional(),
              request_incremental_authorization: z
                .enum(["if_available", "never"])
                .optional(),
              request_multicapture: z
                .enum(["if_available", "never"])
                .optional(),
              request_overcapture: z.enum(["if_available", "never"]).optional(),
              request_three_d_secure: z
                .enum(["any", "automatic", "challenge"])
                .optional(),
              restrictions: z
                .object({
                  brands_blocked: z
                    .array(
                      z.enum([
                        "american_express",
                        "discover_global_network",
                        "mastercard",
                        "visa",
                      ]),
                    )
                    .optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["off_session", "on_session"])
                .optional(),
              statement_descriptor_suffix_kana: z.string().max(22).optional(),
              statement_descriptor_suffix_kanji: z.string().max(17).optional(),
            })
            .optional(),
          cashapp: z
            .object({
              setup_future_usage: z
                .enum(["none", "off_session", "on_session"])
                .optional(),
            })
            .optional(),
          customer_balance: z
            .object({
              bank_transfer: z
                .object({
                  eu_bank_transfer: z
                    .object({ country: z.string().max(5000) })
                    .optional(),
                  requested_address_types: z
                    .array(
                      z.enum([
                        "aba",
                        "iban",
                        "sepa",
                        "sort_code",
                        "spei",
                        "swift",
                        "zengin",
                      ]),
                    )
                    .optional(),
                  type: z.enum([
                    "eu_bank_transfer",
                    "gb_bank_transfer",
                    "jp_bank_transfer",
                    "mx_bank_transfer",
                    "us_bank_transfer",
                  ]),
                })
                .optional(),
              funding_type: z.enum(["bank_transfer"]).optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            })
            .optional(),
          eps: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          fpx: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          giropay: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          grabpay: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          ideal: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          kakao_pay: z
            .object({
              capture_method: z.enum(["manual"]).optional(),
              setup_future_usage: z.enum(["none", "off_session"]).optional(),
            })
            .optional(),
          klarna: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          konbini: z
            .object({
              expires_after_days: z.coerce.number().optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            })
            .optional(),
          kr_card: z
            .object({
              capture_method: z.enum(["manual"]).optional(),
              setup_future_usage: z.enum(["none", "off_session"]).optional(),
            })
            .optional(),
          link: z
            .object({
              setup_future_usage: z.enum(["none", "off_session"]).optional(),
            })
            .optional(),
          mobilepay: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          multibanco: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          naver_pay: z
            .object({
              capture_method: z.enum(["manual"]).optional(),
              setup_future_usage: z.enum(["none", "off_session"]).optional(),
            })
            .optional(),
          oxxo: z
            .object({
              expires_after_days: z.coerce.number().optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            })
            .optional(),
          p24: z
            .object({
              setup_future_usage: z.enum(["none"]).optional(),
              tos_shown_and_accepted: PermissiveBoolean.optional(),
            })
            .optional(),
          pay_by_bank: z.object({}).optional(),
          payco: z
            .object({ capture_method: z.enum(["manual"]).optional() })
            .optional(),
          paynow: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          paypal: z
            .object({
              capture_method: z.enum(["", "manual"]).optional(),
              preferred_locale: z
                .enum([
                  "cs-CZ",
                  "da-DK",
                  "de-AT",
                  "de-DE",
                  "de-LU",
                  "el-GR",
                  "en-GB",
                  "en-US",
                  "es-ES",
                  "fi-FI",
                  "fr-BE",
                  "fr-FR",
                  "fr-LU",
                  "hu-HU",
                  "it-IT",
                  "nl-BE",
                  "nl-NL",
                  "pl-PL",
                  "pt-PT",
                  "sk-SK",
                  "sv-SE",
                ])
                .optional(),
              reference: z.string().max(127).optional(),
              risk_correlation_id: z.string().max(32).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            })
            .optional(),
          pix: z
            .object({ expires_after_seconds: z.coerce.number().optional() })
            .optional(),
          revolut_pay: z
            .object({
              setup_future_usage: z.enum(["none", "off_session"]).optional(),
            })
            .optional(),
          samsung_pay: z
            .object({ capture_method: z.enum(["manual"]).optional() })
            .optional(),
          sepa_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
            })
            .optional(),
          sofort: z
            .object({ setup_future_usage: z.enum(["none"]).optional() })
            .optional(),
          swish: z
            .object({ reference: z.string().max(5000).optional() })
            .optional(),
          us_bank_account: z
            .object({
              financial_connections: z
                .object({
                  permissions: z
                    .array(
                      z.enum([
                        "balances",
                        "ownership",
                        "payment_method",
                        "transactions",
                      ]),
                    )
                    .optional(),
                  prefetch: z
                    .array(z.enum(["balances", "ownership", "transactions"]))
                    .optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
              verification_method: z.enum(["automatic", "instant"]).optional(),
            })
            .optional(),
          wechat_pay: z
            .object({
              app_id: z.string().max(5000).optional(),
              client: z.enum(["android", "ios", "web"]),
              setup_future_usage: z.enum(["none"]).optional(),
            })
            .optional(),
        })
        .optional(),
      payment_method_types: z
        .array(
          z.enum([
            "acss_debit",
            "affirm",
            "afterpay_clearpay",
            "alipay",
            "alma",
            "amazon_pay",
            "au_becs_debit",
            "bacs_debit",
            "bancontact",
            "billie",
            "blik",
            "boleto",
            "card",
            "cashapp",
            "customer_balance",
            "eps",
            "fpx",
            "giropay",
            "grabpay",
            "ideal",
            "kakao_pay",
            "klarna",
            "konbini",
            "kr_card",
            "link",
            "mobilepay",
            "multibanco",
            "naver_pay",
            "oxxo",
            "p24",
            "pay_by_bank",
            "payco",
            "paynow",
            "paypal",
            "pix",
            "promptpay",
            "revolut_pay",
            "samsung_pay",
            "satispay",
            "sepa_debit",
            "sofort",
            "swish",
            "twint",
            "us_bank_account",
            "wechat_pay",
            "zip",
          ]),
        )
        .optional(),
      permissions: z
        .object({
          update_shipping_details: z
            .enum(["client_only", "server_only"])
            .optional(),
        })
        .optional(),
      phone_number_collection: z
        .object({ enabled: PermissiveBoolean })
        .optional(),
      redirect_on_completion: z
        .enum(["always", "if_required", "never"])
        .optional(),
      return_url: z.string().max(5000).optional(),
      saved_payment_method_options: z
        .object({
          allow_redisplay_filters: z
            .array(z.enum(["always", "limited", "unspecified"]))
            .optional(),
          payment_method_save: z.enum(["disabled", "enabled"]).optional(),
        })
        .optional(),
      setup_intent_data: z
        .object({
          description: z.string().max(1000).optional(),
          metadata: z.record(z.string()).optional(),
          on_behalf_of: z.string().optional(),
        })
        .optional(),
      shipping_address_collection: z
        .object({
          allowed_countries: z.array(
            z.enum([
              "AC",
              "AD",
              "AE",
              "AF",
              "AG",
              "AI",
              "AL",
              "AM",
              "AO",
              "AQ",
              "AR",
              "AT",
              "AU",
              "AW",
              "AX",
              "AZ",
              "BA",
              "BB",
              "BD",
              "BE",
              "BF",
              "BG",
              "BH",
              "BI",
              "BJ",
              "BL",
              "BM",
              "BN",
              "BO",
              "BQ",
              "BR",
              "BS",
              "BT",
              "BV",
              "BW",
              "BY",
              "BZ",
              "CA",
              "CD",
              "CF",
              "CG",
              "CH",
              "CI",
              "CK",
              "CL",
              "CM",
              "CN",
              "CO",
              "CR",
              "CV",
              "CW",
              "CY",
              "CZ",
              "DE",
              "DJ",
              "DK",
              "DM",
              "DO",
              "DZ",
              "EC",
              "EE",
              "EG",
              "EH",
              "ER",
              "ES",
              "ET",
              "FI",
              "FJ",
              "FK",
              "FO",
              "FR",
              "GA",
              "GB",
              "GD",
              "GE",
              "GF",
              "GG",
              "GH",
              "GI",
              "GL",
              "GM",
              "GN",
              "GP",
              "GQ",
              "GR",
              "GS",
              "GT",
              "GU",
              "GW",
              "GY",
              "HK",
              "HN",
              "HR",
              "HT",
              "HU",
              "ID",
              "IE",
              "IL",
              "IM",
              "IN",
              "IO",
              "IQ",
              "IS",
              "IT",
              "JE",
              "JM",
              "JO",
              "JP",
              "KE",
              "KG",
              "KH",
              "KI",
              "KM",
              "KN",
              "KR",
              "KW",
              "KY",
              "KZ",
              "LA",
              "LB",
              "LC",
              "LI",
              "LK",
              "LR",
              "LS",
              "LT",
              "LU",
              "LV",
              "LY",
              "MA",
              "MC",
              "MD",
              "ME",
              "MF",
              "MG",
              "MK",
              "ML",
              "MM",
              "MN",
              "MO",
              "MQ",
              "MR",
              "MS",
              "MT",
              "MU",
              "MV",
              "MW",
              "MX",
              "MY",
              "MZ",
              "NA",
              "NC",
              "NE",
              "NG",
              "NI",
              "NL",
              "NO",
              "NP",
              "NR",
              "NU",
              "NZ",
              "OM",
              "PA",
              "PE",
              "PF",
              "PG",
              "PH",
              "PK",
              "PL",
              "PM",
              "PN",
              "PR",
              "PS",
              "PT",
              "PY",
              "QA",
              "RE",
              "RO",
              "RS",
              "RU",
              "RW",
              "SA",
              "SB",
              "SC",
              "SD",
              "SE",
              "SG",
              "SH",
              "SI",
              "SJ",
              "SK",
              "SL",
              "SM",
              "SN",
              "SO",
              "SR",
              "SS",
              "ST",
              "SV",
              "SX",
              "SZ",
              "TA",
              "TC",
              "TD",
              "TF",
              "TG",
              "TH",
              "TJ",
              "TK",
              "TL",
              "TM",
              "TN",
              "TO",
              "TR",
              "TT",
              "TV",
              "TW",
              "TZ",
              "UA",
              "UG",
              "US",
              "UY",
              "UZ",
              "VA",
              "VC",
              "VE",
              "VG",
              "VN",
              "VU",
              "WF",
              "WS",
              "XK",
              "YE",
              "YT",
              "ZA",
              "ZM",
              "ZW",
              "ZZ",
            ]),
          ),
        })
        .optional(),
      shipping_options: z
        .array(
          z.object({
            shipping_rate: z.string().max(5000).optional(),
            shipping_rate_data: z
              .object({
                delivery_estimate: z
                  .object({
                    maximum: z
                      .object({
                        unit: z.enum([
                          "business_day",
                          "day",
                          "hour",
                          "month",
                          "week",
                        ]),
                        value: z.coerce.number(),
                      })
                      .optional(),
                    minimum: z
                      .object({
                        unit: z.enum([
                          "business_day",
                          "day",
                          "hour",
                          "month",
                          "week",
                        ]),
                        value: z.coerce.number(),
                      })
                      .optional(),
                  })
                  .optional(),
                display_name: z.string().max(100),
                fixed_amount: z
                  .object({
                    amount: z.coerce.number(),
                    currency: z.string(),
                    currency_options: z
                      .record(
                        z.object({
                          amount: z.coerce.number(),
                          tax_behavior: z
                            .enum(["exclusive", "inclusive", "unspecified"])
                            .optional(),
                        }),
                      )
                      .optional(),
                  })
                  .optional(),
                metadata: z.record(z.string()).optional(),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                tax_code: z.string().optional(),
                type: z.enum(["fixed_amount"]).optional(),
              })
              .optional(),
          }),
        )
        .optional(),
      submit_type: z
        .enum(["auto", "book", "donate", "pay", "subscribe"])
        .optional(),
      subscription_data: z
        .object({
          application_fee_percent: z.coerce.number().optional(),
          billing_cycle_anchor: z.coerce.number().optional(),
          default_tax_rates: z.array(z.string().max(5000)).optional(),
          description: z.string().max(500).optional(),
          invoice_settings: z
            .object({
              issuer: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
            })
            .optional(),
          metadata: z.record(z.string()).optional(),
          on_behalf_of: z.string().optional(),
          proration_behavior: z.enum(["create_prorations", "none"]).optional(),
          transfer_data: z
            .object({
              amount_percent: z.coerce.number().optional(),
              destination: z.string(),
            })
            .optional(),
          trial_end: z.coerce.number().optional(),
          trial_period_days: z.coerce.number().optional(),
          trial_settings: z
            .object({
              end_behavior: z.object({
                missing_payment_method: z.enum([
                  "cancel",
                  "create_invoice",
                  "pause",
                ]),
              }),
            })
            .optional(),
        })
        .optional(),
      success_url: z.string().max(5000).optional(),
      tax_id_collection: z
        .object({
          enabled: PermissiveBoolean,
          required: z.enum(["if_supported", "never"]).optional(),
        })
        .optional(),
      ui_mode: z.enum(["custom", "embedded", "hosted"]).optional(),
    })
    .optional()

  router.post(
    "postCheckoutSessions",
    "/v1/checkout/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postCheckoutSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCheckoutSessions(input, postCheckoutSessions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCheckoutSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCheckoutSessionsSessionParamSchema = z.object({
    session: z.string().max(66),
  })

  const getCheckoutSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCheckoutSessionsSessionBodySchema = z.object({}).optional()

  router.get(
    "getCheckoutSessionsSession",
    "/v1/checkout/sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCheckoutSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCheckoutSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCheckoutSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCheckoutSessionsSession(
          input,
          getCheckoutSessionsSession.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCheckoutSessionsSession.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCheckoutSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const postCheckoutSessionsSessionBodySchema = z
    .object({
      collected_information: z
        .object({
          shipping_details: z
            .object({
              address: z.object({
                city: z.string().max(5000).optional(),
                country: z.string().max(5000),
                line1: z.string().max(5000),
                line2: z.string().max(5000).optional(),
                postal_code: z.string().max(5000).optional(),
                state: z.string().max(5000).optional(),
              }),
              name: z.string().max(255),
            })
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      shipping_options: z
        .union([
          z.array(
            z.object({
              shipping_rate: z.string().max(5000).optional(),
              shipping_rate_data: z
                .object({
                  delivery_estimate: z
                    .object({
                      maximum: z
                        .object({
                          unit: z.enum([
                            "business_day",
                            "day",
                            "hour",
                            "month",
                            "week",
                          ]),
                          value: z.coerce.number(),
                        })
                        .optional(),
                      minimum: z
                        .object({
                          unit: z.enum([
                            "business_day",
                            "day",
                            "hour",
                            "month",
                            "week",
                          ]),
                          value: z.coerce.number(),
                        })
                        .optional(),
                    })
                    .optional(),
                  display_name: z.string().max(100),
                  fixed_amount: z
                    .object({
                      amount: z.coerce.number(),
                      currency: z.string(),
                      currency_options: z
                        .record(
                          z.object({
                            amount: z.coerce.number(),
                            tax_behavior: z
                              .enum(["exclusive", "inclusive", "unspecified"])
                              .optional(),
                          }),
                        )
                        .optional(),
                    })
                    .optional(),
                  metadata: z.record(z.string()).optional(),
                  tax_behavior: z
                    .enum(["exclusive", "inclusive", "unspecified"])
                    .optional(),
                  tax_code: z.string().optional(),
                  type: z.enum(["fixed_amount"]).optional(),
                })
                .optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
    })
    .optional()

  router.post(
    "postCheckoutSessionsSession",
    "/v1/checkout/sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCheckoutSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCheckoutSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCheckoutSessionsSession(
          input,
          postCheckoutSessionsSession.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCheckoutSessionsSession.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCheckoutSessionsSessionExpireParamSchema = z.object({
    session: z.string().max(5000),
  })

  const postCheckoutSessionsSessionExpireBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postCheckoutSessionsSessionExpire",
    "/v1/checkout/sessions/:session/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCheckoutSessionsSessionExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCheckoutSessionsSessionExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCheckoutSessionsSessionExpire(
          input,
          postCheckoutSessionsSessionExpire.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCheckoutSessionsSessionExpire.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCheckoutSessionsSessionLineItemsParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getCheckoutSessionsSessionLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCheckoutSessionsSessionLineItemsBodySchema = z.object({}).optional()

  router.get(
    "getCheckoutSessionsSessionLineItems",
    "/v1/checkout/sessions/:session/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCheckoutSessionsSessionLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCheckoutSessionsSessionLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCheckoutSessionsSessionLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCheckoutSessionsSessionLineItems(
          input,
          getCheckoutSessionsSessionLineItems.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCheckoutSessionsSessionLineItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateOrdersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getClimateOrdersBodySchema = z.object({}).optional()

  router.get("getClimateOrders", "/v1/climate/orders", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getClimateOrdersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getClimateOrdersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getClimateOrders(input, getClimateOrders.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getClimateOrders.validator(status, body)
    ctx.status = status
    return next()
  })

  const postClimateOrdersBodySchema = z.object({
    amount: z.coerce.number().optional(),
    beneficiary: z.object({ public_name: z.string().max(5000) }).optional(),
    currency: z.string().max(5000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    metric_tons: z.string().optional(),
    product: z.string().max(5000),
  })

  router.post("postClimateOrders", "/v1/climate/orders", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postClimateOrdersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postClimateOrders(input, postClimateOrders.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postClimateOrders.validator(status, body)
    ctx.status = status
    return next()
  })

  const getClimateOrdersOrderParamSchema = z.object({
    order: z.string().max(5000),
  })

  const getClimateOrdersOrderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getClimateOrdersOrderBodySchema = z.object({}).optional()

  router.get(
    "getClimateOrdersOrder",
    "/v1/climate/orders/:order",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getClimateOrdersOrderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getClimateOrdersOrderQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateOrdersOrderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getClimateOrdersOrder(input, getClimateOrdersOrder.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateOrdersOrder.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postClimateOrdersOrderParamSchema = z.object({
    order: z.string().max(5000),
  })

  const postClimateOrdersOrderBodySchema = z
    .object({
      beneficiary: z
        .union([
          z.object({
            public_name: z.union([z.string().max(5000), z.enum([""])]),
          }),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postClimateOrdersOrder",
    "/v1/climate/orders/:order",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postClimateOrdersOrderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postClimateOrdersOrderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postClimateOrdersOrder(input, postClimateOrdersOrder.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postClimateOrdersOrder.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postClimateOrdersOrderCancelParamSchema = z.object({
    order: z.string().max(5000),
  })

  const postClimateOrdersOrderCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postClimateOrdersOrderCancel",
    "/v1/climate/orders/:order/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postClimateOrdersOrderCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postClimateOrdersOrderCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postClimateOrdersOrderCancel(
          input,
          postClimateOrdersOrderCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postClimateOrdersOrderCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateProductsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getClimateProductsBodySchema = z.object({}).optional()

  router.get(
    "getClimateProducts",
    "/v1/climate/products",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getClimateProductsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateProductsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getClimateProducts(input, getClimateProducts.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateProducts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateProductsProductParamSchema = z.object({
    product: z.string().max(5000),
  })

  const getClimateProductsProductQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getClimateProductsProductBodySchema = z.object({}).optional()

  router.get(
    "getClimateProductsProduct",
    "/v1/climate/products/:product",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getClimateProductsProductParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getClimateProductsProductQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateProductsProductBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getClimateProductsProduct(
          input,
          getClimateProductsProduct.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateProductsProduct.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateSuppliersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getClimateSuppliersBodySchema = z.object({}).optional()

  router.get(
    "getClimateSuppliers",
    "/v1/climate/suppliers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getClimateSuppliersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateSuppliersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getClimateSuppliers(input, getClimateSuppliers.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateSuppliers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getClimateSuppliersSupplierParamSchema = z.object({
    supplier: z.string().max(5000),
  })

  const getClimateSuppliersSupplierQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getClimateSuppliersSupplierBodySchema = z.object({}).optional()

  router.get(
    "getClimateSuppliersSupplier",
    "/v1/climate/suppliers/:supplier",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getClimateSuppliersSupplierParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getClimateSuppliersSupplierQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getClimateSuppliersSupplierBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getClimateSuppliersSupplier(
          input,
          getClimateSuppliersSupplier.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getClimateSuppliersSupplier.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getConfirmationTokensConfirmationTokenParamSchema = z.object({
    confirmation_token: z.string().max(5000),
  })

  const getConfirmationTokensConfirmationTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getConfirmationTokensConfirmationTokenBodySchema = z
    .object({})
    .optional()

  router.get(
    "getConfirmationTokensConfirmationToken",
    "/v1/confirmation_tokens/:confirmation_token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getConfirmationTokensConfirmationTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getConfirmationTokensConfirmationTokenQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getConfirmationTokensConfirmationTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getConfirmationTokensConfirmationToken(
          input,
          getConfirmationTokensConfirmationToken.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getConfirmationTokensConfirmationToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCountrySpecsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCountrySpecsBodySchema = z.object({}).optional()

  router.get("getCountrySpecs", "/v1/country_specs", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCountrySpecsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCountrySpecsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getCountrySpecs(input, getCountrySpecs.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCountrySpecs.validator(status, body)
    ctx.status = status
    return next()
  })

  const getCountrySpecsCountryParamSchema = z.object({
    country: z.string().max(5000),
  })

  const getCountrySpecsCountryQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCountrySpecsCountryBodySchema = z.object({}).optional()

  router.get(
    "getCountrySpecsCountry",
    "/v1/country_specs/:country",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCountrySpecsCountryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCountrySpecsCountryQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCountrySpecsCountryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCountrySpecsCountry(input, getCountrySpecsCountry.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCountrySpecsCountry.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCouponsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCouponsBodySchema = z.object({}).optional()

  router.get("getCoupons", "/v1/coupons", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCouponsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCouponsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getCoupons(input, getCoupons.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCoupons.validator(status, body)
    ctx.status = status
    return next()
  })

  const postCouponsBodySchema = z
    .object({
      amount_off: z.coerce.number().optional(),
      applies_to: z
        .object({ products: z.array(z.string().max(5000)).optional() })
        .optional(),
      currency: z.string().optional(),
      currency_options: z
        .record(z.object({ amount_off: z.coerce.number() }))
        .optional(),
      duration: z.enum(["forever", "once", "repeating"]).optional(),
      duration_in_months: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      id: z.string().max(5000).optional(),
      max_redemptions: z.coerce.number().optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(40).optional(),
      percent_off: z.coerce.number().optional(),
      redeem_by: z.coerce.number().optional(),
    })
    .optional()

  router.post("postCoupons", "/v1/coupons", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postCouponsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postCoupons(input, postCoupons.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCoupons.validator(status, body)
    ctx.status = status
    return next()
  })

  const deleteCouponsCouponParamSchema = z.object({
    coupon: z.string().max(5000),
  })

  const deleteCouponsCouponBodySchema = z.object({}).optional()

  router.delete(
    "deleteCouponsCoupon",
    "/v1/coupons/:coupon",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCouponsCouponParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCouponsCouponBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCouponsCoupon(input, deleteCouponsCoupon.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCouponsCoupon.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCouponsCouponParamSchema = z.object({ coupon: z.string().max(5000) })

  const getCouponsCouponQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCouponsCouponBodySchema = z.object({}).optional()

  router.get("getCouponsCoupon", "/v1/coupons/:coupon", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getCouponsCouponParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getCouponsCouponQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCouponsCouponBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getCouponsCoupon(input, getCouponsCoupon.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCouponsCoupon.validator(status, body)
    ctx.status = status
    return next()
  })

  const postCouponsCouponParamSchema = z.object({
    coupon: z.string().max(5000),
  })

  const postCouponsCouponBodySchema = z
    .object({
      currency_options: z
        .record(z.object({ amount_off: z.coerce.number() }))
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(40).optional(),
    })
    .optional()

  router.post("postCouponsCoupon", "/v1/coupons/:coupon", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postCouponsCouponParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postCouponsCouponBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postCouponsCoupon(input, postCouponsCoupon.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCouponsCoupon.validator(status, body)
    ctx.status = status
    return next()
  })

  const getCreditNotesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCreditNotesBodySchema = z.object({}).optional()

  router.get("getCreditNotes", "/v1/credit_notes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCreditNotesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCreditNotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getCreditNotes(input, getCreditNotes.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCreditNotes.validator(status, body)
    ctx.status = status
    return next()
  })

  const postCreditNotesBodySchema = z.object({
    amount: z.coerce.number().optional(),
    credit_amount: z.coerce.number().optional(),
    effective_at: z.coerce.number().optional(),
    email_type: z.enum(["credit_note", "none"]).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    invoice: z.string().max(5000),
    lines: z
      .array(
        z.object({
          amount: z.coerce.number().optional(),
          description: z.string().max(5000).optional(),
          invoice_line_item: z.string().max(5000).optional(),
          quantity: z.coerce.number().optional(),
          tax_amounts: z
            .union([
              z.array(
                z.object({
                  amount: z.coerce.number(),
                  tax_rate: z.string().max(5000),
                  taxable_amount: z.coerce.number(),
                }),
              ),
              z.enum([""]),
            ])
            .optional(),
          tax_rates: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
          type: z.enum(["custom_line_item", "invoice_line_item"]),
          unit_amount: z.coerce.number().optional(),
          unit_amount_decimal: z.string().optional(),
        }),
      )
      .optional(),
    memo: z.string().max(5000).optional(),
    metadata: z.record(z.string()).optional(),
    out_of_band_amount: z.coerce.number().optional(),
    reason: z
      .enum([
        "duplicate",
        "fraudulent",
        "order_change",
        "product_unsatisfactory",
      ])
      .optional(),
    refund_amount: z.coerce.number().optional(),
    refunds: z
      .array(
        z.object({
          amount_refunded: z.coerce.number().optional(),
          refund: z.string().optional(),
        }),
      )
      .optional(),
    shipping_cost: z
      .object({ shipping_rate: z.string().max(5000).optional() })
      .optional(),
  })

  router.post("postCreditNotes", "/v1/credit_notes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postCreditNotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postCreditNotes(input, postCreditNotes.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCreditNotes.validator(status, body)
    ctx.status = status
    return next()
  })

  const getCreditNotesPreviewQuerySchema = z.object({
    amount: z.coerce.number().optional(),
    credit_amount: z.coerce.number().optional(),
    effective_at: z.coerce.number().optional(),
    email_type: z.enum(["credit_note", "none"]).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000),
    lines: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount: z.coerce.number().optional(),
            description: z.string().max(5000).optional(),
            invoice_line_item: z.string().max(5000).optional(),
            quantity: z.coerce.number().optional(),
            tax_amounts: z
              .union([
                z.array(
                  z.object({
                    amount: z.coerce.number(),
                    tax_rate: z.string().max(5000),
                    taxable_amount: z.coerce.number(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            type: z.enum(["custom_line_item", "invoice_line_item"]),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          }),
        ),
      )
      .optional(),
    memo: z.string().max(5000).optional(),
    metadata: z.record(z.string()).optional(),
    out_of_band_amount: z.coerce.number().optional(),
    reason: z
      .enum([
        "duplicate",
        "fraudulent",
        "order_change",
        "product_unsatisfactory",
      ])
      .optional(),
    refund_amount: z.coerce.number().optional(),
    refunds: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount_refunded: z.coerce.number().optional(),
            refund: z.string().optional(),
          }),
        ),
      )
      .optional(),
    shipping_cost: z
      .object({ shipping_rate: z.string().max(5000).optional() })
      .optional(),
  })

  const getCreditNotesPreviewBodySchema = z.object({}).optional()

  router.get(
    "getCreditNotesPreview",
    "/v1/credit_notes/preview",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCreditNotesPreviewQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCreditNotesPreviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCreditNotesPreview(input, getCreditNotesPreview.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCreditNotesPreview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCreditNotesPreviewLinesQuerySchema = z.object({
    amount: z.coerce.number().optional(),
    credit_amount: z.coerce.number().optional(),
    effective_at: z.coerce.number().optional(),
    email_type: z.enum(["credit_note", "none"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000),
    limit: z.coerce.number().optional(),
    lines: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount: z.coerce.number().optional(),
            description: z.string().max(5000).optional(),
            invoice_line_item: z.string().max(5000).optional(),
            quantity: z.coerce.number().optional(),
            tax_amounts: z
              .union([
                z.array(
                  z.object({
                    amount: z.coerce.number(),
                    tax_rate: z.string().max(5000),
                    taxable_amount: z.coerce.number(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            type: z.enum(["custom_line_item", "invoice_line_item"]),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          }),
        ),
      )
      .optional(),
    memo: z.string().max(5000).optional(),
    metadata: z.record(z.string()).optional(),
    out_of_band_amount: z.coerce.number().optional(),
    reason: z
      .enum([
        "duplicate",
        "fraudulent",
        "order_change",
        "product_unsatisfactory",
      ])
      .optional(),
    refund_amount: z.coerce.number().optional(),
    refunds: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z.object({
            amount_refunded: z.coerce.number().optional(),
            refund: z.string().optional(),
          }),
        ),
      )
      .optional(),
    shipping_cost: z
      .object({ shipping_rate: z.string().max(5000).optional() })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCreditNotesPreviewLinesBodySchema = z.object({}).optional()

  router.get(
    "getCreditNotesPreviewLines",
    "/v1/credit_notes/preview/lines",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCreditNotesPreviewLinesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCreditNotesPreviewLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCreditNotesPreviewLines(
          input,
          getCreditNotesPreviewLines.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCreditNotesPreviewLines.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCreditNotesCreditNoteLinesParamSchema = z.object({
    credit_note: z.string().max(5000),
  })

  const getCreditNotesCreditNoteLinesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCreditNotesCreditNoteLinesBodySchema = z.object({}).optional()

  router.get(
    "getCreditNotesCreditNoteLines",
    "/v1/credit_notes/:credit_note/lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCreditNotesCreditNoteLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCreditNotesCreditNoteLinesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCreditNotesCreditNoteLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCreditNotesCreditNoteLines(
          input,
          getCreditNotesCreditNoteLines.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCreditNotesCreditNoteLines.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCreditNotesIdParamSchema = z.object({ id: z.string().max(5000) })

  const getCreditNotesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCreditNotesIdBodySchema = z.object({}).optional()

  router.get("getCreditNotesId", "/v1/credit_notes/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getCreditNotesIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getCreditNotesIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCreditNotesIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getCreditNotesId(input, getCreditNotesId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCreditNotesId.validator(status, body)
    ctx.status = status
    return next()
  })

  const postCreditNotesIdParamSchema = z.object({ id: z.string().max(5000) })

  const postCreditNotesIdBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      memo: z.string().max(5000).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postCreditNotesId",
    "/v1/credit_notes/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCreditNotesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCreditNotesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCreditNotesId(input, postCreditNotesId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCreditNotesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCreditNotesIdVoidParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postCreditNotesIdVoidBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postCreditNotesIdVoid",
    "/v1/credit_notes/:id/void",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCreditNotesIdVoidParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCreditNotesIdVoidBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCreditNotesIdVoid(input, postCreditNotesIdVoid.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCreditNotesIdVoid.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomerSessionsBodySchema = z.object({
    components: z.object({
      buy_button: z.object({ enabled: PermissiveBoolean }).optional(),
      payment_element: z
        .object({
          enabled: PermissiveBoolean,
          features: z
            .object({
              payment_method_allow_redisplay_filters: z
                .array(z.enum(["always", "limited", "unspecified"]))
                .optional(),
              payment_method_redisplay: z
                .enum(["disabled", "enabled"])
                .optional(),
              payment_method_redisplay_limit: z.coerce.number().optional(),
              payment_method_remove: z.enum(["disabled", "enabled"]).optional(),
              payment_method_save: z.enum(["disabled", "enabled"]).optional(),
              payment_method_save_usage: z
                .enum(["off_session", "on_session"])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      pricing_table: z.object({ enabled: PermissiveBoolean }).optional(),
    }),
    customer: z.string().max(5000),
    expand: z.array(z.string().max(5000)).optional(),
  })

  router.post(
    "postCustomerSessions",
    "/v1/customer_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postCustomerSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomerSessions(input, postCustomerSessions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomerSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    email: z.string().max(512).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    test_clock: z.string().max(5000).optional(),
  })

  const getCustomersBodySchema = z.object({}).optional()

  router.get("getCustomers", "/v1/customers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getCustomersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getCustomersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getCustomers(input, getCustomers.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getCustomers.validator(status, body)
    ctx.status = status
    return next()
  })

  const postCustomersBodySchema = z
    .object({
      address: z
        .union([
          z.object({
            city: z.string().max(5000).optional(),
            country: z.string().max(5000).optional(),
            line1: z.string().max(5000).optional(),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000).optional(),
            state: z.string().max(5000).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      balance: z.coerce.number().optional(),
      cash_balance: z
        .object({
          settings: z
            .object({
              reconciliation_mode: z
                .enum(["automatic", "manual", "merchant_default"])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      description: z.string().max(5000).optional(),
      email: z.string().max(512).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      invoice_prefix: z.string().max(5000).optional(),
      invoice_settings: z
        .object({
          custom_fields: z
            .union([
              z.array(
                z.object({
                  name: z.string().max(40),
                  value: z.string().max(140),
                }),
              ),
              z.enum([""]),
            ])
            .optional(),
          default_payment_method: z.string().max(5000).optional(),
          footer: z.string().max(5000).optional(),
          rendering_options: z
            .union([
              z.object({
                amount_tax_display: z
                  .enum(["", "exclude_tax", "include_inclusive_tax"])
                  .optional(),
                template: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(256).optional(),
      next_invoice_sequence: z.coerce.number().optional(),
      payment_method: z.string().max(5000).optional(),
      phone: z.string().max(20).optional(),
      preferred_locales: z.array(z.string().max(5000)).optional(),
      shipping: z
        .union([
          z.object({
            address: z.object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            }),
            name: z.string().max(5000),
            phone: z.string().max(5000).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      source: z.string().max(5000).optional(),
      tax: z
        .object({
          ip_address: z.union([z.string(), z.enum([""])]).optional(),
          validate_location: z.enum(["deferred", "immediately"]).optional(),
        })
        .optional(),
      tax_exempt: z.enum(["", "exempt", "none", "reverse"]).optional(),
      tax_id_data: z
        .array(
          z.object({
            type: z.enum([
              "ad_nrt",
              "ae_trn",
              "al_tin",
              "am_tin",
              "ao_tin",
              "ar_cuit",
              "au_abn",
              "au_arn",
              "ba_tin",
              "bb_tin",
              "bg_uic",
              "bh_vat",
              "bo_tin",
              "br_cnpj",
              "br_cpf",
              "bs_tin",
              "by_tin",
              "ca_bn",
              "ca_gst_hst",
              "ca_pst_bc",
              "ca_pst_mb",
              "ca_pst_sk",
              "ca_qst",
              "cd_nif",
              "ch_uid",
              "ch_vat",
              "cl_tin",
              "cn_tin",
              "co_nit",
              "cr_tin",
              "de_stn",
              "do_rcn",
              "ec_ruc",
              "eg_tin",
              "es_cif",
              "eu_oss_vat",
              "eu_vat",
              "gb_vat",
              "ge_vat",
              "gn_nif",
              "hk_br",
              "hr_oib",
              "hu_tin",
              "id_npwp",
              "il_vat",
              "in_gst",
              "is_vat",
              "jp_cn",
              "jp_rn",
              "jp_trn",
              "ke_pin",
              "kh_tin",
              "kr_brn",
              "kz_bin",
              "li_uid",
              "li_vat",
              "ma_vat",
              "md_vat",
              "me_pib",
              "mk_vat",
              "mr_nif",
              "mx_rfc",
              "my_frp",
              "my_itn",
              "my_sst",
              "ng_tin",
              "no_vat",
              "no_voec",
              "np_pan",
              "nz_gst",
              "om_vat",
              "pe_ruc",
              "ph_tin",
              "ro_tin",
              "rs_pib",
              "ru_inn",
              "ru_kpp",
              "sa_vat",
              "sg_gst",
              "sg_uen",
              "si_tin",
              "sn_ninea",
              "sr_fin",
              "sv_nit",
              "th_vat",
              "tj_tin",
              "tr_tin",
              "tw_vat",
              "tz_vat",
              "ua_vat",
              "ug_tin",
              "us_ein",
              "uy_ruc",
              "uz_tin",
              "uz_vat",
              "ve_rif",
              "vn_tin",
              "za_vat",
              "zm_tin",
              "zw_tin",
            ]),
            value: z.string(),
          }),
        )
        .optional(),
      test_clock: z.string().max(5000).optional(),
    })
    .optional()

  router.post("postCustomers", "/v1/customers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postCustomersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postCustomers(input, postCustomers.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postCustomers.validator(status, body)
    ctx.status = status
    return next()
  })

  const getCustomersSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  const getCustomersSearchBodySchema = z.object({}).optional()

  router.get(
    "getCustomersSearch",
    "/v1/customers/search",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getCustomersSearchQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersSearchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersSearch(input, getCustomersSearch.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersSearch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const deleteCustomersCustomerBodySchema = z.object({}).optional()

  router.delete(
    "deleteCustomersCustomer",
    "/v1/customers/:customer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomer(input, deleteCustomersCustomer.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomer.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomer",
    "/v1/customers/:customer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomer(input, getCustomersCustomer.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomer.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerBodySchema = z
    .object({
      address: z
        .union([
          z.object({
            city: z.string().max(5000).optional(),
            country: z.string().max(5000).optional(),
            line1: z.string().max(5000).optional(),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000).optional(),
            state: z.string().max(5000).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      balance: z.coerce.number().optional(),
      bank_account: z
        .union([
          z.object({
            account_holder_name: z.string().max(5000).optional(),
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000),
            country: z.string().max(5000),
            currency: z.string().optional(),
            object: z.enum(["bank_account"]).optional(),
            routing_number: z.string().max(5000).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      card: z
        .union([
          z.object({
            address_city: z.string().max(5000).optional(),
            address_country: z.string().max(5000).optional(),
            address_line1: z.string().max(5000).optional(),
            address_line2: z.string().max(5000).optional(),
            address_state: z.string().max(5000).optional(),
            address_zip: z.string().max(5000).optional(),
            cvc: z.string().max(5000).optional(),
            exp_month: z.coerce.number(),
            exp_year: z.coerce.number(),
            metadata: z.record(z.string()).optional(),
            name: z.string().max(5000).optional(),
            number: z.string().max(5000),
            object: z.enum(["card"]).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      cash_balance: z
        .object({
          settings: z
            .object({
              reconciliation_mode: z
                .enum(["automatic", "manual", "merchant_default"])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      default_alipay_account: z.string().max(500).optional(),
      default_bank_account: z.string().max(500).optional(),
      default_card: z.string().max(500).optional(),
      default_source: z.string().max(500).optional(),
      description: z.string().max(5000).optional(),
      email: z.string().max(512).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      invoice_prefix: z.string().max(5000).optional(),
      invoice_settings: z
        .object({
          custom_fields: z
            .union([
              z.array(
                z.object({
                  name: z.string().max(40),
                  value: z.string().max(140),
                }),
              ),
              z.enum([""]),
            ])
            .optional(),
          default_payment_method: z.string().max(5000).optional(),
          footer: z.string().max(5000).optional(),
          rendering_options: z
            .union([
              z.object({
                amount_tax_display: z
                  .enum(["", "exclude_tax", "include_inclusive_tax"])
                  .optional(),
                template: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(256).optional(),
      next_invoice_sequence: z.coerce.number().optional(),
      phone: z.string().max(20).optional(),
      preferred_locales: z.array(z.string().max(5000)).optional(),
      shipping: z
        .union([
          z.object({
            address: z.object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            }),
            name: z.string().max(5000),
            phone: z.string().max(5000).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      source: z.string().max(5000).optional(),
      tax: z
        .object({
          ip_address: z.union([z.string(), z.enum([""])]).optional(),
          validate_location: z
            .enum(["auto", "deferred", "immediately"])
            .optional(),
        })
        .optional(),
      tax_exempt: z.enum(["", "exempt", "none", "reverse"]).optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomer",
    "/v1/customers/:customer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomer(input, postCustomersCustomer.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomer.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerBalanceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCustomersCustomerBalanceTransactionsBodySchema = z
    .object({})
    .optional()

  router.get(
    "getCustomersCustomerBalanceTransactions",
    "/v1/customers/:customer/balance_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBalanceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerBalanceTransactions(
          input,
          getCustomersCustomerBalanceTransactions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerBalanceTransactions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerBalanceTransactionsBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    description: z.string().max(350).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
  })

  router.post(
    "postCustomersCustomerBalanceTransactions",
    "/v1/customers/:customer/balance_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBalanceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerBalanceTransactions(
          input,
          postCustomersCustomerBalanceTransactions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBalanceTransactions.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBalanceTransactionsTransactionParamSchema =
    z.object({ customer: z.string().max(5000), transaction: z.string() })

  const getCustomersCustomerBalanceTransactionsTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getCustomersCustomerBalanceTransactionsTransactionBodySchema = z
    .object({})
    .optional()

  router.get(
    "getCustomersCustomerBalanceTransactionsTransaction",
    "/v1/customers/:customer/balance_transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBalanceTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBalanceTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBalanceTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerBalanceTransactionsTransaction(
          input,
          getCustomersCustomerBalanceTransactionsTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerBalanceTransactionsTransaction.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBalanceTransactionsTransactionParamSchema =
    z.object({
      customer: z.string().max(5000),
      transaction: z.string().max(5000),
    })

  const postCustomersCustomerBalanceTransactionsTransactionBodySchema = z
    .object({
      description: z.string().max(350).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerBalanceTransactionsTransaction",
    "/v1/customers/:customer/balance_transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBalanceTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBalanceTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerBalanceTransactionsTransaction(
          input,
          postCustomersCustomerBalanceTransactionsTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBalanceTransactionsTransaction.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBankAccountsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerBankAccountsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  const getCustomersCustomerBankAccountsBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerBankAccounts",
    "/v1/customers/:customer/bank_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBankAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBankAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBankAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerBankAccounts(
          input,
          getCustomersCustomerBankAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerBankAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBankAccountsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerBankAccountsBodySchema = z
    .object({
      alipay_account: z.string().max(5000).optional(),
      bank_account: z
        .union([
          z.object({
            account_holder_name: z.string().max(5000).optional(),
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000),
            country: z.string().max(5000),
            currency: z.string().optional(),
            object: z.enum(["bank_account"]).optional(),
            routing_number: z.string().max(5000).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      card: z
        .union([
          z.object({
            address_city: z.string().max(5000).optional(),
            address_country: z.string().max(5000).optional(),
            address_line1: z.string().max(5000).optional(),
            address_line2: z.string().max(5000).optional(),
            address_state: z.string().max(5000).optional(),
            address_zip: z.string().max(5000).optional(),
            cvc: z.string().max(5000).optional(),
            exp_month: z.coerce.number(),
            exp_year: z.coerce.number(),
            metadata: z.record(z.string()).optional(),
            name: z.string().max(5000).optional(),
            number: z.string().max(5000),
            object: z.enum(["card"]).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      source: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerBankAccounts",
    "/v1/customers/:customer/bank_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBankAccountsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBankAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerBankAccounts(
          input,
          postCustomersCustomerBankAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBankAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  const deleteCustomersCustomerBankAccountsIdBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.delete(
    "deleteCustomersCustomerBankAccountsId",
    "/v1/customers/:customer/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomerBankAccountsId(
          input,
          deleteCustomersCustomerBankAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerBankAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getCustomersCustomerBankAccountsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerBankAccountsIdBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerBankAccountsId",
    "/v1/customers/:customer/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerBankAccountsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerBankAccountsId(
          input,
          getCustomersCustomerBankAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerBankAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBankAccountsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const postCustomersCustomerBankAccountsIdBodySchema = z
    .object({
      account_holder_name: z.string().max(5000).optional(),
      account_holder_type: z.enum(["company", "individual"]).optional(),
      address_city: z.string().max(5000).optional(),
      address_country: z.string().max(5000).optional(),
      address_line1: z.string().max(5000).optional(),
      address_line2: z.string().max(5000).optional(),
      address_state: z.string().max(5000).optional(),
      address_zip: z.string().max(5000).optional(),
      exp_month: z.string().max(5000).optional(),
      exp_year: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(5000).optional(),
      owner: z
        .object({
          address: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          email: z.string().optional(),
          name: z.string().max(5000).optional(),
          phone: z.string().max(5000).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerBankAccountsId",
    "/v1/customers/:customer/bank_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBankAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBankAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerBankAccountsId(
          input,
          postCustomersCustomerBankAccountsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBankAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerBankAccountsIdVerifyParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const postCustomersCustomerBankAccountsIdVerifyBodySchema = z
    .object({
      amounts: z.array(z.coerce.number()).optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerBankAccountsIdVerify",
    "/v1/customers/:customer/bank_accounts/:id/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerBankAccountsIdVerifyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerBankAccountsIdVerifyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerBankAccountsIdVerify(
          input,
          postCustomersCustomerBankAccountsIdVerify.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerBankAccountsIdVerify.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCardsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCardsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  const getCustomersCustomerCardsBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerCards",
    "/v1/customers/:customer/cards",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCardsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCardsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCardsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerCards(
          input,
          getCustomersCustomerCards.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCards.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerCardsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerCardsBodySchema = z
    .object({
      alipay_account: z.string().max(5000).optional(),
      bank_account: z
        .union([
          z.object({
            account_holder_name: z.string().max(5000).optional(),
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000),
            country: z.string().max(5000),
            currency: z.string().optional(),
            object: z.enum(["bank_account"]).optional(),
            routing_number: z.string().max(5000).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      card: z
        .union([
          z.object({
            address_city: z.string().max(5000).optional(),
            address_country: z.string().max(5000).optional(),
            address_line1: z.string().max(5000).optional(),
            address_line2: z.string().max(5000).optional(),
            address_state: z.string().max(5000).optional(),
            address_zip: z.string().max(5000).optional(),
            cvc: z.string().max(5000).optional(),
            exp_month: z.coerce.number(),
            exp_year: z.coerce.number(),
            metadata: z.record(z.string()).optional(),
            name: z.string().max(5000).optional(),
            number: z.string().max(5000),
            object: z.enum(["card"]).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      source: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerCards",
    "/v1/customers/:customer/cards",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerCardsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerCardsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerCards(
          input,
          postCustomersCustomerCards.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerCards.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  const deleteCustomersCustomerCardsIdBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.delete(
    "deleteCustomersCustomerCardsId",
    "/v1/customers/:customer/cards/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerCardsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerCardsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomerCardsId(
          input,
          deleteCustomersCustomerCardsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerCardsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const getCustomersCustomerCardsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerCardsIdBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerCardsId",
    "/v1/customers/:customer/cards/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCardsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCardsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCardsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerCardsId(
          input,
          getCustomersCustomerCardsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCardsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerCardsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const postCustomersCustomerCardsIdBodySchema = z
    .object({
      account_holder_name: z.string().max(5000).optional(),
      account_holder_type: z.enum(["company", "individual"]).optional(),
      address_city: z.string().max(5000).optional(),
      address_country: z.string().max(5000).optional(),
      address_line1: z.string().max(5000).optional(),
      address_line2: z.string().max(5000).optional(),
      address_state: z.string().max(5000).optional(),
      address_zip: z.string().max(5000).optional(),
      exp_month: z.string().max(5000).optional(),
      exp_year: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(5000).optional(),
      owner: z
        .object({
          address: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          email: z.string().optional(),
          name: z.string().max(5000).optional(),
          phone: z.string().max(5000).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerCardsId",
    "/v1/customers/:customer/cards/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerCardsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerCardsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerCardsId(
          input,
          postCustomersCustomerCardsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerCardsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCashBalanceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerCashBalanceBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerCashBalance",
    "/v1/customers/:customer/cash_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCashBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCashBalanceQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCashBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerCashBalance(
          input,
          getCustomersCustomerCashBalance.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCashBalance.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerCashBalanceBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      settings: z
        .object({
          reconciliation_mode: z
            .enum(["automatic", "manual", "merchant_default"])
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerCashBalance",
    "/v1/customers/:customer/cash_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerCashBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerCashBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerCashBalance(
          input,
          postCustomersCustomerCashBalance.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerCashBalance.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCashBalanceTransactionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerCashBalanceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCustomersCustomerCashBalanceTransactionsBodySchema = z
    .object({})
    .optional()

  router.get(
    "getCustomersCustomerCashBalanceTransactions",
    "/v1/customers/:customer/cash_balance_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerCashBalanceTransactions(
          input,
          getCustomersCustomerCashBalanceTransactions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerCashBalanceTransactions.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerCashBalanceTransactionsTransactionParamSchema =
    z.object({ customer: z.string().max(5000), transaction: z.string() })

  const getCustomersCustomerCashBalanceTransactionsTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getCustomersCustomerCashBalanceTransactionsTransactionBodySchema = z
    .object({})
    .optional()

  router.get(
    "getCustomersCustomerCashBalanceTransactionsTransaction",
    "/v1/customers/:customer/cash_balance_transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerCashBalanceTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerCashBalanceTransactionsTransaction(
          input,
          getCustomersCustomerCashBalanceTransactionsTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerCashBalanceTransactionsTransaction.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerDiscountParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const deleteCustomersCustomerDiscountBodySchema = z.object({}).optional()

  router.delete(
    "deleteCustomersCustomerDiscount",
    "/v1/customers/:customer/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomerDiscount(
          input,
          deleteCustomersCustomerDiscount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerDiscount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerDiscountParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerDiscountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerDiscountBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerDiscount",
    "/v1/customers/:customer/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerDiscountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerDiscount(
          input,
          getCustomersCustomerDiscount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerDiscount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerFundingInstructionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerFundingInstructionsBodySchema = z.object({
    bank_transfer: z.object({
      eu_bank_transfer: z.object({ country: z.string().max(5000) }).optional(),
      requested_address_types: z
        .array(z.enum(["iban", "sort_code", "spei", "zengin"]))
        .optional(),
      type: z.enum([
        "eu_bank_transfer",
        "gb_bank_transfer",
        "jp_bank_transfer",
        "mx_bank_transfer",
        "us_bank_transfer",
      ]),
    }),
    currency: z.string(),
    expand: z.array(z.string().max(5000)).optional(),
    funding_type: z.enum(["bank_transfer"]),
  })

  router.post(
    "postCustomersCustomerFundingInstructions",
    "/v1/customers/:customer/funding_instructions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerFundingInstructionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerFundingInstructionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerFundingInstructions(
          input,
          postCustomersCustomerFundingInstructions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerFundingInstructions.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerPaymentMethodsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerPaymentMethodsQuerySchema = z.object({
    allow_redisplay: z.enum(["always", "limited", "unspecified"]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z
      .enum([
        "acss_debit",
        "affirm",
        "afterpay_clearpay",
        "alipay",
        "alma",
        "amazon_pay",
        "au_becs_debit",
        "bacs_debit",
        "bancontact",
        "billie",
        "blik",
        "boleto",
        "card",
        "cashapp",
        "customer_balance",
        "eps",
        "fpx",
        "giropay",
        "grabpay",
        "ideal",
        "kakao_pay",
        "klarna",
        "konbini",
        "kr_card",
        "link",
        "mobilepay",
        "multibanco",
        "naver_pay",
        "nz_bank_account",
        "oxxo",
        "p24",
        "pay_by_bank",
        "payco",
        "paynow",
        "paypal",
        "pix",
        "promptpay",
        "revolut_pay",
        "samsung_pay",
        "satispay",
        "sepa_debit",
        "sofort",
        "swish",
        "twint",
        "us_bank_account",
        "wechat_pay",
        "zip",
      ])
      .optional(),
  })

  const getCustomersCustomerPaymentMethodsBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerPaymentMethods",
    "/v1/customers/:customer/payment_methods",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerPaymentMethodsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerPaymentMethodsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerPaymentMethodsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerPaymentMethods(
          input,
          getCustomersCustomerPaymentMethods.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerPaymentMethods.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerPaymentMethodsPaymentMethodParamSchema = z.object({
    customer: z.string().max(5000),
    payment_method: z.string().max(5000),
  })

  const getCustomersCustomerPaymentMethodsPaymentMethodQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerPaymentMethodsPaymentMethodBodySchema = z
    .object({})
    .optional()

  router.get(
    "getCustomersCustomerPaymentMethodsPaymentMethod",
    "/v1/customers/:customer/payment_methods/:payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerPaymentMethodsPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerPaymentMethodsPaymentMethodQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerPaymentMethodsPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerPaymentMethodsPaymentMethod(
          input,
          getCustomersCustomerPaymentMethodsPaymentMethod.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerPaymentMethodsPaymentMethod.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSourcesParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerSourcesQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    object: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
  })

  const getCustomersCustomerSourcesBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerSources",
    "/v1/customers/:customer/sources",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSourcesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSourcesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSourcesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerSources(
          input,
          getCustomersCustomerSources.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerSources.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSourcesParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerSourcesBodySchema = z
    .object({
      alipay_account: z.string().max(5000).optional(),
      bank_account: z
        .union([
          z.object({
            account_holder_name: z.string().max(5000).optional(),
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000),
            country: z.string().max(5000),
            currency: z.string().optional(),
            object: z.enum(["bank_account"]).optional(),
            routing_number: z.string().max(5000).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      card: z
        .union([
          z.object({
            address_city: z.string().max(5000).optional(),
            address_country: z.string().max(5000).optional(),
            address_line1: z.string().max(5000).optional(),
            address_line2: z.string().max(5000).optional(),
            address_state: z.string().max(5000).optional(),
            address_zip: z.string().max(5000).optional(),
            cvc: z.string().max(5000).optional(),
            exp_month: z.coerce.number(),
            exp_year: z.coerce.number(),
            metadata: z.record(z.string()).optional(),
            name: z.string().max(5000).optional(),
            number: z.string().max(5000),
            object: z.enum(["card"]).optional(),
          }),
          z.string().max(5000),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      source: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerSources",
    "/v1/customers/:customer/sources",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSourcesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSourcesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerSources(
          input,
          postCustomersCustomerSources.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSources.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  const deleteCustomersCustomerSourcesIdBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.delete(
    "deleteCustomersCustomerSourcesId",
    "/v1/customers/:customer/sources/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerSourcesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerSourcesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomerSourcesId(
          input,
          deleteCustomersCustomerSourcesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerSourcesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(500),
  })

  const getCustomersCustomerSourcesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerSourcesIdBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerSourcesId",
    "/v1/customers/:customer/sources/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSourcesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSourcesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSourcesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerSourcesId(
          input,
          getCustomersCustomerSourcesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerSourcesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSourcesIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const postCustomersCustomerSourcesIdBodySchema = z
    .object({
      account_holder_name: z.string().max(5000).optional(),
      account_holder_type: z.enum(["company", "individual"]).optional(),
      address_city: z.string().max(5000).optional(),
      address_country: z.string().max(5000).optional(),
      address_line1: z.string().max(5000).optional(),
      address_line2: z.string().max(5000).optional(),
      address_state: z.string().max(5000).optional(),
      address_zip: z.string().max(5000).optional(),
      exp_month: z.string().max(5000).optional(),
      exp_year: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(5000).optional(),
      owner: z
        .object({
          address: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          email: z.string().optional(),
          name: z.string().max(5000).optional(),
          phone: z.string().max(5000).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerSourcesId",
    "/v1/customers/:customer/sources/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSourcesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSourcesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerSourcesId(
          input,
          postCustomersCustomerSourcesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSourcesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSourcesIdVerifyParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string().max(5000),
  })

  const postCustomersCustomerSourcesIdVerifyBodySchema = z
    .object({
      amounts: z.array(z.coerce.number()).optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerSourcesIdVerify",
    "/v1/customers/:customer/sources/:id/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSourcesIdVerifyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSourcesIdVerifyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerSourcesIdVerify(
          input,
          postCustomersCustomerSourcesIdVerify.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSourcesIdVerify.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSubscriptionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerSubscriptionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCustomersCustomerSubscriptionsBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerSubscriptions",
    "/v1/customers/:customer/subscriptions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSubscriptionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSubscriptionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSubscriptionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerSubscriptions(
          input,
          getCustomersCustomerSubscriptions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerSubscriptions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSubscriptionsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerSubscriptionsBodySchema = z
    .object({
      add_invoice_items: z
        .array(
          z.object({
            discounts: z
              .array(
                z.object({
                  coupon: z.string().max(5000).optional(),
                  discount: z.string().max(5000).optional(),
                  promotion_code: z.string().max(5000).optional(),
                }),
              )
              .optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      application_fee_percent: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      backdate_start_date: z.coerce.number().optional(),
      billing_cycle_anchor: z.coerce.number().optional(),
      cancel_at: z.coerce.number().optional(),
      cancel_at_period_end: PermissiveBoolean.optional(),
      collection_method: z
        .enum(["charge_automatically", "send_invoice"])
        .optional(),
      currency: z.string().optional(),
      days_until_due: z.coerce.number().optional(),
      default_payment_method: z.string().max(5000).optional(),
      default_source: z.string().max(5000).optional(),
      default_tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      invoice_settings: z
        .object({
          account_tax_ids: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
          issuer: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      items: z
        .array(
          z.object({
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            metadata: z.record(z.string()).optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                recurring: z.object({
                  interval: z.enum(["day", "month", "week", "year"]),
                  interval_count: z.coerce.number().optional(),
                }),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      off_session: PermissiveBoolean.optional(),
      payment_behavior: z
        .enum([
          "allow_incomplete",
          "default_incomplete",
          "error_if_incomplete",
          "pending_if_incomplete",
        ])
        .optional(),
      payment_settings: z
        .object({
          payment_method_options: z
            .object({
              acss_debit: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        transaction_type: z
                          .enum(["business", "personal"])
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              bancontact: z
                .union([
                  z.object({
                    preferred_language: z
                      .enum(["de", "en", "fr", "nl"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              card: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        amount: z.coerce.number().optional(),
                        amount_type: z.enum(["fixed", "maximum"]).optional(),
                        description: z.string().max(200).optional(),
                      })
                      .optional(),
                    network: z
                      .enum([
                        "amex",
                        "cartes_bancaires",
                        "diners",
                        "discover",
                        "eftpos_au",
                        "girocard",
                        "interac",
                        "jcb",
                        "link",
                        "mastercard",
                        "unionpay",
                        "unknown",
                        "visa",
                      ])
                      .optional(),
                    request_three_d_secure: z
                      .enum(["any", "automatic", "challenge"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              customer_balance: z
                .union([
                  z.object({
                    bank_transfer: z
                      .object({
                        eu_bank_transfer: z
                          .object({ country: z.string().max(5000) })
                          .optional(),
                        type: z.string().optional(),
                      })
                      .optional(),
                    funding_type: z.string().optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              konbini: z.union([z.object({}), z.enum([""])]).optional(),
              sepa_debit: z.union([z.object({}), z.enum([""])]).optional(),
              us_bank_account: z
                .union([
                  z.object({
                    financial_connections: z
                      .object({
                        filters: z
                          .object({
                            account_subcategories: z
                              .array(z.enum(["checking", "savings"]))
                              .optional(),
                          })
                          .optional(),
                        permissions: z
                          .array(
                            z.enum([
                              "balances",
                              "ownership",
                              "payment_method",
                              "transactions",
                            ]),
                          )
                          .optional(),
                        prefetch: z
                          .array(
                            z.enum(["balances", "ownership", "transactions"]),
                          )
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
            })
            .optional(),
          payment_method_types: z
            .union([
              z.array(
                z.enum([
                  "ach_credit_transfer",
                  "ach_debit",
                  "acss_debit",
                  "amazon_pay",
                  "au_becs_debit",
                  "bacs_debit",
                  "bancontact",
                  "boleto",
                  "card",
                  "cashapp",
                  "customer_balance",
                  "eps",
                  "fpx",
                  "giropay",
                  "grabpay",
                  "ideal",
                  "jp_credit_transfer",
                  "kakao_pay",
                  "klarna",
                  "konbini",
                  "kr_card",
                  "link",
                  "multibanco",
                  "naver_pay",
                  "nz_bank_account",
                  "p24",
                  "payco",
                  "paynow",
                  "paypal",
                  "promptpay",
                  "revolut_pay",
                  "sepa_credit_transfer",
                  "sepa_debit",
                  "sofort",
                  "swish",
                  "us_bank_account",
                  "wechat_pay",
                ]),
              ),
              z.enum([""]),
            ])
            .optional(),
          save_default_payment_method: z
            .enum(["off", "on_subscription"])
            .optional(),
        })
        .optional(),
      pending_invoice_item_interval: z
        .union([
          z.object({
            interval: z.enum(["day", "month", "week", "year"]),
            interval_count: z.coerce.number().optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      proration_behavior: z
        .enum(["always_invoice", "create_prorations", "none"])
        .optional(),
      transfer_data: z
        .object({
          amount_percent: z.coerce.number().optional(),
          destination: z.string(),
        })
        .optional(),
      trial_end: z.union([z.enum(["now"]), z.coerce.number()]).optional(),
      trial_from_plan: PermissiveBoolean.optional(),
      trial_period_days: z.coerce.number().optional(),
      trial_settings: z
        .object({
          end_behavior: z.object({
            missing_payment_method: z.enum([
              "cancel",
              "create_invoice",
              "pause",
            ]),
          }),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerSubscriptions",
    "/v1/customers/:customer/subscriptions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSubscriptionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSubscriptionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerSubscriptions(
          input,
          postCustomersCustomerSubscriptions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerSubscriptions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      invoice_now: PermissiveBoolean.optional(),
      prorate: PermissiveBoolean.optional(),
    })
    .optional()

  router.delete(
    "deleteCustomersCustomerSubscriptionsSubscriptionExposedId",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomerSubscriptionsSubscriptionExposedId(
          input,
          deleteCustomersCustomerSubscriptionsSubscriptionExposedId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        deleteCustomersCustomerSubscriptionsSubscriptionExposedId.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema = z
    .object({})
    .optional()

  router.get(
    "getCustomersCustomerSubscriptionsSubscriptionExposedId",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerSubscriptionsSubscriptionExposedId(
          input,
          getCustomersCustomerSubscriptionsSubscriptionExposedId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerSubscriptionsSubscriptionExposedId.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const postCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema = z
    .object({
      add_invoice_items: z
        .array(
          z.object({
            discounts: z
              .array(
                z.object({
                  coupon: z.string().max(5000).optional(),
                  discount: z.string().max(5000).optional(),
                  promotion_code: z.string().max(5000).optional(),
                }),
              )
              .optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      application_fee_percent: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      billing_cycle_anchor: z.enum(["now", "unchanged"]).optional(),
      cancel_at: z.union([z.coerce.number(), z.enum([""])]).optional(),
      cancel_at_period_end: PermissiveBoolean.optional(),
      cancellation_details: z
        .object({
          comment: z.union([z.string().max(5000), z.enum([""])]).optional(),
          feedback: z
            .enum([
              "",
              "customer_service",
              "low_quality",
              "missing_features",
              "other",
              "switched_service",
              "too_complex",
              "too_expensive",
              "unused",
            ])
            .optional(),
        })
        .optional(),
      collection_method: z
        .enum(["charge_automatically", "send_invoice"])
        .optional(),
      days_until_due: z.coerce.number().optional(),
      default_payment_method: z.string().max(5000).optional(),
      default_source: z.union([z.string().max(5000), z.enum([""])]).optional(),
      default_tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      invoice_settings: z
        .object({
          account_tax_ids: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
          issuer: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      items: z
        .array(
          z.object({
            clear_usage: PermissiveBoolean.optional(),
            deleted: PermissiveBoolean.optional(),
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            id: z.string().max(5000).optional(),
            metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                recurring: z.object({
                  interval: z.enum(["day", "month", "week", "year"]),
                  interval_count: z.coerce.number().optional(),
                }),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      off_session: PermissiveBoolean.optional(),
      pause_collection: z
        .union([
          z.object({
            behavior: z.enum(["keep_as_draft", "mark_uncollectible", "void"]),
            resumes_at: z.coerce.number().optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      payment_behavior: z
        .enum([
          "allow_incomplete",
          "default_incomplete",
          "error_if_incomplete",
          "pending_if_incomplete",
        ])
        .optional(),
      payment_settings: z
        .object({
          payment_method_options: z
            .object({
              acss_debit: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        transaction_type: z
                          .enum(["business", "personal"])
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              bancontact: z
                .union([
                  z.object({
                    preferred_language: z
                      .enum(["de", "en", "fr", "nl"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              card: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        amount: z.coerce.number().optional(),
                        amount_type: z.enum(["fixed", "maximum"]).optional(),
                        description: z.string().max(200).optional(),
                      })
                      .optional(),
                    network: z
                      .enum([
                        "amex",
                        "cartes_bancaires",
                        "diners",
                        "discover",
                        "eftpos_au",
                        "girocard",
                        "interac",
                        "jcb",
                        "link",
                        "mastercard",
                        "unionpay",
                        "unknown",
                        "visa",
                      ])
                      .optional(),
                    request_three_d_secure: z
                      .enum(["any", "automatic", "challenge"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              customer_balance: z
                .union([
                  z.object({
                    bank_transfer: z
                      .object({
                        eu_bank_transfer: z
                          .object({ country: z.string().max(5000) })
                          .optional(),
                        type: z.string().optional(),
                      })
                      .optional(),
                    funding_type: z.string().optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              konbini: z.union([z.object({}), z.enum([""])]).optional(),
              sepa_debit: z.union([z.object({}), z.enum([""])]).optional(),
              us_bank_account: z
                .union([
                  z.object({
                    financial_connections: z
                      .object({
                        filters: z
                          .object({
                            account_subcategories: z
                              .array(z.enum(["checking", "savings"]))
                              .optional(),
                          })
                          .optional(),
                        permissions: z
                          .array(
                            z.enum([
                              "balances",
                              "ownership",
                              "payment_method",
                              "transactions",
                            ]),
                          )
                          .optional(),
                        prefetch: z
                          .array(
                            z.enum(["balances", "ownership", "transactions"]),
                          )
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
            })
            .optional(),
          payment_method_types: z
            .union([
              z.array(
                z.enum([
                  "ach_credit_transfer",
                  "ach_debit",
                  "acss_debit",
                  "amazon_pay",
                  "au_becs_debit",
                  "bacs_debit",
                  "bancontact",
                  "boleto",
                  "card",
                  "cashapp",
                  "customer_balance",
                  "eps",
                  "fpx",
                  "giropay",
                  "grabpay",
                  "ideal",
                  "jp_credit_transfer",
                  "kakao_pay",
                  "klarna",
                  "konbini",
                  "kr_card",
                  "link",
                  "multibanco",
                  "naver_pay",
                  "nz_bank_account",
                  "p24",
                  "payco",
                  "paynow",
                  "paypal",
                  "promptpay",
                  "revolut_pay",
                  "sepa_credit_transfer",
                  "sepa_debit",
                  "sofort",
                  "swish",
                  "us_bank_account",
                  "wechat_pay",
                ]),
              ),
              z.enum([""]),
            ])
            .optional(),
          save_default_payment_method: z
            .enum(["off", "on_subscription"])
            .optional(),
        })
        .optional(),
      pending_invoice_item_interval: z
        .union([
          z.object({
            interval: z.enum(["day", "month", "week", "year"]),
            interval_count: z.coerce.number().optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      proration_behavior: z
        .enum(["always_invoice", "create_prorations", "none"])
        .optional(),
      proration_date: z.coerce.number().optional(),
      transfer_data: z
        .union([
          z.object({
            amount_percent: z.coerce.number().optional(),
            destination: z.string(),
          }),
          z.enum([""]),
        ])
        .optional(),
      trial_end: z.union([z.enum(["now"]), z.coerce.number()]).optional(),
      trial_from_plan: PermissiveBoolean.optional(),
      trial_settings: z
        .object({
          end_behavior: z.object({
            missing_payment_method: z.enum([
              "cancel",
              "create_invoice",
              "pause",
            ]),
          }),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postCustomersCustomerSubscriptionsSubscriptionExposedId",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerSubscriptionsSubscriptionExposedId(
          input,
          postCustomersCustomerSubscriptionsSubscriptionExposedId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postCustomersCustomerSubscriptionsSubscriptionExposedId.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema =
    z.object({}).optional()

  router.delete(
    "deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
          input,
          deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        deleteCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema =
    z.object({
      customer: z.string().max(5000),
      subscription_exposed_id: z.string().max(5000),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema =
    z.object({}).optional()

  router.get(
    "getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount",
    "/v1/customers/:customer/subscriptions/:subscription_exposed_id/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount(
          input,
          getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getCustomersCustomerSubscriptionsSubscriptionExposedIdDiscount.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerTaxIdsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const getCustomersCustomerTaxIdsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getCustomersCustomerTaxIdsBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerTaxIds",
    "/v1/customers/:customer/tax_ids",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerTaxIdsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerTaxIdsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerTaxIdsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerTaxIds(
          input,
          getCustomersCustomerTaxIds.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerTaxIds.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postCustomersCustomerTaxIdsParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postCustomersCustomerTaxIdsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    type: z.enum([
      "ad_nrt",
      "ae_trn",
      "al_tin",
      "am_tin",
      "ao_tin",
      "ar_cuit",
      "au_abn",
      "au_arn",
      "ba_tin",
      "bb_tin",
      "bg_uic",
      "bh_vat",
      "bo_tin",
      "br_cnpj",
      "br_cpf",
      "bs_tin",
      "by_tin",
      "ca_bn",
      "ca_gst_hst",
      "ca_pst_bc",
      "ca_pst_mb",
      "ca_pst_sk",
      "ca_qst",
      "cd_nif",
      "ch_uid",
      "ch_vat",
      "cl_tin",
      "cn_tin",
      "co_nit",
      "cr_tin",
      "de_stn",
      "do_rcn",
      "ec_ruc",
      "eg_tin",
      "es_cif",
      "eu_oss_vat",
      "eu_vat",
      "gb_vat",
      "ge_vat",
      "gn_nif",
      "hk_br",
      "hr_oib",
      "hu_tin",
      "id_npwp",
      "il_vat",
      "in_gst",
      "is_vat",
      "jp_cn",
      "jp_rn",
      "jp_trn",
      "ke_pin",
      "kh_tin",
      "kr_brn",
      "kz_bin",
      "li_uid",
      "li_vat",
      "ma_vat",
      "md_vat",
      "me_pib",
      "mk_vat",
      "mr_nif",
      "mx_rfc",
      "my_frp",
      "my_itn",
      "my_sst",
      "ng_tin",
      "no_vat",
      "no_voec",
      "np_pan",
      "nz_gst",
      "om_vat",
      "pe_ruc",
      "ph_tin",
      "ro_tin",
      "rs_pib",
      "ru_inn",
      "ru_kpp",
      "sa_vat",
      "sg_gst",
      "sg_uen",
      "si_tin",
      "sn_ninea",
      "sr_fin",
      "sv_nit",
      "th_vat",
      "tj_tin",
      "tr_tin",
      "tw_vat",
      "tz_vat",
      "ua_vat",
      "ug_tin",
      "us_ein",
      "uy_ruc",
      "uz_tin",
      "uz_vat",
      "ve_rif",
      "vn_tin",
      "za_vat",
      "zm_tin",
      "zw_tin",
    ]),
    value: z.string(),
  })

  router.post(
    "postCustomersCustomerTaxIds",
    "/v1/customers/:customer/tax_ids",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postCustomersCustomerTaxIdsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postCustomersCustomerTaxIdsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postCustomersCustomerTaxIds(
          input,
          postCustomersCustomerTaxIds.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postCustomersCustomerTaxIds.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteCustomersCustomerTaxIdsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  const deleteCustomersCustomerTaxIdsIdBodySchema = z.object({}).optional()

  router.delete(
    "deleteCustomersCustomerTaxIdsId",
    "/v1/customers/:customer/tax_ids/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteCustomersCustomerTaxIdsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteCustomersCustomerTaxIdsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteCustomersCustomerTaxIdsId(
          input,
          deleteCustomersCustomerTaxIdsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteCustomersCustomerTaxIdsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getCustomersCustomerTaxIdsIdParamSchema = z.object({
    customer: z.string().max(5000),
    id: z.string(),
  })

  const getCustomersCustomerTaxIdsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getCustomersCustomerTaxIdsIdBodySchema = z.object({}).optional()

  router.get(
    "getCustomersCustomerTaxIdsId",
    "/v1/customers/:customer/tax_ids/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getCustomersCustomerTaxIdsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getCustomersCustomerTaxIdsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getCustomersCustomerTaxIdsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getCustomersCustomerTaxIdsId(
          input,
          getCustomersCustomerTaxIdsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getCustomersCustomerTaxIdsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getDisputesQuerySchema = z.object({
    charge: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getDisputesBodySchema = z.object({}).optional()

  router.get("getDisputes", "/v1/disputes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getDisputesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getDisputesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getDisputes(input, getDisputes.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getDisputes.validator(status, body)
    ctx.status = status
    return next()
  })

  const getDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const getDisputesDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getDisputesDisputeBodySchema = z.object({}).optional()

  router.get(
    "getDisputesDispute",
    "/v1/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getDisputesDisputeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getDisputesDispute(input, getDisputesDispute.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getDisputesDispute.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const postDisputesDisputeBodySchema = z
    .object({
      evidence: z
        .object({
          access_activity_log: z.string().max(20000).optional(),
          billing_address: z.string().max(5000).optional(),
          cancellation_policy: z.string().optional(),
          cancellation_policy_disclosure: z.string().max(20000).optional(),
          cancellation_rebuttal: z.string().max(20000).optional(),
          customer_communication: z.string().optional(),
          customer_email_address: z.string().max(5000).optional(),
          customer_name: z.string().max(5000).optional(),
          customer_purchase_ip: z.string().max(5000).optional(),
          customer_signature: z.string().optional(),
          duplicate_charge_documentation: z.string().optional(),
          duplicate_charge_explanation: z.string().max(20000).optional(),
          duplicate_charge_id: z.string().max(5000).optional(),
          enhanced_evidence: z
            .union([
              z.object({
                visa_compelling_evidence_3: z
                  .object({
                    disputed_transaction: z
                      .object({
                        customer_account_id: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_device_fingerprint: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_device_id: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_email_address: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        customer_purchase_ip: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        merchandise_or_services: z
                          .enum(["merchandise", "services"])
                          .optional(),
                        product_description: z
                          .union([z.string().max(5000), z.enum([""])])
                          .optional(),
                        shipping_address: z
                          .object({
                            city: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            country: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            line1: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            line2: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            postal_code: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                            state: z
                              .union([z.string().max(5000), z.enum([""])])
                              .optional(),
                          })
                          .optional(),
                      })
                      .optional(),
                    prior_undisputed_transactions: z
                      .array(
                        z.object({
                          charge: z.string().max(5000),
                          customer_account_id: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_device_fingerprint: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_device_id: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_email_address: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          customer_purchase_ip: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          product_description: z
                            .union([z.string().max(5000), z.enum([""])])
                            .optional(),
                          shipping_address: z
                            .object({
                              city: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              country: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              line1: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              line2: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              postal_code: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                              state: z
                                .union([z.string().max(5000), z.enum([""])])
                                .optional(),
                            })
                            .optional(),
                        }),
                      )
                      .optional(),
                  })
                  .optional(),
                visa_compliance: z
                  .object({ fee_acknowledged: PermissiveBoolean.optional() })
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          product_description: z.string().max(20000).optional(),
          receipt: z.string().optional(),
          refund_policy: z.string().optional(),
          refund_policy_disclosure: z.string().max(20000).optional(),
          refund_refusal_explanation: z.string().max(20000).optional(),
          service_date: z.string().max(5000).optional(),
          service_documentation: z.string().optional(),
          shipping_address: z.string().max(5000).optional(),
          shipping_carrier: z.string().max(5000).optional(),
          shipping_date: z.string().max(5000).optional(),
          shipping_documentation: z.string().optional(),
          shipping_tracking_number: z.string().max(5000).optional(),
          uncategorized_file: z.string().optional(),
          uncategorized_text: z.string().max(20000).optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      submit: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postDisputesDispute",
    "/v1/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postDisputesDispute(input, postDisputesDispute.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postDisputesDispute.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postDisputesDisputeCloseParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const postDisputesDisputeCloseBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postDisputesDisputeClose",
    "/v1/disputes/:dispute/close",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postDisputesDisputeCloseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postDisputesDisputeCloseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postDisputesDisputeClose(
          input,
          postDisputesDisputeClose.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postDisputesDisputeClose.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsActiveEntitlementsQuerySchema = z.object({
    customer: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getEntitlementsActiveEntitlementsBodySchema = z.object({}).optional()

  router.get(
    "getEntitlementsActiveEntitlements",
    "/v1/entitlements/active_entitlements",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getEntitlementsActiveEntitlementsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsActiveEntitlementsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getEntitlementsActiveEntitlements(
          input,
          getEntitlementsActiveEntitlements.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsActiveEntitlements.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsActiveEntitlementsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getEntitlementsActiveEntitlementsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getEntitlementsActiveEntitlementsIdBodySchema = z.object({}).optional()

  router.get(
    "getEntitlementsActiveEntitlementsId",
    "/v1/entitlements/active_entitlements/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getEntitlementsActiveEntitlementsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getEntitlementsActiveEntitlementsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsActiveEntitlementsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getEntitlementsActiveEntitlementsId(
          input,
          getEntitlementsActiveEntitlementsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsActiveEntitlementsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsFeaturesQuerySchema = z.object({
    archived: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_key: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getEntitlementsFeaturesBodySchema = z.object({}).optional()

  router.get(
    "getEntitlementsFeatures",
    "/v1/entitlements/features",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getEntitlementsFeaturesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getEntitlementsFeatures(input, getEntitlementsFeatures.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsFeatures.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postEntitlementsFeaturesBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    lookup_key: z.string().max(80),
    metadata: z.record(z.string()).optional(),
    name: z.string().max(80),
  })

  router.post(
    "postEntitlementsFeatures",
    "/v1/entitlements/features",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postEntitlementsFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postEntitlementsFeatures(
          input,
          postEntitlementsFeatures.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postEntitlementsFeatures.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEntitlementsFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getEntitlementsFeaturesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getEntitlementsFeaturesIdBodySchema = z.object({}).optional()

  router.get(
    "getEntitlementsFeaturesId",
    "/v1/entitlements/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getEntitlementsFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getEntitlementsFeaturesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getEntitlementsFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getEntitlementsFeaturesId(
          input,
          getEntitlementsFeaturesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEntitlementsFeaturesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postEntitlementsFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postEntitlementsFeaturesIdBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(80).optional(),
    })
    .optional()

  router.post(
    "postEntitlementsFeaturesId",
    "/v1/entitlements/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postEntitlementsFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postEntitlementsFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postEntitlementsFeaturesId(
          input,
          postEntitlementsFeaturesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postEntitlementsFeaturesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postEphemeralKeysBodySchema = z
    .object({
      customer: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      issuing_card: z.string().max(5000).optional(),
      nonce: z.string().max(5000).optional(),
      verification_session: z.string().max(5000).optional(),
    })
    .optional()

  router.post("postEphemeralKeys", "/v1/ephemeral_keys", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postEphemeralKeysBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postEphemeralKeys(input, postEphemeralKeys.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postEphemeralKeys.validator(status, body)
    ctx.status = status
    return next()
  })

  const deleteEphemeralKeysKeyParamSchema = z.object({
    key: z.string().max(5000),
  })

  const deleteEphemeralKeysKeyBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.delete(
    "deleteEphemeralKeysKey",
    "/v1/ephemeral_keys/:key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteEphemeralKeysKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteEphemeralKeysKeyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteEphemeralKeysKey(input, deleteEphemeralKeysKey.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteEphemeralKeysKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEventsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    delivery_success: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.string().max(5000).optional(),
    types: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getEventsBodySchema = z.object({}).optional()

  router.get("getEvents", "/v1/events", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getEventsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getEventsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getEvents(input, getEvents.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getEvents.validator(status, body)
    ctx.status = status
    return next()
  })

  const getEventsIdParamSchema = z.object({ id: z.string().max(5000) })

  const getEventsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getEventsIdBodySchema = z.object({}).optional()

  router.get("getEventsId", "/v1/events/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getEventsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getEventsIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getEventsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getEventsId(input, getEventsId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getEventsId.validator(status, body)
    ctx.status = status
    return next()
  })

  const getExchangeRatesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getExchangeRatesBodySchema = z.object({}).optional()

  router.get("getExchangeRates", "/v1/exchange_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getExchangeRatesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getExchangeRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getExchangeRates(input, getExchangeRates.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getExchangeRates.validator(status, body)
    ctx.status = status
    return next()
  })

  const getExchangeRatesRateIdParamSchema = z.object({
    rate_id: z.string().max(5000),
  })

  const getExchangeRatesRateIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getExchangeRatesRateIdBodySchema = z.object({}).optional()

  router.get(
    "getExchangeRatesRateId",
    "/v1/exchange_rates/:rate_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getExchangeRatesRateIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getExchangeRatesRateIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getExchangeRatesRateIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getExchangeRatesRateId(input, getExchangeRatesRateId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getExchangeRatesRateId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postExternalAccountsIdParamSchema = z.object({ id: z.string() })

  const postExternalAccountsIdBodySchema = z
    .object({
      account_holder_name: z.string().max(5000).optional(),
      account_holder_type: z.enum(["", "company", "individual"]).optional(),
      account_type: z.enum(["checking", "futsu", "savings", "toza"]).optional(),
      address_city: z.string().max(5000).optional(),
      address_country: z.string().max(5000).optional(),
      address_line1: z.string().max(5000).optional(),
      address_line2: z.string().max(5000).optional(),
      address_state: z.string().max(5000).optional(),
      address_zip: z.string().max(5000).optional(),
      default_for_currency: PermissiveBoolean.optional(),
      documents: z
        .object({
          bank_account_ownership_verification: z
            .object({ files: z.array(z.string().max(500)).optional() })
            .optional(),
        })
        .optional(),
      exp_month: z.string().max(5000).optional(),
      exp_year: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postExternalAccountsId",
    "/v1/external_accounts/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postExternalAccountsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postExternalAccountsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postExternalAccountsId(input, postExternalAccountsId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postExternalAccountsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFileLinksQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    expired: PermissiveBoolean.optional(),
    file: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  const getFileLinksBodySchema = z.object({}).optional()

  router.get("getFileLinks", "/v1/file_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getFileLinksQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFileLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getFileLinks(input, getFileLinks.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFileLinks.validator(status, body)
    ctx.status = status
    return next()
  })

  const postFileLinksBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    expires_at: z.coerce.number().optional(),
    file: z.string().max(5000),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
  })

  router.post("postFileLinks", "/v1/file_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postFileLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postFileLinks(input, postFileLinks.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postFileLinks.validator(status, body)
    ctx.status = status
    return next()
  })

  const getFileLinksLinkParamSchema = z.object({ link: z.string() })

  const getFileLinksLinkQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getFileLinksLinkBodySchema = z.object({}).optional()

  router.get("getFileLinksLink", "/v1/file_links/:link", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getFileLinksLinkParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getFileLinksLinkQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFileLinksLinkBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getFileLinksLink(input, getFileLinksLink.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFileLinksLink.validator(status, body)
    ctx.status = status
    return next()
  })

  const postFileLinksLinkParamSchema = z.object({ link: z.string() })

  const postFileLinksLinkBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      expires_at: z
        .union([z.enum(["now"]), z.coerce.number(), z.enum([""])])
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postFileLinksLink",
    "/v1/file_links/:link",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFileLinksLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFileLinksLinkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postFileLinksLink(input, postFileLinksLink.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFileLinksLink.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFilesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    purpose: z
      .enum([
        "account_requirement",
        "additional_verification",
        "business_icon",
        "business_logo",
        "customer_signature",
        "dispute_evidence",
        "document_provider_identity_document",
        "finance_report_run",
        "financial_account_statement",
        "identity_document",
        "identity_document_downloadable",
        "issuing_regulatory_reporting",
        "pci_document",
        "selfie",
        "sigma_scheduled_query",
        "tax_document_user_upload",
        "terminal_reader_splashscreen",
      ])
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getFilesBodySchema = z.object({}).optional()

  router.get("getFiles", "/v1/files", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getFilesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFilesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getFiles(input, getFiles.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFiles.validator(status, body)
    ctx.status = status
    return next()
  })

  const postFilesBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    file: z.string(),
    file_link_data: z
      .object({
        create: PermissiveBoolean,
        expires_at: z.coerce.number().optional(),
        metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      })
      .optional(),
    purpose: z.enum([
      "account_requirement",
      "additional_verification",
      "business_icon",
      "business_logo",
      "customer_signature",
      "dispute_evidence",
      "identity_document",
      "issuing_regulatory_reporting",
      "pci_document",
      "tax_document_user_upload",
      "terminal_reader_splashscreen",
    ]),
  })

  router.post("postFiles", "/v1/files", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postFilesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postFiles(input, postFiles.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postFiles.validator(status, body)
    ctx.status = status
    return next()
  })

  const getFilesFileParamSchema = z.object({ file: z.string().max(5000) })

  const getFilesFileQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getFilesFileBodySchema = z.object({}).optional()

  router.get("getFilesFile", "/v1/files/:file", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getFilesFileParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getFilesFileQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getFilesFileBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getFilesFile(input, getFilesFile.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getFilesFile.validator(status, body)
    ctx.status = status
    return next()
  })

  const getFinancialConnectionsAccountsQuerySchema = z.object({
    account_holder: z
      .object({
        account: z.string().max(5000).optional(),
        customer: z.string().max(5000).optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    session: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getFinancialConnectionsAccountsBodySchema = z.object({}).optional()

  router.get(
    "getFinancialConnectionsAccounts",
    "/v1/financial_connections/accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getFinancialConnectionsAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getFinancialConnectionsAccounts(
          input,
          getFinancialConnectionsAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getFinancialConnectionsAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getFinancialConnectionsAccountsAccountBodySchema = z
    .object({})
    .optional()

  router.get(
    "getFinancialConnectionsAccountsAccount",
    "/v1/financial_connections/accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsAccountsAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getFinancialConnectionsAccountsAccount(
          input,
          getFinancialConnectionsAccountsAccount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsAccountsAccount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountDisconnectParamSchema = z.object(
    { account: z.string().max(5000) },
  )

  const postFinancialConnectionsAccountsAccountDisconnectBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postFinancialConnectionsAccountsAccountDisconnect",
    "/v1/financial_connections/accounts/:account/disconnect",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountDisconnectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountDisconnectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountDisconnect(
          input,
          postFinancialConnectionsAccountsAccountDisconnect.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFinancialConnectionsAccountsAccountDisconnect.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsAccountsAccountOwnersParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getFinancialConnectionsAccountsAccountOwnersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    ownership: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  const getFinancialConnectionsAccountsAccountOwnersBodySchema = z
    .object({})
    .optional()

  router.get(
    "getFinancialConnectionsAccountsAccountOwners",
    "/v1/financial_connections/accounts/:account/owners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsAccountsAccountOwnersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsAccountsAccountOwnersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsAccountsAccountOwnersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getFinancialConnectionsAccountsAccountOwners(
          input,
          getFinancialConnectionsAccountsAccountOwners.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsAccountsAccountOwners.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountRefreshParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postFinancialConnectionsAccountsAccountRefreshBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    features: z.array(z.enum(["balance", "ownership", "transactions"])),
  })

  router.post(
    "postFinancialConnectionsAccountsAccountRefresh",
    "/v1/financial_connections/accounts/:account/refresh",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountRefreshParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountRefreshBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountRefresh(
          input,
          postFinancialConnectionsAccountsAccountRefresh.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFinancialConnectionsAccountsAccountRefresh.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountSubscribeParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postFinancialConnectionsAccountsAccountSubscribeBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    features: z.array(z.enum(["transactions"])),
  })

  router.post(
    "postFinancialConnectionsAccountsAccountSubscribe",
    "/v1/financial_connections/accounts/:account/subscribe",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountSubscribeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountSubscribeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountSubscribe(
          input,
          postFinancialConnectionsAccountsAccountSubscribe.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFinancialConnectionsAccountsAccountSubscribe.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsAccountsAccountUnsubscribeParamSchema =
    z.object({ account: z.string().max(5000) })

  const postFinancialConnectionsAccountsAccountUnsubscribeBodySchema = z.object(
    {
      expand: z.array(z.string().max(5000)).optional(),
      features: z.array(z.enum(["transactions"])),
    },
  )

  router.post(
    "postFinancialConnectionsAccountsAccountUnsubscribe",
    "/v1/financial_connections/accounts/:account/unsubscribe",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postFinancialConnectionsAccountsAccountUnsubscribeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsAccountsAccountUnsubscribeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postFinancialConnectionsAccountsAccountUnsubscribe(
          input,
          postFinancialConnectionsAccountsAccountUnsubscribe.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFinancialConnectionsAccountsAccountUnsubscribe.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postFinancialConnectionsSessionsBodySchema = z.object({
    account_holder: z.object({
      account: z.string().max(5000).optional(),
      customer: z.string().max(5000).optional(),
      type: z.enum(["account", "customer"]),
    }),
    expand: z.array(z.string().max(5000)).optional(),
    filters: z
      .object({
        account_subcategories: z
          .array(
            z.enum([
              "checking",
              "credit_card",
              "line_of_credit",
              "mortgage",
              "savings",
            ]),
          )
          .optional(),
        countries: z.array(z.string().max(5000)).optional(),
      })
      .optional(),
    permissions: z.array(
      z.enum(["balances", "ownership", "payment_method", "transactions"]),
    ),
    prefetch: z
      .array(z.enum(["balances", "ownership", "transactions"]))
      .optional(),
    return_url: z.string().max(5000).optional(),
  })

  router.post(
    "postFinancialConnectionsSessions",
    "/v1/financial_connections/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postFinancialConnectionsSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postFinancialConnectionsSessions(
          input,
          postFinancialConnectionsSessions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postFinancialConnectionsSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getFinancialConnectionsSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getFinancialConnectionsSessionsSessionBodySchema = z
    .object({})
    .optional()

  router.get(
    "getFinancialConnectionsSessionsSession",
    "/v1/financial_connections/sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getFinancialConnectionsSessionsSession(
          input,
          getFinancialConnectionsSessionsSession.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsSessionsSession.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsTransactionsQuerySchema = z.object({
    account: z.string().max(5000),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    transacted_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    transaction_refresh: z.object({ after: z.string().max(5000) }).optional(),
  })

  const getFinancialConnectionsTransactionsBodySchema = z.object({}).optional()

  router.get(
    "getFinancialConnectionsTransactions",
    "/v1/financial_connections/transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getFinancialConnectionsTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getFinancialConnectionsTransactions(
          input,
          getFinancialConnectionsTransactions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsTransactions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getFinancialConnectionsTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getFinancialConnectionsTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getFinancialConnectionsTransactionsTransactionBodySchema = z
    .object({})
    .optional()

  router.get(
    "getFinancialConnectionsTransactionsTransaction",
    "/v1/financial_connections/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getFinancialConnectionsTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getFinancialConnectionsTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getFinancialConnectionsTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getFinancialConnectionsTransactionsTransaction(
          input,
          getFinancialConnectionsTransactionsTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getFinancialConnectionsTransactionsTransaction.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getForwardingRequestsQuerySchema = z.object({
    created: z
      .object({
        gt: z.coerce.number().optional(),
        gte: z.coerce.number().optional(),
        lt: z.coerce.number().optional(),
        lte: z.coerce.number().optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getForwardingRequestsBodySchema = z.object({}).optional()

  router.get(
    "getForwardingRequests",
    "/v1/forwarding/requests",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getForwardingRequestsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getForwardingRequestsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getForwardingRequests(input, getForwardingRequests.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getForwardingRequests.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postForwardingRequestsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    payment_method: z.string().max(5000),
    replacements: z.array(
      z.enum([
        "card_cvc",
        "card_expiry",
        "card_number",
        "cardholder_name",
        "request_signature",
      ]),
    ),
    request: z
      .object({
        body: z.string().max(5000).optional(),
        headers: z
          .array(
            z.object({
              name: z.string().max(5000),
              value: z.string().max(5000),
            }),
          )
          .optional(),
      })
      .optional(),
    url: z.string().max(5000),
  })

  router.post(
    "postForwardingRequests",
    "/v1/forwarding/requests",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postForwardingRequestsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postForwardingRequests(input, postForwardingRequests.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postForwardingRequests.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getForwardingRequestsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getForwardingRequestsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getForwardingRequestsIdBodySchema = z.object({}).optional()

  router.get(
    "getForwardingRequestsId",
    "/v1/forwarding/requests/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getForwardingRequestsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getForwardingRequestsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getForwardingRequestsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getForwardingRequestsId(input, getForwardingRequestsId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getForwardingRequestsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationReportsQuerySchema = z.object({
    client_reference_id: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["document", "id_number"]).optional(),
    verification_session: z.string().max(5000).optional(),
  })

  const getIdentityVerificationReportsBodySchema = z.object({}).optional()

  router.get(
    "getIdentityVerificationReports",
    "/v1/identity/verification_reports",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIdentityVerificationReportsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationReportsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIdentityVerificationReports(
          input,
          getIdentityVerificationReports.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationReports.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationReportsReportParamSchema = z.object({
    report: z.string().max(5000),
  })

  const getIdentityVerificationReportsReportQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIdentityVerificationReportsReportBodySchema = z.object({}).optional()

  router.get(
    "getIdentityVerificationReportsReport",
    "/v1/identity/verification_reports/:report",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIdentityVerificationReportsReportParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIdentityVerificationReportsReportQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationReportsReportBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIdentityVerificationReportsReport(
          input,
          getIdentityVerificationReportsReport.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationReportsReport.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationSessionsQuerySchema = z.object({
    client_reference_id: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    related_customer: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "processing", "requires_input", "verified"])
      .optional(),
  })

  const getIdentityVerificationSessionsBodySchema = z.object({}).optional()

  router.get(
    "getIdentityVerificationSessions",
    "/v1/identity/verification_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIdentityVerificationSessionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIdentityVerificationSessions(
          input,
          getIdentityVerificationSessions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIdentityVerificationSessionsBodySchema = z
    .object({
      client_reference_id: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      options: z
        .object({
          document: z
            .union([
              z.object({
                allowed_types: z
                  .array(z.enum(["driving_license", "id_card", "passport"]))
                  .optional(),
                require_id_number: PermissiveBoolean.optional(),
                require_live_capture: PermissiveBoolean.optional(),
                require_matching_selfie: PermissiveBoolean.optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      provided_details: z
        .object({ email: z.string().optional(), phone: z.string().optional() })
        .optional(),
      related_customer: z.string().max(5000).optional(),
      return_url: z.string().optional(),
      type: z.enum(["document", "id_number"]).optional(),
      verification_flow: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postIdentityVerificationSessions",
    "/v1/identity/verification_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIdentityVerificationSessions(
          input,
          postIdentityVerificationSessions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIdentityVerificationSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getIdentityVerificationSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIdentityVerificationSessionsSessionBodySchema = z
    .object({})
    .optional()

  router.get(
    "getIdentityVerificationSessionsSession",
    "/v1/identity/verification_sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIdentityVerificationSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIdentityVerificationSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIdentityVerificationSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIdentityVerificationSessionsSession(
          input,
          getIdentityVerificationSessionsSession.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIdentityVerificationSessionsSession.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIdentityVerificationSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const postIdentityVerificationSessionsSessionBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      options: z
        .object({
          document: z
            .union([
              z.object({
                allowed_types: z
                  .array(z.enum(["driving_license", "id_card", "passport"]))
                  .optional(),
                require_id_number: PermissiveBoolean.optional(),
                require_live_capture: PermissiveBoolean.optional(),
                require_matching_selfie: PermissiveBoolean.optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      provided_details: z
        .object({ email: z.string().optional(), phone: z.string().optional() })
        .optional(),
      type: z.enum(["document", "id_number"]).optional(),
    })
    .optional()

  router.post(
    "postIdentityVerificationSessionsSession",
    "/v1/identity/verification_sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIdentityVerificationSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIdentityVerificationSessionsSession(
          input,
          postIdentityVerificationSessionsSession.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessionsSession.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIdentityVerificationSessionsSessionCancelParamSchema = z.object({
    session: z.string().max(5000),
  })

  const postIdentityVerificationSessionsSessionCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postIdentityVerificationSessionsSessionCancel",
    "/v1/identity/verification_sessions/:session/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIdentityVerificationSessionsSessionCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsSessionCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIdentityVerificationSessionsSessionCancel(
          input,
          postIdentityVerificationSessionsSessionCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessionsSessionCancel.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIdentityVerificationSessionsSessionRedactParamSchema = z.object({
    session: z.string().max(5000),
  })

  const postIdentityVerificationSessionsSessionRedactBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postIdentityVerificationSessionsSessionRedact",
    "/v1/identity/verification_sessions/:session/redact",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIdentityVerificationSessionsSessionRedactParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIdentityVerificationSessionsSessionRedactBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIdentityVerificationSessionsSessionRedact(
          input,
          postIdentityVerificationSessionsSessionRedact.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIdentityVerificationSessionsSessionRedact.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getInvoicePaymentsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    payment: z
      .object({
        payment_intent: z.string().max(5000).optional(),
        type: z.enum(["payment_intent"]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "open", "paid"]).optional(),
  })

  const getInvoicePaymentsBodySchema = z.object({}).optional()

  router.get(
    "getInvoicePayments",
    "/v1/invoice_payments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getInvoicePaymentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicePaymentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getInvoicePayments(input, getInvoicePayments.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicePayments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicePaymentsInvoicePaymentParamSchema = z.object({
    invoice_payment: z.string().max(5000),
  })

  const getInvoicePaymentsInvoicePaymentQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getInvoicePaymentsInvoicePaymentBodySchema = z.object({}).optional()

  router.get(
    "getInvoicePaymentsInvoicePayment",
    "/v1/invoice_payments/:invoice_payment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoicePaymentsInvoicePaymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoicePaymentsInvoicePaymentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicePaymentsInvoicePaymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getInvoicePaymentsInvoicePayment(
          input,
          getInvoicePaymentsInvoicePayment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicePaymentsInvoicePayment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoiceRenderingTemplatesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "archived"]).optional(),
  })

  const getInvoiceRenderingTemplatesBodySchema = z.object({}).optional()

  router.get(
    "getInvoiceRenderingTemplates",
    "/v1/invoice_rendering_templates",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getInvoiceRenderingTemplatesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoiceRenderingTemplatesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getInvoiceRenderingTemplates(
          input,
          getInvoiceRenderingTemplates.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoiceRenderingTemplates.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoiceRenderingTemplatesTemplateParamSchema = z.object({
    template: z.string().max(5000),
  })

  const getInvoiceRenderingTemplatesTemplateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    version: z.coerce.number().optional(),
  })

  const getInvoiceRenderingTemplatesTemplateBodySchema = z.object({}).optional()

  router.get(
    "getInvoiceRenderingTemplatesTemplate",
    "/v1/invoice_rendering_templates/:template",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoiceRenderingTemplatesTemplateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoiceRenderingTemplatesTemplateQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoiceRenderingTemplatesTemplateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getInvoiceRenderingTemplatesTemplate(
          input,
          getInvoiceRenderingTemplatesTemplate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoiceRenderingTemplatesTemplate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoiceRenderingTemplatesTemplateArchiveParamSchema = z.object({
    template: z.string().max(5000),
  })

  const postInvoiceRenderingTemplatesTemplateArchiveBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postInvoiceRenderingTemplatesTemplateArchive",
    "/v1/invoice_rendering_templates/:template/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateArchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateArchiveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoiceRenderingTemplatesTemplateArchive(
          input,
          postInvoiceRenderingTemplatesTemplateArchive.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoiceRenderingTemplatesTemplateArchive.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postInvoiceRenderingTemplatesTemplateUnarchiveParamSchema = z.object({
    template: z.string().max(5000),
  })

  const postInvoiceRenderingTemplatesTemplateUnarchiveBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postInvoiceRenderingTemplatesTemplateUnarchive",
    "/v1/invoice_rendering_templates/:template/unarchive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateUnarchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoiceRenderingTemplatesTemplateUnarchiveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoiceRenderingTemplatesTemplateUnarchive(
          input,
          postInvoiceRenderingTemplatesTemplateUnarchive.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoiceRenderingTemplatesTemplateUnarchive.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getInvoiceitemsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    invoice: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    pending: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getInvoiceitemsBodySchema = z.object({}).optional()

  router.get("getInvoiceitems", "/v1/invoiceitems", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getInvoiceitemsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getInvoiceitemsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getInvoiceitems(input, getInvoiceitems.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getInvoiceitems.validator(status, body)
    ctx.status = status
    return next()
  })

  const postInvoiceitemsBodySchema = z.object({
    amount: z.coerce.number().optional(),
    currency: z.string().optional(),
    customer: z.string().max(5000),
    description: z.string().max(5000).optional(),
    discountable: PermissiveBoolean.optional(),
    discounts: z
      .union([
        z.array(
          z.object({
            coupon: z.string().max(5000).optional(),
            discount: z.string().max(5000).optional(),
            promotion_code: z.string().max(5000).optional(),
          }),
        ),
        z.enum([""]),
      ])
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    invoice: z.string().max(5000).optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    period: z
      .object({ end: z.coerce.number(), start: z.coerce.number() })
      .optional(),
    price_data: z
      .object({
        currency: z.string(),
        product: z.string().max(5000),
        tax_behavior: z
          .enum(["exclusive", "inclusive", "unspecified"])
          .optional(),
        unit_amount: z.coerce.number().optional(),
        unit_amount_decimal: z.string().optional(),
      })
      .optional(),
    pricing: z.object({ price: z.string().max(5000).optional() }).optional(),
    quantity: z.coerce.number().optional(),
    subscription: z.string().max(5000).optional(),
    tax_behavior: z.enum(["exclusive", "inclusive", "unspecified"]).optional(),
    tax_code: z.union([z.string(), z.enum([""])]).optional(),
    tax_rates: z.array(z.string().max(5000)).optional(),
    unit_amount_decimal: z.string().optional(),
  })

  router.post("postInvoiceitems", "/v1/invoiceitems", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postInvoiceitemsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postInvoiceitems(input, postInvoiceitems.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postInvoiceitems.validator(status, body)
    ctx.status = status
    return next()
  })

  const deleteInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  const deleteInvoiceitemsInvoiceitemBodySchema = z.object({}).optional()

  router.delete(
    "deleteInvoiceitemsInvoiceitem",
    "/v1/invoiceitems/:invoiceitem",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteInvoiceitemsInvoiceitemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteInvoiceitemsInvoiceitemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteInvoiceitemsInvoiceitem(
          input,
          deleteInvoiceitemsInvoiceitem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteInvoiceitemsInvoiceitem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  const getInvoiceitemsInvoiceitemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getInvoiceitemsInvoiceitemBodySchema = z.object({}).optional()

  router.get(
    "getInvoiceitemsInvoiceitem",
    "/v1/invoiceitems/:invoiceitem",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoiceitemsInvoiceitemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoiceitemsInvoiceitemQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoiceitemsInvoiceitemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getInvoiceitemsInvoiceitem(
          input,
          getInvoiceitemsInvoiceitem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoiceitemsInvoiceitem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoiceitemsInvoiceitemParamSchema = z.object({
    invoiceitem: z.string().max(5000),
  })

  const postInvoiceitemsInvoiceitemBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      description: z.string().max(5000).optional(),
      discountable: PermissiveBoolean.optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      period: z
        .object({ end: z.coerce.number(), start: z.coerce.number() })
        .optional(),
      price_data: z
        .object({
          currency: z.string(),
          product: z.string().max(5000),
          tax_behavior: z
            .enum(["exclusive", "inclusive", "unspecified"])
            .optional(),
          unit_amount: z.coerce.number().optional(),
          unit_amount_decimal: z.string().optional(),
        })
        .optional(),
      pricing: z.object({ price: z.string().max(5000).optional() }).optional(),
      quantity: z.coerce.number().optional(),
      tax_behavior: z
        .enum(["exclusive", "inclusive", "unspecified"])
        .optional(),
      tax_code: z.union([z.string(), z.enum([""])]).optional(),
      tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      unit_amount_decimal: z.string().optional(),
    })
    .optional()

  router.post(
    "postInvoiceitemsInvoiceitem",
    "/v1/invoiceitems/:invoiceitem",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoiceitemsInvoiceitemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoiceitemsInvoiceitemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoiceitemsInvoiceitem(
          input,
          postInvoiceitemsInvoiceitem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoiceitemsInvoiceitem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesQuerySchema = z.object({
    collection_method: z
      .enum(["charge_automatically", "send_invoice"])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    due_date: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["draft", "open", "paid", "uncollectible", "void"])
      .optional(),
    subscription: z.string().max(5000).optional(),
  })

  const getInvoicesBodySchema = z.object({}).optional()

  router.get("getInvoices", "/v1/invoices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getInvoicesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getInvoicesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getInvoices(input, getInvoices.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getInvoices.validator(status, body)
    ctx.status = status
    return next()
  })

  const postInvoicesBodySchema = z
    .object({
      account_tax_ids: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      application_fee_amount: z.coerce.number().optional(),
      auto_advance: PermissiveBoolean.optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      automatically_finalizes_at: z.coerce.number().optional(),
      collection_method: z
        .enum(["charge_automatically", "send_invoice"])
        .optional(),
      currency: z.string().optional(),
      custom_fields: z
        .union([
          z.array(
            z.object({ name: z.string().max(40), value: z.string().max(140) }),
          ),
          z.enum([""]),
        ])
        .optional(),
      customer: z.string().max(5000).optional(),
      days_until_due: z.coerce.number().optional(),
      default_payment_method: z.string().max(5000).optional(),
      default_source: z.string().max(5000).optional(),
      default_tax_rates: z.array(z.string().max(5000)).optional(),
      description: z.string().max(1500).optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      due_date: z.coerce.number().optional(),
      effective_at: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      footer: z.string().max(5000).optional(),
      from_invoice: z
        .object({ action: z.enum(["revision"]), invoice: z.string().max(5000) })
        .optional(),
      issuer: z
        .object({
          account: z.string().optional(),
          type: z.enum(["account", "self"]),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      number: z.string().max(26).optional(),
      on_behalf_of: z.string().optional(),
      payment_settings: z
        .object({
          default_mandate: z
            .union([z.string().max(5000), z.enum([""])])
            .optional(),
          payment_method_options: z
            .object({
              acss_debit: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        transaction_type: z
                          .enum(["business", "personal"])
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              bancontact: z
                .union([
                  z.object({
                    preferred_language: z
                      .enum(["de", "en", "fr", "nl"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              card: z
                .union([
                  z.object({
                    installments: z
                      .object({
                        enabled: PermissiveBoolean.optional(),
                        plan: z
                          .union([
                            z.object({
                              count: z.coerce.number().optional(),
                              interval: z.enum(["month"]).optional(),
                              type: z.enum(["fixed_count"]),
                            }),
                            z.enum([""]),
                          ])
                          .optional(),
                      })
                      .optional(),
                    request_three_d_secure: z
                      .enum(["any", "automatic", "challenge"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              customer_balance: z
                .union([
                  z.object({
                    bank_transfer: z
                      .object({
                        eu_bank_transfer: z
                          .object({ country: z.string().max(5000) })
                          .optional(),
                        type: z.string().optional(),
                      })
                      .optional(),
                    funding_type: z.string().optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              konbini: z.union([z.object({}), z.enum([""])]).optional(),
              sepa_debit: z.union([z.object({}), z.enum([""])]).optional(),
              us_bank_account: z
                .union([
                  z.object({
                    financial_connections: z
                      .object({
                        filters: z
                          .object({
                            account_subcategories: z
                              .array(z.enum(["checking", "savings"]))
                              .optional(),
                          })
                          .optional(),
                        permissions: z
                          .array(
                            z.enum([
                              "balances",
                              "ownership",
                              "payment_method",
                              "transactions",
                            ]),
                          )
                          .optional(),
                        prefetch: z
                          .array(
                            z.enum(["balances", "ownership", "transactions"]),
                          )
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
            })
            .optional(),
          payment_method_types: z
            .union([
              z.array(
                z.enum([
                  "ach_credit_transfer",
                  "ach_debit",
                  "acss_debit",
                  "amazon_pay",
                  "au_becs_debit",
                  "bacs_debit",
                  "bancontact",
                  "boleto",
                  "card",
                  "cashapp",
                  "customer_balance",
                  "eps",
                  "fpx",
                  "giropay",
                  "grabpay",
                  "ideal",
                  "jp_credit_transfer",
                  "kakao_pay",
                  "klarna",
                  "konbini",
                  "kr_card",
                  "link",
                  "multibanco",
                  "naver_pay",
                  "nz_bank_account",
                  "p24",
                  "payco",
                  "paynow",
                  "paypal",
                  "promptpay",
                  "revolut_pay",
                  "sepa_credit_transfer",
                  "sepa_debit",
                  "sofort",
                  "swish",
                  "us_bank_account",
                  "wechat_pay",
                ]),
              ),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      pending_invoice_items_behavior: z.enum(["exclude", "include"]).optional(),
      rendering: z
        .object({
          amount_tax_display: z
            .enum(["", "exclude_tax", "include_inclusive_tax"])
            .optional(),
          pdf: z
            .object({ page_size: z.enum(["a4", "auto", "letter"]).optional() })
            .optional(),
          template: z.string().max(5000).optional(),
          template_version: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
        })
        .optional(),
      shipping_cost: z
        .object({
          shipping_rate: z.string().max(5000).optional(),
          shipping_rate_data: z
            .object({
              delivery_estimate: z
                .object({
                  maximum: z
                    .object({
                      unit: z.enum([
                        "business_day",
                        "day",
                        "hour",
                        "month",
                        "week",
                      ]),
                      value: z.coerce.number(),
                    })
                    .optional(),
                  minimum: z
                    .object({
                      unit: z.enum([
                        "business_day",
                        "day",
                        "hour",
                        "month",
                        "week",
                      ]),
                      value: z.coerce.number(),
                    })
                    .optional(),
                })
                .optional(),
              display_name: z.string().max(100),
              fixed_amount: z
                .object({
                  amount: z.coerce.number(),
                  currency: z.string(),
                  currency_options: z
                    .record(
                      z.object({
                        amount: z.coerce.number(),
                        tax_behavior: z
                          .enum(["exclusive", "inclusive", "unspecified"])
                          .optional(),
                      }),
                    )
                    .optional(),
                })
                .optional(),
              metadata: z.record(z.string()).optional(),
              tax_behavior: z
                .enum(["exclusive", "inclusive", "unspecified"])
                .optional(),
              tax_code: z.string().optional(),
              type: z.enum(["fixed_amount"]).optional(),
            })
            .optional(),
        })
        .optional(),
      shipping_details: z
        .object({
          address: z.object({
            city: z.string().max(5000).optional(),
            country: z.string().max(5000).optional(),
            line1: z.string().max(5000).optional(),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000).optional(),
            state: z.string().max(5000).optional(),
          }),
          name: z.string().max(5000),
          phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
        })
        .optional(),
      statement_descriptor: z.string().max(22).optional(),
      subscription: z.string().max(5000).optional(),
      transfer_data: z
        .object({
          amount: z.coerce.number().optional(),
          destination: z.string(),
        })
        .optional(),
    })
    .optional()

  router.post("postInvoices", "/v1/invoices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postInvoicesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postInvoices(input, postInvoices.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postInvoices.validator(status, body)
    ctx.status = status
    return next()
  })

  const postInvoicesCreatePreviewBodySchema = z
    .object({
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      currency: z.string().optional(),
      customer: z.string().max(5000).optional(),
      customer_details: z
        .object({
          address: z
            .union([
              z.object({
                city: z.string().max(5000).optional(),
                country: z.string().max(5000).optional(),
                line1: z.string().max(5000).optional(),
                line2: z.string().max(5000).optional(),
                postal_code: z.string().max(5000).optional(),
                state: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          shipping: z
            .union([
              z.object({
                address: z.object({
                  city: z.string().max(5000).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(5000).optional(),
                  line2: z.string().max(5000).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                }),
                name: z.string().max(5000),
                phone: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          tax: z
            .object({
              ip_address: z.union([z.string(), z.enum([""])]).optional(),
            })
            .optional(),
          tax_exempt: z.enum(["", "exempt", "none", "reverse"]).optional(),
          tax_ids: z
            .array(
              z.object({
                type: z.enum([
                  "ad_nrt",
                  "ae_trn",
                  "al_tin",
                  "am_tin",
                  "ao_tin",
                  "ar_cuit",
                  "au_abn",
                  "au_arn",
                  "ba_tin",
                  "bb_tin",
                  "bg_uic",
                  "bh_vat",
                  "bo_tin",
                  "br_cnpj",
                  "br_cpf",
                  "bs_tin",
                  "by_tin",
                  "ca_bn",
                  "ca_gst_hst",
                  "ca_pst_bc",
                  "ca_pst_mb",
                  "ca_pst_sk",
                  "ca_qst",
                  "cd_nif",
                  "ch_uid",
                  "ch_vat",
                  "cl_tin",
                  "cn_tin",
                  "co_nit",
                  "cr_tin",
                  "de_stn",
                  "do_rcn",
                  "ec_ruc",
                  "eg_tin",
                  "es_cif",
                  "eu_oss_vat",
                  "eu_vat",
                  "gb_vat",
                  "ge_vat",
                  "gn_nif",
                  "hk_br",
                  "hr_oib",
                  "hu_tin",
                  "id_npwp",
                  "il_vat",
                  "in_gst",
                  "is_vat",
                  "jp_cn",
                  "jp_rn",
                  "jp_trn",
                  "ke_pin",
                  "kh_tin",
                  "kr_brn",
                  "kz_bin",
                  "li_uid",
                  "li_vat",
                  "ma_vat",
                  "md_vat",
                  "me_pib",
                  "mk_vat",
                  "mr_nif",
                  "mx_rfc",
                  "my_frp",
                  "my_itn",
                  "my_sst",
                  "ng_tin",
                  "no_vat",
                  "no_voec",
                  "np_pan",
                  "nz_gst",
                  "om_vat",
                  "pe_ruc",
                  "ph_tin",
                  "ro_tin",
                  "rs_pib",
                  "ru_inn",
                  "ru_kpp",
                  "sa_vat",
                  "sg_gst",
                  "sg_uen",
                  "si_tin",
                  "sn_ninea",
                  "sr_fin",
                  "sv_nit",
                  "th_vat",
                  "tj_tin",
                  "tr_tin",
                  "tw_vat",
                  "tz_vat",
                  "ua_vat",
                  "ug_tin",
                  "us_ein",
                  "uy_ruc",
                  "uz_tin",
                  "uz_vat",
                  "ve_rif",
                  "vn_tin",
                  "za_vat",
                  "zm_tin",
                  "zw_tin",
                ]),
                value: z.string(),
              }),
            )
            .optional(),
        })
        .optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      invoice_items: z
        .array(
          z.object({
            amount: z.coerce.number().optional(),
            currency: z.string().optional(),
            description: z.string().max(5000).optional(),
            discountable: PermissiveBoolean.optional(),
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            invoiceitem: z.string().max(5000).optional(),
            metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
            period: z
              .object({ end: z.coerce.number(), start: z.coerce.number() })
              .optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_behavior: z
              .enum(["exclusive", "inclusive", "unspecified"])
              .optional(),
            tax_code: z.union([z.string(), z.enum([""])]).optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          }),
        )
        .optional(),
      issuer: z
        .object({
          account: z.string().optional(),
          type: z.enum(["account", "self"]),
        })
        .optional(),
      on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
      preview_mode: z.enum(["next", "recurring"]).optional(),
      schedule: z.string().max(5000).optional(),
      schedule_details: z
        .object({
          end_behavior: z.enum(["cancel", "release"]).optional(),
          phases: z
            .array(
              z.object({
                add_invoice_items: z
                  .array(
                    z.object({
                      discounts: z
                        .array(
                          z.object({
                            coupon: z.string().max(5000).optional(),
                            discount: z.string().max(5000).optional(),
                            promotion_code: z.string().max(5000).optional(),
                          }),
                        )
                        .optional(),
                      price: z.string().max(5000).optional(),
                      price_data: z
                        .object({
                          currency: z.string(),
                          product: z.string().max(5000),
                          tax_behavior: z
                            .enum(["exclusive", "inclusive", "unspecified"])
                            .optional(),
                          unit_amount: z.coerce.number().optional(),
                          unit_amount_decimal: z.string().optional(),
                        })
                        .optional(),
                      quantity: z.coerce.number().optional(),
                      tax_rates: z
                        .union([z.array(z.string().max(5000)), z.enum([""])])
                        .optional(),
                    }),
                  )
                  .optional(),
                application_fee_percent: z.coerce.number().optional(),
                automatic_tax: z
                  .object({
                    enabled: PermissiveBoolean,
                    liability: z
                      .object({
                        account: z.string().optional(),
                        type: z.enum(["account", "self"]),
                      })
                      .optional(),
                  })
                  .optional(),
                billing_cycle_anchor: z
                  .enum(["automatic", "phase_start"])
                  .optional(),
                collection_method: z
                  .enum(["charge_automatically", "send_invoice"])
                  .optional(),
                default_payment_method: z.string().max(5000).optional(),
                default_tax_rates: z
                  .union([z.array(z.string().max(5000)), z.enum([""])])
                  .optional(),
                description: z
                  .union([z.string().max(500), z.enum([""])])
                  .optional(),
                discounts: z
                  .union([
                    z.array(
                      z.object({
                        coupon: z.string().max(5000).optional(),
                        discount: z.string().max(5000).optional(),
                        promotion_code: z.string().max(5000).optional(),
                      }),
                    ),
                    z.enum([""]),
                  ])
                  .optional(),
                end_date: z
                  .union([z.coerce.number(), z.enum(["now"])])
                  .optional(),
                invoice_settings: z
                  .object({
                    account_tax_ids: z
                      .union([z.array(z.string().max(5000)), z.enum([""])])
                      .optional(),
                    days_until_due: z.coerce.number().optional(),
                    issuer: z
                      .object({
                        account: z.string().optional(),
                        type: z.enum(["account", "self"]),
                      })
                      .optional(),
                  })
                  .optional(),
                items: z.array(
                  z.object({
                    discounts: z
                      .union([
                        z.array(
                          z.object({
                            coupon: z.string().max(5000).optional(),
                            discount: z.string().max(5000).optional(),
                            promotion_code: z.string().max(5000).optional(),
                          }),
                        ),
                        z.enum([""]),
                      ])
                      .optional(),
                    metadata: z.record(z.string()).optional(),
                    price: z.string().max(5000).optional(),
                    price_data: z
                      .object({
                        currency: z.string(),
                        product: z.string().max(5000),
                        recurring: z.object({
                          interval: z.enum(["day", "month", "week", "year"]),
                          interval_count: z.coerce.number().optional(),
                        }),
                        tax_behavior: z
                          .enum(["exclusive", "inclusive", "unspecified"])
                          .optional(),
                        unit_amount: z.coerce.number().optional(),
                        unit_amount_decimal: z.string().optional(),
                      })
                      .optional(),
                    quantity: z.coerce.number().optional(),
                    tax_rates: z
                      .union([z.array(z.string().max(5000)), z.enum([""])])
                      .optional(),
                  }),
                ),
                iterations: z.coerce.number().optional(),
                metadata: z.record(z.string()).optional(),
                on_behalf_of: z.string().optional(),
                proration_behavior: z
                  .enum(["always_invoice", "create_prorations", "none"])
                  .optional(),
                start_date: z
                  .union([z.coerce.number(), z.enum(["now"])])
                  .optional(),
                transfer_data: z
                  .object({
                    amount_percent: z.coerce.number().optional(),
                    destination: z.string(),
                  })
                  .optional(),
                trial: PermissiveBoolean.optional(),
                trial_end: z
                  .union([z.coerce.number(), z.enum(["now"])])
                  .optional(),
              }),
            )
            .optional(),
          proration_behavior: z
            .enum(["always_invoice", "create_prorations", "none"])
            .optional(),
        })
        .optional(),
      subscription: z.string().max(5000).optional(),
      subscription_details: z
        .object({
          billing_cycle_anchor: z
            .union([z.enum(["now", "unchanged"]), z.coerce.number()])
            .optional(),
          cancel_at: z.union([z.coerce.number(), z.enum([""])]).optional(),
          cancel_at_period_end: PermissiveBoolean.optional(),
          cancel_now: PermissiveBoolean.optional(),
          default_tax_rates: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
          items: z
            .array(
              z.object({
                clear_usage: PermissiveBoolean.optional(),
                deleted: PermissiveBoolean.optional(),
                discounts: z
                  .union([
                    z.array(
                      z.object({
                        coupon: z.string().max(5000).optional(),
                        discount: z.string().max(5000).optional(),
                        promotion_code: z.string().max(5000).optional(),
                      }),
                    ),
                    z.enum([""]),
                  ])
                  .optional(),
                id: z.string().max(5000).optional(),
                metadata: z
                  .union([z.record(z.string()), z.enum([""])])
                  .optional(),
                price: z.string().max(5000).optional(),
                price_data: z
                  .object({
                    currency: z.string(),
                    product: z.string().max(5000),
                    recurring: z.object({
                      interval: z.enum(["day", "month", "week", "year"]),
                      interval_count: z.coerce.number().optional(),
                    }),
                    tax_behavior: z
                      .enum(["exclusive", "inclusive", "unspecified"])
                      .optional(),
                    unit_amount: z.coerce.number().optional(),
                    unit_amount_decimal: z.string().optional(),
                  })
                  .optional(),
                quantity: z.coerce.number().optional(),
                tax_rates: z
                  .union([z.array(z.string().max(5000)), z.enum([""])])
                  .optional(),
              }),
            )
            .optional(),
          proration_behavior: z
            .enum(["always_invoice", "create_prorations", "none"])
            .optional(),
          proration_date: z.coerce.number().optional(),
          resume_at: z.enum(["now"]).optional(),
          start_date: z.coerce.number().optional(),
          trial_end: z.union([z.enum(["now"]), z.coerce.number()]).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postInvoicesCreatePreview",
    "/v1/invoices/create_preview",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postInvoicesCreatePreviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesCreatePreview(
          input,
          postInvoicesCreatePreview.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesCreatePreview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  const getInvoicesSearchBodySchema = z.object({}).optional()

  router.get("getInvoicesSearch", "/v1/invoices/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getInvoicesSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getInvoicesSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getInvoicesSearch(input, getInvoicesSearch.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getInvoicesSearch.validator(status, body)
    ctx.status = status
    return next()
  })

  const deleteInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const deleteInvoicesInvoiceBodySchema = z.object({}).optional()

  router.delete(
    "deleteInvoicesInvoice",
    "/v1/invoices/:invoice",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteInvoicesInvoiceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteInvoicesInvoiceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteInvoicesInvoice(input, deleteInvoicesInvoice.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteInvoicesInvoice.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const getInvoicesInvoiceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getInvoicesInvoiceBodySchema = z.object({}).optional()

  router.get(
    "getInvoicesInvoice",
    "/v1/invoices/:invoice",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoicesInvoiceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoicesInvoiceQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicesInvoiceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getInvoicesInvoice(input, getInvoicesInvoice.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicesInvoice.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceBodySchema = z
    .object({
      account_tax_ids: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      application_fee_amount: z.coerce.number().optional(),
      auto_advance: PermissiveBoolean.optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      automatically_finalizes_at: z.coerce.number().optional(),
      collection_method: z
        .enum(["charge_automatically", "send_invoice"])
        .optional(),
      custom_fields: z
        .union([
          z.array(
            z.object({ name: z.string().max(40), value: z.string().max(140) }),
          ),
          z.enum([""]),
        ])
        .optional(),
      days_until_due: z.coerce.number().optional(),
      default_payment_method: z.string().max(5000).optional(),
      default_source: z.union([z.string().max(5000), z.enum([""])]).optional(),
      default_tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      description: z.string().max(1500).optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      due_date: z.coerce.number().optional(),
      effective_at: z.union([z.coerce.number(), z.enum([""])]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      footer: z.string().max(5000).optional(),
      issuer: z
        .object({
          account: z.string().optional(),
          type: z.enum(["account", "self"]),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      number: z.union([z.string().max(26), z.enum([""])]).optional(),
      on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
      payment_settings: z
        .object({
          default_mandate: z
            .union([z.string().max(5000), z.enum([""])])
            .optional(),
          payment_method_options: z
            .object({
              acss_debit: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        transaction_type: z
                          .enum(["business", "personal"])
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              bancontact: z
                .union([
                  z.object({
                    preferred_language: z
                      .enum(["de", "en", "fr", "nl"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              card: z
                .union([
                  z.object({
                    installments: z
                      .object({
                        enabled: PermissiveBoolean.optional(),
                        plan: z
                          .union([
                            z.object({
                              count: z.coerce.number().optional(),
                              interval: z.enum(["month"]).optional(),
                              type: z.enum(["fixed_count"]),
                            }),
                            z.enum([""]),
                          ])
                          .optional(),
                      })
                      .optional(),
                    request_three_d_secure: z
                      .enum(["any", "automatic", "challenge"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              customer_balance: z
                .union([
                  z.object({
                    bank_transfer: z
                      .object({
                        eu_bank_transfer: z
                          .object({ country: z.string().max(5000) })
                          .optional(),
                        type: z.string().optional(),
                      })
                      .optional(),
                    funding_type: z.string().optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              konbini: z.union([z.object({}), z.enum([""])]).optional(),
              sepa_debit: z.union([z.object({}), z.enum([""])]).optional(),
              us_bank_account: z
                .union([
                  z.object({
                    financial_connections: z
                      .object({
                        filters: z
                          .object({
                            account_subcategories: z
                              .array(z.enum(["checking", "savings"]))
                              .optional(),
                          })
                          .optional(),
                        permissions: z
                          .array(
                            z.enum([
                              "balances",
                              "ownership",
                              "payment_method",
                              "transactions",
                            ]),
                          )
                          .optional(),
                        prefetch: z
                          .array(
                            z.enum(["balances", "ownership", "transactions"]),
                          )
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
            })
            .optional(),
          payment_method_types: z
            .union([
              z.array(
                z.enum([
                  "ach_credit_transfer",
                  "ach_debit",
                  "acss_debit",
                  "amazon_pay",
                  "au_becs_debit",
                  "bacs_debit",
                  "bancontact",
                  "boleto",
                  "card",
                  "cashapp",
                  "customer_balance",
                  "eps",
                  "fpx",
                  "giropay",
                  "grabpay",
                  "ideal",
                  "jp_credit_transfer",
                  "kakao_pay",
                  "klarna",
                  "konbini",
                  "kr_card",
                  "link",
                  "multibanco",
                  "naver_pay",
                  "nz_bank_account",
                  "p24",
                  "payco",
                  "paynow",
                  "paypal",
                  "promptpay",
                  "revolut_pay",
                  "sepa_credit_transfer",
                  "sepa_debit",
                  "sofort",
                  "swish",
                  "us_bank_account",
                  "wechat_pay",
                ]),
              ),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      rendering: z
        .object({
          amount_tax_display: z
            .enum(["", "exclude_tax", "include_inclusive_tax"])
            .optional(),
          pdf: z
            .object({ page_size: z.enum(["a4", "auto", "letter"]).optional() })
            .optional(),
          template: z.string().max(5000).optional(),
          template_version: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
        })
        .optional(),
      shipping_cost: z
        .union([
          z.object({
            shipping_rate: z.string().max(5000).optional(),
            shipping_rate_data: z
              .object({
                delivery_estimate: z
                  .object({
                    maximum: z
                      .object({
                        unit: z.enum([
                          "business_day",
                          "day",
                          "hour",
                          "month",
                          "week",
                        ]),
                        value: z.coerce.number(),
                      })
                      .optional(),
                    minimum: z
                      .object({
                        unit: z.enum([
                          "business_day",
                          "day",
                          "hour",
                          "month",
                          "week",
                        ]),
                        value: z.coerce.number(),
                      })
                      .optional(),
                  })
                  .optional(),
                display_name: z.string().max(100),
                fixed_amount: z
                  .object({
                    amount: z.coerce.number(),
                    currency: z.string(),
                    currency_options: z
                      .record(
                        z.object({
                          amount: z.coerce.number(),
                          tax_behavior: z
                            .enum(["exclusive", "inclusive", "unspecified"])
                            .optional(),
                        }),
                      )
                      .optional(),
                  })
                  .optional(),
                metadata: z.record(z.string()).optional(),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                tax_code: z.string().optional(),
                type: z.enum(["fixed_amount"]).optional(),
              })
              .optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      shipping_details: z
        .union([
          z.object({
            address: z.object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            }),
            name: z.string().max(5000),
            phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      statement_descriptor: z.string().max(22).optional(),
      transfer_data: z
        .union([
          z.object({
            amount: z.coerce.number().optional(),
            destination: z.string(),
          }),
          z.enum([""]),
        ])
        .optional(),
    })
    .optional()

  router.post(
    "postInvoicesInvoice",
    "/v1/invoices/:invoice",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoice(input, postInvoicesInvoice.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoice.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceAddLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceAddLinesBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    invoice_metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    lines: z.array(
      z.object({
        amount: z.coerce.number().optional(),
        description: z.string().max(5000).optional(),
        discountable: PermissiveBoolean.optional(),
        discounts: z
          .union([
            z.array(
              z.object({
                coupon: z.string().max(5000).optional(),
                discount: z.string().max(5000).optional(),
                promotion_code: z.string().max(5000).optional(),
              }),
            ),
            z.enum([""]),
          ])
          .optional(),
        invoice_item: z.string().max(5000).optional(),
        metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
        period: z
          .object({ end: z.coerce.number(), start: z.coerce.number() })
          .optional(),
        price_data: z
          .object({
            currency: z.string(),
            product: z.string().max(5000).optional(),
            product_data: z
              .object({
                description: z.string().max(40000).optional(),
                images: z.array(z.string()).optional(),
                metadata: z.record(z.string()).optional(),
                name: z.string().max(5000),
                tax_code: z.string().max(5000).optional(),
              })
              .optional(),
            tax_behavior: z
              .enum(["exclusive", "inclusive", "unspecified"])
              .optional(),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          })
          .optional(),
        pricing: z
          .object({ price: z.string().max(5000).optional() })
          .optional(),
        quantity: z.coerce.number().optional(),
        tax_amounts: z
          .union([
            z.array(
              z.object({
                amount: z.coerce.number(),
                tax_rate_data: z.object({
                  country: z.string().max(5000).optional(),
                  description: z.string().max(5000).optional(),
                  display_name: z.string().max(100),
                  inclusive: PermissiveBoolean,
                  jurisdiction: z.string().max(200).optional(),
                  jurisdiction_level: z
                    .enum([
                      "city",
                      "country",
                      "county",
                      "district",
                      "multiple",
                      "state",
                    ])
                    .optional(),
                  percentage: z.coerce.number(),
                  state: z.string().max(5000).optional(),
                  tax_type: z
                    .enum([
                      "amusement_tax",
                      "communications_tax",
                      "gst",
                      "hst",
                      "igst",
                      "jct",
                      "lease_tax",
                      "pst",
                      "qst",
                      "retail_delivery_fee",
                      "rst",
                      "sales_tax",
                      "service_tax",
                      "vat",
                    ])
                    .optional(),
                }),
                taxability_reason: z
                  .enum([
                    "customer_exempt",
                    "not_collecting",
                    "not_subject_to_tax",
                    "not_supported",
                    "portion_product_exempt",
                    "portion_reduced_rated",
                    "portion_standard_rated",
                    "product_exempt",
                    "product_exempt_holiday",
                    "proportionally_rated",
                    "reduced_rated",
                    "reverse_charge",
                    "standard_rated",
                    "taxable_basis_reduced",
                    "zero_rated",
                  ])
                  .optional(),
                taxable_amount: z.coerce.number(),
              }),
            ),
            z.enum([""]),
          ])
          .optional(),
        tax_rates: z
          .union([z.array(z.string().max(5000)), z.enum([""])])
          .optional(),
      }),
    ),
  })

  router.post(
    "postInvoicesInvoiceAddLines",
    "/v1/invoices/:invoice/add_lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceAddLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceAddLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceAddLines(
          input,
          postInvoicesInvoiceAddLines.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceAddLines.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceFinalizeParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceFinalizeBodySchema = z
    .object({
      auto_advance: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postInvoicesInvoiceFinalize",
    "/v1/invoices/:invoice/finalize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceFinalizeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceFinalizeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceFinalize(
          input,
          postInvoicesInvoiceFinalize.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceFinalize.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getInvoicesInvoiceLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const getInvoicesInvoiceLinesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getInvoicesInvoiceLinesBodySchema = z.object({}).optional()

  router.get(
    "getInvoicesInvoiceLines",
    "/v1/invoices/:invoice/lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getInvoicesInvoiceLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getInvoicesInvoiceLinesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getInvoicesInvoiceLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getInvoicesInvoiceLines(input, getInvoicesInvoiceLines.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getInvoicesInvoiceLines.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceLinesLineItemIdParamSchema = z.object({
    invoice: z.string().max(5000),
    line_item_id: z.string().max(5000),
  })

  const postInvoicesInvoiceLinesLineItemIdBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      description: z.string().max(5000).optional(),
      discountable: PermissiveBoolean.optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      period: z
        .object({ end: z.coerce.number(), start: z.coerce.number() })
        .optional(),
      price_data: z
        .object({
          currency: z.string(),
          product: z.string().max(5000).optional(),
          product_data: z
            .object({
              description: z.string().max(40000).optional(),
              images: z.array(z.string()).optional(),
              metadata: z.record(z.string()).optional(),
              name: z.string().max(5000),
              tax_code: z.string().max(5000).optional(),
            })
            .optional(),
          tax_behavior: z
            .enum(["exclusive", "inclusive", "unspecified"])
            .optional(),
          unit_amount: z.coerce.number().optional(),
          unit_amount_decimal: z.string().optional(),
        })
        .optional(),
      pricing: z.object({ price: z.string().max(5000).optional() }).optional(),
      quantity: z.coerce.number().optional(),
      tax_amounts: z
        .union([
          z.array(
            z.object({
              amount: z.coerce.number(),
              tax_rate_data: z.object({
                country: z.string().max(5000).optional(),
                description: z.string().max(5000).optional(),
                display_name: z.string().max(100),
                inclusive: PermissiveBoolean,
                jurisdiction: z.string().max(200).optional(),
                jurisdiction_level: z
                  .enum([
                    "city",
                    "country",
                    "county",
                    "district",
                    "multiple",
                    "state",
                  ])
                  .optional(),
                percentage: z.coerce.number(),
                state: z.string().max(5000).optional(),
                tax_type: z
                  .enum([
                    "amusement_tax",
                    "communications_tax",
                    "gst",
                    "hst",
                    "igst",
                    "jct",
                    "lease_tax",
                    "pst",
                    "qst",
                    "retail_delivery_fee",
                    "rst",
                    "sales_tax",
                    "service_tax",
                    "vat",
                  ])
                  .optional(),
              }),
              taxability_reason: z
                .enum([
                  "customer_exempt",
                  "not_collecting",
                  "not_subject_to_tax",
                  "not_supported",
                  "portion_product_exempt",
                  "portion_reduced_rated",
                  "portion_standard_rated",
                  "product_exempt",
                  "product_exempt_holiday",
                  "proportionally_rated",
                  "reduced_rated",
                  "reverse_charge",
                  "standard_rated",
                  "taxable_basis_reduced",
                  "zero_rated",
                ])
                .optional(),
              taxable_amount: z.coerce.number(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
    })
    .optional()

  router.post(
    "postInvoicesInvoiceLinesLineItemId",
    "/v1/invoices/:invoice/lines/:line_item_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceLinesLineItemIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceLinesLineItemIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceLinesLineItemId(
          input,
          postInvoicesInvoiceLinesLineItemId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceLinesLineItemId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceMarkUncollectibleParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceMarkUncollectibleBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postInvoicesInvoiceMarkUncollectible",
    "/v1/invoices/:invoice/mark_uncollectible",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceMarkUncollectibleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceMarkUncollectibleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceMarkUncollectible(
          input,
          postInvoicesInvoiceMarkUncollectible.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceMarkUncollectible.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoicePayParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoicePayBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      forgive: PermissiveBoolean.optional(),
      mandate: z.union([z.string().max(5000), z.enum([""])]).optional(),
      off_session: PermissiveBoolean.optional(),
      paid_out_of_band: PermissiveBoolean.optional(),
      payment_method: z.string().max(5000).optional(),
      source: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postInvoicesInvoicePay",
    "/v1/invoices/:invoice/pay",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoicePayParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoicePayBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoicePay(input, postInvoicesInvoicePay.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoicePay.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceRemoveLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceRemoveLinesBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    invoice_metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    lines: z.array(
      z.object({
        behavior: z.enum(["delete", "unassign"]),
        id: z.string().max(5000),
      }),
    ),
  })

  router.post(
    "postInvoicesInvoiceRemoveLines",
    "/v1/invoices/:invoice/remove_lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceRemoveLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceRemoveLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceRemoveLines(
          input,
          postInvoicesInvoiceRemoveLines.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceRemoveLines.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceSendParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceSendBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postInvoicesInvoiceSend",
    "/v1/invoices/:invoice/send",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceSendParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceSendBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceSend(input, postInvoicesInvoiceSend.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceSend.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceUpdateLinesParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceUpdateLinesBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    invoice_metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    lines: z.array(
      z.object({
        amount: z.coerce.number().optional(),
        description: z.string().max(5000).optional(),
        discountable: PermissiveBoolean.optional(),
        discounts: z
          .union([
            z.array(
              z.object({
                coupon: z.string().max(5000).optional(),
                discount: z.string().max(5000).optional(),
                promotion_code: z.string().max(5000).optional(),
              }),
            ),
            z.enum([""]),
          ])
          .optional(),
        id: z.string().max(5000),
        metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
        period: z
          .object({ end: z.coerce.number(), start: z.coerce.number() })
          .optional(),
        price_data: z
          .object({
            currency: z.string(),
            product: z.string().max(5000).optional(),
            product_data: z
              .object({
                description: z.string().max(40000).optional(),
                images: z.array(z.string()).optional(),
                metadata: z.record(z.string()).optional(),
                name: z.string().max(5000),
                tax_code: z.string().max(5000).optional(),
              })
              .optional(),
            tax_behavior: z
              .enum(["exclusive", "inclusive", "unspecified"])
              .optional(),
            unit_amount: z.coerce.number().optional(),
            unit_amount_decimal: z.string().optional(),
          })
          .optional(),
        pricing: z
          .object({ price: z.string().max(5000).optional() })
          .optional(),
        quantity: z.coerce.number().optional(),
        tax_amounts: z
          .union([
            z.array(
              z.object({
                amount: z.coerce.number(),
                tax_rate_data: z.object({
                  country: z.string().max(5000).optional(),
                  description: z.string().max(5000).optional(),
                  display_name: z.string().max(100),
                  inclusive: PermissiveBoolean,
                  jurisdiction: z.string().max(200).optional(),
                  jurisdiction_level: z
                    .enum([
                      "city",
                      "country",
                      "county",
                      "district",
                      "multiple",
                      "state",
                    ])
                    .optional(),
                  percentage: z.coerce.number(),
                  state: z.string().max(5000).optional(),
                  tax_type: z
                    .enum([
                      "amusement_tax",
                      "communications_tax",
                      "gst",
                      "hst",
                      "igst",
                      "jct",
                      "lease_tax",
                      "pst",
                      "qst",
                      "retail_delivery_fee",
                      "rst",
                      "sales_tax",
                      "service_tax",
                      "vat",
                    ])
                    .optional(),
                }),
                taxability_reason: z
                  .enum([
                    "customer_exempt",
                    "not_collecting",
                    "not_subject_to_tax",
                    "not_supported",
                    "portion_product_exempt",
                    "portion_reduced_rated",
                    "portion_standard_rated",
                    "product_exempt",
                    "product_exempt_holiday",
                    "proportionally_rated",
                    "reduced_rated",
                    "reverse_charge",
                    "standard_rated",
                    "taxable_basis_reduced",
                    "zero_rated",
                  ])
                  .optional(),
                taxable_amount: z.coerce.number(),
              }),
            ),
            z.enum([""]),
          ])
          .optional(),
        tax_rates: z
          .union([z.array(z.string().max(5000)), z.enum([""])])
          .optional(),
      }),
    ),
  })

  router.post(
    "postInvoicesInvoiceUpdateLines",
    "/v1/invoices/:invoice/update_lines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceUpdateLinesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceUpdateLinesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceUpdateLines(
          input,
          postInvoicesInvoiceUpdateLines.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceUpdateLines.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postInvoicesInvoiceVoidParamSchema = z.object({
    invoice: z.string().max(5000),
  })

  const postInvoicesInvoiceVoidBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postInvoicesInvoiceVoid",
    "/v1/invoices/:invoice/void",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postInvoicesInvoiceVoidParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postInvoicesInvoiceVoidBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postInvoicesInvoiceVoid(input, postInvoicesInvoiceVoid.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postInvoicesInvoiceVoid.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingAuthorizationsQuerySchema = z.object({
    card: z.string().max(5000).optional(),
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["closed", "expired", "pending", "reversed"]).optional(),
  })

  const getIssuingAuthorizationsBodySchema = z.object({}).optional()

  router.get(
    "getIssuingAuthorizations",
    "/v1/issuing/authorizations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingAuthorizationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingAuthorizationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingAuthorizations(
          input,
          getIssuingAuthorizations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingAuthorizations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingAuthorizationsAuthorizationParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  const getIssuingAuthorizationsAuthorizationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingAuthorizationsAuthorizationBodySchema = z
    .object({})
    .optional()

  router.get(
    "getIssuingAuthorizationsAuthorization",
    "/v1/issuing/authorizations/:authorization",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingAuthorizationsAuthorizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingAuthorizationsAuthorizationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingAuthorizationsAuthorizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingAuthorizationsAuthorization(
          input,
          getIssuingAuthorizationsAuthorization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingAuthorizationsAuthorization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingAuthorizationsAuthorizationParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  const postIssuingAuthorizationsAuthorizationBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postIssuingAuthorizationsAuthorization",
    "/v1/issuing/authorizations/:authorization",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingAuthorizationsAuthorizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingAuthorizationsAuthorizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingAuthorizationsAuthorization(
          input,
          postIssuingAuthorizationsAuthorization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingAuthorizationsAuthorization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingAuthorizationsAuthorizationApproveParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  const postIssuingAuthorizationsAuthorizationApproveBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postIssuingAuthorizationsAuthorizationApprove",
    "/v1/issuing/authorizations/:authorization/approve",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingAuthorizationsAuthorizationApproveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingAuthorizationsAuthorizationApproveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingAuthorizationsAuthorizationApprove(
          input,
          postIssuingAuthorizationsAuthorizationApprove.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingAuthorizationsAuthorizationApprove.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postIssuingAuthorizationsAuthorizationDeclineParamSchema = z.object({
    authorization: z.string().max(5000),
  })

  const postIssuingAuthorizationsAuthorizationDeclineBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postIssuingAuthorizationsAuthorizationDecline",
    "/v1/issuing/authorizations/:authorization/decline",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingAuthorizationsAuthorizationDeclineParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingAuthorizationsAuthorizationDeclineBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingAuthorizationsAuthorizationDecline(
          input,
          postIssuingAuthorizationsAuthorizationDecline.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingAuthorizationsAuthorizationDecline.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getIssuingCardholdersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    email: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    phone_number: z.string().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "blocked", "inactive"]).optional(),
    type: z.enum(["company", "individual"]).optional(),
  })

  const getIssuingCardholdersBodySchema = z.object({}).optional()

  router.get(
    "getIssuingCardholders",
    "/v1/issuing/cardholders",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingCardholdersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingCardholdersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingCardholders(input, getIssuingCardholders.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingCardholders.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingCardholdersBodySchema = z.object({
    billing: z.object({
      address: z.object({
        city: z.string().max(5000),
        country: z.string().max(5000),
        line1: z.string().max(5000),
        line2: z.string().max(5000).optional(),
        postal_code: z.string().max(5000),
        state: z.string().max(5000).optional(),
      }),
    }),
    company: z.object({ tax_id: z.string().max(5000).optional() }).optional(),
    email: z.string().optional(),
    expand: z.array(z.string().max(5000)).optional(),
    individual: z
      .object({
        card_issuing: z
          .object({
            user_terms_acceptance: z
              .object({
                date: z.coerce.number().optional(),
                ip: z.string().optional(),
                user_agent: z
                  .union([z.string().max(5000), z.enum([""])])
                  .optional(),
              })
              .optional(),
          })
          .optional(),
        dob: z
          .object({
            day: z.coerce.number(),
            month: z.coerce.number(),
            year: z.coerce.number(),
          })
          .optional(),
        first_name: z.string().optional(),
        last_name: z.string().optional(),
        verification: z
          .object({
            document: z
              .object({
                back: z.string().max(5000).optional(),
                front: z.string().max(5000).optional(),
              })
              .optional(),
          })
          .optional(),
      })
      .optional(),
    metadata: z.record(z.string()).optional(),
    name: z.string(),
    phone_number: z.string().optional(),
    preferred_locales: z
      .array(z.enum(["de", "en", "es", "fr", "it"]))
      .optional(),
    spending_controls: z
      .object({
        allowed_categories: z
          .array(
            z.enum([
              "ac_refrigeration_repair",
              "accounting_bookkeeping_services",
              "advertising_services",
              "agricultural_cooperative",
              "airlines_air_carriers",
              "airports_flying_fields",
              "ambulance_services",
              "amusement_parks_carnivals",
              "antique_reproductions",
              "antique_shops",
              "aquariums",
              "architectural_surveying_services",
              "art_dealers_and_galleries",
              "artists_supply_and_craft_shops",
              "auto_and_home_supply_stores",
              "auto_body_repair_shops",
              "auto_paint_shops",
              "auto_service_shops",
              "automated_cash_disburse",
              "automated_fuel_dispensers",
              "automobile_associations",
              "automotive_parts_and_accessories_stores",
              "automotive_tire_stores",
              "bail_and_bond_payments",
              "bakeries",
              "bands_orchestras",
              "barber_and_beauty_shops",
              "betting_casino_gambling",
              "bicycle_shops",
              "billiard_pool_establishments",
              "boat_dealers",
              "boat_rentals_and_leases",
              "book_stores",
              "books_periodicals_and_newspapers",
              "bowling_alleys",
              "bus_lines",
              "business_secretarial_schools",
              "buying_shopping_services",
              "cable_satellite_and_other_pay_television_and_radio",
              "camera_and_photographic_supply_stores",
              "candy_nut_and_confectionery_stores",
              "car_and_truck_dealers_new_used",
              "car_and_truck_dealers_used_only",
              "car_rental_agencies",
              "car_washes",
              "carpentry_services",
              "carpet_upholstery_cleaning",
              "caterers",
              "charitable_and_social_service_organizations_fundraising",
              "chemicals_and_allied_products",
              "child_care_services",
              "childrens_and_infants_wear_stores",
              "chiropodists_podiatrists",
              "chiropractors",
              "cigar_stores_and_stands",
              "civic_social_fraternal_associations",
              "cleaning_and_maintenance",
              "clothing_rental",
              "colleges_universities",
              "commercial_equipment",
              "commercial_footwear",
              "commercial_photography_art_and_graphics",
              "commuter_transport_and_ferries",
              "computer_network_services",
              "computer_programming",
              "computer_repair",
              "computer_software_stores",
              "computers_peripherals_and_software",
              "concrete_work_services",
              "construction_materials",
              "consulting_public_relations",
              "correspondence_schools",
              "cosmetic_stores",
              "counseling_services",
              "country_clubs",
              "courier_services",
              "court_costs",
              "credit_reporting_agencies",
              "cruise_lines",
              "dairy_products_stores",
              "dance_hall_studios_schools",
              "dating_escort_services",
              "dentists_orthodontists",
              "department_stores",
              "detective_agencies",
              "digital_goods_applications",
              "digital_goods_games",
              "digital_goods_large_volume",
              "digital_goods_media",
              "direct_marketing_catalog_merchant",
              "direct_marketing_combination_catalog_and_retail_merchant",
              "direct_marketing_inbound_telemarketing",
              "direct_marketing_insurance_services",
              "direct_marketing_other",
              "direct_marketing_outbound_telemarketing",
              "direct_marketing_subscription",
              "direct_marketing_travel",
              "discount_stores",
              "doctors",
              "door_to_door_sales",
              "drapery_window_covering_and_upholstery_stores",
              "drinking_places",
              "drug_stores_and_pharmacies",
              "drugs_drug_proprietaries_and_druggist_sundries",
              "dry_cleaners",
              "durable_goods",
              "duty_free_stores",
              "eating_places_restaurants",
              "educational_services",
              "electric_razor_stores",
              "electric_vehicle_charging",
              "electrical_parts_and_equipment",
              "electrical_services",
              "electronics_repair_shops",
              "electronics_stores",
              "elementary_secondary_schools",
              "emergency_services_gcas_visa_use_only",
              "employment_temp_agencies",
              "equipment_rental",
              "exterminating_services",
              "family_clothing_stores",
              "fast_food_restaurants",
              "financial_institutions",
              "fines_government_administrative_entities",
              "fireplace_fireplace_screens_and_accessories_stores",
              "floor_covering_stores",
              "florists",
              "florists_supplies_nursery_stock_and_flowers",
              "freezer_and_locker_meat_provisioners",
              "fuel_dealers_non_automotive",
              "funeral_services_crematories",
              "furniture_home_furnishings_and_equipment_stores_except_appliances",
              "furniture_repair_refinishing",
              "furriers_and_fur_shops",
              "general_services",
              "gift_card_novelty_and_souvenir_shops",
              "glass_paint_and_wallpaper_stores",
              "glassware_crystal_stores",
              "golf_courses_public",
              "government_licensed_horse_dog_racing_us_region_only",
              "government_licensed_online_casions_online_gambling_us_region_only",
              "government_owned_lotteries_non_us_region",
              "government_owned_lotteries_us_region_only",
              "government_services",
              "grocery_stores_supermarkets",
              "hardware_equipment_and_supplies",
              "hardware_stores",
              "health_and_beauty_spas",
              "hearing_aids_sales_and_supplies",
              "heating_plumbing_a_c",
              "hobby_toy_and_game_shops",
              "home_supply_warehouse_stores",
              "hospitals",
              "hotels_motels_and_resorts",
              "household_appliance_stores",
              "industrial_supplies",
              "information_retrieval_services",
              "insurance_default",
              "insurance_underwriting_premiums",
              "intra_company_purchases",
              "jewelry_stores_watches_clocks_and_silverware_stores",
              "landscaping_services",
              "laundries",
              "laundry_cleaning_services",
              "legal_services_attorneys",
              "luggage_and_leather_goods_stores",
              "lumber_building_materials_stores",
              "manual_cash_disburse",
              "marinas_service_and_supplies",
              "marketplaces",
              "masonry_stonework_and_plaster",
              "massage_parlors",
              "medical_and_dental_labs",
              "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
              "medical_services",
              "membership_organizations",
              "mens_and_boys_clothing_and_accessories_stores",
              "mens_womens_clothing_stores",
              "metal_service_centers",
              "miscellaneous",
              "miscellaneous_apparel_and_accessory_shops",
              "miscellaneous_auto_dealers",
              "miscellaneous_business_services",
              "miscellaneous_food_stores",
              "miscellaneous_general_merchandise",
              "miscellaneous_general_services",
              "miscellaneous_home_furnishing_specialty_stores",
              "miscellaneous_publishing_and_printing",
              "miscellaneous_recreation_services",
              "miscellaneous_repair_shops",
              "miscellaneous_specialty_retail",
              "mobile_home_dealers",
              "motion_picture_theaters",
              "motor_freight_carriers_and_trucking",
              "motor_homes_dealers",
              "motor_vehicle_supplies_and_new_parts",
              "motorcycle_shops_and_dealers",
              "motorcycle_shops_dealers",
              "music_stores_musical_instruments_pianos_and_sheet_music",
              "news_dealers_and_newsstands",
              "non_fi_money_orders",
              "non_fi_stored_value_card_purchase_load",
              "nondurable_goods",
              "nurseries_lawn_and_garden_supply_stores",
              "nursing_personal_care",
              "office_and_commercial_furniture",
              "opticians_eyeglasses",
              "optometrists_ophthalmologist",
              "orthopedic_goods_prosthetic_devices",
              "osteopaths",
              "package_stores_beer_wine_and_liquor",
              "paints_varnishes_and_supplies",
              "parking_lots_garages",
              "passenger_railways",
              "pawn_shops",
              "pet_shops_pet_food_and_supplies",
              "petroleum_and_petroleum_products",
              "photo_developing",
              "photographic_photocopy_microfilm_equipment_and_supplies",
              "photographic_studios",
              "picture_video_production",
              "piece_goods_notions_and_other_dry_goods",
              "plumbing_heating_equipment_and_supplies",
              "political_organizations",
              "postal_services_government_only",
              "precious_stones_and_metals_watches_and_jewelry",
              "professional_services",
              "public_warehousing_and_storage",
              "quick_copy_repro_and_blueprint",
              "railroads",
              "real_estate_agents_and_managers_rentals",
              "record_stores",
              "recreational_vehicle_rentals",
              "religious_goods_stores",
              "religious_organizations",
              "roofing_siding_sheet_metal",
              "secretarial_support_services",
              "security_brokers_dealers",
              "service_stations",
              "sewing_needlework_fabric_and_piece_goods_stores",
              "shoe_repair_hat_cleaning",
              "shoe_stores",
              "small_appliance_repair",
              "snowmobile_dealers",
              "special_trade_services",
              "specialty_cleaning",
              "sporting_goods_stores",
              "sporting_recreation_camps",
              "sports_and_riding_apparel_stores",
              "sports_clubs_fields",
              "stamp_and_coin_stores",
              "stationary_office_supplies_printing_and_writing_paper",
              "stationery_stores_office_and_school_supply_stores",
              "swimming_pools_sales",
              "t_ui_travel_germany",
              "tailors_alterations",
              "tax_payments_government_agencies",
              "tax_preparation_services",
              "taxicabs_limousines",
              "telecommunication_equipment_and_telephone_sales",
              "telecommunication_services",
              "telegraph_services",
              "tent_and_awning_shops",
              "testing_laboratories",
              "theatrical_ticket_agencies",
              "timeshares",
              "tire_retreading_and_repair",
              "tolls_bridge_fees",
              "tourist_attractions_and_exhibits",
              "towing_services",
              "trailer_parks_campgrounds",
              "transportation_services",
              "travel_agencies_tour_operators",
              "truck_stop_iteration",
              "truck_utility_trailer_rentals",
              "typesetting_plate_making_and_related_services",
              "typewriter_stores",
              "u_s_federal_government_agencies_or_departments",
              "uniforms_commercial_clothing",
              "used_merchandise_and_secondhand_stores",
              "utilities",
              "variety_stores",
              "veterinary_services",
              "video_amusement_game_supplies",
              "video_game_arcades",
              "video_tape_rental_stores",
              "vocational_trade_schools",
              "watch_jewelry_repair",
              "welding_repair",
              "wholesale_clubs",
              "wig_and_toupee_stores",
              "wires_money_orders",
              "womens_accessory_and_specialty_shops",
              "womens_ready_to_wear_stores",
              "wrecking_and_salvage_yards",
            ]),
          )
          .optional(),
        allowed_merchant_countries: z.array(z.string().max(5000)).optional(),
        blocked_categories: z
          .array(
            z.enum([
              "ac_refrigeration_repair",
              "accounting_bookkeeping_services",
              "advertising_services",
              "agricultural_cooperative",
              "airlines_air_carriers",
              "airports_flying_fields",
              "ambulance_services",
              "amusement_parks_carnivals",
              "antique_reproductions",
              "antique_shops",
              "aquariums",
              "architectural_surveying_services",
              "art_dealers_and_galleries",
              "artists_supply_and_craft_shops",
              "auto_and_home_supply_stores",
              "auto_body_repair_shops",
              "auto_paint_shops",
              "auto_service_shops",
              "automated_cash_disburse",
              "automated_fuel_dispensers",
              "automobile_associations",
              "automotive_parts_and_accessories_stores",
              "automotive_tire_stores",
              "bail_and_bond_payments",
              "bakeries",
              "bands_orchestras",
              "barber_and_beauty_shops",
              "betting_casino_gambling",
              "bicycle_shops",
              "billiard_pool_establishments",
              "boat_dealers",
              "boat_rentals_and_leases",
              "book_stores",
              "books_periodicals_and_newspapers",
              "bowling_alleys",
              "bus_lines",
              "business_secretarial_schools",
              "buying_shopping_services",
              "cable_satellite_and_other_pay_television_and_radio",
              "camera_and_photographic_supply_stores",
              "candy_nut_and_confectionery_stores",
              "car_and_truck_dealers_new_used",
              "car_and_truck_dealers_used_only",
              "car_rental_agencies",
              "car_washes",
              "carpentry_services",
              "carpet_upholstery_cleaning",
              "caterers",
              "charitable_and_social_service_organizations_fundraising",
              "chemicals_and_allied_products",
              "child_care_services",
              "childrens_and_infants_wear_stores",
              "chiropodists_podiatrists",
              "chiropractors",
              "cigar_stores_and_stands",
              "civic_social_fraternal_associations",
              "cleaning_and_maintenance",
              "clothing_rental",
              "colleges_universities",
              "commercial_equipment",
              "commercial_footwear",
              "commercial_photography_art_and_graphics",
              "commuter_transport_and_ferries",
              "computer_network_services",
              "computer_programming",
              "computer_repair",
              "computer_software_stores",
              "computers_peripherals_and_software",
              "concrete_work_services",
              "construction_materials",
              "consulting_public_relations",
              "correspondence_schools",
              "cosmetic_stores",
              "counseling_services",
              "country_clubs",
              "courier_services",
              "court_costs",
              "credit_reporting_agencies",
              "cruise_lines",
              "dairy_products_stores",
              "dance_hall_studios_schools",
              "dating_escort_services",
              "dentists_orthodontists",
              "department_stores",
              "detective_agencies",
              "digital_goods_applications",
              "digital_goods_games",
              "digital_goods_large_volume",
              "digital_goods_media",
              "direct_marketing_catalog_merchant",
              "direct_marketing_combination_catalog_and_retail_merchant",
              "direct_marketing_inbound_telemarketing",
              "direct_marketing_insurance_services",
              "direct_marketing_other",
              "direct_marketing_outbound_telemarketing",
              "direct_marketing_subscription",
              "direct_marketing_travel",
              "discount_stores",
              "doctors",
              "door_to_door_sales",
              "drapery_window_covering_and_upholstery_stores",
              "drinking_places",
              "drug_stores_and_pharmacies",
              "drugs_drug_proprietaries_and_druggist_sundries",
              "dry_cleaners",
              "durable_goods",
              "duty_free_stores",
              "eating_places_restaurants",
              "educational_services",
              "electric_razor_stores",
              "electric_vehicle_charging",
              "electrical_parts_and_equipment",
              "electrical_services",
              "electronics_repair_shops",
              "electronics_stores",
              "elementary_secondary_schools",
              "emergency_services_gcas_visa_use_only",
              "employment_temp_agencies",
              "equipment_rental",
              "exterminating_services",
              "family_clothing_stores",
              "fast_food_restaurants",
              "financial_institutions",
              "fines_government_administrative_entities",
              "fireplace_fireplace_screens_and_accessories_stores",
              "floor_covering_stores",
              "florists",
              "florists_supplies_nursery_stock_and_flowers",
              "freezer_and_locker_meat_provisioners",
              "fuel_dealers_non_automotive",
              "funeral_services_crematories",
              "furniture_home_furnishings_and_equipment_stores_except_appliances",
              "furniture_repair_refinishing",
              "furriers_and_fur_shops",
              "general_services",
              "gift_card_novelty_and_souvenir_shops",
              "glass_paint_and_wallpaper_stores",
              "glassware_crystal_stores",
              "golf_courses_public",
              "government_licensed_horse_dog_racing_us_region_only",
              "government_licensed_online_casions_online_gambling_us_region_only",
              "government_owned_lotteries_non_us_region",
              "government_owned_lotteries_us_region_only",
              "government_services",
              "grocery_stores_supermarkets",
              "hardware_equipment_and_supplies",
              "hardware_stores",
              "health_and_beauty_spas",
              "hearing_aids_sales_and_supplies",
              "heating_plumbing_a_c",
              "hobby_toy_and_game_shops",
              "home_supply_warehouse_stores",
              "hospitals",
              "hotels_motels_and_resorts",
              "household_appliance_stores",
              "industrial_supplies",
              "information_retrieval_services",
              "insurance_default",
              "insurance_underwriting_premiums",
              "intra_company_purchases",
              "jewelry_stores_watches_clocks_and_silverware_stores",
              "landscaping_services",
              "laundries",
              "laundry_cleaning_services",
              "legal_services_attorneys",
              "luggage_and_leather_goods_stores",
              "lumber_building_materials_stores",
              "manual_cash_disburse",
              "marinas_service_and_supplies",
              "marketplaces",
              "masonry_stonework_and_plaster",
              "massage_parlors",
              "medical_and_dental_labs",
              "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
              "medical_services",
              "membership_organizations",
              "mens_and_boys_clothing_and_accessories_stores",
              "mens_womens_clothing_stores",
              "metal_service_centers",
              "miscellaneous",
              "miscellaneous_apparel_and_accessory_shops",
              "miscellaneous_auto_dealers",
              "miscellaneous_business_services",
              "miscellaneous_food_stores",
              "miscellaneous_general_merchandise",
              "miscellaneous_general_services",
              "miscellaneous_home_furnishing_specialty_stores",
              "miscellaneous_publishing_and_printing",
              "miscellaneous_recreation_services",
              "miscellaneous_repair_shops",
              "miscellaneous_specialty_retail",
              "mobile_home_dealers",
              "motion_picture_theaters",
              "motor_freight_carriers_and_trucking",
              "motor_homes_dealers",
              "motor_vehicle_supplies_and_new_parts",
              "motorcycle_shops_and_dealers",
              "motorcycle_shops_dealers",
              "music_stores_musical_instruments_pianos_and_sheet_music",
              "news_dealers_and_newsstands",
              "non_fi_money_orders",
              "non_fi_stored_value_card_purchase_load",
              "nondurable_goods",
              "nurseries_lawn_and_garden_supply_stores",
              "nursing_personal_care",
              "office_and_commercial_furniture",
              "opticians_eyeglasses",
              "optometrists_ophthalmologist",
              "orthopedic_goods_prosthetic_devices",
              "osteopaths",
              "package_stores_beer_wine_and_liquor",
              "paints_varnishes_and_supplies",
              "parking_lots_garages",
              "passenger_railways",
              "pawn_shops",
              "pet_shops_pet_food_and_supplies",
              "petroleum_and_petroleum_products",
              "photo_developing",
              "photographic_photocopy_microfilm_equipment_and_supplies",
              "photographic_studios",
              "picture_video_production",
              "piece_goods_notions_and_other_dry_goods",
              "plumbing_heating_equipment_and_supplies",
              "political_organizations",
              "postal_services_government_only",
              "precious_stones_and_metals_watches_and_jewelry",
              "professional_services",
              "public_warehousing_and_storage",
              "quick_copy_repro_and_blueprint",
              "railroads",
              "real_estate_agents_and_managers_rentals",
              "record_stores",
              "recreational_vehicle_rentals",
              "religious_goods_stores",
              "religious_organizations",
              "roofing_siding_sheet_metal",
              "secretarial_support_services",
              "security_brokers_dealers",
              "service_stations",
              "sewing_needlework_fabric_and_piece_goods_stores",
              "shoe_repair_hat_cleaning",
              "shoe_stores",
              "small_appliance_repair",
              "snowmobile_dealers",
              "special_trade_services",
              "specialty_cleaning",
              "sporting_goods_stores",
              "sporting_recreation_camps",
              "sports_and_riding_apparel_stores",
              "sports_clubs_fields",
              "stamp_and_coin_stores",
              "stationary_office_supplies_printing_and_writing_paper",
              "stationery_stores_office_and_school_supply_stores",
              "swimming_pools_sales",
              "t_ui_travel_germany",
              "tailors_alterations",
              "tax_payments_government_agencies",
              "tax_preparation_services",
              "taxicabs_limousines",
              "telecommunication_equipment_and_telephone_sales",
              "telecommunication_services",
              "telegraph_services",
              "tent_and_awning_shops",
              "testing_laboratories",
              "theatrical_ticket_agencies",
              "timeshares",
              "tire_retreading_and_repair",
              "tolls_bridge_fees",
              "tourist_attractions_and_exhibits",
              "towing_services",
              "trailer_parks_campgrounds",
              "transportation_services",
              "travel_agencies_tour_operators",
              "truck_stop_iteration",
              "truck_utility_trailer_rentals",
              "typesetting_plate_making_and_related_services",
              "typewriter_stores",
              "u_s_federal_government_agencies_or_departments",
              "uniforms_commercial_clothing",
              "used_merchandise_and_secondhand_stores",
              "utilities",
              "variety_stores",
              "veterinary_services",
              "video_amusement_game_supplies",
              "video_game_arcades",
              "video_tape_rental_stores",
              "vocational_trade_schools",
              "watch_jewelry_repair",
              "welding_repair",
              "wholesale_clubs",
              "wig_and_toupee_stores",
              "wires_money_orders",
              "womens_accessory_and_specialty_shops",
              "womens_ready_to_wear_stores",
              "wrecking_and_salvage_yards",
            ]),
          )
          .optional(),
        blocked_merchant_countries: z.array(z.string().max(5000)).optional(),
        spending_limits: z
          .array(
            z.object({
              amount: z.coerce.number(),
              categories: z
                .array(
                  z.enum([
                    "ac_refrigeration_repair",
                    "accounting_bookkeeping_services",
                    "advertising_services",
                    "agricultural_cooperative",
                    "airlines_air_carriers",
                    "airports_flying_fields",
                    "ambulance_services",
                    "amusement_parks_carnivals",
                    "antique_reproductions",
                    "antique_shops",
                    "aquariums",
                    "architectural_surveying_services",
                    "art_dealers_and_galleries",
                    "artists_supply_and_craft_shops",
                    "auto_and_home_supply_stores",
                    "auto_body_repair_shops",
                    "auto_paint_shops",
                    "auto_service_shops",
                    "automated_cash_disburse",
                    "automated_fuel_dispensers",
                    "automobile_associations",
                    "automotive_parts_and_accessories_stores",
                    "automotive_tire_stores",
                    "bail_and_bond_payments",
                    "bakeries",
                    "bands_orchestras",
                    "barber_and_beauty_shops",
                    "betting_casino_gambling",
                    "bicycle_shops",
                    "billiard_pool_establishments",
                    "boat_dealers",
                    "boat_rentals_and_leases",
                    "book_stores",
                    "books_periodicals_and_newspapers",
                    "bowling_alleys",
                    "bus_lines",
                    "business_secretarial_schools",
                    "buying_shopping_services",
                    "cable_satellite_and_other_pay_television_and_radio",
                    "camera_and_photographic_supply_stores",
                    "candy_nut_and_confectionery_stores",
                    "car_and_truck_dealers_new_used",
                    "car_and_truck_dealers_used_only",
                    "car_rental_agencies",
                    "car_washes",
                    "carpentry_services",
                    "carpet_upholstery_cleaning",
                    "caterers",
                    "charitable_and_social_service_organizations_fundraising",
                    "chemicals_and_allied_products",
                    "child_care_services",
                    "childrens_and_infants_wear_stores",
                    "chiropodists_podiatrists",
                    "chiropractors",
                    "cigar_stores_and_stands",
                    "civic_social_fraternal_associations",
                    "cleaning_and_maintenance",
                    "clothing_rental",
                    "colleges_universities",
                    "commercial_equipment",
                    "commercial_footwear",
                    "commercial_photography_art_and_graphics",
                    "commuter_transport_and_ferries",
                    "computer_network_services",
                    "computer_programming",
                    "computer_repair",
                    "computer_software_stores",
                    "computers_peripherals_and_software",
                    "concrete_work_services",
                    "construction_materials",
                    "consulting_public_relations",
                    "correspondence_schools",
                    "cosmetic_stores",
                    "counseling_services",
                    "country_clubs",
                    "courier_services",
                    "court_costs",
                    "credit_reporting_agencies",
                    "cruise_lines",
                    "dairy_products_stores",
                    "dance_hall_studios_schools",
                    "dating_escort_services",
                    "dentists_orthodontists",
                    "department_stores",
                    "detective_agencies",
                    "digital_goods_applications",
                    "digital_goods_games",
                    "digital_goods_large_volume",
                    "digital_goods_media",
                    "direct_marketing_catalog_merchant",
                    "direct_marketing_combination_catalog_and_retail_merchant",
                    "direct_marketing_inbound_telemarketing",
                    "direct_marketing_insurance_services",
                    "direct_marketing_other",
                    "direct_marketing_outbound_telemarketing",
                    "direct_marketing_subscription",
                    "direct_marketing_travel",
                    "discount_stores",
                    "doctors",
                    "door_to_door_sales",
                    "drapery_window_covering_and_upholstery_stores",
                    "drinking_places",
                    "drug_stores_and_pharmacies",
                    "drugs_drug_proprietaries_and_druggist_sundries",
                    "dry_cleaners",
                    "durable_goods",
                    "duty_free_stores",
                    "eating_places_restaurants",
                    "educational_services",
                    "electric_razor_stores",
                    "electric_vehicle_charging",
                    "electrical_parts_and_equipment",
                    "electrical_services",
                    "electronics_repair_shops",
                    "electronics_stores",
                    "elementary_secondary_schools",
                    "emergency_services_gcas_visa_use_only",
                    "employment_temp_agencies",
                    "equipment_rental",
                    "exterminating_services",
                    "family_clothing_stores",
                    "fast_food_restaurants",
                    "financial_institutions",
                    "fines_government_administrative_entities",
                    "fireplace_fireplace_screens_and_accessories_stores",
                    "floor_covering_stores",
                    "florists",
                    "florists_supplies_nursery_stock_and_flowers",
                    "freezer_and_locker_meat_provisioners",
                    "fuel_dealers_non_automotive",
                    "funeral_services_crematories",
                    "furniture_home_furnishings_and_equipment_stores_except_appliances",
                    "furniture_repair_refinishing",
                    "furriers_and_fur_shops",
                    "general_services",
                    "gift_card_novelty_and_souvenir_shops",
                    "glass_paint_and_wallpaper_stores",
                    "glassware_crystal_stores",
                    "golf_courses_public",
                    "government_licensed_horse_dog_racing_us_region_only",
                    "government_licensed_online_casions_online_gambling_us_region_only",
                    "government_owned_lotteries_non_us_region",
                    "government_owned_lotteries_us_region_only",
                    "government_services",
                    "grocery_stores_supermarkets",
                    "hardware_equipment_and_supplies",
                    "hardware_stores",
                    "health_and_beauty_spas",
                    "hearing_aids_sales_and_supplies",
                    "heating_plumbing_a_c",
                    "hobby_toy_and_game_shops",
                    "home_supply_warehouse_stores",
                    "hospitals",
                    "hotels_motels_and_resorts",
                    "household_appliance_stores",
                    "industrial_supplies",
                    "information_retrieval_services",
                    "insurance_default",
                    "insurance_underwriting_premiums",
                    "intra_company_purchases",
                    "jewelry_stores_watches_clocks_and_silverware_stores",
                    "landscaping_services",
                    "laundries",
                    "laundry_cleaning_services",
                    "legal_services_attorneys",
                    "luggage_and_leather_goods_stores",
                    "lumber_building_materials_stores",
                    "manual_cash_disburse",
                    "marinas_service_and_supplies",
                    "marketplaces",
                    "masonry_stonework_and_plaster",
                    "massage_parlors",
                    "medical_and_dental_labs",
                    "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                    "medical_services",
                    "membership_organizations",
                    "mens_and_boys_clothing_and_accessories_stores",
                    "mens_womens_clothing_stores",
                    "metal_service_centers",
                    "miscellaneous",
                    "miscellaneous_apparel_and_accessory_shops",
                    "miscellaneous_auto_dealers",
                    "miscellaneous_business_services",
                    "miscellaneous_food_stores",
                    "miscellaneous_general_merchandise",
                    "miscellaneous_general_services",
                    "miscellaneous_home_furnishing_specialty_stores",
                    "miscellaneous_publishing_and_printing",
                    "miscellaneous_recreation_services",
                    "miscellaneous_repair_shops",
                    "miscellaneous_specialty_retail",
                    "mobile_home_dealers",
                    "motion_picture_theaters",
                    "motor_freight_carriers_and_trucking",
                    "motor_homes_dealers",
                    "motor_vehicle_supplies_and_new_parts",
                    "motorcycle_shops_and_dealers",
                    "motorcycle_shops_dealers",
                    "music_stores_musical_instruments_pianos_and_sheet_music",
                    "news_dealers_and_newsstands",
                    "non_fi_money_orders",
                    "non_fi_stored_value_card_purchase_load",
                    "nondurable_goods",
                    "nurseries_lawn_and_garden_supply_stores",
                    "nursing_personal_care",
                    "office_and_commercial_furniture",
                    "opticians_eyeglasses",
                    "optometrists_ophthalmologist",
                    "orthopedic_goods_prosthetic_devices",
                    "osteopaths",
                    "package_stores_beer_wine_and_liquor",
                    "paints_varnishes_and_supplies",
                    "parking_lots_garages",
                    "passenger_railways",
                    "pawn_shops",
                    "pet_shops_pet_food_and_supplies",
                    "petroleum_and_petroleum_products",
                    "photo_developing",
                    "photographic_photocopy_microfilm_equipment_and_supplies",
                    "photographic_studios",
                    "picture_video_production",
                    "piece_goods_notions_and_other_dry_goods",
                    "plumbing_heating_equipment_and_supplies",
                    "political_organizations",
                    "postal_services_government_only",
                    "precious_stones_and_metals_watches_and_jewelry",
                    "professional_services",
                    "public_warehousing_and_storage",
                    "quick_copy_repro_and_blueprint",
                    "railroads",
                    "real_estate_agents_and_managers_rentals",
                    "record_stores",
                    "recreational_vehicle_rentals",
                    "religious_goods_stores",
                    "religious_organizations",
                    "roofing_siding_sheet_metal",
                    "secretarial_support_services",
                    "security_brokers_dealers",
                    "service_stations",
                    "sewing_needlework_fabric_and_piece_goods_stores",
                    "shoe_repair_hat_cleaning",
                    "shoe_stores",
                    "small_appliance_repair",
                    "snowmobile_dealers",
                    "special_trade_services",
                    "specialty_cleaning",
                    "sporting_goods_stores",
                    "sporting_recreation_camps",
                    "sports_and_riding_apparel_stores",
                    "sports_clubs_fields",
                    "stamp_and_coin_stores",
                    "stationary_office_supplies_printing_and_writing_paper",
                    "stationery_stores_office_and_school_supply_stores",
                    "swimming_pools_sales",
                    "t_ui_travel_germany",
                    "tailors_alterations",
                    "tax_payments_government_agencies",
                    "tax_preparation_services",
                    "taxicabs_limousines",
                    "telecommunication_equipment_and_telephone_sales",
                    "telecommunication_services",
                    "telegraph_services",
                    "tent_and_awning_shops",
                    "testing_laboratories",
                    "theatrical_ticket_agencies",
                    "timeshares",
                    "tire_retreading_and_repair",
                    "tolls_bridge_fees",
                    "tourist_attractions_and_exhibits",
                    "towing_services",
                    "trailer_parks_campgrounds",
                    "transportation_services",
                    "travel_agencies_tour_operators",
                    "truck_stop_iteration",
                    "truck_utility_trailer_rentals",
                    "typesetting_plate_making_and_related_services",
                    "typewriter_stores",
                    "u_s_federal_government_agencies_or_departments",
                    "uniforms_commercial_clothing",
                    "used_merchandise_and_secondhand_stores",
                    "utilities",
                    "variety_stores",
                    "veterinary_services",
                    "video_amusement_game_supplies",
                    "video_game_arcades",
                    "video_tape_rental_stores",
                    "vocational_trade_schools",
                    "watch_jewelry_repair",
                    "welding_repair",
                    "wholesale_clubs",
                    "wig_and_toupee_stores",
                    "wires_money_orders",
                    "womens_accessory_and_specialty_shops",
                    "womens_ready_to_wear_stores",
                    "wrecking_and_salvage_yards",
                  ]),
                )
                .optional(),
              interval: z.enum([
                "all_time",
                "daily",
                "monthly",
                "per_authorization",
                "weekly",
                "yearly",
              ]),
            }),
          )
          .optional(),
        spending_limits_currency: z.string().optional(),
      })
      .optional(),
    status: z.enum(["active", "inactive"]).optional(),
    type: z.enum(["company", "individual"]).optional(),
  })

  router.post(
    "postIssuingCardholders",
    "/v1/issuing/cardholders",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIssuingCardholdersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingCardholders(input, postIssuingCardholders.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingCardholders.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingCardholdersCardholderParamSchema = z.object({
    cardholder: z.string().max(5000),
  })

  const getIssuingCardholdersCardholderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingCardholdersCardholderBodySchema = z.object({}).optional()

  router.get(
    "getIssuingCardholdersCardholder",
    "/v1/issuing/cardholders/:cardholder",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingCardholdersCardholderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingCardholdersCardholderQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingCardholdersCardholderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingCardholdersCardholder(
          input,
          getIssuingCardholdersCardholder.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingCardholdersCardholder.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingCardholdersCardholderParamSchema = z.object({
    cardholder: z.string().max(5000),
  })

  const postIssuingCardholdersCardholderBodySchema = z
    .object({
      billing: z
        .object({
          address: z.object({
            city: z.string().max(5000),
            country: z.string().max(5000),
            line1: z.string().max(5000),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000),
            state: z.string().max(5000).optional(),
          }),
        })
        .optional(),
      company: z.object({ tax_id: z.string().max(5000).optional() }).optional(),
      email: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      individual: z
        .object({
          card_issuing: z
            .object({
              user_terms_acceptance: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z
                    .union([z.string().max(5000), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          dob: z
            .object({
              day: z.coerce.number(),
              month: z.coerce.number(),
              year: z.coerce.number(),
            })
            .optional(),
          first_name: z.string().optional(),
          last_name: z.string().optional(),
          verification: z
            .object({
              document: z
                .object({
                  back: z.string().max(5000).optional(),
                  front: z.string().max(5000).optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      metadata: z.record(z.string()).optional(),
      phone_number: z.string().optional(),
      preferred_locales: z
        .array(z.enum(["de", "en", "es", "fr", "it"]))
        .optional(),
      spending_controls: z
        .object({
          allowed_categories: z
            .array(
              z.enum([
                "ac_refrigeration_repair",
                "accounting_bookkeeping_services",
                "advertising_services",
                "agricultural_cooperative",
                "airlines_air_carriers",
                "airports_flying_fields",
                "ambulance_services",
                "amusement_parks_carnivals",
                "antique_reproductions",
                "antique_shops",
                "aquariums",
                "architectural_surveying_services",
                "art_dealers_and_galleries",
                "artists_supply_and_craft_shops",
                "auto_and_home_supply_stores",
                "auto_body_repair_shops",
                "auto_paint_shops",
                "auto_service_shops",
                "automated_cash_disburse",
                "automated_fuel_dispensers",
                "automobile_associations",
                "automotive_parts_and_accessories_stores",
                "automotive_tire_stores",
                "bail_and_bond_payments",
                "bakeries",
                "bands_orchestras",
                "barber_and_beauty_shops",
                "betting_casino_gambling",
                "bicycle_shops",
                "billiard_pool_establishments",
                "boat_dealers",
                "boat_rentals_and_leases",
                "book_stores",
                "books_periodicals_and_newspapers",
                "bowling_alleys",
                "bus_lines",
                "business_secretarial_schools",
                "buying_shopping_services",
                "cable_satellite_and_other_pay_television_and_radio",
                "camera_and_photographic_supply_stores",
                "candy_nut_and_confectionery_stores",
                "car_and_truck_dealers_new_used",
                "car_and_truck_dealers_used_only",
                "car_rental_agencies",
                "car_washes",
                "carpentry_services",
                "carpet_upholstery_cleaning",
                "caterers",
                "charitable_and_social_service_organizations_fundraising",
                "chemicals_and_allied_products",
                "child_care_services",
                "childrens_and_infants_wear_stores",
                "chiropodists_podiatrists",
                "chiropractors",
                "cigar_stores_and_stands",
                "civic_social_fraternal_associations",
                "cleaning_and_maintenance",
                "clothing_rental",
                "colleges_universities",
                "commercial_equipment",
                "commercial_footwear",
                "commercial_photography_art_and_graphics",
                "commuter_transport_and_ferries",
                "computer_network_services",
                "computer_programming",
                "computer_repair",
                "computer_software_stores",
                "computers_peripherals_and_software",
                "concrete_work_services",
                "construction_materials",
                "consulting_public_relations",
                "correspondence_schools",
                "cosmetic_stores",
                "counseling_services",
                "country_clubs",
                "courier_services",
                "court_costs",
                "credit_reporting_agencies",
                "cruise_lines",
                "dairy_products_stores",
                "dance_hall_studios_schools",
                "dating_escort_services",
                "dentists_orthodontists",
                "department_stores",
                "detective_agencies",
                "digital_goods_applications",
                "digital_goods_games",
                "digital_goods_large_volume",
                "digital_goods_media",
                "direct_marketing_catalog_merchant",
                "direct_marketing_combination_catalog_and_retail_merchant",
                "direct_marketing_inbound_telemarketing",
                "direct_marketing_insurance_services",
                "direct_marketing_other",
                "direct_marketing_outbound_telemarketing",
                "direct_marketing_subscription",
                "direct_marketing_travel",
                "discount_stores",
                "doctors",
                "door_to_door_sales",
                "drapery_window_covering_and_upholstery_stores",
                "drinking_places",
                "drug_stores_and_pharmacies",
                "drugs_drug_proprietaries_and_druggist_sundries",
                "dry_cleaners",
                "durable_goods",
                "duty_free_stores",
                "eating_places_restaurants",
                "educational_services",
                "electric_razor_stores",
                "electric_vehicle_charging",
                "electrical_parts_and_equipment",
                "electrical_services",
                "electronics_repair_shops",
                "electronics_stores",
                "elementary_secondary_schools",
                "emergency_services_gcas_visa_use_only",
                "employment_temp_agencies",
                "equipment_rental",
                "exterminating_services",
                "family_clothing_stores",
                "fast_food_restaurants",
                "financial_institutions",
                "fines_government_administrative_entities",
                "fireplace_fireplace_screens_and_accessories_stores",
                "floor_covering_stores",
                "florists",
                "florists_supplies_nursery_stock_and_flowers",
                "freezer_and_locker_meat_provisioners",
                "fuel_dealers_non_automotive",
                "funeral_services_crematories",
                "furniture_home_furnishings_and_equipment_stores_except_appliances",
                "furniture_repair_refinishing",
                "furriers_and_fur_shops",
                "general_services",
                "gift_card_novelty_and_souvenir_shops",
                "glass_paint_and_wallpaper_stores",
                "glassware_crystal_stores",
                "golf_courses_public",
                "government_licensed_horse_dog_racing_us_region_only",
                "government_licensed_online_casions_online_gambling_us_region_only",
                "government_owned_lotteries_non_us_region",
                "government_owned_lotteries_us_region_only",
                "government_services",
                "grocery_stores_supermarkets",
                "hardware_equipment_and_supplies",
                "hardware_stores",
                "health_and_beauty_spas",
                "hearing_aids_sales_and_supplies",
                "heating_plumbing_a_c",
                "hobby_toy_and_game_shops",
                "home_supply_warehouse_stores",
                "hospitals",
                "hotels_motels_and_resorts",
                "household_appliance_stores",
                "industrial_supplies",
                "information_retrieval_services",
                "insurance_default",
                "insurance_underwriting_premiums",
                "intra_company_purchases",
                "jewelry_stores_watches_clocks_and_silverware_stores",
                "landscaping_services",
                "laundries",
                "laundry_cleaning_services",
                "legal_services_attorneys",
                "luggage_and_leather_goods_stores",
                "lumber_building_materials_stores",
                "manual_cash_disburse",
                "marinas_service_and_supplies",
                "marketplaces",
                "masonry_stonework_and_plaster",
                "massage_parlors",
                "medical_and_dental_labs",
                "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                "medical_services",
                "membership_organizations",
                "mens_and_boys_clothing_and_accessories_stores",
                "mens_womens_clothing_stores",
                "metal_service_centers",
                "miscellaneous",
                "miscellaneous_apparel_and_accessory_shops",
                "miscellaneous_auto_dealers",
                "miscellaneous_business_services",
                "miscellaneous_food_stores",
                "miscellaneous_general_merchandise",
                "miscellaneous_general_services",
                "miscellaneous_home_furnishing_specialty_stores",
                "miscellaneous_publishing_and_printing",
                "miscellaneous_recreation_services",
                "miscellaneous_repair_shops",
                "miscellaneous_specialty_retail",
                "mobile_home_dealers",
                "motion_picture_theaters",
                "motor_freight_carriers_and_trucking",
                "motor_homes_dealers",
                "motor_vehicle_supplies_and_new_parts",
                "motorcycle_shops_and_dealers",
                "motorcycle_shops_dealers",
                "music_stores_musical_instruments_pianos_and_sheet_music",
                "news_dealers_and_newsstands",
                "non_fi_money_orders",
                "non_fi_stored_value_card_purchase_load",
                "nondurable_goods",
                "nurseries_lawn_and_garden_supply_stores",
                "nursing_personal_care",
                "office_and_commercial_furniture",
                "opticians_eyeglasses",
                "optometrists_ophthalmologist",
                "orthopedic_goods_prosthetic_devices",
                "osteopaths",
                "package_stores_beer_wine_and_liquor",
                "paints_varnishes_and_supplies",
                "parking_lots_garages",
                "passenger_railways",
                "pawn_shops",
                "pet_shops_pet_food_and_supplies",
                "petroleum_and_petroleum_products",
                "photo_developing",
                "photographic_photocopy_microfilm_equipment_and_supplies",
                "photographic_studios",
                "picture_video_production",
                "piece_goods_notions_and_other_dry_goods",
                "plumbing_heating_equipment_and_supplies",
                "political_organizations",
                "postal_services_government_only",
                "precious_stones_and_metals_watches_and_jewelry",
                "professional_services",
                "public_warehousing_and_storage",
                "quick_copy_repro_and_blueprint",
                "railroads",
                "real_estate_agents_and_managers_rentals",
                "record_stores",
                "recreational_vehicle_rentals",
                "religious_goods_stores",
                "religious_organizations",
                "roofing_siding_sheet_metal",
                "secretarial_support_services",
                "security_brokers_dealers",
                "service_stations",
                "sewing_needlework_fabric_and_piece_goods_stores",
                "shoe_repair_hat_cleaning",
                "shoe_stores",
                "small_appliance_repair",
                "snowmobile_dealers",
                "special_trade_services",
                "specialty_cleaning",
                "sporting_goods_stores",
                "sporting_recreation_camps",
                "sports_and_riding_apparel_stores",
                "sports_clubs_fields",
                "stamp_and_coin_stores",
                "stationary_office_supplies_printing_and_writing_paper",
                "stationery_stores_office_and_school_supply_stores",
                "swimming_pools_sales",
                "t_ui_travel_germany",
                "tailors_alterations",
                "tax_payments_government_agencies",
                "tax_preparation_services",
                "taxicabs_limousines",
                "telecommunication_equipment_and_telephone_sales",
                "telecommunication_services",
                "telegraph_services",
                "tent_and_awning_shops",
                "testing_laboratories",
                "theatrical_ticket_agencies",
                "timeshares",
                "tire_retreading_and_repair",
                "tolls_bridge_fees",
                "tourist_attractions_and_exhibits",
                "towing_services",
                "trailer_parks_campgrounds",
                "transportation_services",
                "travel_agencies_tour_operators",
                "truck_stop_iteration",
                "truck_utility_trailer_rentals",
                "typesetting_plate_making_and_related_services",
                "typewriter_stores",
                "u_s_federal_government_agencies_or_departments",
                "uniforms_commercial_clothing",
                "used_merchandise_and_secondhand_stores",
                "utilities",
                "variety_stores",
                "veterinary_services",
                "video_amusement_game_supplies",
                "video_game_arcades",
                "video_tape_rental_stores",
                "vocational_trade_schools",
                "watch_jewelry_repair",
                "welding_repair",
                "wholesale_clubs",
                "wig_and_toupee_stores",
                "wires_money_orders",
                "womens_accessory_and_specialty_shops",
                "womens_ready_to_wear_stores",
                "wrecking_and_salvage_yards",
              ]),
            )
            .optional(),
          allowed_merchant_countries: z.array(z.string().max(5000)).optional(),
          blocked_categories: z
            .array(
              z.enum([
                "ac_refrigeration_repair",
                "accounting_bookkeeping_services",
                "advertising_services",
                "agricultural_cooperative",
                "airlines_air_carriers",
                "airports_flying_fields",
                "ambulance_services",
                "amusement_parks_carnivals",
                "antique_reproductions",
                "antique_shops",
                "aquariums",
                "architectural_surveying_services",
                "art_dealers_and_galleries",
                "artists_supply_and_craft_shops",
                "auto_and_home_supply_stores",
                "auto_body_repair_shops",
                "auto_paint_shops",
                "auto_service_shops",
                "automated_cash_disburse",
                "automated_fuel_dispensers",
                "automobile_associations",
                "automotive_parts_and_accessories_stores",
                "automotive_tire_stores",
                "bail_and_bond_payments",
                "bakeries",
                "bands_orchestras",
                "barber_and_beauty_shops",
                "betting_casino_gambling",
                "bicycle_shops",
                "billiard_pool_establishments",
                "boat_dealers",
                "boat_rentals_and_leases",
                "book_stores",
                "books_periodicals_and_newspapers",
                "bowling_alleys",
                "bus_lines",
                "business_secretarial_schools",
                "buying_shopping_services",
                "cable_satellite_and_other_pay_television_and_radio",
                "camera_and_photographic_supply_stores",
                "candy_nut_and_confectionery_stores",
                "car_and_truck_dealers_new_used",
                "car_and_truck_dealers_used_only",
                "car_rental_agencies",
                "car_washes",
                "carpentry_services",
                "carpet_upholstery_cleaning",
                "caterers",
                "charitable_and_social_service_organizations_fundraising",
                "chemicals_and_allied_products",
                "child_care_services",
                "childrens_and_infants_wear_stores",
                "chiropodists_podiatrists",
                "chiropractors",
                "cigar_stores_and_stands",
                "civic_social_fraternal_associations",
                "cleaning_and_maintenance",
                "clothing_rental",
                "colleges_universities",
                "commercial_equipment",
                "commercial_footwear",
                "commercial_photography_art_and_graphics",
                "commuter_transport_and_ferries",
                "computer_network_services",
                "computer_programming",
                "computer_repair",
                "computer_software_stores",
                "computers_peripherals_and_software",
                "concrete_work_services",
                "construction_materials",
                "consulting_public_relations",
                "correspondence_schools",
                "cosmetic_stores",
                "counseling_services",
                "country_clubs",
                "courier_services",
                "court_costs",
                "credit_reporting_agencies",
                "cruise_lines",
                "dairy_products_stores",
                "dance_hall_studios_schools",
                "dating_escort_services",
                "dentists_orthodontists",
                "department_stores",
                "detective_agencies",
                "digital_goods_applications",
                "digital_goods_games",
                "digital_goods_large_volume",
                "digital_goods_media",
                "direct_marketing_catalog_merchant",
                "direct_marketing_combination_catalog_and_retail_merchant",
                "direct_marketing_inbound_telemarketing",
                "direct_marketing_insurance_services",
                "direct_marketing_other",
                "direct_marketing_outbound_telemarketing",
                "direct_marketing_subscription",
                "direct_marketing_travel",
                "discount_stores",
                "doctors",
                "door_to_door_sales",
                "drapery_window_covering_and_upholstery_stores",
                "drinking_places",
                "drug_stores_and_pharmacies",
                "drugs_drug_proprietaries_and_druggist_sundries",
                "dry_cleaners",
                "durable_goods",
                "duty_free_stores",
                "eating_places_restaurants",
                "educational_services",
                "electric_razor_stores",
                "electric_vehicle_charging",
                "electrical_parts_and_equipment",
                "electrical_services",
                "electronics_repair_shops",
                "electronics_stores",
                "elementary_secondary_schools",
                "emergency_services_gcas_visa_use_only",
                "employment_temp_agencies",
                "equipment_rental",
                "exterminating_services",
                "family_clothing_stores",
                "fast_food_restaurants",
                "financial_institutions",
                "fines_government_administrative_entities",
                "fireplace_fireplace_screens_and_accessories_stores",
                "floor_covering_stores",
                "florists",
                "florists_supplies_nursery_stock_and_flowers",
                "freezer_and_locker_meat_provisioners",
                "fuel_dealers_non_automotive",
                "funeral_services_crematories",
                "furniture_home_furnishings_and_equipment_stores_except_appliances",
                "furniture_repair_refinishing",
                "furriers_and_fur_shops",
                "general_services",
                "gift_card_novelty_and_souvenir_shops",
                "glass_paint_and_wallpaper_stores",
                "glassware_crystal_stores",
                "golf_courses_public",
                "government_licensed_horse_dog_racing_us_region_only",
                "government_licensed_online_casions_online_gambling_us_region_only",
                "government_owned_lotteries_non_us_region",
                "government_owned_lotteries_us_region_only",
                "government_services",
                "grocery_stores_supermarkets",
                "hardware_equipment_and_supplies",
                "hardware_stores",
                "health_and_beauty_spas",
                "hearing_aids_sales_and_supplies",
                "heating_plumbing_a_c",
                "hobby_toy_and_game_shops",
                "home_supply_warehouse_stores",
                "hospitals",
                "hotels_motels_and_resorts",
                "household_appliance_stores",
                "industrial_supplies",
                "information_retrieval_services",
                "insurance_default",
                "insurance_underwriting_premiums",
                "intra_company_purchases",
                "jewelry_stores_watches_clocks_and_silverware_stores",
                "landscaping_services",
                "laundries",
                "laundry_cleaning_services",
                "legal_services_attorneys",
                "luggage_and_leather_goods_stores",
                "lumber_building_materials_stores",
                "manual_cash_disburse",
                "marinas_service_and_supplies",
                "marketplaces",
                "masonry_stonework_and_plaster",
                "massage_parlors",
                "medical_and_dental_labs",
                "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                "medical_services",
                "membership_organizations",
                "mens_and_boys_clothing_and_accessories_stores",
                "mens_womens_clothing_stores",
                "metal_service_centers",
                "miscellaneous",
                "miscellaneous_apparel_and_accessory_shops",
                "miscellaneous_auto_dealers",
                "miscellaneous_business_services",
                "miscellaneous_food_stores",
                "miscellaneous_general_merchandise",
                "miscellaneous_general_services",
                "miscellaneous_home_furnishing_specialty_stores",
                "miscellaneous_publishing_and_printing",
                "miscellaneous_recreation_services",
                "miscellaneous_repair_shops",
                "miscellaneous_specialty_retail",
                "mobile_home_dealers",
                "motion_picture_theaters",
                "motor_freight_carriers_and_trucking",
                "motor_homes_dealers",
                "motor_vehicle_supplies_and_new_parts",
                "motorcycle_shops_and_dealers",
                "motorcycle_shops_dealers",
                "music_stores_musical_instruments_pianos_and_sheet_music",
                "news_dealers_and_newsstands",
                "non_fi_money_orders",
                "non_fi_stored_value_card_purchase_load",
                "nondurable_goods",
                "nurseries_lawn_and_garden_supply_stores",
                "nursing_personal_care",
                "office_and_commercial_furniture",
                "opticians_eyeglasses",
                "optometrists_ophthalmologist",
                "orthopedic_goods_prosthetic_devices",
                "osteopaths",
                "package_stores_beer_wine_and_liquor",
                "paints_varnishes_and_supplies",
                "parking_lots_garages",
                "passenger_railways",
                "pawn_shops",
                "pet_shops_pet_food_and_supplies",
                "petroleum_and_petroleum_products",
                "photo_developing",
                "photographic_photocopy_microfilm_equipment_and_supplies",
                "photographic_studios",
                "picture_video_production",
                "piece_goods_notions_and_other_dry_goods",
                "plumbing_heating_equipment_and_supplies",
                "political_organizations",
                "postal_services_government_only",
                "precious_stones_and_metals_watches_and_jewelry",
                "professional_services",
                "public_warehousing_and_storage",
                "quick_copy_repro_and_blueprint",
                "railroads",
                "real_estate_agents_and_managers_rentals",
                "record_stores",
                "recreational_vehicle_rentals",
                "religious_goods_stores",
                "religious_organizations",
                "roofing_siding_sheet_metal",
                "secretarial_support_services",
                "security_brokers_dealers",
                "service_stations",
                "sewing_needlework_fabric_and_piece_goods_stores",
                "shoe_repair_hat_cleaning",
                "shoe_stores",
                "small_appliance_repair",
                "snowmobile_dealers",
                "special_trade_services",
                "specialty_cleaning",
                "sporting_goods_stores",
                "sporting_recreation_camps",
                "sports_and_riding_apparel_stores",
                "sports_clubs_fields",
                "stamp_and_coin_stores",
                "stationary_office_supplies_printing_and_writing_paper",
                "stationery_stores_office_and_school_supply_stores",
                "swimming_pools_sales",
                "t_ui_travel_germany",
                "tailors_alterations",
                "tax_payments_government_agencies",
                "tax_preparation_services",
                "taxicabs_limousines",
                "telecommunication_equipment_and_telephone_sales",
                "telecommunication_services",
                "telegraph_services",
                "tent_and_awning_shops",
                "testing_laboratories",
                "theatrical_ticket_agencies",
                "timeshares",
                "tire_retreading_and_repair",
                "tolls_bridge_fees",
                "tourist_attractions_and_exhibits",
                "towing_services",
                "trailer_parks_campgrounds",
                "transportation_services",
                "travel_agencies_tour_operators",
                "truck_stop_iteration",
                "truck_utility_trailer_rentals",
                "typesetting_plate_making_and_related_services",
                "typewriter_stores",
                "u_s_federal_government_agencies_or_departments",
                "uniforms_commercial_clothing",
                "used_merchandise_and_secondhand_stores",
                "utilities",
                "variety_stores",
                "veterinary_services",
                "video_amusement_game_supplies",
                "video_game_arcades",
                "video_tape_rental_stores",
                "vocational_trade_schools",
                "watch_jewelry_repair",
                "welding_repair",
                "wholesale_clubs",
                "wig_and_toupee_stores",
                "wires_money_orders",
                "womens_accessory_and_specialty_shops",
                "womens_ready_to_wear_stores",
                "wrecking_and_salvage_yards",
              ]),
            )
            .optional(),
          blocked_merchant_countries: z.array(z.string().max(5000)).optional(),
          spending_limits: z
            .array(
              z.object({
                amount: z.coerce.number(),
                categories: z
                  .array(
                    z.enum([
                      "ac_refrigeration_repair",
                      "accounting_bookkeeping_services",
                      "advertising_services",
                      "agricultural_cooperative",
                      "airlines_air_carriers",
                      "airports_flying_fields",
                      "ambulance_services",
                      "amusement_parks_carnivals",
                      "antique_reproductions",
                      "antique_shops",
                      "aquariums",
                      "architectural_surveying_services",
                      "art_dealers_and_galleries",
                      "artists_supply_and_craft_shops",
                      "auto_and_home_supply_stores",
                      "auto_body_repair_shops",
                      "auto_paint_shops",
                      "auto_service_shops",
                      "automated_cash_disburse",
                      "automated_fuel_dispensers",
                      "automobile_associations",
                      "automotive_parts_and_accessories_stores",
                      "automotive_tire_stores",
                      "bail_and_bond_payments",
                      "bakeries",
                      "bands_orchestras",
                      "barber_and_beauty_shops",
                      "betting_casino_gambling",
                      "bicycle_shops",
                      "billiard_pool_establishments",
                      "boat_dealers",
                      "boat_rentals_and_leases",
                      "book_stores",
                      "books_periodicals_and_newspapers",
                      "bowling_alleys",
                      "bus_lines",
                      "business_secretarial_schools",
                      "buying_shopping_services",
                      "cable_satellite_and_other_pay_television_and_radio",
                      "camera_and_photographic_supply_stores",
                      "candy_nut_and_confectionery_stores",
                      "car_and_truck_dealers_new_used",
                      "car_and_truck_dealers_used_only",
                      "car_rental_agencies",
                      "car_washes",
                      "carpentry_services",
                      "carpet_upholstery_cleaning",
                      "caterers",
                      "charitable_and_social_service_organizations_fundraising",
                      "chemicals_and_allied_products",
                      "child_care_services",
                      "childrens_and_infants_wear_stores",
                      "chiropodists_podiatrists",
                      "chiropractors",
                      "cigar_stores_and_stands",
                      "civic_social_fraternal_associations",
                      "cleaning_and_maintenance",
                      "clothing_rental",
                      "colleges_universities",
                      "commercial_equipment",
                      "commercial_footwear",
                      "commercial_photography_art_and_graphics",
                      "commuter_transport_and_ferries",
                      "computer_network_services",
                      "computer_programming",
                      "computer_repair",
                      "computer_software_stores",
                      "computers_peripherals_and_software",
                      "concrete_work_services",
                      "construction_materials",
                      "consulting_public_relations",
                      "correspondence_schools",
                      "cosmetic_stores",
                      "counseling_services",
                      "country_clubs",
                      "courier_services",
                      "court_costs",
                      "credit_reporting_agencies",
                      "cruise_lines",
                      "dairy_products_stores",
                      "dance_hall_studios_schools",
                      "dating_escort_services",
                      "dentists_orthodontists",
                      "department_stores",
                      "detective_agencies",
                      "digital_goods_applications",
                      "digital_goods_games",
                      "digital_goods_large_volume",
                      "digital_goods_media",
                      "direct_marketing_catalog_merchant",
                      "direct_marketing_combination_catalog_and_retail_merchant",
                      "direct_marketing_inbound_telemarketing",
                      "direct_marketing_insurance_services",
                      "direct_marketing_other",
                      "direct_marketing_outbound_telemarketing",
                      "direct_marketing_subscription",
                      "direct_marketing_travel",
                      "discount_stores",
                      "doctors",
                      "door_to_door_sales",
                      "drapery_window_covering_and_upholstery_stores",
                      "drinking_places",
                      "drug_stores_and_pharmacies",
                      "drugs_drug_proprietaries_and_druggist_sundries",
                      "dry_cleaners",
                      "durable_goods",
                      "duty_free_stores",
                      "eating_places_restaurants",
                      "educational_services",
                      "electric_razor_stores",
                      "electric_vehicle_charging",
                      "electrical_parts_and_equipment",
                      "electrical_services",
                      "electronics_repair_shops",
                      "electronics_stores",
                      "elementary_secondary_schools",
                      "emergency_services_gcas_visa_use_only",
                      "employment_temp_agencies",
                      "equipment_rental",
                      "exterminating_services",
                      "family_clothing_stores",
                      "fast_food_restaurants",
                      "financial_institutions",
                      "fines_government_administrative_entities",
                      "fireplace_fireplace_screens_and_accessories_stores",
                      "floor_covering_stores",
                      "florists",
                      "florists_supplies_nursery_stock_and_flowers",
                      "freezer_and_locker_meat_provisioners",
                      "fuel_dealers_non_automotive",
                      "funeral_services_crematories",
                      "furniture_home_furnishings_and_equipment_stores_except_appliances",
                      "furniture_repair_refinishing",
                      "furriers_and_fur_shops",
                      "general_services",
                      "gift_card_novelty_and_souvenir_shops",
                      "glass_paint_and_wallpaper_stores",
                      "glassware_crystal_stores",
                      "golf_courses_public",
                      "government_licensed_horse_dog_racing_us_region_only",
                      "government_licensed_online_casions_online_gambling_us_region_only",
                      "government_owned_lotteries_non_us_region",
                      "government_owned_lotteries_us_region_only",
                      "government_services",
                      "grocery_stores_supermarkets",
                      "hardware_equipment_and_supplies",
                      "hardware_stores",
                      "health_and_beauty_spas",
                      "hearing_aids_sales_and_supplies",
                      "heating_plumbing_a_c",
                      "hobby_toy_and_game_shops",
                      "home_supply_warehouse_stores",
                      "hospitals",
                      "hotels_motels_and_resorts",
                      "household_appliance_stores",
                      "industrial_supplies",
                      "information_retrieval_services",
                      "insurance_default",
                      "insurance_underwriting_premiums",
                      "intra_company_purchases",
                      "jewelry_stores_watches_clocks_and_silverware_stores",
                      "landscaping_services",
                      "laundries",
                      "laundry_cleaning_services",
                      "legal_services_attorneys",
                      "luggage_and_leather_goods_stores",
                      "lumber_building_materials_stores",
                      "manual_cash_disburse",
                      "marinas_service_and_supplies",
                      "marketplaces",
                      "masonry_stonework_and_plaster",
                      "massage_parlors",
                      "medical_and_dental_labs",
                      "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                      "medical_services",
                      "membership_organizations",
                      "mens_and_boys_clothing_and_accessories_stores",
                      "mens_womens_clothing_stores",
                      "metal_service_centers",
                      "miscellaneous",
                      "miscellaneous_apparel_and_accessory_shops",
                      "miscellaneous_auto_dealers",
                      "miscellaneous_business_services",
                      "miscellaneous_food_stores",
                      "miscellaneous_general_merchandise",
                      "miscellaneous_general_services",
                      "miscellaneous_home_furnishing_specialty_stores",
                      "miscellaneous_publishing_and_printing",
                      "miscellaneous_recreation_services",
                      "miscellaneous_repair_shops",
                      "miscellaneous_specialty_retail",
                      "mobile_home_dealers",
                      "motion_picture_theaters",
                      "motor_freight_carriers_and_trucking",
                      "motor_homes_dealers",
                      "motor_vehicle_supplies_and_new_parts",
                      "motorcycle_shops_and_dealers",
                      "motorcycle_shops_dealers",
                      "music_stores_musical_instruments_pianos_and_sheet_music",
                      "news_dealers_and_newsstands",
                      "non_fi_money_orders",
                      "non_fi_stored_value_card_purchase_load",
                      "nondurable_goods",
                      "nurseries_lawn_and_garden_supply_stores",
                      "nursing_personal_care",
                      "office_and_commercial_furniture",
                      "opticians_eyeglasses",
                      "optometrists_ophthalmologist",
                      "orthopedic_goods_prosthetic_devices",
                      "osteopaths",
                      "package_stores_beer_wine_and_liquor",
                      "paints_varnishes_and_supplies",
                      "parking_lots_garages",
                      "passenger_railways",
                      "pawn_shops",
                      "pet_shops_pet_food_and_supplies",
                      "petroleum_and_petroleum_products",
                      "photo_developing",
                      "photographic_photocopy_microfilm_equipment_and_supplies",
                      "photographic_studios",
                      "picture_video_production",
                      "piece_goods_notions_and_other_dry_goods",
                      "plumbing_heating_equipment_and_supplies",
                      "political_organizations",
                      "postal_services_government_only",
                      "precious_stones_and_metals_watches_and_jewelry",
                      "professional_services",
                      "public_warehousing_and_storage",
                      "quick_copy_repro_and_blueprint",
                      "railroads",
                      "real_estate_agents_and_managers_rentals",
                      "record_stores",
                      "recreational_vehicle_rentals",
                      "religious_goods_stores",
                      "religious_organizations",
                      "roofing_siding_sheet_metal",
                      "secretarial_support_services",
                      "security_brokers_dealers",
                      "service_stations",
                      "sewing_needlework_fabric_and_piece_goods_stores",
                      "shoe_repair_hat_cleaning",
                      "shoe_stores",
                      "small_appliance_repair",
                      "snowmobile_dealers",
                      "special_trade_services",
                      "specialty_cleaning",
                      "sporting_goods_stores",
                      "sporting_recreation_camps",
                      "sports_and_riding_apparel_stores",
                      "sports_clubs_fields",
                      "stamp_and_coin_stores",
                      "stationary_office_supplies_printing_and_writing_paper",
                      "stationery_stores_office_and_school_supply_stores",
                      "swimming_pools_sales",
                      "t_ui_travel_germany",
                      "tailors_alterations",
                      "tax_payments_government_agencies",
                      "tax_preparation_services",
                      "taxicabs_limousines",
                      "telecommunication_equipment_and_telephone_sales",
                      "telecommunication_services",
                      "telegraph_services",
                      "tent_and_awning_shops",
                      "testing_laboratories",
                      "theatrical_ticket_agencies",
                      "timeshares",
                      "tire_retreading_and_repair",
                      "tolls_bridge_fees",
                      "tourist_attractions_and_exhibits",
                      "towing_services",
                      "trailer_parks_campgrounds",
                      "transportation_services",
                      "travel_agencies_tour_operators",
                      "truck_stop_iteration",
                      "truck_utility_trailer_rentals",
                      "typesetting_plate_making_and_related_services",
                      "typewriter_stores",
                      "u_s_federal_government_agencies_or_departments",
                      "uniforms_commercial_clothing",
                      "used_merchandise_and_secondhand_stores",
                      "utilities",
                      "variety_stores",
                      "veterinary_services",
                      "video_amusement_game_supplies",
                      "video_game_arcades",
                      "video_tape_rental_stores",
                      "vocational_trade_schools",
                      "watch_jewelry_repair",
                      "welding_repair",
                      "wholesale_clubs",
                      "wig_and_toupee_stores",
                      "wires_money_orders",
                      "womens_accessory_and_specialty_shops",
                      "womens_ready_to_wear_stores",
                      "wrecking_and_salvage_yards",
                    ]),
                  )
                  .optional(),
                interval: z.enum([
                  "all_time",
                  "daily",
                  "monthly",
                  "per_authorization",
                  "weekly",
                  "yearly",
                ]),
              }),
            )
            .optional(),
          spending_limits_currency: z.string().optional(),
        })
        .optional(),
      status: z.enum(["active", "inactive"]).optional(),
    })
    .optional()

  router.post(
    "postIssuingCardholdersCardholder",
    "/v1/issuing/cardholders/:cardholder",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingCardholdersCardholderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingCardholdersCardholderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingCardholdersCardholder(
          input,
          postIssuingCardholdersCardholder.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingCardholdersCardholder.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingCardsQuerySchema = z.object({
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    exp_month: z.coerce.number().optional(),
    exp_year: z.coerce.number().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    last4: z.string().max(5000).optional(),
    limit: z.coerce.number().optional(),
    personalization_design: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "canceled", "inactive"]).optional(),
    type: z.enum(["physical", "virtual"]).optional(),
  })

  const getIssuingCardsBodySchema = z.object({}).optional()

  router.get("getIssuingCards", "/v1/issuing/cards", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getIssuingCardsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getIssuingCardsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getIssuingCards(input, getIssuingCards.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getIssuingCards.validator(status, body)
    ctx.status = status
    return next()
  })

  const postIssuingCardsBodySchema = z.object({
    cardholder: z.string().max(5000).optional(),
    currency: z.string(),
    expand: z.array(z.string().max(5000)).optional(),
    financial_account: z.string().optional(),
    metadata: z.record(z.string()).optional(),
    personalization_design: z.string().max(5000).optional(),
    pin: z
      .object({ encrypted_number: z.string().max(5000).optional() })
      .optional(),
    replacement_for: z.string().max(5000).optional(),
    replacement_reason: z
      .enum(["damaged", "expired", "lost", "stolen"])
      .optional(),
    second_line: z.union([z.string().max(5000), z.enum([""])]).optional(),
    shipping: z
      .object({
        address: z.object({
          city: z.string().max(5000),
          country: z.string().max(5000),
          line1: z.string().max(5000),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000),
          state: z.string().max(5000).optional(),
        }),
        address_validation: z
          .object({
            mode: z.enum([
              "disabled",
              "normalization_only",
              "validation_and_normalization",
            ]),
          })
          .optional(),
        customs: z
          .object({ eori_number: z.string().max(5000).optional() })
          .optional(),
        name: z.string().max(5000),
        phone_number: z.string().optional(),
        require_signature: PermissiveBoolean.optional(),
        service: z.enum(["express", "priority", "standard"]).optional(),
        type: z.enum(["bulk", "individual"]).optional(),
      })
      .optional(),
    spending_controls: z
      .object({
        allowed_categories: z
          .array(
            z.enum([
              "ac_refrigeration_repair",
              "accounting_bookkeeping_services",
              "advertising_services",
              "agricultural_cooperative",
              "airlines_air_carriers",
              "airports_flying_fields",
              "ambulance_services",
              "amusement_parks_carnivals",
              "antique_reproductions",
              "antique_shops",
              "aquariums",
              "architectural_surveying_services",
              "art_dealers_and_galleries",
              "artists_supply_and_craft_shops",
              "auto_and_home_supply_stores",
              "auto_body_repair_shops",
              "auto_paint_shops",
              "auto_service_shops",
              "automated_cash_disburse",
              "automated_fuel_dispensers",
              "automobile_associations",
              "automotive_parts_and_accessories_stores",
              "automotive_tire_stores",
              "bail_and_bond_payments",
              "bakeries",
              "bands_orchestras",
              "barber_and_beauty_shops",
              "betting_casino_gambling",
              "bicycle_shops",
              "billiard_pool_establishments",
              "boat_dealers",
              "boat_rentals_and_leases",
              "book_stores",
              "books_periodicals_and_newspapers",
              "bowling_alleys",
              "bus_lines",
              "business_secretarial_schools",
              "buying_shopping_services",
              "cable_satellite_and_other_pay_television_and_radio",
              "camera_and_photographic_supply_stores",
              "candy_nut_and_confectionery_stores",
              "car_and_truck_dealers_new_used",
              "car_and_truck_dealers_used_only",
              "car_rental_agencies",
              "car_washes",
              "carpentry_services",
              "carpet_upholstery_cleaning",
              "caterers",
              "charitable_and_social_service_organizations_fundraising",
              "chemicals_and_allied_products",
              "child_care_services",
              "childrens_and_infants_wear_stores",
              "chiropodists_podiatrists",
              "chiropractors",
              "cigar_stores_and_stands",
              "civic_social_fraternal_associations",
              "cleaning_and_maintenance",
              "clothing_rental",
              "colleges_universities",
              "commercial_equipment",
              "commercial_footwear",
              "commercial_photography_art_and_graphics",
              "commuter_transport_and_ferries",
              "computer_network_services",
              "computer_programming",
              "computer_repair",
              "computer_software_stores",
              "computers_peripherals_and_software",
              "concrete_work_services",
              "construction_materials",
              "consulting_public_relations",
              "correspondence_schools",
              "cosmetic_stores",
              "counseling_services",
              "country_clubs",
              "courier_services",
              "court_costs",
              "credit_reporting_agencies",
              "cruise_lines",
              "dairy_products_stores",
              "dance_hall_studios_schools",
              "dating_escort_services",
              "dentists_orthodontists",
              "department_stores",
              "detective_agencies",
              "digital_goods_applications",
              "digital_goods_games",
              "digital_goods_large_volume",
              "digital_goods_media",
              "direct_marketing_catalog_merchant",
              "direct_marketing_combination_catalog_and_retail_merchant",
              "direct_marketing_inbound_telemarketing",
              "direct_marketing_insurance_services",
              "direct_marketing_other",
              "direct_marketing_outbound_telemarketing",
              "direct_marketing_subscription",
              "direct_marketing_travel",
              "discount_stores",
              "doctors",
              "door_to_door_sales",
              "drapery_window_covering_and_upholstery_stores",
              "drinking_places",
              "drug_stores_and_pharmacies",
              "drugs_drug_proprietaries_and_druggist_sundries",
              "dry_cleaners",
              "durable_goods",
              "duty_free_stores",
              "eating_places_restaurants",
              "educational_services",
              "electric_razor_stores",
              "electric_vehicle_charging",
              "electrical_parts_and_equipment",
              "electrical_services",
              "electronics_repair_shops",
              "electronics_stores",
              "elementary_secondary_schools",
              "emergency_services_gcas_visa_use_only",
              "employment_temp_agencies",
              "equipment_rental",
              "exterminating_services",
              "family_clothing_stores",
              "fast_food_restaurants",
              "financial_institutions",
              "fines_government_administrative_entities",
              "fireplace_fireplace_screens_and_accessories_stores",
              "floor_covering_stores",
              "florists",
              "florists_supplies_nursery_stock_and_flowers",
              "freezer_and_locker_meat_provisioners",
              "fuel_dealers_non_automotive",
              "funeral_services_crematories",
              "furniture_home_furnishings_and_equipment_stores_except_appliances",
              "furniture_repair_refinishing",
              "furriers_and_fur_shops",
              "general_services",
              "gift_card_novelty_and_souvenir_shops",
              "glass_paint_and_wallpaper_stores",
              "glassware_crystal_stores",
              "golf_courses_public",
              "government_licensed_horse_dog_racing_us_region_only",
              "government_licensed_online_casions_online_gambling_us_region_only",
              "government_owned_lotteries_non_us_region",
              "government_owned_lotteries_us_region_only",
              "government_services",
              "grocery_stores_supermarkets",
              "hardware_equipment_and_supplies",
              "hardware_stores",
              "health_and_beauty_spas",
              "hearing_aids_sales_and_supplies",
              "heating_plumbing_a_c",
              "hobby_toy_and_game_shops",
              "home_supply_warehouse_stores",
              "hospitals",
              "hotels_motels_and_resorts",
              "household_appliance_stores",
              "industrial_supplies",
              "information_retrieval_services",
              "insurance_default",
              "insurance_underwriting_premiums",
              "intra_company_purchases",
              "jewelry_stores_watches_clocks_and_silverware_stores",
              "landscaping_services",
              "laundries",
              "laundry_cleaning_services",
              "legal_services_attorneys",
              "luggage_and_leather_goods_stores",
              "lumber_building_materials_stores",
              "manual_cash_disburse",
              "marinas_service_and_supplies",
              "marketplaces",
              "masonry_stonework_and_plaster",
              "massage_parlors",
              "medical_and_dental_labs",
              "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
              "medical_services",
              "membership_organizations",
              "mens_and_boys_clothing_and_accessories_stores",
              "mens_womens_clothing_stores",
              "metal_service_centers",
              "miscellaneous",
              "miscellaneous_apparel_and_accessory_shops",
              "miscellaneous_auto_dealers",
              "miscellaneous_business_services",
              "miscellaneous_food_stores",
              "miscellaneous_general_merchandise",
              "miscellaneous_general_services",
              "miscellaneous_home_furnishing_specialty_stores",
              "miscellaneous_publishing_and_printing",
              "miscellaneous_recreation_services",
              "miscellaneous_repair_shops",
              "miscellaneous_specialty_retail",
              "mobile_home_dealers",
              "motion_picture_theaters",
              "motor_freight_carriers_and_trucking",
              "motor_homes_dealers",
              "motor_vehicle_supplies_and_new_parts",
              "motorcycle_shops_and_dealers",
              "motorcycle_shops_dealers",
              "music_stores_musical_instruments_pianos_and_sheet_music",
              "news_dealers_and_newsstands",
              "non_fi_money_orders",
              "non_fi_stored_value_card_purchase_load",
              "nondurable_goods",
              "nurseries_lawn_and_garden_supply_stores",
              "nursing_personal_care",
              "office_and_commercial_furniture",
              "opticians_eyeglasses",
              "optometrists_ophthalmologist",
              "orthopedic_goods_prosthetic_devices",
              "osteopaths",
              "package_stores_beer_wine_and_liquor",
              "paints_varnishes_and_supplies",
              "parking_lots_garages",
              "passenger_railways",
              "pawn_shops",
              "pet_shops_pet_food_and_supplies",
              "petroleum_and_petroleum_products",
              "photo_developing",
              "photographic_photocopy_microfilm_equipment_and_supplies",
              "photographic_studios",
              "picture_video_production",
              "piece_goods_notions_and_other_dry_goods",
              "plumbing_heating_equipment_and_supplies",
              "political_organizations",
              "postal_services_government_only",
              "precious_stones_and_metals_watches_and_jewelry",
              "professional_services",
              "public_warehousing_and_storage",
              "quick_copy_repro_and_blueprint",
              "railroads",
              "real_estate_agents_and_managers_rentals",
              "record_stores",
              "recreational_vehicle_rentals",
              "religious_goods_stores",
              "religious_organizations",
              "roofing_siding_sheet_metal",
              "secretarial_support_services",
              "security_brokers_dealers",
              "service_stations",
              "sewing_needlework_fabric_and_piece_goods_stores",
              "shoe_repair_hat_cleaning",
              "shoe_stores",
              "small_appliance_repair",
              "snowmobile_dealers",
              "special_trade_services",
              "specialty_cleaning",
              "sporting_goods_stores",
              "sporting_recreation_camps",
              "sports_and_riding_apparel_stores",
              "sports_clubs_fields",
              "stamp_and_coin_stores",
              "stationary_office_supplies_printing_and_writing_paper",
              "stationery_stores_office_and_school_supply_stores",
              "swimming_pools_sales",
              "t_ui_travel_germany",
              "tailors_alterations",
              "tax_payments_government_agencies",
              "tax_preparation_services",
              "taxicabs_limousines",
              "telecommunication_equipment_and_telephone_sales",
              "telecommunication_services",
              "telegraph_services",
              "tent_and_awning_shops",
              "testing_laboratories",
              "theatrical_ticket_agencies",
              "timeshares",
              "tire_retreading_and_repair",
              "tolls_bridge_fees",
              "tourist_attractions_and_exhibits",
              "towing_services",
              "trailer_parks_campgrounds",
              "transportation_services",
              "travel_agencies_tour_operators",
              "truck_stop_iteration",
              "truck_utility_trailer_rentals",
              "typesetting_plate_making_and_related_services",
              "typewriter_stores",
              "u_s_federal_government_agencies_or_departments",
              "uniforms_commercial_clothing",
              "used_merchandise_and_secondhand_stores",
              "utilities",
              "variety_stores",
              "veterinary_services",
              "video_amusement_game_supplies",
              "video_game_arcades",
              "video_tape_rental_stores",
              "vocational_trade_schools",
              "watch_jewelry_repair",
              "welding_repair",
              "wholesale_clubs",
              "wig_and_toupee_stores",
              "wires_money_orders",
              "womens_accessory_and_specialty_shops",
              "womens_ready_to_wear_stores",
              "wrecking_and_salvage_yards",
            ]),
          )
          .optional(),
        allowed_merchant_countries: z.array(z.string().max(5000)).optional(),
        blocked_categories: z
          .array(
            z.enum([
              "ac_refrigeration_repair",
              "accounting_bookkeeping_services",
              "advertising_services",
              "agricultural_cooperative",
              "airlines_air_carriers",
              "airports_flying_fields",
              "ambulance_services",
              "amusement_parks_carnivals",
              "antique_reproductions",
              "antique_shops",
              "aquariums",
              "architectural_surveying_services",
              "art_dealers_and_galleries",
              "artists_supply_and_craft_shops",
              "auto_and_home_supply_stores",
              "auto_body_repair_shops",
              "auto_paint_shops",
              "auto_service_shops",
              "automated_cash_disburse",
              "automated_fuel_dispensers",
              "automobile_associations",
              "automotive_parts_and_accessories_stores",
              "automotive_tire_stores",
              "bail_and_bond_payments",
              "bakeries",
              "bands_orchestras",
              "barber_and_beauty_shops",
              "betting_casino_gambling",
              "bicycle_shops",
              "billiard_pool_establishments",
              "boat_dealers",
              "boat_rentals_and_leases",
              "book_stores",
              "books_periodicals_and_newspapers",
              "bowling_alleys",
              "bus_lines",
              "business_secretarial_schools",
              "buying_shopping_services",
              "cable_satellite_and_other_pay_television_and_radio",
              "camera_and_photographic_supply_stores",
              "candy_nut_and_confectionery_stores",
              "car_and_truck_dealers_new_used",
              "car_and_truck_dealers_used_only",
              "car_rental_agencies",
              "car_washes",
              "carpentry_services",
              "carpet_upholstery_cleaning",
              "caterers",
              "charitable_and_social_service_organizations_fundraising",
              "chemicals_and_allied_products",
              "child_care_services",
              "childrens_and_infants_wear_stores",
              "chiropodists_podiatrists",
              "chiropractors",
              "cigar_stores_and_stands",
              "civic_social_fraternal_associations",
              "cleaning_and_maintenance",
              "clothing_rental",
              "colleges_universities",
              "commercial_equipment",
              "commercial_footwear",
              "commercial_photography_art_and_graphics",
              "commuter_transport_and_ferries",
              "computer_network_services",
              "computer_programming",
              "computer_repair",
              "computer_software_stores",
              "computers_peripherals_and_software",
              "concrete_work_services",
              "construction_materials",
              "consulting_public_relations",
              "correspondence_schools",
              "cosmetic_stores",
              "counseling_services",
              "country_clubs",
              "courier_services",
              "court_costs",
              "credit_reporting_agencies",
              "cruise_lines",
              "dairy_products_stores",
              "dance_hall_studios_schools",
              "dating_escort_services",
              "dentists_orthodontists",
              "department_stores",
              "detective_agencies",
              "digital_goods_applications",
              "digital_goods_games",
              "digital_goods_large_volume",
              "digital_goods_media",
              "direct_marketing_catalog_merchant",
              "direct_marketing_combination_catalog_and_retail_merchant",
              "direct_marketing_inbound_telemarketing",
              "direct_marketing_insurance_services",
              "direct_marketing_other",
              "direct_marketing_outbound_telemarketing",
              "direct_marketing_subscription",
              "direct_marketing_travel",
              "discount_stores",
              "doctors",
              "door_to_door_sales",
              "drapery_window_covering_and_upholstery_stores",
              "drinking_places",
              "drug_stores_and_pharmacies",
              "drugs_drug_proprietaries_and_druggist_sundries",
              "dry_cleaners",
              "durable_goods",
              "duty_free_stores",
              "eating_places_restaurants",
              "educational_services",
              "electric_razor_stores",
              "electric_vehicle_charging",
              "electrical_parts_and_equipment",
              "electrical_services",
              "electronics_repair_shops",
              "electronics_stores",
              "elementary_secondary_schools",
              "emergency_services_gcas_visa_use_only",
              "employment_temp_agencies",
              "equipment_rental",
              "exterminating_services",
              "family_clothing_stores",
              "fast_food_restaurants",
              "financial_institutions",
              "fines_government_administrative_entities",
              "fireplace_fireplace_screens_and_accessories_stores",
              "floor_covering_stores",
              "florists",
              "florists_supplies_nursery_stock_and_flowers",
              "freezer_and_locker_meat_provisioners",
              "fuel_dealers_non_automotive",
              "funeral_services_crematories",
              "furniture_home_furnishings_and_equipment_stores_except_appliances",
              "furniture_repair_refinishing",
              "furriers_and_fur_shops",
              "general_services",
              "gift_card_novelty_and_souvenir_shops",
              "glass_paint_and_wallpaper_stores",
              "glassware_crystal_stores",
              "golf_courses_public",
              "government_licensed_horse_dog_racing_us_region_only",
              "government_licensed_online_casions_online_gambling_us_region_only",
              "government_owned_lotteries_non_us_region",
              "government_owned_lotteries_us_region_only",
              "government_services",
              "grocery_stores_supermarkets",
              "hardware_equipment_and_supplies",
              "hardware_stores",
              "health_and_beauty_spas",
              "hearing_aids_sales_and_supplies",
              "heating_plumbing_a_c",
              "hobby_toy_and_game_shops",
              "home_supply_warehouse_stores",
              "hospitals",
              "hotels_motels_and_resorts",
              "household_appliance_stores",
              "industrial_supplies",
              "information_retrieval_services",
              "insurance_default",
              "insurance_underwriting_premiums",
              "intra_company_purchases",
              "jewelry_stores_watches_clocks_and_silverware_stores",
              "landscaping_services",
              "laundries",
              "laundry_cleaning_services",
              "legal_services_attorneys",
              "luggage_and_leather_goods_stores",
              "lumber_building_materials_stores",
              "manual_cash_disburse",
              "marinas_service_and_supplies",
              "marketplaces",
              "masonry_stonework_and_plaster",
              "massage_parlors",
              "medical_and_dental_labs",
              "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
              "medical_services",
              "membership_organizations",
              "mens_and_boys_clothing_and_accessories_stores",
              "mens_womens_clothing_stores",
              "metal_service_centers",
              "miscellaneous",
              "miscellaneous_apparel_and_accessory_shops",
              "miscellaneous_auto_dealers",
              "miscellaneous_business_services",
              "miscellaneous_food_stores",
              "miscellaneous_general_merchandise",
              "miscellaneous_general_services",
              "miscellaneous_home_furnishing_specialty_stores",
              "miscellaneous_publishing_and_printing",
              "miscellaneous_recreation_services",
              "miscellaneous_repair_shops",
              "miscellaneous_specialty_retail",
              "mobile_home_dealers",
              "motion_picture_theaters",
              "motor_freight_carriers_and_trucking",
              "motor_homes_dealers",
              "motor_vehicle_supplies_and_new_parts",
              "motorcycle_shops_and_dealers",
              "motorcycle_shops_dealers",
              "music_stores_musical_instruments_pianos_and_sheet_music",
              "news_dealers_and_newsstands",
              "non_fi_money_orders",
              "non_fi_stored_value_card_purchase_load",
              "nondurable_goods",
              "nurseries_lawn_and_garden_supply_stores",
              "nursing_personal_care",
              "office_and_commercial_furniture",
              "opticians_eyeglasses",
              "optometrists_ophthalmologist",
              "orthopedic_goods_prosthetic_devices",
              "osteopaths",
              "package_stores_beer_wine_and_liquor",
              "paints_varnishes_and_supplies",
              "parking_lots_garages",
              "passenger_railways",
              "pawn_shops",
              "pet_shops_pet_food_and_supplies",
              "petroleum_and_petroleum_products",
              "photo_developing",
              "photographic_photocopy_microfilm_equipment_and_supplies",
              "photographic_studios",
              "picture_video_production",
              "piece_goods_notions_and_other_dry_goods",
              "plumbing_heating_equipment_and_supplies",
              "political_organizations",
              "postal_services_government_only",
              "precious_stones_and_metals_watches_and_jewelry",
              "professional_services",
              "public_warehousing_and_storage",
              "quick_copy_repro_and_blueprint",
              "railroads",
              "real_estate_agents_and_managers_rentals",
              "record_stores",
              "recreational_vehicle_rentals",
              "religious_goods_stores",
              "religious_organizations",
              "roofing_siding_sheet_metal",
              "secretarial_support_services",
              "security_brokers_dealers",
              "service_stations",
              "sewing_needlework_fabric_and_piece_goods_stores",
              "shoe_repair_hat_cleaning",
              "shoe_stores",
              "small_appliance_repair",
              "snowmobile_dealers",
              "special_trade_services",
              "specialty_cleaning",
              "sporting_goods_stores",
              "sporting_recreation_camps",
              "sports_and_riding_apparel_stores",
              "sports_clubs_fields",
              "stamp_and_coin_stores",
              "stationary_office_supplies_printing_and_writing_paper",
              "stationery_stores_office_and_school_supply_stores",
              "swimming_pools_sales",
              "t_ui_travel_germany",
              "tailors_alterations",
              "tax_payments_government_agencies",
              "tax_preparation_services",
              "taxicabs_limousines",
              "telecommunication_equipment_and_telephone_sales",
              "telecommunication_services",
              "telegraph_services",
              "tent_and_awning_shops",
              "testing_laboratories",
              "theatrical_ticket_agencies",
              "timeshares",
              "tire_retreading_and_repair",
              "tolls_bridge_fees",
              "tourist_attractions_and_exhibits",
              "towing_services",
              "trailer_parks_campgrounds",
              "transportation_services",
              "travel_agencies_tour_operators",
              "truck_stop_iteration",
              "truck_utility_trailer_rentals",
              "typesetting_plate_making_and_related_services",
              "typewriter_stores",
              "u_s_federal_government_agencies_or_departments",
              "uniforms_commercial_clothing",
              "used_merchandise_and_secondhand_stores",
              "utilities",
              "variety_stores",
              "veterinary_services",
              "video_amusement_game_supplies",
              "video_game_arcades",
              "video_tape_rental_stores",
              "vocational_trade_schools",
              "watch_jewelry_repair",
              "welding_repair",
              "wholesale_clubs",
              "wig_and_toupee_stores",
              "wires_money_orders",
              "womens_accessory_and_specialty_shops",
              "womens_ready_to_wear_stores",
              "wrecking_and_salvage_yards",
            ]),
          )
          .optional(),
        blocked_merchant_countries: z.array(z.string().max(5000)).optional(),
        spending_limits: z
          .array(
            z.object({
              amount: z.coerce.number(),
              categories: z
                .array(
                  z.enum([
                    "ac_refrigeration_repair",
                    "accounting_bookkeeping_services",
                    "advertising_services",
                    "agricultural_cooperative",
                    "airlines_air_carriers",
                    "airports_flying_fields",
                    "ambulance_services",
                    "amusement_parks_carnivals",
                    "antique_reproductions",
                    "antique_shops",
                    "aquariums",
                    "architectural_surveying_services",
                    "art_dealers_and_galleries",
                    "artists_supply_and_craft_shops",
                    "auto_and_home_supply_stores",
                    "auto_body_repair_shops",
                    "auto_paint_shops",
                    "auto_service_shops",
                    "automated_cash_disburse",
                    "automated_fuel_dispensers",
                    "automobile_associations",
                    "automotive_parts_and_accessories_stores",
                    "automotive_tire_stores",
                    "bail_and_bond_payments",
                    "bakeries",
                    "bands_orchestras",
                    "barber_and_beauty_shops",
                    "betting_casino_gambling",
                    "bicycle_shops",
                    "billiard_pool_establishments",
                    "boat_dealers",
                    "boat_rentals_and_leases",
                    "book_stores",
                    "books_periodicals_and_newspapers",
                    "bowling_alleys",
                    "bus_lines",
                    "business_secretarial_schools",
                    "buying_shopping_services",
                    "cable_satellite_and_other_pay_television_and_radio",
                    "camera_and_photographic_supply_stores",
                    "candy_nut_and_confectionery_stores",
                    "car_and_truck_dealers_new_used",
                    "car_and_truck_dealers_used_only",
                    "car_rental_agencies",
                    "car_washes",
                    "carpentry_services",
                    "carpet_upholstery_cleaning",
                    "caterers",
                    "charitable_and_social_service_organizations_fundraising",
                    "chemicals_and_allied_products",
                    "child_care_services",
                    "childrens_and_infants_wear_stores",
                    "chiropodists_podiatrists",
                    "chiropractors",
                    "cigar_stores_and_stands",
                    "civic_social_fraternal_associations",
                    "cleaning_and_maintenance",
                    "clothing_rental",
                    "colleges_universities",
                    "commercial_equipment",
                    "commercial_footwear",
                    "commercial_photography_art_and_graphics",
                    "commuter_transport_and_ferries",
                    "computer_network_services",
                    "computer_programming",
                    "computer_repair",
                    "computer_software_stores",
                    "computers_peripherals_and_software",
                    "concrete_work_services",
                    "construction_materials",
                    "consulting_public_relations",
                    "correspondence_schools",
                    "cosmetic_stores",
                    "counseling_services",
                    "country_clubs",
                    "courier_services",
                    "court_costs",
                    "credit_reporting_agencies",
                    "cruise_lines",
                    "dairy_products_stores",
                    "dance_hall_studios_schools",
                    "dating_escort_services",
                    "dentists_orthodontists",
                    "department_stores",
                    "detective_agencies",
                    "digital_goods_applications",
                    "digital_goods_games",
                    "digital_goods_large_volume",
                    "digital_goods_media",
                    "direct_marketing_catalog_merchant",
                    "direct_marketing_combination_catalog_and_retail_merchant",
                    "direct_marketing_inbound_telemarketing",
                    "direct_marketing_insurance_services",
                    "direct_marketing_other",
                    "direct_marketing_outbound_telemarketing",
                    "direct_marketing_subscription",
                    "direct_marketing_travel",
                    "discount_stores",
                    "doctors",
                    "door_to_door_sales",
                    "drapery_window_covering_and_upholstery_stores",
                    "drinking_places",
                    "drug_stores_and_pharmacies",
                    "drugs_drug_proprietaries_and_druggist_sundries",
                    "dry_cleaners",
                    "durable_goods",
                    "duty_free_stores",
                    "eating_places_restaurants",
                    "educational_services",
                    "electric_razor_stores",
                    "electric_vehicle_charging",
                    "electrical_parts_and_equipment",
                    "electrical_services",
                    "electronics_repair_shops",
                    "electronics_stores",
                    "elementary_secondary_schools",
                    "emergency_services_gcas_visa_use_only",
                    "employment_temp_agencies",
                    "equipment_rental",
                    "exterminating_services",
                    "family_clothing_stores",
                    "fast_food_restaurants",
                    "financial_institutions",
                    "fines_government_administrative_entities",
                    "fireplace_fireplace_screens_and_accessories_stores",
                    "floor_covering_stores",
                    "florists",
                    "florists_supplies_nursery_stock_and_flowers",
                    "freezer_and_locker_meat_provisioners",
                    "fuel_dealers_non_automotive",
                    "funeral_services_crematories",
                    "furniture_home_furnishings_and_equipment_stores_except_appliances",
                    "furniture_repair_refinishing",
                    "furriers_and_fur_shops",
                    "general_services",
                    "gift_card_novelty_and_souvenir_shops",
                    "glass_paint_and_wallpaper_stores",
                    "glassware_crystal_stores",
                    "golf_courses_public",
                    "government_licensed_horse_dog_racing_us_region_only",
                    "government_licensed_online_casions_online_gambling_us_region_only",
                    "government_owned_lotteries_non_us_region",
                    "government_owned_lotteries_us_region_only",
                    "government_services",
                    "grocery_stores_supermarkets",
                    "hardware_equipment_and_supplies",
                    "hardware_stores",
                    "health_and_beauty_spas",
                    "hearing_aids_sales_and_supplies",
                    "heating_plumbing_a_c",
                    "hobby_toy_and_game_shops",
                    "home_supply_warehouse_stores",
                    "hospitals",
                    "hotels_motels_and_resorts",
                    "household_appliance_stores",
                    "industrial_supplies",
                    "information_retrieval_services",
                    "insurance_default",
                    "insurance_underwriting_premiums",
                    "intra_company_purchases",
                    "jewelry_stores_watches_clocks_and_silverware_stores",
                    "landscaping_services",
                    "laundries",
                    "laundry_cleaning_services",
                    "legal_services_attorneys",
                    "luggage_and_leather_goods_stores",
                    "lumber_building_materials_stores",
                    "manual_cash_disburse",
                    "marinas_service_and_supplies",
                    "marketplaces",
                    "masonry_stonework_and_plaster",
                    "massage_parlors",
                    "medical_and_dental_labs",
                    "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                    "medical_services",
                    "membership_organizations",
                    "mens_and_boys_clothing_and_accessories_stores",
                    "mens_womens_clothing_stores",
                    "metal_service_centers",
                    "miscellaneous",
                    "miscellaneous_apparel_and_accessory_shops",
                    "miscellaneous_auto_dealers",
                    "miscellaneous_business_services",
                    "miscellaneous_food_stores",
                    "miscellaneous_general_merchandise",
                    "miscellaneous_general_services",
                    "miscellaneous_home_furnishing_specialty_stores",
                    "miscellaneous_publishing_and_printing",
                    "miscellaneous_recreation_services",
                    "miscellaneous_repair_shops",
                    "miscellaneous_specialty_retail",
                    "mobile_home_dealers",
                    "motion_picture_theaters",
                    "motor_freight_carriers_and_trucking",
                    "motor_homes_dealers",
                    "motor_vehicle_supplies_and_new_parts",
                    "motorcycle_shops_and_dealers",
                    "motorcycle_shops_dealers",
                    "music_stores_musical_instruments_pianos_and_sheet_music",
                    "news_dealers_and_newsstands",
                    "non_fi_money_orders",
                    "non_fi_stored_value_card_purchase_load",
                    "nondurable_goods",
                    "nurseries_lawn_and_garden_supply_stores",
                    "nursing_personal_care",
                    "office_and_commercial_furniture",
                    "opticians_eyeglasses",
                    "optometrists_ophthalmologist",
                    "orthopedic_goods_prosthetic_devices",
                    "osteopaths",
                    "package_stores_beer_wine_and_liquor",
                    "paints_varnishes_and_supplies",
                    "parking_lots_garages",
                    "passenger_railways",
                    "pawn_shops",
                    "pet_shops_pet_food_and_supplies",
                    "petroleum_and_petroleum_products",
                    "photo_developing",
                    "photographic_photocopy_microfilm_equipment_and_supplies",
                    "photographic_studios",
                    "picture_video_production",
                    "piece_goods_notions_and_other_dry_goods",
                    "plumbing_heating_equipment_and_supplies",
                    "political_organizations",
                    "postal_services_government_only",
                    "precious_stones_and_metals_watches_and_jewelry",
                    "professional_services",
                    "public_warehousing_and_storage",
                    "quick_copy_repro_and_blueprint",
                    "railroads",
                    "real_estate_agents_and_managers_rentals",
                    "record_stores",
                    "recreational_vehicle_rentals",
                    "religious_goods_stores",
                    "religious_organizations",
                    "roofing_siding_sheet_metal",
                    "secretarial_support_services",
                    "security_brokers_dealers",
                    "service_stations",
                    "sewing_needlework_fabric_and_piece_goods_stores",
                    "shoe_repair_hat_cleaning",
                    "shoe_stores",
                    "small_appliance_repair",
                    "snowmobile_dealers",
                    "special_trade_services",
                    "specialty_cleaning",
                    "sporting_goods_stores",
                    "sporting_recreation_camps",
                    "sports_and_riding_apparel_stores",
                    "sports_clubs_fields",
                    "stamp_and_coin_stores",
                    "stationary_office_supplies_printing_and_writing_paper",
                    "stationery_stores_office_and_school_supply_stores",
                    "swimming_pools_sales",
                    "t_ui_travel_germany",
                    "tailors_alterations",
                    "tax_payments_government_agencies",
                    "tax_preparation_services",
                    "taxicabs_limousines",
                    "telecommunication_equipment_and_telephone_sales",
                    "telecommunication_services",
                    "telegraph_services",
                    "tent_and_awning_shops",
                    "testing_laboratories",
                    "theatrical_ticket_agencies",
                    "timeshares",
                    "tire_retreading_and_repair",
                    "tolls_bridge_fees",
                    "tourist_attractions_and_exhibits",
                    "towing_services",
                    "trailer_parks_campgrounds",
                    "transportation_services",
                    "travel_agencies_tour_operators",
                    "truck_stop_iteration",
                    "truck_utility_trailer_rentals",
                    "typesetting_plate_making_and_related_services",
                    "typewriter_stores",
                    "u_s_federal_government_agencies_or_departments",
                    "uniforms_commercial_clothing",
                    "used_merchandise_and_secondhand_stores",
                    "utilities",
                    "variety_stores",
                    "veterinary_services",
                    "video_amusement_game_supplies",
                    "video_game_arcades",
                    "video_tape_rental_stores",
                    "vocational_trade_schools",
                    "watch_jewelry_repair",
                    "welding_repair",
                    "wholesale_clubs",
                    "wig_and_toupee_stores",
                    "wires_money_orders",
                    "womens_accessory_and_specialty_shops",
                    "womens_ready_to_wear_stores",
                    "wrecking_and_salvage_yards",
                  ]),
                )
                .optional(),
              interval: z.enum([
                "all_time",
                "daily",
                "monthly",
                "per_authorization",
                "weekly",
                "yearly",
              ]),
            }),
          )
          .optional(),
      })
      .optional(),
    status: z.enum(["active", "inactive"]).optional(),
    type: z.enum(["physical", "virtual"]),
  })

  router.post("postIssuingCards", "/v1/issuing/cards", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postIssuingCardsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postIssuingCards(input, postIssuingCards.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postIssuingCards.validator(status, body)
    ctx.status = status
    return next()
  })

  const getIssuingCardsCardParamSchema = z.object({
    card: z.string().max(5000),
  })

  const getIssuingCardsCardQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingCardsCardBodySchema = z.object({}).optional()

  router.get(
    "getIssuingCardsCard",
    "/v1/issuing/cards/:card",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingCardsCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingCardsCardQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingCardsCardBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingCardsCard(input, getIssuingCardsCard.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingCardsCard.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingCardsCardParamSchema = z.object({
    card: z.string().max(5000),
  })

  const postIssuingCardsCardBodySchema = z
    .object({
      cancellation_reason: z.enum(["lost", "stolen"]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      personalization_design: z.string().max(5000).optional(),
      pin: z
        .object({ encrypted_number: z.string().max(5000).optional() })
        .optional(),
      shipping: z
        .object({
          address: z.object({
            city: z.string().max(5000),
            country: z.string().max(5000),
            line1: z.string().max(5000),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000),
            state: z.string().max(5000).optional(),
          }),
          address_validation: z
            .object({
              mode: z.enum([
                "disabled",
                "normalization_only",
                "validation_and_normalization",
              ]),
            })
            .optional(),
          customs: z
            .object({ eori_number: z.string().max(5000).optional() })
            .optional(),
          name: z.string().max(5000),
          phone_number: z.string().optional(),
          require_signature: PermissiveBoolean.optional(),
          service: z.enum(["express", "priority", "standard"]).optional(),
          type: z.enum(["bulk", "individual"]).optional(),
        })
        .optional(),
      spending_controls: z
        .object({
          allowed_categories: z
            .array(
              z.enum([
                "ac_refrigeration_repair",
                "accounting_bookkeeping_services",
                "advertising_services",
                "agricultural_cooperative",
                "airlines_air_carriers",
                "airports_flying_fields",
                "ambulance_services",
                "amusement_parks_carnivals",
                "antique_reproductions",
                "antique_shops",
                "aquariums",
                "architectural_surveying_services",
                "art_dealers_and_galleries",
                "artists_supply_and_craft_shops",
                "auto_and_home_supply_stores",
                "auto_body_repair_shops",
                "auto_paint_shops",
                "auto_service_shops",
                "automated_cash_disburse",
                "automated_fuel_dispensers",
                "automobile_associations",
                "automotive_parts_and_accessories_stores",
                "automotive_tire_stores",
                "bail_and_bond_payments",
                "bakeries",
                "bands_orchestras",
                "barber_and_beauty_shops",
                "betting_casino_gambling",
                "bicycle_shops",
                "billiard_pool_establishments",
                "boat_dealers",
                "boat_rentals_and_leases",
                "book_stores",
                "books_periodicals_and_newspapers",
                "bowling_alleys",
                "bus_lines",
                "business_secretarial_schools",
                "buying_shopping_services",
                "cable_satellite_and_other_pay_television_and_radio",
                "camera_and_photographic_supply_stores",
                "candy_nut_and_confectionery_stores",
                "car_and_truck_dealers_new_used",
                "car_and_truck_dealers_used_only",
                "car_rental_agencies",
                "car_washes",
                "carpentry_services",
                "carpet_upholstery_cleaning",
                "caterers",
                "charitable_and_social_service_organizations_fundraising",
                "chemicals_and_allied_products",
                "child_care_services",
                "childrens_and_infants_wear_stores",
                "chiropodists_podiatrists",
                "chiropractors",
                "cigar_stores_and_stands",
                "civic_social_fraternal_associations",
                "cleaning_and_maintenance",
                "clothing_rental",
                "colleges_universities",
                "commercial_equipment",
                "commercial_footwear",
                "commercial_photography_art_and_graphics",
                "commuter_transport_and_ferries",
                "computer_network_services",
                "computer_programming",
                "computer_repair",
                "computer_software_stores",
                "computers_peripherals_and_software",
                "concrete_work_services",
                "construction_materials",
                "consulting_public_relations",
                "correspondence_schools",
                "cosmetic_stores",
                "counseling_services",
                "country_clubs",
                "courier_services",
                "court_costs",
                "credit_reporting_agencies",
                "cruise_lines",
                "dairy_products_stores",
                "dance_hall_studios_schools",
                "dating_escort_services",
                "dentists_orthodontists",
                "department_stores",
                "detective_agencies",
                "digital_goods_applications",
                "digital_goods_games",
                "digital_goods_large_volume",
                "digital_goods_media",
                "direct_marketing_catalog_merchant",
                "direct_marketing_combination_catalog_and_retail_merchant",
                "direct_marketing_inbound_telemarketing",
                "direct_marketing_insurance_services",
                "direct_marketing_other",
                "direct_marketing_outbound_telemarketing",
                "direct_marketing_subscription",
                "direct_marketing_travel",
                "discount_stores",
                "doctors",
                "door_to_door_sales",
                "drapery_window_covering_and_upholstery_stores",
                "drinking_places",
                "drug_stores_and_pharmacies",
                "drugs_drug_proprietaries_and_druggist_sundries",
                "dry_cleaners",
                "durable_goods",
                "duty_free_stores",
                "eating_places_restaurants",
                "educational_services",
                "electric_razor_stores",
                "electric_vehicle_charging",
                "electrical_parts_and_equipment",
                "electrical_services",
                "electronics_repair_shops",
                "electronics_stores",
                "elementary_secondary_schools",
                "emergency_services_gcas_visa_use_only",
                "employment_temp_agencies",
                "equipment_rental",
                "exterminating_services",
                "family_clothing_stores",
                "fast_food_restaurants",
                "financial_institutions",
                "fines_government_administrative_entities",
                "fireplace_fireplace_screens_and_accessories_stores",
                "floor_covering_stores",
                "florists",
                "florists_supplies_nursery_stock_and_flowers",
                "freezer_and_locker_meat_provisioners",
                "fuel_dealers_non_automotive",
                "funeral_services_crematories",
                "furniture_home_furnishings_and_equipment_stores_except_appliances",
                "furniture_repair_refinishing",
                "furriers_and_fur_shops",
                "general_services",
                "gift_card_novelty_and_souvenir_shops",
                "glass_paint_and_wallpaper_stores",
                "glassware_crystal_stores",
                "golf_courses_public",
                "government_licensed_horse_dog_racing_us_region_only",
                "government_licensed_online_casions_online_gambling_us_region_only",
                "government_owned_lotteries_non_us_region",
                "government_owned_lotteries_us_region_only",
                "government_services",
                "grocery_stores_supermarkets",
                "hardware_equipment_and_supplies",
                "hardware_stores",
                "health_and_beauty_spas",
                "hearing_aids_sales_and_supplies",
                "heating_plumbing_a_c",
                "hobby_toy_and_game_shops",
                "home_supply_warehouse_stores",
                "hospitals",
                "hotels_motels_and_resorts",
                "household_appliance_stores",
                "industrial_supplies",
                "information_retrieval_services",
                "insurance_default",
                "insurance_underwriting_premiums",
                "intra_company_purchases",
                "jewelry_stores_watches_clocks_and_silverware_stores",
                "landscaping_services",
                "laundries",
                "laundry_cleaning_services",
                "legal_services_attorneys",
                "luggage_and_leather_goods_stores",
                "lumber_building_materials_stores",
                "manual_cash_disburse",
                "marinas_service_and_supplies",
                "marketplaces",
                "masonry_stonework_and_plaster",
                "massage_parlors",
                "medical_and_dental_labs",
                "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                "medical_services",
                "membership_organizations",
                "mens_and_boys_clothing_and_accessories_stores",
                "mens_womens_clothing_stores",
                "metal_service_centers",
                "miscellaneous",
                "miscellaneous_apparel_and_accessory_shops",
                "miscellaneous_auto_dealers",
                "miscellaneous_business_services",
                "miscellaneous_food_stores",
                "miscellaneous_general_merchandise",
                "miscellaneous_general_services",
                "miscellaneous_home_furnishing_specialty_stores",
                "miscellaneous_publishing_and_printing",
                "miscellaneous_recreation_services",
                "miscellaneous_repair_shops",
                "miscellaneous_specialty_retail",
                "mobile_home_dealers",
                "motion_picture_theaters",
                "motor_freight_carriers_and_trucking",
                "motor_homes_dealers",
                "motor_vehicle_supplies_and_new_parts",
                "motorcycle_shops_and_dealers",
                "motorcycle_shops_dealers",
                "music_stores_musical_instruments_pianos_and_sheet_music",
                "news_dealers_and_newsstands",
                "non_fi_money_orders",
                "non_fi_stored_value_card_purchase_load",
                "nondurable_goods",
                "nurseries_lawn_and_garden_supply_stores",
                "nursing_personal_care",
                "office_and_commercial_furniture",
                "opticians_eyeglasses",
                "optometrists_ophthalmologist",
                "orthopedic_goods_prosthetic_devices",
                "osteopaths",
                "package_stores_beer_wine_and_liquor",
                "paints_varnishes_and_supplies",
                "parking_lots_garages",
                "passenger_railways",
                "pawn_shops",
                "pet_shops_pet_food_and_supplies",
                "petroleum_and_petroleum_products",
                "photo_developing",
                "photographic_photocopy_microfilm_equipment_and_supplies",
                "photographic_studios",
                "picture_video_production",
                "piece_goods_notions_and_other_dry_goods",
                "plumbing_heating_equipment_and_supplies",
                "political_organizations",
                "postal_services_government_only",
                "precious_stones_and_metals_watches_and_jewelry",
                "professional_services",
                "public_warehousing_and_storage",
                "quick_copy_repro_and_blueprint",
                "railroads",
                "real_estate_agents_and_managers_rentals",
                "record_stores",
                "recreational_vehicle_rentals",
                "religious_goods_stores",
                "religious_organizations",
                "roofing_siding_sheet_metal",
                "secretarial_support_services",
                "security_brokers_dealers",
                "service_stations",
                "sewing_needlework_fabric_and_piece_goods_stores",
                "shoe_repair_hat_cleaning",
                "shoe_stores",
                "small_appliance_repair",
                "snowmobile_dealers",
                "special_trade_services",
                "specialty_cleaning",
                "sporting_goods_stores",
                "sporting_recreation_camps",
                "sports_and_riding_apparel_stores",
                "sports_clubs_fields",
                "stamp_and_coin_stores",
                "stationary_office_supplies_printing_and_writing_paper",
                "stationery_stores_office_and_school_supply_stores",
                "swimming_pools_sales",
                "t_ui_travel_germany",
                "tailors_alterations",
                "tax_payments_government_agencies",
                "tax_preparation_services",
                "taxicabs_limousines",
                "telecommunication_equipment_and_telephone_sales",
                "telecommunication_services",
                "telegraph_services",
                "tent_and_awning_shops",
                "testing_laboratories",
                "theatrical_ticket_agencies",
                "timeshares",
                "tire_retreading_and_repair",
                "tolls_bridge_fees",
                "tourist_attractions_and_exhibits",
                "towing_services",
                "trailer_parks_campgrounds",
                "transportation_services",
                "travel_agencies_tour_operators",
                "truck_stop_iteration",
                "truck_utility_trailer_rentals",
                "typesetting_plate_making_and_related_services",
                "typewriter_stores",
                "u_s_federal_government_agencies_or_departments",
                "uniforms_commercial_clothing",
                "used_merchandise_and_secondhand_stores",
                "utilities",
                "variety_stores",
                "veterinary_services",
                "video_amusement_game_supplies",
                "video_game_arcades",
                "video_tape_rental_stores",
                "vocational_trade_schools",
                "watch_jewelry_repair",
                "welding_repair",
                "wholesale_clubs",
                "wig_and_toupee_stores",
                "wires_money_orders",
                "womens_accessory_and_specialty_shops",
                "womens_ready_to_wear_stores",
                "wrecking_and_salvage_yards",
              ]),
            )
            .optional(),
          allowed_merchant_countries: z.array(z.string().max(5000)).optional(),
          blocked_categories: z
            .array(
              z.enum([
                "ac_refrigeration_repair",
                "accounting_bookkeeping_services",
                "advertising_services",
                "agricultural_cooperative",
                "airlines_air_carriers",
                "airports_flying_fields",
                "ambulance_services",
                "amusement_parks_carnivals",
                "antique_reproductions",
                "antique_shops",
                "aquariums",
                "architectural_surveying_services",
                "art_dealers_and_galleries",
                "artists_supply_and_craft_shops",
                "auto_and_home_supply_stores",
                "auto_body_repair_shops",
                "auto_paint_shops",
                "auto_service_shops",
                "automated_cash_disburse",
                "automated_fuel_dispensers",
                "automobile_associations",
                "automotive_parts_and_accessories_stores",
                "automotive_tire_stores",
                "bail_and_bond_payments",
                "bakeries",
                "bands_orchestras",
                "barber_and_beauty_shops",
                "betting_casino_gambling",
                "bicycle_shops",
                "billiard_pool_establishments",
                "boat_dealers",
                "boat_rentals_and_leases",
                "book_stores",
                "books_periodicals_and_newspapers",
                "bowling_alleys",
                "bus_lines",
                "business_secretarial_schools",
                "buying_shopping_services",
                "cable_satellite_and_other_pay_television_and_radio",
                "camera_and_photographic_supply_stores",
                "candy_nut_and_confectionery_stores",
                "car_and_truck_dealers_new_used",
                "car_and_truck_dealers_used_only",
                "car_rental_agencies",
                "car_washes",
                "carpentry_services",
                "carpet_upholstery_cleaning",
                "caterers",
                "charitable_and_social_service_organizations_fundraising",
                "chemicals_and_allied_products",
                "child_care_services",
                "childrens_and_infants_wear_stores",
                "chiropodists_podiatrists",
                "chiropractors",
                "cigar_stores_and_stands",
                "civic_social_fraternal_associations",
                "cleaning_and_maintenance",
                "clothing_rental",
                "colleges_universities",
                "commercial_equipment",
                "commercial_footwear",
                "commercial_photography_art_and_graphics",
                "commuter_transport_and_ferries",
                "computer_network_services",
                "computer_programming",
                "computer_repair",
                "computer_software_stores",
                "computers_peripherals_and_software",
                "concrete_work_services",
                "construction_materials",
                "consulting_public_relations",
                "correspondence_schools",
                "cosmetic_stores",
                "counseling_services",
                "country_clubs",
                "courier_services",
                "court_costs",
                "credit_reporting_agencies",
                "cruise_lines",
                "dairy_products_stores",
                "dance_hall_studios_schools",
                "dating_escort_services",
                "dentists_orthodontists",
                "department_stores",
                "detective_agencies",
                "digital_goods_applications",
                "digital_goods_games",
                "digital_goods_large_volume",
                "digital_goods_media",
                "direct_marketing_catalog_merchant",
                "direct_marketing_combination_catalog_and_retail_merchant",
                "direct_marketing_inbound_telemarketing",
                "direct_marketing_insurance_services",
                "direct_marketing_other",
                "direct_marketing_outbound_telemarketing",
                "direct_marketing_subscription",
                "direct_marketing_travel",
                "discount_stores",
                "doctors",
                "door_to_door_sales",
                "drapery_window_covering_and_upholstery_stores",
                "drinking_places",
                "drug_stores_and_pharmacies",
                "drugs_drug_proprietaries_and_druggist_sundries",
                "dry_cleaners",
                "durable_goods",
                "duty_free_stores",
                "eating_places_restaurants",
                "educational_services",
                "electric_razor_stores",
                "electric_vehicle_charging",
                "electrical_parts_and_equipment",
                "electrical_services",
                "electronics_repair_shops",
                "electronics_stores",
                "elementary_secondary_schools",
                "emergency_services_gcas_visa_use_only",
                "employment_temp_agencies",
                "equipment_rental",
                "exterminating_services",
                "family_clothing_stores",
                "fast_food_restaurants",
                "financial_institutions",
                "fines_government_administrative_entities",
                "fireplace_fireplace_screens_and_accessories_stores",
                "floor_covering_stores",
                "florists",
                "florists_supplies_nursery_stock_and_flowers",
                "freezer_and_locker_meat_provisioners",
                "fuel_dealers_non_automotive",
                "funeral_services_crematories",
                "furniture_home_furnishings_and_equipment_stores_except_appliances",
                "furniture_repair_refinishing",
                "furriers_and_fur_shops",
                "general_services",
                "gift_card_novelty_and_souvenir_shops",
                "glass_paint_and_wallpaper_stores",
                "glassware_crystal_stores",
                "golf_courses_public",
                "government_licensed_horse_dog_racing_us_region_only",
                "government_licensed_online_casions_online_gambling_us_region_only",
                "government_owned_lotteries_non_us_region",
                "government_owned_lotteries_us_region_only",
                "government_services",
                "grocery_stores_supermarkets",
                "hardware_equipment_and_supplies",
                "hardware_stores",
                "health_and_beauty_spas",
                "hearing_aids_sales_and_supplies",
                "heating_plumbing_a_c",
                "hobby_toy_and_game_shops",
                "home_supply_warehouse_stores",
                "hospitals",
                "hotels_motels_and_resorts",
                "household_appliance_stores",
                "industrial_supplies",
                "information_retrieval_services",
                "insurance_default",
                "insurance_underwriting_premiums",
                "intra_company_purchases",
                "jewelry_stores_watches_clocks_and_silverware_stores",
                "landscaping_services",
                "laundries",
                "laundry_cleaning_services",
                "legal_services_attorneys",
                "luggage_and_leather_goods_stores",
                "lumber_building_materials_stores",
                "manual_cash_disburse",
                "marinas_service_and_supplies",
                "marketplaces",
                "masonry_stonework_and_plaster",
                "massage_parlors",
                "medical_and_dental_labs",
                "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                "medical_services",
                "membership_organizations",
                "mens_and_boys_clothing_and_accessories_stores",
                "mens_womens_clothing_stores",
                "metal_service_centers",
                "miscellaneous",
                "miscellaneous_apparel_and_accessory_shops",
                "miscellaneous_auto_dealers",
                "miscellaneous_business_services",
                "miscellaneous_food_stores",
                "miscellaneous_general_merchandise",
                "miscellaneous_general_services",
                "miscellaneous_home_furnishing_specialty_stores",
                "miscellaneous_publishing_and_printing",
                "miscellaneous_recreation_services",
                "miscellaneous_repair_shops",
                "miscellaneous_specialty_retail",
                "mobile_home_dealers",
                "motion_picture_theaters",
                "motor_freight_carriers_and_trucking",
                "motor_homes_dealers",
                "motor_vehicle_supplies_and_new_parts",
                "motorcycle_shops_and_dealers",
                "motorcycle_shops_dealers",
                "music_stores_musical_instruments_pianos_and_sheet_music",
                "news_dealers_and_newsstands",
                "non_fi_money_orders",
                "non_fi_stored_value_card_purchase_load",
                "nondurable_goods",
                "nurseries_lawn_and_garden_supply_stores",
                "nursing_personal_care",
                "office_and_commercial_furniture",
                "opticians_eyeglasses",
                "optometrists_ophthalmologist",
                "orthopedic_goods_prosthetic_devices",
                "osteopaths",
                "package_stores_beer_wine_and_liquor",
                "paints_varnishes_and_supplies",
                "parking_lots_garages",
                "passenger_railways",
                "pawn_shops",
                "pet_shops_pet_food_and_supplies",
                "petroleum_and_petroleum_products",
                "photo_developing",
                "photographic_photocopy_microfilm_equipment_and_supplies",
                "photographic_studios",
                "picture_video_production",
                "piece_goods_notions_and_other_dry_goods",
                "plumbing_heating_equipment_and_supplies",
                "political_organizations",
                "postal_services_government_only",
                "precious_stones_and_metals_watches_and_jewelry",
                "professional_services",
                "public_warehousing_and_storage",
                "quick_copy_repro_and_blueprint",
                "railroads",
                "real_estate_agents_and_managers_rentals",
                "record_stores",
                "recreational_vehicle_rentals",
                "religious_goods_stores",
                "religious_organizations",
                "roofing_siding_sheet_metal",
                "secretarial_support_services",
                "security_brokers_dealers",
                "service_stations",
                "sewing_needlework_fabric_and_piece_goods_stores",
                "shoe_repair_hat_cleaning",
                "shoe_stores",
                "small_appliance_repair",
                "snowmobile_dealers",
                "special_trade_services",
                "specialty_cleaning",
                "sporting_goods_stores",
                "sporting_recreation_camps",
                "sports_and_riding_apparel_stores",
                "sports_clubs_fields",
                "stamp_and_coin_stores",
                "stationary_office_supplies_printing_and_writing_paper",
                "stationery_stores_office_and_school_supply_stores",
                "swimming_pools_sales",
                "t_ui_travel_germany",
                "tailors_alterations",
                "tax_payments_government_agencies",
                "tax_preparation_services",
                "taxicabs_limousines",
                "telecommunication_equipment_and_telephone_sales",
                "telecommunication_services",
                "telegraph_services",
                "tent_and_awning_shops",
                "testing_laboratories",
                "theatrical_ticket_agencies",
                "timeshares",
                "tire_retreading_and_repair",
                "tolls_bridge_fees",
                "tourist_attractions_and_exhibits",
                "towing_services",
                "trailer_parks_campgrounds",
                "transportation_services",
                "travel_agencies_tour_operators",
                "truck_stop_iteration",
                "truck_utility_trailer_rentals",
                "typesetting_plate_making_and_related_services",
                "typewriter_stores",
                "u_s_federal_government_agencies_or_departments",
                "uniforms_commercial_clothing",
                "used_merchandise_and_secondhand_stores",
                "utilities",
                "variety_stores",
                "veterinary_services",
                "video_amusement_game_supplies",
                "video_game_arcades",
                "video_tape_rental_stores",
                "vocational_trade_schools",
                "watch_jewelry_repair",
                "welding_repair",
                "wholesale_clubs",
                "wig_and_toupee_stores",
                "wires_money_orders",
                "womens_accessory_and_specialty_shops",
                "womens_ready_to_wear_stores",
                "wrecking_and_salvage_yards",
              ]),
            )
            .optional(),
          blocked_merchant_countries: z.array(z.string().max(5000)).optional(),
          spending_limits: z
            .array(
              z.object({
                amount: z.coerce.number(),
                categories: z
                  .array(
                    z.enum([
                      "ac_refrigeration_repair",
                      "accounting_bookkeeping_services",
                      "advertising_services",
                      "agricultural_cooperative",
                      "airlines_air_carriers",
                      "airports_flying_fields",
                      "ambulance_services",
                      "amusement_parks_carnivals",
                      "antique_reproductions",
                      "antique_shops",
                      "aquariums",
                      "architectural_surveying_services",
                      "art_dealers_and_galleries",
                      "artists_supply_and_craft_shops",
                      "auto_and_home_supply_stores",
                      "auto_body_repair_shops",
                      "auto_paint_shops",
                      "auto_service_shops",
                      "automated_cash_disburse",
                      "automated_fuel_dispensers",
                      "automobile_associations",
                      "automotive_parts_and_accessories_stores",
                      "automotive_tire_stores",
                      "bail_and_bond_payments",
                      "bakeries",
                      "bands_orchestras",
                      "barber_and_beauty_shops",
                      "betting_casino_gambling",
                      "bicycle_shops",
                      "billiard_pool_establishments",
                      "boat_dealers",
                      "boat_rentals_and_leases",
                      "book_stores",
                      "books_periodicals_and_newspapers",
                      "bowling_alleys",
                      "bus_lines",
                      "business_secretarial_schools",
                      "buying_shopping_services",
                      "cable_satellite_and_other_pay_television_and_radio",
                      "camera_and_photographic_supply_stores",
                      "candy_nut_and_confectionery_stores",
                      "car_and_truck_dealers_new_used",
                      "car_and_truck_dealers_used_only",
                      "car_rental_agencies",
                      "car_washes",
                      "carpentry_services",
                      "carpet_upholstery_cleaning",
                      "caterers",
                      "charitable_and_social_service_organizations_fundraising",
                      "chemicals_and_allied_products",
                      "child_care_services",
                      "childrens_and_infants_wear_stores",
                      "chiropodists_podiatrists",
                      "chiropractors",
                      "cigar_stores_and_stands",
                      "civic_social_fraternal_associations",
                      "cleaning_and_maintenance",
                      "clothing_rental",
                      "colleges_universities",
                      "commercial_equipment",
                      "commercial_footwear",
                      "commercial_photography_art_and_graphics",
                      "commuter_transport_and_ferries",
                      "computer_network_services",
                      "computer_programming",
                      "computer_repair",
                      "computer_software_stores",
                      "computers_peripherals_and_software",
                      "concrete_work_services",
                      "construction_materials",
                      "consulting_public_relations",
                      "correspondence_schools",
                      "cosmetic_stores",
                      "counseling_services",
                      "country_clubs",
                      "courier_services",
                      "court_costs",
                      "credit_reporting_agencies",
                      "cruise_lines",
                      "dairy_products_stores",
                      "dance_hall_studios_schools",
                      "dating_escort_services",
                      "dentists_orthodontists",
                      "department_stores",
                      "detective_agencies",
                      "digital_goods_applications",
                      "digital_goods_games",
                      "digital_goods_large_volume",
                      "digital_goods_media",
                      "direct_marketing_catalog_merchant",
                      "direct_marketing_combination_catalog_and_retail_merchant",
                      "direct_marketing_inbound_telemarketing",
                      "direct_marketing_insurance_services",
                      "direct_marketing_other",
                      "direct_marketing_outbound_telemarketing",
                      "direct_marketing_subscription",
                      "direct_marketing_travel",
                      "discount_stores",
                      "doctors",
                      "door_to_door_sales",
                      "drapery_window_covering_and_upholstery_stores",
                      "drinking_places",
                      "drug_stores_and_pharmacies",
                      "drugs_drug_proprietaries_and_druggist_sundries",
                      "dry_cleaners",
                      "durable_goods",
                      "duty_free_stores",
                      "eating_places_restaurants",
                      "educational_services",
                      "electric_razor_stores",
                      "electric_vehicle_charging",
                      "electrical_parts_and_equipment",
                      "electrical_services",
                      "electronics_repair_shops",
                      "electronics_stores",
                      "elementary_secondary_schools",
                      "emergency_services_gcas_visa_use_only",
                      "employment_temp_agencies",
                      "equipment_rental",
                      "exterminating_services",
                      "family_clothing_stores",
                      "fast_food_restaurants",
                      "financial_institutions",
                      "fines_government_administrative_entities",
                      "fireplace_fireplace_screens_and_accessories_stores",
                      "floor_covering_stores",
                      "florists",
                      "florists_supplies_nursery_stock_and_flowers",
                      "freezer_and_locker_meat_provisioners",
                      "fuel_dealers_non_automotive",
                      "funeral_services_crematories",
                      "furniture_home_furnishings_and_equipment_stores_except_appliances",
                      "furniture_repair_refinishing",
                      "furriers_and_fur_shops",
                      "general_services",
                      "gift_card_novelty_and_souvenir_shops",
                      "glass_paint_and_wallpaper_stores",
                      "glassware_crystal_stores",
                      "golf_courses_public",
                      "government_licensed_horse_dog_racing_us_region_only",
                      "government_licensed_online_casions_online_gambling_us_region_only",
                      "government_owned_lotteries_non_us_region",
                      "government_owned_lotteries_us_region_only",
                      "government_services",
                      "grocery_stores_supermarkets",
                      "hardware_equipment_and_supplies",
                      "hardware_stores",
                      "health_and_beauty_spas",
                      "hearing_aids_sales_and_supplies",
                      "heating_plumbing_a_c",
                      "hobby_toy_and_game_shops",
                      "home_supply_warehouse_stores",
                      "hospitals",
                      "hotels_motels_and_resorts",
                      "household_appliance_stores",
                      "industrial_supplies",
                      "information_retrieval_services",
                      "insurance_default",
                      "insurance_underwriting_premiums",
                      "intra_company_purchases",
                      "jewelry_stores_watches_clocks_and_silverware_stores",
                      "landscaping_services",
                      "laundries",
                      "laundry_cleaning_services",
                      "legal_services_attorneys",
                      "luggage_and_leather_goods_stores",
                      "lumber_building_materials_stores",
                      "manual_cash_disburse",
                      "marinas_service_and_supplies",
                      "marketplaces",
                      "masonry_stonework_and_plaster",
                      "massage_parlors",
                      "medical_and_dental_labs",
                      "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
                      "medical_services",
                      "membership_organizations",
                      "mens_and_boys_clothing_and_accessories_stores",
                      "mens_womens_clothing_stores",
                      "metal_service_centers",
                      "miscellaneous",
                      "miscellaneous_apparel_and_accessory_shops",
                      "miscellaneous_auto_dealers",
                      "miscellaneous_business_services",
                      "miscellaneous_food_stores",
                      "miscellaneous_general_merchandise",
                      "miscellaneous_general_services",
                      "miscellaneous_home_furnishing_specialty_stores",
                      "miscellaneous_publishing_and_printing",
                      "miscellaneous_recreation_services",
                      "miscellaneous_repair_shops",
                      "miscellaneous_specialty_retail",
                      "mobile_home_dealers",
                      "motion_picture_theaters",
                      "motor_freight_carriers_and_trucking",
                      "motor_homes_dealers",
                      "motor_vehicle_supplies_and_new_parts",
                      "motorcycle_shops_and_dealers",
                      "motorcycle_shops_dealers",
                      "music_stores_musical_instruments_pianos_and_sheet_music",
                      "news_dealers_and_newsstands",
                      "non_fi_money_orders",
                      "non_fi_stored_value_card_purchase_load",
                      "nondurable_goods",
                      "nurseries_lawn_and_garden_supply_stores",
                      "nursing_personal_care",
                      "office_and_commercial_furniture",
                      "opticians_eyeglasses",
                      "optometrists_ophthalmologist",
                      "orthopedic_goods_prosthetic_devices",
                      "osteopaths",
                      "package_stores_beer_wine_and_liquor",
                      "paints_varnishes_and_supplies",
                      "parking_lots_garages",
                      "passenger_railways",
                      "pawn_shops",
                      "pet_shops_pet_food_and_supplies",
                      "petroleum_and_petroleum_products",
                      "photo_developing",
                      "photographic_photocopy_microfilm_equipment_and_supplies",
                      "photographic_studios",
                      "picture_video_production",
                      "piece_goods_notions_and_other_dry_goods",
                      "plumbing_heating_equipment_and_supplies",
                      "political_organizations",
                      "postal_services_government_only",
                      "precious_stones_and_metals_watches_and_jewelry",
                      "professional_services",
                      "public_warehousing_and_storage",
                      "quick_copy_repro_and_blueprint",
                      "railroads",
                      "real_estate_agents_and_managers_rentals",
                      "record_stores",
                      "recreational_vehicle_rentals",
                      "religious_goods_stores",
                      "religious_organizations",
                      "roofing_siding_sheet_metal",
                      "secretarial_support_services",
                      "security_brokers_dealers",
                      "service_stations",
                      "sewing_needlework_fabric_and_piece_goods_stores",
                      "shoe_repair_hat_cleaning",
                      "shoe_stores",
                      "small_appliance_repair",
                      "snowmobile_dealers",
                      "special_trade_services",
                      "specialty_cleaning",
                      "sporting_goods_stores",
                      "sporting_recreation_camps",
                      "sports_and_riding_apparel_stores",
                      "sports_clubs_fields",
                      "stamp_and_coin_stores",
                      "stationary_office_supplies_printing_and_writing_paper",
                      "stationery_stores_office_and_school_supply_stores",
                      "swimming_pools_sales",
                      "t_ui_travel_germany",
                      "tailors_alterations",
                      "tax_payments_government_agencies",
                      "tax_preparation_services",
                      "taxicabs_limousines",
                      "telecommunication_equipment_and_telephone_sales",
                      "telecommunication_services",
                      "telegraph_services",
                      "tent_and_awning_shops",
                      "testing_laboratories",
                      "theatrical_ticket_agencies",
                      "timeshares",
                      "tire_retreading_and_repair",
                      "tolls_bridge_fees",
                      "tourist_attractions_and_exhibits",
                      "towing_services",
                      "trailer_parks_campgrounds",
                      "transportation_services",
                      "travel_agencies_tour_operators",
                      "truck_stop_iteration",
                      "truck_utility_trailer_rentals",
                      "typesetting_plate_making_and_related_services",
                      "typewriter_stores",
                      "u_s_federal_government_agencies_or_departments",
                      "uniforms_commercial_clothing",
                      "used_merchandise_and_secondhand_stores",
                      "utilities",
                      "variety_stores",
                      "veterinary_services",
                      "video_amusement_game_supplies",
                      "video_game_arcades",
                      "video_tape_rental_stores",
                      "vocational_trade_schools",
                      "watch_jewelry_repair",
                      "welding_repair",
                      "wholesale_clubs",
                      "wig_and_toupee_stores",
                      "wires_money_orders",
                      "womens_accessory_and_specialty_shops",
                      "womens_ready_to_wear_stores",
                      "wrecking_and_salvage_yards",
                    ]),
                  )
                  .optional(),
                interval: z.enum([
                  "all_time",
                  "daily",
                  "monthly",
                  "per_authorization",
                  "weekly",
                  "yearly",
                ]),
              }),
            )
            .optional(),
        })
        .optional(),
      status: z.enum(["active", "canceled", "inactive"]).optional(),
    })
    .optional()

  router.post(
    "postIssuingCardsCard",
    "/v1/issuing/cards/:card",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingCardsCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingCardsCardBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingCardsCard(input, postIssuingCardsCard.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingCardsCard.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingDisputesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["expired", "lost", "submitted", "unsubmitted", "won"])
      .optional(),
    transaction: z.string().max(5000).optional(),
  })

  const getIssuingDisputesBodySchema = z.object({}).optional()

  router.get(
    "getIssuingDisputes",
    "/v1/issuing/disputes",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingDisputesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingDisputesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingDisputes(input, getIssuingDisputes.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingDisputes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingDisputesBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      evidence: z
        .object({
          canceled: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                canceled_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                cancellation_policy_provided: z
                  .union([PermissiveBoolean, z.enum([""])])
                  .optional(),
                cancellation_reason: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                expected_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_type: z.enum(["", "merchandise", "service"]).optional(),
                return_status: z
                  .enum(["", "merchant_rejected", "successful"])
                  .optional(),
                returned_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          duplicate: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                card_statement: z.union([z.string(), z.enum([""])]).optional(),
                cash_receipt: z.union([z.string(), z.enum([""])]).optional(),
                check_image: z.union([z.string(), z.enum([""])]).optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                original_transaction: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          fraudulent: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          merchandise_not_as_described: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                received_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                return_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                return_status: z
                  .enum(["", "merchant_rejected", "successful"])
                  .optional(),
                returned_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          no_valid_authorization: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          not_received: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                expected_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_type: z.enum(["", "merchandise", "service"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          other: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_type: z.enum(["", "merchandise", "service"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          reason: z
            .enum([
              "canceled",
              "duplicate",
              "fraudulent",
              "merchandise_not_as_described",
              "no_valid_authorization",
              "not_received",
              "other",
              "service_not_as_described",
            ])
            .optional(),
          service_not_as_described: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                canceled_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                cancellation_reason: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                received_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      transaction: z.string().max(5000).optional(),
      treasury: z.object({ received_debit: z.string().max(5000) }).optional(),
    })
    .optional()

  router.post(
    "postIssuingDisputes",
    "/v1/issuing/disputes",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIssuingDisputesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingDisputes(input, postIssuingDisputes.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingDisputes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const getIssuingDisputesDisputeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingDisputesDisputeBodySchema = z.object({}).optional()

  router.get(
    "getIssuingDisputesDispute",
    "/v1/issuing/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingDisputesDisputeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingDisputesDispute(
          input,
          getIssuingDisputesDispute.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingDisputesDispute.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingDisputesDisputeParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const postIssuingDisputesDisputeBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      evidence: z
        .object({
          canceled: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                canceled_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                cancellation_policy_provided: z
                  .union([PermissiveBoolean, z.enum([""])])
                  .optional(),
                cancellation_reason: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                expected_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_type: z.enum(["", "merchandise", "service"]).optional(),
                return_status: z
                  .enum(["", "merchant_rejected", "successful"])
                  .optional(),
                returned_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          duplicate: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                card_statement: z.union([z.string(), z.enum([""])]).optional(),
                cash_receipt: z.union([z.string(), z.enum([""])]).optional(),
                check_image: z.union([z.string(), z.enum([""])]).optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                original_transaction: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          fraudulent: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          merchandise_not_as_described: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                received_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                return_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                return_status: z
                  .enum(["", "merchant_rejected", "successful"])
                  .optional(),
                returned_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          no_valid_authorization: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          not_received: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                expected_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_type: z.enum(["", "merchandise", "service"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          other: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                product_type: z.enum(["", "merchandise", "service"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          reason: z
            .enum([
              "canceled",
              "duplicate",
              "fraudulent",
              "merchandise_not_as_described",
              "no_valid_authorization",
              "not_received",
              "other",
              "service_not_as_described",
            ])
            .optional(),
          service_not_as_described: z
            .union([
              z.object({
                additional_documentation: z
                  .union([z.string(), z.enum([""])])
                  .optional(),
                canceled_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                cancellation_reason: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                explanation: z
                  .union([z.string().max(2500), z.enum([""])])
                  .optional(),
                received_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postIssuingDisputesDispute",
    "/v1/issuing/disputes/:dispute",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingDisputesDisputeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingDisputesDisputeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingDisputesDispute(
          input,
          postIssuingDisputesDispute.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingDisputesDispute.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingDisputesDisputeSubmitParamSchema = z.object({
    dispute: z.string().max(5000),
  })

  const postIssuingDisputesDisputeSubmitBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postIssuingDisputesDisputeSubmit",
    "/v1/issuing/disputes/:dispute/submit",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingDisputesDisputeSubmitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingDisputesDisputeSubmitBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingDisputesDisputeSubmit(
          input,
          postIssuingDisputesDisputeSubmit.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingDisputesDisputeSubmit.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingPersonalizationDesignsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_keys: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(200)),
      )
      .optional(),
    preferences: z
      .object({
        is_default: PermissiveBoolean.optional(),
        is_platform_default: PermissiveBoolean.optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive", "rejected", "review"]).optional(),
  })

  const getIssuingPersonalizationDesignsBodySchema = z.object({}).optional()

  router.get(
    "getIssuingPersonalizationDesigns",
    "/v1/issuing/personalization_designs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingPersonalizationDesignsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPersonalizationDesignsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingPersonalizationDesigns(
          input,
          getIssuingPersonalizationDesigns.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingPersonalizationDesigns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingPersonalizationDesignsBodySchema = z.object({
    card_logo: z.string().optional(),
    carrier_text: z
      .object({
        footer_body: z.union([z.string().max(200), z.enum([""])]).optional(),
        footer_title: z.union([z.string().max(30), z.enum([""])]).optional(),
        header_body: z.union([z.string().max(200), z.enum([""])]).optional(),
        header_title: z.union([z.string().max(30), z.enum([""])]).optional(),
      })
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    lookup_key: z.string().max(200).optional(),
    metadata: z.record(z.string()).optional(),
    name: z.string().max(200).optional(),
    physical_bundle: z.string().max(5000),
    preferences: z.object({ is_default: PermissiveBoolean }).optional(),
    transfer_lookup_key: PermissiveBoolean.optional(),
  })

  router.post(
    "postIssuingPersonalizationDesigns",
    "/v1/issuing/personalization_designs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postIssuingPersonalizationDesignsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingPersonalizationDesigns(
          input,
          postIssuingPersonalizationDesigns.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingPersonalizationDesigns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingPersonalizationDesignsPersonalizationDesignParamSchema =
    z.object({ personalization_design: z.string().max(5000) })

  const getIssuingPersonalizationDesignsPersonalizationDesignQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getIssuingPersonalizationDesignsPersonalizationDesignBodySchema = z
    .object({})
    .optional()

  router.get(
    "getIssuingPersonalizationDesignsPersonalizationDesign",
    "/v1/issuing/personalization_designs/:personalization_design",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingPersonalizationDesignsPersonalizationDesignQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingPersonalizationDesignsPersonalizationDesign(
          input,
          getIssuingPersonalizationDesignsPersonalizationDesign.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getIssuingPersonalizationDesignsPersonalizationDesign.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postIssuingPersonalizationDesignsPersonalizationDesignParamSchema =
    z.object({ personalization_design: z.string().max(5000) })

  const postIssuingPersonalizationDesignsPersonalizationDesignBodySchema = z
    .object({
      card_logo: z.union([z.string(), z.enum([""])]).optional(),
      carrier_text: z
        .union([
          z.object({
            footer_body: z
              .union([z.string().max(200), z.enum([""])])
              .optional(),
            footer_title: z
              .union([z.string().max(30), z.enum([""])])
              .optional(),
            header_body: z
              .union([z.string().max(200), z.enum([""])])
              .optional(),
            header_title: z
              .union([z.string().max(30), z.enum([""])])
              .optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      lookup_key: z.union([z.string().max(200), z.enum([""])]).optional(),
      metadata: z.record(z.string()).optional(),
      name: z.union([z.string().max(200), z.enum([""])]).optional(),
      physical_bundle: z.string().max(5000).optional(),
      preferences: z.object({ is_default: PermissiveBoolean }).optional(),
      transfer_lookup_key: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postIssuingPersonalizationDesignsPersonalizationDesign",
    "/v1/issuing/personalization_designs/:personalization_design",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingPersonalizationDesignsPersonalizationDesignParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingPersonalizationDesignsPersonalizationDesignBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingPersonalizationDesignsPersonalizationDesign(
          input,
          postIssuingPersonalizationDesignsPersonalizationDesign.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postIssuingPersonalizationDesignsPersonalizationDesign.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getIssuingPhysicalBundlesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "inactive", "review"]).optional(),
    type: z.enum(["custom", "standard"]).optional(),
  })

  const getIssuingPhysicalBundlesBodySchema = z.object({}).optional()

  router.get(
    "getIssuingPhysicalBundles",
    "/v1/issuing/physical_bundles",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingPhysicalBundlesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPhysicalBundlesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingPhysicalBundles(
          input,
          getIssuingPhysicalBundles.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingPhysicalBundles.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingPhysicalBundlesPhysicalBundleParamSchema = z.object({
    physical_bundle: z.string().max(5000),
  })

  const getIssuingPhysicalBundlesPhysicalBundleQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingPhysicalBundlesPhysicalBundleBodySchema = z
    .object({})
    .optional()

  router.get(
    "getIssuingPhysicalBundlesPhysicalBundle",
    "/v1/issuing/physical_bundles/:physical_bundle",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingPhysicalBundlesPhysicalBundleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingPhysicalBundlesPhysicalBundleQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingPhysicalBundlesPhysicalBundleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingPhysicalBundlesPhysicalBundle(
          input,
          getIssuingPhysicalBundlesPhysicalBundle.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingPhysicalBundlesPhysicalBundle.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingSettlementsSettlementParamSchema = z.object({
    settlement: z.string().max(5000),
  })

  const getIssuingSettlementsSettlementQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingSettlementsSettlementBodySchema = z.object({}).optional()

  router.get(
    "getIssuingSettlementsSettlement",
    "/v1/issuing/settlements/:settlement",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingSettlementsSettlementParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingSettlementsSettlementQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingSettlementsSettlementBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingSettlementsSettlement(
          input,
          getIssuingSettlementsSettlement.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingSettlementsSettlement.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingSettlementsSettlementParamSchema = z.object({
    settlement: z.string().max(5000),
  })

  const postIssuingSettlementsSettlementBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postIssuingSettlementsSettlement",
    "/v1/issuing/settlements/:settlement",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingSettlementsSettlementParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingSettlementsSettlementBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingSettlementsSettlement(
          input,
          postIssuingSettlementsSettlement.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingSettlementsSettlement.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingTokensQuerySchema = z.object({
    card: z.string().max(5000),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "deleted", "requested", "suspended"]).optional(),
  })

  const getIssuingTokensBodySchema = z.object({}).optional()

  router.get("getIssuingTokens", "/v1/issuing/tokens", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getIssuingTokensQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getIssuingTokensBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getIssuingTokens(input, getIssuingTokens.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getIssuingTokens.validator(status, body)
    ctx.status = status
    return next()
  })

  const getIssuingTokensTokenParamSchema = z.object({
    token: z.string().max(5000),
  })

  const getIssuingTokensTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingTokensTokenBodySchema = z.object({}).optional()

  router.get(
    "getIssuingTokensToken",
    "/v1/issuing/tokens/:token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingTokensTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingTokensTokenQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingTokensTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingTokensToken(input, getIssuingTokensToken.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingTokensToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingTokensTokenParamSchema = z.object({
    token: z.string().max(5000),
  })

  const postIssuingTokensTokenBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    status: z.enum(["active", "deleted", "suspended"]),
  })

  router.post(
    "postIssuingTokensToken",
    "/v1/issuing/tokens/:token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingTokensTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingTokensTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingTokensToken(input, postIssuingTokensToken.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingTokensToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingTransactionsQuerySchema = z.object({
    card: z.string().max(5000).optional(),
    cardholder: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["capture", "refund"]).optional(),
  })

  const getIssuingTransactionsBodySchema = z.object({}).optional()

  router.get(
    "getIssuingTransactions",
    "/v1/issuing/transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getIssuingTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingTransactions(input, getIssuingTransactions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingTransactions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getIssuingTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getIssuingTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getIssuingTransactionsTransactionBodySchema = z.object({}).optional()

  router.get(
    "getIssuingTransactionsTransaction",
    "/v1/issuing/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getIssuingTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getIssuingTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getIssuingTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getIssuingTransactionsTransaction(
          input,
          getIssuingTransactionsTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getIssuingTransactionsTransaction.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postIssuingTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const postIssuingTransactionsTransactionBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postIssuingTransactionsTransaction",
    "/v1/issuing/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postIssuingTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postIssuingTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postIssuingTransactionsTransaction(
          input,
          postIssuingTransactionsTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postIssuingTransactionsTransaction.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postLinkAccountSessionsBodySchema = z.object({
    account_holder: z.object({
      account: z.string().max(5000).optional(),
      customer: z.string().max(5000).optional(),
      type: z.enum(["account", "customer"]),
    }),
    expand: z.array(z.string().max(5000)).optional(),
    filters: z
      .object({
        account_subcategories: z
          .array(
            z.enum([
              "checking",
              "credit_card",
              "line_of_credit",
              "mortgage",
              "savings",
            ]),
          )
          .optional(),
        countries: z.array(z.string().max(5000)).optional(),
      })
      .optional(),
    permissions: z.array(
      z.enum(["balances", "ownership", "payment_method", "transactions"]),
    ),
    prefetch: z
      .array(z.enum(["balances", "ownership", "transactions"]))
      .optional(),
    return_url: z.string().max(5000).optional(),
  })

  router.post(
    "postLinkAccountSessions",
    "/v1/link_account_sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postLinkAccountSessionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postLinkAccountSessions(input, postLinkAccountSessions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postLinkAccountSessions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getLinkAccountSessionsSessionParamSchema = z.object({
    session: z.string().max(5000),
  })

  const getLinkAccountSessionsSessionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getLinkAccountSessionsSessionBodySchema = z.object({}).optional()

  router.get(
    "getLinkAccountSessionsSession",
    "/v1/link_account_sessions/:session",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getLinkAccountSessionsSessionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getLinkAccountSessionsSessionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getLinkAccountSessionsSessionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getLinkAccountSessionsSession(
          input,
          getLinkAccountSessionsSession.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getLinkAccountSessionsSession.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getLinkedAccountsQuerySchema = z.object({
    account_holder: z
      .object({
        account: z.string().max(5000).optional(),
        customer: z.string().max(5000).optional(),
      })
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    session: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getLinkedAccountsBodySchema = z.object({}).optional()

  router.get("getLinkedAccounts", "/v1/linked_accounts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getLinkedAccountsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getLinkedAccountsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getLinkedAccounts(input, getLinkedAccounts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getLinkedAccounts.validator(status, body)
    ctx.status = status
    return next()
  })

  const getLinkedAccountsAccountParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getLinkedAccountsAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getLinkedAccountsAccountBodySchema = z.object({}).optional()

  router.get(
    "getLinkedAccountsAccount",
    "/v1/linked_accounts/:account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getLinkedAccountsAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getLinkedAccountsAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getLinkedAccountsAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getLinkedAccountsAccount(
          input,
          getLinkedAccountsAccount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getLinkedAccountsAccount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postLinkedAccountsAccountDisconnectParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postLinkedAccountsAccountDisconnectBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postLinkedAccountsAccountDisconnect",
    "/v1/linked_accounts/:account/disconnect",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postLinkedAccountsAccountDisconnectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postLinkedAccountsAccountDisconnectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postLinkedAccountsAccountDisconnect(
          input,
          postLinkedAccountsAccountDisconnect.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postLinkedAccountsAccountDisconnect.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getLinkedAccountsAccountOwnersParamSchema = z.object({
    account: z.string().max(5000),
  })

  const getLinkedAccountsAccountOwnersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    ownership: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  const getLinkedAccountsAccountOwnersBodySchema = z.object({}).optional()

  router.get(
    "getLinkedAccountsAccountOwners",
    "/v1/linked_accounts/:account/owners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getLinkedAccountsAccountOwnersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getLinkedAccountsAccountOwnersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getLinkedAccountsAccountOwnersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getLinkedAccountsAccountOwners(
          input,
          getLinkedAccountsAccountOwners.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getLinkedAccountsAccountOwners.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postLinkedAccountsAccountRefreshParamSchema = z.object({
    account: z.string().max(5000),
  })

  const postLinkedAccountsAccountRefreshBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    features: z.array(z.enum(["balance", "ownership", "transactions"])),
  })

  router.post(
    "postLinkedAccountsAccountRefresh",
    "/v1/linked_accounts/:account/refresh",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postLinkedAccountsAccountRefreshParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postLinkedAccountsAccountRefreshBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postLinkedAccountsAccountRefresh(
          input,
          postLinkedAccountsAccountRefresh.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postLinkedAccountsAccountRefresh.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getMandatesMandateParamSchema = z.object({ mandate: z.string() })

  const getMandatesMandateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getMandatesMandateBodySchema = z.object({}).optional()

  router.get(
    "getMandatesMandate",
    "/v1/mandates/:mandate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getMandatesMandateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getMandatesMandateQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getMandatesMandateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getMandatesMandate(input, getMandatesMandate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getMandatesMandate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentIntentsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getPaymentIntentsBodySchema = z.object({}).optional()

  router.get("getPaymentIntents", "/v1/payment_intents", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPaymentIntentsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPaymentIntentsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPaymentIntents(input, getPaymentIntents.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPaymentIntents.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPaymentIntentsBodySchema = z.object({
    amount: z.coerce.number(),
    application_fee_amount: z.coerce.number().optional(),
    automatic_payment_methods: z
      .object({
        allow_redirects: z.enum(["always", "never"]).optional(),
        enabled: PermissiveBoolean,
      })
      .optional(),
    capture_method: z
      .enum(["automatic", "automatic_async", "manual"])
      .optional(),
    confirm: PermissiveBoolean.optional(),
    confirmation_method: z.enum(["automatic", "manual"]).optional(),
    confirmation_token: z.string().max(5000).optional(),
    currency: z.string(),
    customer: z.string().max(5000).optional(),
    description: z.string().max(1000).optional(),
    error_on_requires_action: PermissiveBoolean.optional(),
    expand: z.array(z.string().max(5000)).optional(),
    mandate: z.string().max(5000).optional(),
    mandate_data: z
      .union([
        z.object({
          customer_acceptance: z.object({
            accepted_at: z.coerce.number().optional(),
            offline: z.object({}).optional(),
            online: z
              .object({
                ip_address: z.string(),
                user_agent: z.string().max(5000),
              })
              .optional(),
            type: z.enum(["offline", "online"]),
          }),
        }),
        z.enum([""]),
      ])
      .optional(),
    metadata: z.record(z.string()).optional(),
    off_session: z
      .union([PermissiveBoolean, z.enum(["one_off", "recurring"])])
      .optional(),
    on_behalf_of: z.string().optional(),
    payment_method: z.string().max(5000).optional(),
    payment_method_configuration: z.string().max(100).optional(),
    payment_method_data: z
      .object({
        acss_debit: z
          .object({
            account_number: z.string().max(5000),
            institution_number: z.string().max(5000),
            transit_number: z.string().max(5000),
          })
          .optional(),
        affirm: z.object({}).optional(),
        afterpay_clearpay: z.object({}).optional(),
        alipay: z.object({}).optional(),
        allow_redisplay: z
          .enum(["always", "limited", "unspecified"])
          .optional(),
        alma: z.object({}).optional(),
        amazon_pay: z.object({}).optional(),
        au_becs_debit: z
          .object({
            account_number: z.string().max(5000),
            bsb_number: z.string().max(5000),
          })
          .optional(),
        bacs_debit: z
          .object({
            account_number: z.string().max(5000).optional(),
            sort_code: z.string().max(5000).optional(),
          })
          .optional(),
        bancontact: z.object({}).optional(),
        billie: z.object({}).optional(),
        billing_details: z
          .object({
            address: z
              .union([
                z.object({
                  city: z.string().max(5000).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(5000).optional(),
                  line2: z.string().max(5000).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
            email: z.union([z.string(), z.enum([""])]).optional(),
            name: z.union([z.string().max(5000), z.enum([""])]).optional(),
            phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
          })
          .optional(),
        blik: z.object({}).optional(),
        boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
        cashapp: z.object({}).optional(),
        customer_balance: z.object({}).optional(),
        eps: z
          .object({
            bank: z
              .enum([
                "arzte_und_apotheker_bank",
                "austrian_anadi_bank_ag",
                "bank_austria",
                "bankhaus_carl_spangler",
                "bankhaus_schelhammer_und_schattera_ag",
                "bawag_psk_ag",
                "bks_bank_ag",
                "brull_kallmus_bank_ag",
                "btv_vier_lander_bank",
                "capital_bank_grawe_gruppe_ag",
                "deutsche_bank_ag",
                "dolomitenbank",
                "easybank_ag",
                "erste_bank_und_sparkassen",
                "hypo_alpeadriabank_international_ag",
                "hypo_bank_burgenland_aktiengesellschaft",
                "hypo_noe_lb_fur_niederosterreich_u_wien",
                "hypo_oberosterreich_salzburg_steiermark",
                "hypo_tirol_bank_ag",
                "hypo_vorarlberg_bank_ag",
                "marchfelder_bank",
                "oberbank_ag",
                "raiffeisen_bankengruppe_osterreich",
                "schoellerbank_ag",
                "sparda_bank_wien",
                "volksbank_gruppe",
                "volkskreditbank_ag",
                "vr_bank_braunau",
              ])
              .optional(),
          })
          .optional(),
        fpx: z
          .object({
            bank: z.enum([
              "affin_bank",
              "agrobank",
              "alliance_bank",
              "ambank",
              "bank_islam",
              "bank_muamalat",
              "bank_of_china",
              "bank_rakyat",
              "bsn",
              "cimb",
              "deutsche_bank",
              "hong_leong_bank",
              "hsbc",
              "kfh",
              "maybank2e",
              "maybank2u",
              "ocbc",
              "pb_enterprise",
              "public_bank",
              "rhb",
              "standard_chartered",
              "uob",
            ]),
          })
          .optional(),
        giropay: z.object({}).optional(),
        grabpay: z.object({}).optional(),
        ideal: z
          .object({
            bank: z
              .enum([
                "abn_amro",
                "asn_bank",
                "bunq",
                "handelsbanken",
                "ing",
                "knab",
                "moneyou",
                "n26",
                "nn",
                "rabobank",
                "regiobank",
                "revolut",
                "sns_bank",
                "triodos_bank",
                "van_lanschot",
                "yoursafe",
              ])
              .optional(),
          })
          .optional(),
        interac_present: z.object({}).optional(),
        kakao_pay: z.object({}).optional(),
        klarna: z
          .object({
            dob: z
              .object({
                day: z.coerce.number(),
                month: z.coerce.number(),
                year: z.coerce.number(),
              })
              .optional(),
          })
          .optional(),
        konbini: z.object({}).optional(),
        kr_card: z.object({}).optional(),
        link: z.object({}).optional(),
        metadata: z.record(z.string()).optional(),
        mobilepay: z.object({}).optional(),
        multibanco: z.object({}).optional(),
        naver_pay: z
          .object({ funding: z.enum(["card", "points"]).optional() })
          .optional(),
        nz_bank_account: z
          .object({
            account_holder_name: z.string().max(5000).optional(),
            account_number: z.string().max(5000),
            bank_code: z.string().max(5000),
            branch_code: z.string().max(5000),
            reference: z.string().max(128).optional(),
            suffix: z.string().max(5000),
          })
          .optional(),
        oxxo: z.object({}).optional(),
        p24: z
          .object({
            bank: z
              .enum([
                "alior_bank",
                "bank_millennium",
                "bank_nowy_bfg_sa",
                "bank_pekao_sa",
                "banki_spbdzielcze",
                "blik",
                "bnp_paribas",
                "boz",
                "citi_handlowy",
                "credit_agricole",
                "envelobank",
                "etransfer_pocztowy24",
                "getin_bank",
                "ideabank",
                "ing",
                "inteligo",
                "mbank_mtransfer",
                "nest_przelew",
                "noble_pay",
                "pbac_z_ipko",
                "plus_bank",
                "santander_przelew24",
                "tmobile_usbugi_bankowe",
                "toyota_bank",
                "velobank",
                "volkswagen_bank",
              ])
              .optional(),
          })
          .optional(),
        pay_by_bank: z.object({}).optional(),
        payco: z.object({}).optional(),
        paynow: z.object({}).optional(),
        paypal: z.object({}).optional(),
        pix: z.object({}).optional(),
        promptpay: z.object({}).optional(),
        radar_options: z
          .object({ session: z.string().max(5000).optional() })
          .optional(),
        revolut_pay: z.object({}).optional(),
        samsung_pay: z.object({}).optional(),
        satispay: z.object({}).optional(),
        sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
        sofort: z
          .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
          .optional(),
        swish: z.object({}).optional(),
        twint: z.object({}).optional(),
        type: z.enum([
          "acss_debit",
          "affirm",
          "afterpay_clearpay",
          "alipay",
          "alma",
          "amazon_pay",
          "au_becs_debit",
          "bacs_debit",
          "bancontact",
          "billie",
          "blik",
          "boleto",
          "cashapp",
          "customer_balance",
          "eps",
          "fpx",
          "giropay",
          "grabpay",
          "ideal",
          "kakao_pay",
          "klarna",
          "konbini",
          "kr_card",
          "link",
          "mobilepay",
          "multibanco",
          "naver_pay",
          "nz_bank_account",
          "oxxo",
          "p24",
          "pay_by_bank",
          "payco",
          "paynow",
          "paypal",
          "pix",
          "promptpay",
          "revolut_pay",
          "samsung_pay",
          "satispay",
          "sepa_debit",
          "sofort",
          "swish",
          "twint",
          "us_bank_account",
          "wechat_pay",
          "zip",
        ]),
        us_bank_account: z
          .object({
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000).optional(),
            account_type: z.enum(["checking", "savings"]).optional(),
            financial_connections_account: z.string().max(5000).optional(),
            routing_number: z.string().max(5000).optional(),
          })
          .optional(),
        wechat_pay: z.object({}).optional(),
        zip: z.object({}).optional(),
      })
      .optional(),
    payment_method_options: z
      .object({
        acss_debit: z
          .union([
            z.object({
              mandate_options: z
                .object({
                  custom_mandate_url: z
                    .union([z.string(), z.enum([""])])
                    .optional(),
                  interval_description: z.string().max(500).optional(),
                  payment_schedule: z
                    .enum(["combined", "interval", "sporadic"])
                    .optional(),
                  transaction_type: z.enum(["business", "personal"]).optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        affirm: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              preferred_locale: z.string().max(30).optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        afterpay_clearpay: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              reference: z.string().max(128).optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        alipay: z
          .union([
            z.object({
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        alma: z
          .union([
            z.object({ capture_method: z.enum(["", "manual"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        amazon_pay: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        au_becs_debit: z
          .union([
            z.object({
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        bacs_debit: z
          .union([
            z.object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        bancontact: z
          .union([
            z.object({
              preferred_language: z.enum(["de", "en", "fr", "nl"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        blik: z
          .union([
            z.object({
              code: z.string().max(5000).optional(),
              setup_future_usage: z.enum(["", "none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        boleto: z
          .union([
            z.object({
              expires_after_days: z.coerce.number().optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        card: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              cvc_token: z.string().max(5000).optional(),
              installments: z
                .object({
                  enabled: PermissiveBoolean.optional(),
                  plan: z
                    .union([
                      z.object({
                        count: z.coerce.number().optional(),
                        interval: z.enum(["month"]).optional(),
                        type: z.enum(["fixed_count"]),
                      }),
                      z.enum([""]),
                    ])
                    .optional(),
                })
                .optional(),
              mandate_options: z
                .object({
                  amount: z.coerce.number(),
                  amount_type: z.enum(["fixed", "maximum"]),
                  description: z.string().max(200).optional(),
                  end_date: z.coerce.number().optional(),
                  interval: z.enum([
                    "day",
                    "month",
                    "sporadic",
                    "week",
                    "year",
                  ]),
                  interval_count: z.coerce.number().optional(),
                  reference: z.string().max(80),
                  start_date: z.coerce.number(),
                  supported_types: z.array(z.enum(["india"])).optional(),
                })
                .optional(),
              network: z
                .enum([
                  "amex",
                  "cartes_bancaires",
                  "diners",
                  "discover",
                  "eftpos_au",
                  "girocard",
                  "interac",
                  "jcb",
                  "link",
                  "mastercard",
                  "unionpay",
                  "unknown",
                  "visa",
                ])
                .optional(),
              request_extended_authorization: z
                .enum(["if_available", "never"])
                .optional(),
              request_incremental_authorization: z
                .enum(["if_available", "never"])
                .optional(),
              request_multicapture: z
                .enum(["if_available", "never"])
                .optional(),
              request_overcapture: z.enum(["if_available", "never"]).optional(),
              request_three_d_secure: z
                .enum(["any", "automatic", "challenge"])
                .optional(),
              require_cvc_recollection: PermissiveBoolean.optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
              statement_descriptor_suffix_kana: z
                .union([z.string().max(22), z.enum([""])])
                .optional(),
              statement_descriptor_suffix_kanji: z
                .union([z.string().max(17), z.enum([""])])
                .optional(),
              three_d_secure: z
                .object({
                  ares_trans_status: z
                    .enum(["A", "C", "I", "N", "R", "U", "Y"])
                    .optional(),
                  cryptogram: z.string().max(5000),
                  electronic_commerce_indicator: z
                    .enum(["01", "02", "05", "06", "07"])
                    .optional(),
                  exemption_indicator: z.enum(["low_risk", "none"]).optional(),
                  network_options: z
                    .object({
                      cartes_bancaires: z
                        .object({
                          cb_avalgo: z.enum(["0", "1", "2", "3", "4", "A"]),
                          cb_exemption: z.string().max(4).optional(),
                          cb_score: z.coerce.number().optional(),
                        })
                        .optional(),
                    })
                    .optional(),
                  requestor_challenge_indicator: z.string().max(2).optional(),
                  transaction_id: z.string().max(5000),
                  version: z.enum(["1.0.2", "2.1.0", "2.2.0"]),
                })
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        card_present: z
          .union([
            z.object({
              request_extended_authorization: PermissiveBoolean.optional(),
              request_incremental_authorization_support:
                PermissiveBoolean.optional(),
              routing: z
                .object({
                  requested_priority: z
                    .enum(["domestic", "international"])
                    .optional(),
                })
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        cashapp: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        customer_balance: z
          .union([
            z.object({
              bank_transfer: z
                .object({
                  eu_bank_transfer: z
                    .object({ country: z.string().max(5000) })
                    .optional(),
                  requested_address_types: z
                    .array(
                      z.enum([
                        "aba",
                        "iban",
                        "sepa",
                        "sort_code",
                        "spei",
                        "swift",
                        "zengin",
                      ]),
                    )
                    .optional(),
                  type: z.enum([
                    "eu_bank_transfer",
                    "gb_bank_transfer",
                    "jp_bank_transfer",
                    "mx_bank_transfer",
                    "us_bank_transfer",
                  ]),
                })
                .optional(),
              funding_type: z.enum(["bank_transfer"]).optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        eps: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        fpx: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        giropay: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        grabpay: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        ideal: z
          .union([
            z.object({
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        interac_present: z.union([z.object({}), z.enum([""])]).optional(),
        kakao_pay: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        klarna: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              preferred_locale: z
                .enum([
                  "cs-CZ",
                  "da-DK",
                  "de-AT",
                  "de-CH",
                  "de-DE",
                  "el-GR",
                  "en-AT",
                  "en-AU",
                  "en-BE",
                  "en-CA",
                  "en-CH",
                  "en-CZ",
                  "en-DE",
                  "en-DK",
                  "en-ES",
                  "en-FI",
                  "en-FR",
                  "en-GB",
                  "en-GR",
                  "en-IE",
                  "en-IT",
                  "en-NL",
                  "en-NO",
                  "en-NZ",
                  "en-PL",
                  "en-PT",
                  "en-RO",
                  "en-SE",
                  "en-US",
                  "es-ES",
                  "es-US",
                  "fi-FI",
                  "fr-BE",
                  "fr-CA",
                  "fr-CH",
                  "fr-FR",
                  "it-CH",
                  "it-IT",
                  "nb-NO",
                  "nl-BE",
                  "nl-NL",
                  "pl-PL",
                  "pt-PT",
                  "ro-RO",
                  "sv-FI",
                  "sv-SE",
                ])
                .optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        konbini: z
          .union([
            z.object({
              confirmation_number: z
                .union([z.string().max(11), z.enum([""])])
                .optional(),
              expires_after_days: z
                .union([z.coerce.number(), z.enum([""])])
                .optional(),
              expires_at: z.union([z.coerce.number(), z.enum([""])]).optional(),
              product_description: z
                .union([z.string().max(22), z.enum([""])])
                .optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        kr_card: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        link: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        mobilepay: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        multibanco: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        naver_pay: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        nz_bank_account: z
          .union([
            z.object({
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        oxxo: z
          .union([
            z.object({
              expires_after_days: z.coerce.number().optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        p24: z
          .union([
            z.object({
              setup_future_usage: z.enum(["none"]).optional(),
              tos_shown_and_accepted: PermissiveBoolean.optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        pay_by_bank: z.union([z.object({}), z.enum([""])]).optional(),
        payco: z
          .union([
            z.object({ capture_method: z.enum(["", "manual"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        paynow: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        paypal: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              preferred_locale: z
                .enum([
                  "cs-CZ",
                  "da-DK",
                  "de-AT",
                  "de-DE",
                  "de-LU",
                  "el-GR",
                  "en-GB",
                  "en-US",
                  "es-ES",
                  "fi-FI",
                  "fr-BE",
                  "fr-FR",
                  "fr-LU",
                  "hu-HU",
                  "it-IT",
                  "nl-BE",
                  "nl-NL",
                  "pl-PL",
                  "pt-PT",
                  "sk-SK",
                  "sv-SE",
                ])
                .optional(),
              reference: z.string().max(127).optional(),
              risk_correlation_id: z.string().max(32).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        pix: z
          .union([
            z.object({
              expires_after_seconds: z.coerce.number().optional(),
              expires_at: z.coerce.number().optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        promptpay: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        revolut_pay: z
          .union([
            z.object({
              capture_method: z.enum(["", "manual"]).optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        samsung_pay: z
          .union([
            z.object({ capture_method: z.enum(["", "manual"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        sepa_debit: z
          .union([
            z.object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        sofort: z
          .union([
            z.object({
              preferred_language: z
                .enum(["", "de", "en", "es", "fr", "it", "nl", "pl"])
                .optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        swish: z
          .union([
            z.object({
              reference: z
                .union([z.string().max(5000), z.enum([""])])
                .optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        twint: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
        us_bank_account: z
          .union([
            z.object({
              financial_connections: z
                .object({
                  filters: z
                    .object({
                      account_subcategories: z
                        .array(z.enum(["checking", "savings"]))
                        .optional(),
                    })
                    .optional(),
                  permissions: z
                    .array(
                      z.enum([
                        "balances",
                        "ownership",
                        "payment_method",
                        "transactions",
                      ]),
                    )
                    .optional(),
                  prefetch: z
                    .array(z.enum(["balances", "ownership", "transactions"]))
                    .optional(),
                  return_url: z.string().max(5000).optional(),
                })
                .optional(),
              mandate_options: z
                .object({ collection_method: z.enum(["", "paper"]).optional() })
                .optional(),
              networks: z
                .object({
                  requested: z
                    .array(z.enum(["ach", "us_domestic_wire"]))
                    .optional(),
                })
                .optional(),
              preferred_settlement_speed: z
                .enum(["", "fastest", "standard"])
                .optional(),
              setup_future_usage: z
                .enum(["", "none", "off_session", "on_session"])
                .optional(),
              target_date: z.string().max(5000).optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        wechat_pay: z
          .union([
            z.object({
              app_id: z.string().max(5000).optional(),
              client: z.enum(["android", "ios", "web"]).optional(),
              setup_future_usage: z.enum(["none"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
        zip: z
          .union([
            z.object({ setup_future_usage: z.enum(["none"]).optional() }),
            z.enum([""]),
          ])
          .optional(),
      })
      .optional(),
    payment_method_types: z.array(z.string().max(5000)).optional(),
    radar_options: z
      .object({ session: z.string().max(5000).optional() })
      .optional(),
    receipt_email: z.string().optional(),
    return_url: z.string().optional(),
    setup_future_usage: z.enum(["off_session", "on_session"]).optional(),
    shipping: z
      .object({
        address: z.object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        }),
        carrier: z.string().max(5000).optional(),
        name: z.string().max(5000),
        phone: z.string().max(5000).optional(),
        tracking_number: z.string().max(5000).optional(),
      })
      .optional(),
    statement_descriptor: z.string().max(22).optional(),
    statement_descriptor_suffix: z.string().max(22).optional(),
    transfer_data: z
      .object({ amount: z.coerce.number().optional(), destination: z.string() })
      .optional(),
    transfer_group: z.string().optional(),
    use_stripe_sdk: PermissiveBoolean.optional(),
  })

  router.post(
    "postPaymentIntents",
    "/v1/payment_intents",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntents(input, postPaymentIntents.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntents.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentIntentsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  const getPaymentIntentsSearchBodySchema = z.object({}).optional()

  router.get(
    "getPaymentIntentsSearch",
    "/v1/payment_intents/search",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getPaymentIntentsSearchQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentIntentsSearchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentIntentsSearch(input, getPaymentIntentsSearch.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentIntentsSearch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const getPaymentIntentsIntentQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPaymentIntentsIntentBodySchema = z.object({}).optional()

  router.get(
    "getPaymentIntentsIntent",
    "/v1/payment_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentIntentsIntentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentIntentsIntent(input, getPaymentIntentsIntent.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentIntentsIntent.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postPaymentIntentsIntentBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      application_fee_amount: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      capture_method: z
        .enum(["automatic", "automatic_async", "manual"])
        .optional(),
      currency: z.string().optional(),
      customer: z.string().max(5000).optional(),
      description: z.string().max(1000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      payment_method: z.string().max(5000).optional(),
      payment_method_configuration: z.string().max(100).optional(),
      payment_method_data: z
        .object({
          acss_debit: z
            .object({
              account_number: z.string().max(5000),
              institution_number: z.string().max(5000),
              transit_number: z.string().max(5000),
            })
            .optional(),
          affirm: z.object({}).optional(),
          afterpay_clearpay: z.object({}).optional(),
          alipay: z.object({}).optional(),
          allow_redisplay: z
            .enum(["always", "limited", "unspecified"])
            .optional(),
          alma: z.object({}).optional(),
          amazon_pay: z.object({}).optional(),
          au_becs_debit: z
            .object({
              account_number: z.string().max(5000),
              bsb_number: z.string().max(5000),
            })
            .optional(),
          bacs_debit: z
            .object({
              account_number: z.string().max(5000).optional(),
              sort_code: z.string().max(5000).optional(),
            })
            .optional(),
          bancontact: z.object({}).optional(),
          billie: z.object({}).optional(),
          billing_details: z
            .object({
              address: z
                .union([
                  z.object({
                    city: z.string().max(5000).optional(),
                    country: z.string().max(5000).optional(),
                    line1: z.string().max(5000).optional(),
                    line2: z.string().max(5000).optional(),
                    postal_code: z.string().max(5000).optional(),
                    state: z.string().max(5000).optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              email: z.union([z.string(), z.enum([""])]).optional(),
              name: z.union([z.string().max(5000), z.enum([""])]).optional(),
              phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
            })
            .optional(),
          blik: z.object({}).optional(),
          boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
          cashapp: z.object({}).optional(),
          customer_balance: z.object({}).optional(),
          eps: z
            .object({
              bank: z
                .enum([
                  "arzte_und_apotheker_bank",
                  "austrian_anadi_bank_ag",
                  "bank_austria",
                  "bankhaus_carl_spangler",
                  "bankhaus_schelhammer_und_schattera_ag",
                  "bawag_psk_ag",
                  "bks_bank_ag",
                  "brull_kallmus_bank_ag",
                  "btv_vier_lander_bank",
                  "capital_bank_grawe_gruppe_ag",
                  "deutsche_bank_ag",
                  "dolomitenbank",
                  "easybank_ag",
                  "erste_bank_und_sparkassen",
                  "hypo_alpeadriabank_international_ag",
                  "hypo_bank_burgenland_aktiengesellschaft",
                  "hypo_noe_lb_fur_niederosterreich_u_wien",
                  "hypo_oberosterreich_salzburg_steiermark",
                  "hypo_tirol_bank_ag",
                  "hypo_vorarlberg_bank_ag",
                  "marchfelder_bank",
                  "oberbank_ag",
                  "raiffeisen_bankengruppe_osterreich",
                  "schoellerbank_ag",
                  "sparda_bank_wien",
                  "volksbank_gruppe",
                  "volkskreditbank_ag",
                  "vr_bank_braunau",
                ])
                .optional(),
            })
            .optional(),
          fpx: z
            .object({
              bank: z.enum([
                "affin_bank",
                "agrobank",
                "alliance_bank",
                "ambank",
                "bank_islam",
                "bank_muamalat",
                "bank_of_china",
                "bank_rakyat",
                "bsn",
                "cimb",
                "deutsche_bank",
                "hong_leong_bank",
                "hsbc",
                "kfh",
                "maybank2e",
                "maybank2u",
                "ocbc",
                "pb_enterprise",
                "public_bank",
                "rhb",
                "standard_chartered",
                "uob",
              ]),
            })
            .optional(),
          giropay: z.object({}).optional(),
          grabpay: z.object({}).optional(),
          ideal: z
            .object({
              bank: z
                .enum([
                  "abn_amro",
                  "asn_bank",
                  "bunq",
                  "handelsbanken",
                  "ing",
                  "knab",
                  "moneyou",
                  "n26",
                  "nn",
                  "rabobank",
                  "regiobank",
                  "revolut",
                  "sns_bank",
                  "triodos_bank",
                  "van_lanschot",
                  "yoursafe",
                ])
                .optional(),
            })
            .optional(),
          interac_present: z.object({}).optional(),
          kakao_pay: z.object({}).optional(),
          klarna: z
            .object({
              dob: z
                .object({
                  day: z.coerce.number(),
                  month: z.coerce.number(),
                  year: z.coerce.number(),
                })
                .optional(),
            })
            .optional(),
          konbini: z.object({}).optional(),
          kr_card: z.object({}).optional(),
          link: z.object({}).optional(),
          metadata: z.record(z.string()).optional(),
          mobilepay: z.object({}).optional(),
          multibanco: z.object({}).optional(),
          naver_pay: z
            .object({ funding: z.enum(["card", "points"]).optional() })
            .optional(),
          nz_bank_account: z
            .object({
              account_holder_name: z.string().max(5000).optional(),
              account_number: z.string().max(5000),
              bank_code: z.string().max(5000),
              branch_code: z.string().max(5000),
              reference: z.string().max(128).optional(),
              suffix: z.string().max(5000),
            })
            .optional(),
          oxxo: z.object({}).optional(),
          p24: z
            .object({
              bank: z
                .enum([
                  "alior_bank",
                  "bank_millennium",
                  "bank_nowy_bfg_sa",
                  "bank_pekao_sa",
                  "banki_spbdzielcze",
                  "blik",
                  "bnp_paribas",
                  "boz",
                  "citi_handlowy",
                  "credit_agricole",
                  "envelobank",
                  "etransfer_pocztowy24",
                  "getin_bank",
                  "ideabank",
                  "ing",
                  "inteligo",
                  "mbank_mtransfer",
                  "nest_przelew",
                  "noble_pay",
                  "pbac_z_ipko",
                  "plus_bank",
                  "santander_przelew24",
                  "tmobile_usbugi_bankowe",
                  "toyota_bank",
                  "velobank",
                  "volkswagen_bank",
                ])
                .optional(),
            })
            .optional(),
          pay_by_bank: z.object({}).optional(),
          payco: z.object({}).optional(),
          paynow: z.object({}).optional(),
          paypal: z.object({}).optional(),
          pix: z.object({}).optional(),
          promptpay: z.object({}).optional(),
          radar_options: z
            .object({ session: z.string().max(5000).optional() })
            .optional(),
          revolut_pay: z.object({}).optional(),
          samsung_pay: z.object({}).optional(),
          satispay: z.object({}).optional(),
          sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
          sofort: z
            .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
            .optional(),
          swish: z.object({}).optional(),
          twint: z.object({}).optional(),
          type: z.enum([
            "acss_debit",
            "affirm",
            "afterpay_clearpay",
            "alipay",
            "alma",
            "amazon_pay",
            "au_becs_debit",
            "bacs_debit",
            "bancontact",
            "billie",
            "blik",
            "boleto",
            "cashapp",
            "customer_balance",
            "eps",
            "fpx",
            "giropay",
            "grabpay",
            "ideal",
            "kakao_pay",
            "klarna",
            "konbini",
            "kr_card",
            "link",
            "mobilepay",
            "multibanco",
            "naver_pay",
            "nz_bank_account",
            "oxxo",
            "p24",
            "pay_by_bank",
            "payco",
            "paynow",
            "paypal",
            "pix",
            "promptpay",
            "revolut_pay",
            "samsung_pay",
            "satispay",
            "sepa_debit",
            "sofort",
            "swish",
            "twint",
            "us_bank_account",
            "wechat_pay",
            "zip",
          ]),
          us_bank_account: z
            .object({
              account_holder_type: z.enum(["company", "individual"]).optional(),
              account_number: z.string().max(5000).optional(),
              account_type: z.enum(["checking", "savings"]).optional(),
              financial_connections_account: z.string().max(5000).optional(),
              routing_number: z.string().max(5000).optional(),
            })
            .optional(),
          wechat_pay: z.object({}).optional(),
          zip: z.object({}).optional(),
        })
        .optional(),
      payment_method_options: z
        .object({
          acss_debit: z
            .union([
              z.object({
                mandate_options: z
                  .object({
                    custom_mandate_url: z
                      .union([z.string(), z.enum([""])])
                      .optional(),
                    interval_description: z.string().max(500).optional(),
                    payment_schedule: z
                      .enum(["combined", "interval", "sporadic"])
                      .optional(),
                    transaction_type: z
                      .enum(["business", "personal"])
                      .optional(),
                  })
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
                verification_method: z
                  .enum(["automatic", "instant", "microdeposits"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          affirm: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                preferred_locale: z.string().max(30).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          afterpay_clearpay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                reference: z.string().max(128).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          alipay: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          alma: z
            .union([
              z.object({ capture_method: z.enum(["", "manual"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          amazon_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          au_becs_debit: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          bacs_debit: z
            .union([
              z.object({
                mandate_options: z
                  .object({
                    reference_prefix: z
                      .union([z.string().max(12), z.enum([""])])
                      .optional(),
                  })
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          bancontact: z
            .union([
              z.object({
                preferred_language: z.enum(["de", "en", "fr", "nl"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          blik: z
            .union([
              z.object({
                code: z.string().max(5000).optional(),
                setup_future_usage: z.enum(["", "none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          boleto: z
            .union([
              z.object({
                expires_after_days: z.coerce.number().optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          card: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                cvc_token: z.string().max(5000).optional(),
                installments: z
                  .object({
                    enabled: PermissiveBoolean.optional(),
                    plan: z
                      .union([
                        z.object({
                          count: z.coerce.number().optional(),
                          interval: z.enum(["month"]).optional(),
                          type: z.enum(["fixed_count"]),
                        }),
                        z.enum([""]),
                      ])
                      .optional(),
                  })
                  .optional(),
                mandate_options: z
                  .object({
                    amount: z.coerce.number(),
                    amount_type: z.enum(["fixed", "maximum"]),
                    description: z.string().max(200).optional(),
                    end_date: z.coerce.number().optional(),
                    interval: z.enum([
                      "day",
                      "month",
                      "sporadic",
                      "week",
                      "year",
                    ]),
                    interval_count: z.coerce.number().optional(),
                    reference: z.string().max(80),
                    start_date: z.coerce.number(),
                    supported_types: z.array(z.enum(["india"])).optional(),
                  })
                  .optional(),
                network: z
                  .enum([
                    "amex",
                    "cartes_bancaires",
                    "diners",
                    "discover",
                    "eftpos_au",
                    "girocard",
                    "interac",
                    "jcb",
                    "link",
                    "mastercard",
                    "unionpay",
                    "unknown",
                    "visa",
                  ])
                  .optional(),
                request_extended_authorization: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_incremental_authorization: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_multicapture: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_overcapture: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_three_d_secure: z
                  .enum(["any", "automatic", "challenge"])
                  .optional(),
                require_cvc_recollection: PermissiveBoolean.optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                statement_descriptor_suffix_kana: z
                  .union([z.string().max(22), z.enum([""])])
                  .optional(),
                statement_descriptor_suffix_kanji: z
                  .union([z.string().max(17), z.enum([""])])
                  .optional(),
                three_d_secure: z
                  .object({
                    ares_trans_status: z
                      .enum(["A", "C", "I", "N", "R", "U", "Y"])
                      .optional(),
                    cryptogram: z.string().max(5000),
                    electronic_commerce_indicator: z
                      .enum(["01", "02", "05", "06", "07"])
                      .optional(),
                    exemption_indicator: z
                      .enum(["low_risk", "none"])
                      .optional(),
                    network_options: z
                      .object({
                        cartes_bancaires: z
                          .object({
                            cb_avalgo: z.enum(["0", "1", "2", "3", "4", "A"]),
                            cb_exemption: z.string().max(4).optional(),
                            cb_score: z.coerce.number().optional(),
                          })
                          .optional(),
                      })
                      .optional(),
                    requestor_challenge_indicator: z.string().max(2).optional(),
                    transaction_id: z.string().max(5000),
                    version: z.enum(["1.0.2", "2.1.0", "2.2.0"]),
                  })
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          card_present: z
            .union([
              z.object({
                request_extended_authorization: PermissiveBoolean.optional(),
                request_incremental_authorization_support:
                  PermissiveBoolean.optional(),
                routing: z
                  .object({
                    requested_priority: z
                      .enum(["domestic", "international"])
                      .optional(),
                  })
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          cashapp: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          customer_balance: z
            .union([
              z.object({
                bank_transfer: z
                  .object({
                    eu_bank_transfer: z
                      .object({ country: z.string().max(5000) })
                      .optional(),
                    requested_address_types: z
                      .array(
                        z.enum([
                          "aba",
                          "iban",
                          "sepa",
                          "sort_code",
                          "spei",
                          "swift",
                          "zengin",
                        ]),
                      )
                      .optional(),
                    type: z.enum([
                      "eu_bank_transfer",
                      "gb_bank_transfer",
                      "jp_bank_transfer",
                      "mx_bank_transfer",
                      "us_bank_transfer",
                    ]),
                  })
                  .optional(),
                funding_type: z.enum(["bank_transfer"]).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          eps: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          fpx: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          giropay: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          grabpay: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          ideal: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          interac_present: z.union([z.object({}), z.enum([""])]).optional(),
          kakao_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          klarna: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                preferred_locale: z
                  .enum([
                    "cs-CZ",
                    "da-DK",
                    "de-AT",
                    "de-CH",
                    "de-DE",
                    "el-GR",
                    "en-AT",
                    "en-AU",
                    "en-BE",
                    "en-CA",
                    "en-CH",
                    "en-CZ",
                    "en-DE",
                    "en-DK",
                    "en-ES",
                    "en-FI",
                    "en-FR",
                    "en-GB",
                    "en-GR",
                    "en-IE",
                    "en-IT",
                    "en-NL",
                    "en-NO",
                    "en-NZ",
                    "en-PL",
                    "en-PT",
                    "en-RO",
                    "en-SE",
                    "en-US",
                    "es-ES",
                    "es-US",
                    "fi-FI",
                    "fr-BE",
                    "fr-CA",
                    "fr-CH",
                    "fr-FR",
                    "it-CH",
                    "it-IT",
                    "nb-NO",
                    "nl-BE",
                    "nl-NL",
                    "pl-PL",
                    "pt-PT",
                    "ro-RO",
                    "sv-FI",
                    "sv-SE",
                  ])
                  .optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          konbini: z
            .union([
              z.object({
                confirmation_number: z
                  .union([z.string().max(11), z.enum([""])])
                  .optional(),
                expires_after_days: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                expires_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(22), z.enum([""])])
                  .optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          kr_card: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          link: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          mobilepay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          multibanco: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          naver_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          nz_bank_account: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          oxxo: z
            .union([
              z.object({
                expires_after_days: z.coerce.number().optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          p24: z
            .union([
              z.object({
                setup_future_usage: z.enum(["none"]).optional(),
                tos_shown_and_accepted: PermissiveBoolean.optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          pay_by_bank: z.union([z.object({}), z.enum([""])]).optional(),
          payco: z
            .union([
              z.object({ capture_method: z.enum(["", "manual"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          paynow: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          paypal: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                preferred_locale: z
                  .enum([
                    "cs-CZ",
                    "da-DK",
                    "de-AT",
                    "de-DE",
                    "de-LU",
                    "el-GR",
                    "en-GB",
                    "en-US",
                    "es-ES",
                    "fi-FI",
                    "fr-BE",
                    "fr-FR",
                    "fr-LU",
                    "hu-HU",
                    "it-IT",
                    "nl-BE",
                    "nl-NL",
                    "pl-PL",
                    "pt-PT",
                    "sk-SK",
                    "sv-SE",
                  ])
                  .optional(),
                reference: z.string().max(127).optional(),
                risk_correlation_id: z.string().max(32).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          pix: z
            .union([
              z.object({
                expires_after_seconds: z.coerce.number().optional(),
                expires_at: z.coerce.number().optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          promptpay: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          revolut_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          samsung_pay: z
            .union([
              z.object({ capture_method: z.enum(["", "manual"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          sepa_debit: z
            .union([
              z.object({
                mandate_options: z
                  .object({
                    reference_prefix: z
                      .union([z.string().max(12), z.enum([""])])
                      .optional(),
                  })
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          sofort: z
            .union([
              z.object({
                preferred_language: z
                  .enum(["", "de", "en", "es", "fr", "it", "nl", "pl"])
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          swish: z
            .union([
              z.object({
                reference: z
                  .union([z.string().max(5000), z.enum([""])])
                  .optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          twint: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          us_bank_account: z
            .union([
              z.object({
                financial_connections: z
                  .object({
                    filters: z
                      .object({
                        account_subcategories: z
                          .array(z.enum(["checking", "savings"]))
                          .optional(),
                      })
                      .optional(),
                    permissions: z
                      .array(
                        z.enum([
                          "balances",
                          "ownership",
                          "payment_method",
                          "transactions",
                        ]),
                      )
                      .optional(),
                    prefetch: z
                      .array(z.enum(["balances", "ownership", "transactions"]))
                      .optional(),
                    return_url: z.string().max(5000).optional(),
                  })
                  .optional(),
                mandate_options: z
                  .object({
                    collection_method: z.enum(["", "paper"]).optional(),
                  })
                  .optional(),
                networks: z
                  .object({
                    requested: z
                      .array(z.enum(["ach", "us_domestic_wire"]))
                      .optional(),
                  })
                  .optional(),
                preferred_settlement_speed: z
                  .enum(["", "fastest", "standard"])
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
                verification_method: z
                  .enum(["automatic", "instant", "microdeposits"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          wechat_pay: z
            .union([
              z.object({
                app_id: z.string().max(5000).optional(),
                client: z.enum(["android", "ios", "web"]).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          zip: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      payment_method_types: z.array(z.string().max(5000)).optional(),
      receipt_email: z.union([z.string(), z.enum([""])]).optional(),
      setup_future_usage: z.enum(["", "off_session", "on_session"]).optional(),
      shipping: z
        .union([
          z.object({
            address: z.object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            }),
            carrier: z.string().max(5000).optional(),
            name: z.string().max(5000),
            phone: z.string().max(5000).optional(),
            tracking_number: z.string().max(5000).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      statement_descriptor: z.string().max(22).optional(),
      statement_descriptor_suffix: z.string().max(22).optional(),
      transfer_data: z
        .object({ amount: z.coerce.number().optional() })
        .optional(),
      transfer_group: z.string().optional(),
    })
    .optional()

  router.post(
    "postPaymentIntentsIntent",
    "/v1/payment_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntentsIntent(
          input,
          postPaymentIntentsIntent.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntent.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentApplyCustomerBalanceParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postPaymentIntentsIntentApplyCustomerBalanceBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      currency: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postPaymentIntentsIntentApplyCustomerBalance",
    "/v1/payment_intents/:intent/apply_customer_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentApplyCustomerBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentApplyCustomerBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntentsIntentApplyCustomerBalance(
          input,
          postPaymentIntentsIntentApplyCustomerBalance.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentApplyCustomerBalance.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentCancelParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postPaymentIntentsIntentCancelBodySchema = z
    .object({
      cancellation_reason: z
        .enum(["abandoned", "duplicate", "fraudulent", "requested_by_customer"])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postPaymentIntentsIntentCancel",
    "/v1/payment_intents/:intent/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntentsIntentCancel(
          input,
          postPaymentIntentsIntentCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentCaptureParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postPaymentIntentsIntentCaptureBodySchema = z
    .object({
      amount_to_capture: z.coerce.number().optional(),
      application_fee_amount: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      final_capture: PermissiveBoolean.optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      statement_descriptor: z.string().max(22).optional(),
      statement_descriptor_suffix: z.string().max(22).optional(),
      transfer_data: z
        .object({ amount: z.coerce.number().optional() })
        .optional(),
    })
    .optional()

  router.post(
    "postPaymentIntentsIntentCapture",
    "/v1/payment_intents/:intent/capture",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentCaptureParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntentsIntentCapture(
          input,
          postPaymentIntentsIntentCapture.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentCapture.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentConfirmParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postPaymentIntentsIntentConfirmBodySchema = z
    .object({
      capture_method: z
        .enum(["automatic", "automatic_async", "manual"])
        .optional(),
      client_secret: z.string().max(5000).optional(),
      confirmation_token: z.string().max(5000).optional(),
      error_on_requires_action: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      mandate: z.string().max(5000).optional(),
      mandate_data: z
        .union([
          z.object({
            customer_acceptance: z.object({
              accepted_at: z.coerce.number().optional(),
              offline: z.object({}).optional(),
              online: z
                .object({
                  ip_address: z.string(),
                  user_agent: z.string().max(5000),
                })
                .optional(),
              type: z.enum(["offline", "online"]),
            }),
          }),
          z.enum([""]),
          z.object({
            customer_acceptance: z.object({
              online: z.object({
                ip_address: z.string().optional(),
                user_agent: z.string().max(5000).optional(),
              }),
              type: z.enum(["online"]),
            }),
          }),
        ])
        .optional(),
      off_session: z
        .union([PermissiveBoolean, z.enum(["one_off", "recurring"])])
        .optional(),
      payment_method: z.string().max(5000).optional(),
      payment_method_data: z
        .object({
          acss_debit: z
            .object({
              account_number: z.string().max(5000),
              institution_number: z.string().max(5000),
              transit_number: z.string().max(5000),
            })
            .optional(),
          affirm: z.object({}).optional(),
          afterpay_clearpay: z.object({}).optional(),
          alipay: z.object({}).optional(),
          allow_redisplay: z
            .enum(["always", "limited", "unspecified"])
            .optional(),
          alma: z.object({}).optional(),
          amazon_pay: z.object({}).optional(),
          au_becs_debit: z
            .object({
              account_number: z.string().max(5000),
              bsb_number: z.string().max(5000),
            })
            .optional(),
          bacs_debit: z
            .object({
              account_number: z.string().max(5000).optional(),
              sort_code: z.string().max(5000).optional(),
            })
            .optional(),
          bancontact: z.object({}).optional(),
          billie: z.object({}).optional(),
          billing_details: z
            .object({
              address: z
                .union([
                  z.object({
                    city: z.string().max(5000).optional(),
                    country: z.string().max(5000).optional(),
                    line1: z.string().max(5000).optional(),
                    line2: z.string().max(5000).optional(),
                    postal_code: z.string().max(5000).optional(),
                    state: z.string().max(5000).optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              email: z.union([z.string(), z.enum([""])]).optional(),
              name: z.union([z.string().max(5000), z.enum([""])]).optional(),
              phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
            })
            .optional(),
          blik: z.object({}).optional(),
          boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
          cashapp: z.object({}).optional(),
          customer_balance: z.object({}).optional(),
          eps: z
            .object({
              bank: z
                .enum([
                  "arzte_und_apotheker_bank",
                  "austrian_anadi_bank_ag",
                  "bank_austria",
                  "bankhaus_carl_spangler",
                  "bankhaus_schelhammer_und_schattera_ag",
                  "bawag_psk_ag",
                  "bks_bank_ag",
                  "brull_kallmus_bank_ag",
                  "btv_vier_lander_bank",
                  "capital_bank_grawe_gruppe_ag",
                  "deutsche_bank_ag",
                  "dolomitenbank",
                  "easybank_ag",
                  "erste_bank_und_sparkassen",
                  "hypo_alpeadriabank_international_ag",
                  "hypo_bank_burgenland_aktiengesellschaft",
                  "hypo_noe_lb_fur_niederosterreich_u_wien",
                  "hypo_oberosterreich_salzburg_steiermark",
                  "hypo_tirol_bank_ag",
                  "hypo_vorarlberg_bank_ag",
                  "marchfelder_bank",
                  "oberbank_ag",
                  "raiffeisen_bankengruppe_osterreich",
                  "schoellerbank_ag",
                  "sparda_bank_wien",
                  "volksbank_gruppe",
                  "volkskreditbank_ag",
                  "vr_bank_braunau",
                ])
                .optional(),
            })
            .optional(),
          fpx: z
            .object({
              bank: z.enum([
                "affin_bank",
                "agrobank",
                "alliance_bank",
                "ambank",
                "bank_islam",
                "bank_muamalat",
                "bank_of_china",
                "bank_rakyat",
                "bsn",
                "cimb",
                "deutsche_bank",
                "hong_leong_bank",
                "hsbc",
                "kfh",
                "maybank2e",
                "maybank2u",
                "ocbc",
                "pb_enterprise",
                "public_bank",
                "rhb",
                "standard_chartered",
                "uob",
              ]),
            })
            .optional(),
          giropay: z.object({}).optional(),
          grabpay: z.object({}).optional(),
          ideal: z
            .object({
              bank: z
                .enum([
                  "abn_amro",
                  "asn_bank",
                  "bunq",
                  "handelsbanken",
                  "ing",
                  "knab",
                  "moneyou",
                  "n26",
                  "nn",
                  "rabobank",
                  "regiobank",
                  "revolut",
                  "sns_bank",
                  "triodos_bank",
                  "van_lanschot",
                  "yoursafe",
                ])
                .optional(),
            })
            .optional(),
          interac_present: z.object({}).optional(),
          kakao_pay: z.object({}).optional(),
          klarna: z
            .object({
              dob: z
                .object({
                  day: z.coerce.number(),
                  month: z.coerce.number(),
                  year: z.coerce.number(),
                })
                .optional(),
            })
            .optional(),
          konbini: z.object({}).optional(),
          kr_card: z.object({}).optional(),
          link: z.object({}).optional(),
          metadata: z.record(z.string()).optional(),
          mobilepay: z.object({}).optional(),
          multibanco: z.object({}).optional(),
          naver_pay: z
            .object({ funding: z.enum(["card", "points"]).optional() })
            .optional(),
          nz_bank_account: z
            .object({
              account_holder_name: z.string().max(5000).optional(),
              account_number: z.string().max(5000),
              bank_code: z.string().max(5000),
              branch_code: z.string().max(5000),
              reference: z.string().max(128).optional(),
              suffix: z.string().max(5000),
            })
            .optional(),
          oxxo: z.object({}).optional(),
          p24: z
            .object({
              bank: z
                .enum([
                  "alior_bank",
                  "bank_millennium",
                  "bank_nowy_bfg_sa",
                  "bank_pekao_sa",
                  "banki_spbdzielcze",
                  "blik",
                  "bnp_paribas",
                  "boz",
                  "citi_handlowy",
                  "credit_agricole",
                  "envelobank",
                  "etransfer_pocztowy24",
                  "getin_bank",
                  "ideabank",
                  "ing",
                  "inteligo",
                  "mbank_mtransfer",
                  "nest_przelew",
                  "noble_pay",
                  "pbac_z_ipko",
                  "plus_bank",
                  "santander_przelew24",
                  "tmobile_usbugi_bankowe",
                  "toyota_bank",
                  "velobank",
                  "volkswagen_bank",
                ])
                .optional(),
            })
            .optional(),
          pay_by_bank: z.object({}).optional(),
          payco: z.object({}).optional(),
          paynow: z.object({}).optional(),
          paypal: z.object({}).optional(),
          pix: z.object({}).optional(),
          promptpay: z.object({}).optional(),
          radar_options: z
            .object({ session: z.string().max(5000).optional() })
            .optional(),
          revolut_pay: z.object({}).optional(),
          samsung_pay: z.object({}).optional(),
          satispay: z.object({}).optional(),
          sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
          sofort: z
            .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
            .optional(),
          swish: z.object({}).optional(),
          twint: z.object({}).optional(),
          type: z.enum([
            "acss_debit",
            "affirm",
            "afterpay_clearpay",
            "alipay",
            "alma",
            "amazon_pay",
            "au_becs_debit",
            "bacs_debit",
            "bancontact",
            "billie",
            "blik",
            "boleto",
            "cashapp",
            "customer_balance",
            "eps",
            "fpx",
            "giropay",
            "grabpay",
            "ideal",
            "kakao_pay",
            "klarna",
            "konbini",
            "kr_card",
            "link",
            "mobilepay",
            "multibanco",
            "naver_pay",
            "nz_bank_account",
            "oxxo",
            "p24",
            "pay_by_bank",
            "payco",
            "paynow",
            "paypal",
            "pix",
            "promptpay",
            "revolut_pay",
            "samsung_pay",
            "satispay",
            "sepa_debit",
            "sofort",
            "swish",
            "twint",
            "us_bank_account",
            "wechat_pay",
            "zip",
          ]),
          us_bank_account: z
            .object({
              account_holder_type: z.enum(["company", "individual"]).optional(),
              account_number: z.string().max(5000).optional(),
              account_type: z.enum(["checking", "savings"]).optional(),
              financial_connections_account: z.string().max(5000).optional(),
              routing_number: z.string().max(5000).optional(),
            })
            .optional(),
          wechat_pay: z.object({}).optional(),
          zip: z.object({}).optional(),
        })
        .optional(),
      payment_method_options: z
        .object({
          acss_debit: z
            .union([
              z.object({
                mandate_options: z
                  .object({
                    custom_mandate_url: z
                      .union([z.string(), z.enum([""])])
                      .optional(),
                    interval_description: z.string().max(500).optional(),
                    payment_schedule: z
                      .enum(["combined", "interval", "sporadic"])
                      .optional(),
                    transaction_type: z
                      .enum(["business", "personal"])
                      .optional(),
                  })
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
                verification_method: z
                  .enum(["automatic", "instant", "microdeposits"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          affirm: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                preferred_locale: z.string().max(30).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          afterpay_clearpay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                reference: z.string().max(128).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          alipay: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          alma: z
            .union([
              z.object({ capture_method: z.enum(["", "manual"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          amazon_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          au_becs_debit: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          bacs_debit: z
            .union([
              z.object({
                mandate_options: z
                  .object({
                    reference_prefix: z
                      .union([z.string().max(12), z.enum([""])])
                      .optional(),
                  })
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          bancontact: z
            .union([
              z.object({
                preferred_language: z.enum(["de", "en", "fr", "nl"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          blik: z
            .union([
              z.object({
                code: z.string().max(5000).optional(),
                setup_future_usage: z.enum(["", "none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          boleto: z
            .union([
              z.object({
                expires_after_days: z.coerce.number().optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          card: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                cvc_token: z.string().max(5000).optional(),
                installments: z
                  .object({
                    enabled: PermissiveBoolean.optional(),
                    plan: z
                      .union([
                        z.object({
                          count: z.coerce.number().optional(),
                          interval: z.enum(["month"]).optional(),
                          type: z.enum(["fixed_count"]),
                        }),
                        z.enum([""]),
                      ])
                      .optional(),
                  })
                  .optional(),
                mandate_options: z
                  .object({
                    amount: z.coerce.number(),
                    amount_type: z.enum(["fixed", "maximum"]),
                    description: z.string().max(200).optional(),
                    end_date: z.coerce.number().optional(),
                    interval: z.enum([
                      "day",
                      "month",
                      "sporadic",
                      "week",
                      "year",
                    ]),
                    interval_count: z.coerce.number().optional(),
                    reference: z.string().max(80),
                    start_date: z.coerce.number(),
                    supported_types: z.array(z.enum(["india"])).optional(),
                  })
                  .optional(),
                network: z
                  .enum([
                    "amex",
                    "cartes_bancaires",
                    "diners",
                    "discover",
                    "eftpos_au",
                    "girocard",
                    "interac",
                    "jcb",
                    "link",
                    "mastercard",
                    "unionpay",
                    "unknown",
                    "visa",
                  ])
                  .optional(),
                request_extended_authorization: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_incremental_authorization: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_multicapture: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_overcapture: z
                  .enum(["if_available", "never"])
                  .optional(),
                request_three_d_secure: z
                  .enum(["any", "automatic", "challenge"])
                  .optional(),
                require_cvc_recollection: PermissiveBoolean.optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                statement_descriptor_suffix_kana: z
                  .union([z.string().max(22), z.enum([""])])
                  .optional(),
                statement_descriptor_suffix_kanji: z
                  .union([z.string().max(17), z.enum([""])])
                  .optional(),
                three_d_secure: z
                  .object({
                    ares_trans_status: z
                      .enum(["A", "C", "I", "N", "R", "U", "Y"])
                      .optional(),
                    cryptogram: z.string().max(5000),
                    electronic_commerce_indicator: z
                      .enum(["01", "02", "05", "06", "07"])
                      .optional(),
                    exemption_indicator: z
                      .enum(["low_risk", "none"])
                      .optional(),
                    network_options: z
                      .object({
                        cartes_bancaires: z
                          .object({
                            cb_avalgo: z.enum(["0", "1", "2", "3", "4", "A"]),
                            cb_exemption: z.string().max(4).optional(),
                            cb_score: z.coerce.number().optional(),
                          })
                          .optional(),
                      })
                      .optional(),
                    requestor_challenge_indicator: z.string().max(2).optional(),
                    transaction_id: z.string().max(5000),
                    version: z.enum(["1.0.2", "2.1.0", "2.2.0"]),
                  })
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          card_present: z
            .union([
              z.object({
                request_extended_authorization: PermissiveBoolean.optional(),
                request_incremental_authorization_support:
                  PermissiveBoolean.optional(),
                routing: z
                  .object({
                    requested_priority: z
                      .enum(["domestic", "international"])
                      .optional(),
                  })
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          cashapp: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          customer_balance: z
            .union([
              z.object({
                bank_transfer: z
                  .object({
                    eu_bank_transfer: z
                      .object({ country: z.string().max(5000) })
                      .optional(),
                    requested_address_types: z
                      .array(
                        z.enum([
                          "aba",
                          "iban",
                          "sepa",
                          "sort_code",
                          "spei",
                          "swift",
                          "zengin",
                        ]),
                      )
                      .optional(),
                    type: z.enum([
                      "eu_bank_transfer",
                      "gb_bank_transfer",
                      "jp_bank_transfer",
                      "mx_bank_transfer",
                      "us_bank_transfer",
                    ]),
                  })
                  .optional(),
                funding_type: z.enum(["bank_transfer"]).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          eps: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          fpx: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          giropay: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          grabpay: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          ideal: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          interac_present: z.union([z.object({}), z.enum([""])]).optional(),
          kakao_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          klarna: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                preferred_locale: z
                  .enum([
                    "cs-CZ",
                    "da-DK",
                    "de-AT",
                    "de-CH",
                    "de-DE",
                    "el-GR",
                    "en-AT",
                    "en-AU",
                    "en-BE",
                    "en-CA",
                    "en-CH",
                    "en-CZ",
                    "en-DE",
                    "en-DK",
                    "en-ES",
                    "en-FI",
                    "en-FR",
                    "en-GB",
                    "en-GR",
                    "en-IE",
                    "en-IT",
                    "en-NL",
                    "en-NO",
                    "en-NZ",
                    "en-PL",
                    "en-PT",
                    "en-RO",
                    "en-SE",
                    "en-US",
                    "es-ES",
                    "es-US",
                    "fi-FI",
                    "fr-BE",
                    "fr-CA",
                    "fr-CH",
                    "fr-FR",
                    "it-CH",
                    "it-IT",
                    "nb-NO",
                    "nl-BE",
                    "nl-NL",
                    "pl-PL",
                    "pt-PT",
                    "ro-RO",
                    "sv-FI",
                    "sv-SE",
                  ])
                  .optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          konbini: z
            .union([
              z.object({
                confirmation_number: z
                  .union([z.string().max(11), z.enum([""])])
                  .optional(),
                expires_after_days: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                expires_at: z
                  .union([z.coerce.number(), z.enum([""])])
                  .optional(),
                product_description: z
                  .union([z.string().max(22), z.enum([""])])
                  .optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          kr_card: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          link: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          mobilepay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          multibanco: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          naver_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          nz_bank_account: z
            .union([
              z.object({
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          oxxo: z
            .union([
              z.object({
                expires_after_days: z.coerce.number().optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          p24: z
            .union([
              z.object({
                setup_future_usage: z.enum(["none"]).optional(),
                tos_shown_and_accepted: PermissiveBoolean.optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          pay_by_bank: z.union([z.object({}), z.enum([""])]).optional(),
          payco: z
            .union([
              z.object({ capture_method: z.enum(["", "manual"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          paynow: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          paypal: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                preferred_locale: z
                  .enum([
                    "cs-CZ",
                    "da-DK",
                    "de-AT",
                    "de-DE",
                    "de-LU",
                    "el-GR",
                    "en-GB",
                    "en-US",
                    "es-ES",
                    "fi-FI",
                    "fr-BE",
                    "fr-FR",
                    "fr-LU",
                    "hu-HU",
                    "it-IT",
                    "nl-BE",
                    "nl-NL",
                    "pl-PL",
                    "pt-PT",
                    "sk-SK",
                    "sv-SE",
                  ])
                  .optional(),
                reference: z.string().max(127).optional(),
                risk_correlation_id: z.string().max(32).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          pix: z
            .union([
              z.object({
                expires_after_seconds: z.coerce.number().optional(),
                expires_at: z.coerce.number().optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          promptpay: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          revolut_pay: z
            .union([
              z.object({
                capture_method: z.enum(["", "manual"]).optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          samsung_pay: z
            .union([
              z.object({ capture_method: z.enum(["", "manual"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          sepa_debit: z
            .union([
              z.object({
                mandate_options: z
                  .object({
                    reference_prefix: z
                      .union([z.string().max(12), z.enum([""])])
                      .optional(),
                  })
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          sofort: z
            .union([
              z.object({
                preferred_language: z
                  .enum(["", "de", "en", "es", "fr", "it", "nl", "pl"])
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          swish: z
            .union([
              z.object({
                reference: z
                  .union([z.string().max(5000), z.enum([""])])
                  .optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          twint: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
          us_bank_account: z
            .union([
              z.object({
                financial_connections: z
                  .object({
                    filters: z
                      .object({
                        account_subcategories: z
                          .array(z.enum(["checking", "savings"]))
                          .optional(),
                      })
                      .optional(),
                    permissions: z
                      .array(
                        z.enum([
                          "balances",
                          "ownership",
                          "payment_method",
                          "transactions",
                        ]),
                      )
                      .optional(),
                    prefetch: z
                      .array(z.enum(["balances", "ownership", "transactions"]))
                      .optional(),
                    return_url: z.string().max(5000).optional(),
                  })
                  .optional(),
                mandate_options: z
                  .object({
                    collection_method: z.enum(["", "paper"]).optional(),
                  })
                  .optional(),
                networks: z
                  .object({
                    requested: z
                      .array(z.enum(["ach", "us_domestic_wire"]))
                      .optional(),
                  })
                  .optional(),
                preferred_settlement_speed: z
                  .enum(["", "fastest", "standard"])
                  .optional(),
                setup_future_usage: z
                  .enum(["", "none", "off_session", "on_session"])
                  .optional(),
                target_date: z.string().max(5000).optional(),
                verification_method: z
                  .enum(["automatic", "instant", "microdeposits"])
                  .optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          wechat_pay: z
            .union([
              z.object({
                app_id: z.string().max(5000).optional(),
                client: z.enum(["android", "ios", "web"]).optional(),
                setup_future_usage: z.enum(["none"]).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          zip: z
            .union([
              z.object({ setup_future_usage: z.enum(["none"]).optional() }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      payment_method_types: z.array(z.string().max(5000)).optional(),
      radar_options: z
        .object({ session: z.string().max(5000).optional() })
        .optional(),
      receipt_email: z.union([z.string(), z.enum([""])]).optional(),
      return_url: z.string().optional(),
      setup_future_usage: z.enum(["", "off_session", "on_session"]).optional(),
      shipping: z
        .union([
          z.object({
            address: z.object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            }),
            carrier: z.string().max(5000).optional(),
            name: z.string().max(5000),
            phone: z.string().max(5000).optional(),
            tracking_number: z.string().max(5000).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      use_stripe_sdk: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postPaymentIntentsIntentConfirm",
    "/v1/payment_intents/:intent/confirm",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentConfirmParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentConfirmBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntentsIntentConfirm(
          input,
          postPaymentIntentsIntentConfirm.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentConfirm.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentIncrementAuthorizationParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postPaymentIntentsIntentIncrementAuthorizationBodySchema = z.object({
    amount: z.coerce.number(),
    application_fee_amount: z.coerce.number().optional(),
    description: z.string().max(1000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    statement_descriptor: z.string().max(22).optional(),
    transfer_data: z
      .object({ amount: z.coerce.number().optional() })
      .optional(),
  })

  router.post(
    "postPaymentIntentsIntentIncrementAuthorization",
    "/v1/payment_intents/:intent/increment_authorization",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentIncrementAuthorizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentIncrementAuthorizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntentsIntentIncrementAuthorization(
          input,
          postPaymentIntentsIntentIncrementAuthorization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentIncrementAuthorization.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentIntentsIntentVerifyMicrodepositsParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postPaymentIntentsIntentVerifyMicrodepositsBodySchema = z
    .object({
      amounts: z.array(z.coerce.number()).optional(),
      client_secret: z.string().max(5000).optional(),
      descriptor_code: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postPaymentIntentsIntentVerifyMicrodeposits",
    "/v1/payment_intents/:intent/verify_microdeposits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentIntentsIntentVerifyMicrodepositsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentIntentsIntentVerifyMicrodepositsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentIntentsIntentVerifyMicrodeposits(
          input,
          postPaymentIntentsIntentVerifyMicrodeposits.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentIntentsIntentVerifyMicrodeposits.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getPaymentLinksQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getPaymentLinksBodySchema = z.object({}).optional()

  router.get("getPaymentLinks", "/v1/payment_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPaymentLinksQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPaymentLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPaymentLinks(input, getPaymentLinks.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPaymentLinks.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPaymentLinksBodySchema = z.object({
    after_completion: z
      .object({
        hosted_confirmation: z
          .object({ custom_message: z.string().max(500).optional() })
          .optional(),
        redirect: z.object({ url: z.string().max(2048) }).optional(),
        type: z.enum(["hosted_confirmation", "redirect"]),
      })
      .optional(),
    allow_promotion_codes: PermissiveBoolean.optional(),
    application_fee_amount: z.coerce.number().optional(),
    application_fee_percent: z.coerce.number().optional(),
    automatic_tax: z
      .object({
        enabled: PermissiveBoolean,
        liability: z
          .object({
            account: z.string().optional(),
            type: z.enum(["account", "self"]),
          })
          .optional(),
      })
      .optional(),
    billing_address_collection: z.enum(["auto", "required"]).optional(),
    consent_collection: z
      .object({
        payment_method_reuse_agreement: z
          .object({ position: z.enum(["auto", "hidden"]) })
          .optional(),
        promotions: z.enum(["auto", "none"]).optional(),
        terms_of_service: z.enum(["none", "required"]).optional(),
      })
      .optional(),
    currency: z.string().optional(),
    custom_fields: z
      .array(
        z.object({
          dropdown: z
            .object({
              default_value: z.string().max(100).optional(),
              options: z.array(
                z.object({
                  label: z.string().max(100),
                  value: z.string().max(100),
                }),
              ),
            })
            .optional(),
          key: z.string().max(200),
          label: z.object({
            custom: z.string().max(50),
            type: z.enum(["custom"]),
          }),
          numeric: z
            .object({
              default_value: z.string().max(255).optional(),
              maximum_length: z.coerce.number().optional(),
              minimum_length: z.coerce.number().optional(),
            })
            .optional(),
          optional: PermissiveBoolean.optional(),
          text: z
            .object({
              default_value: z.string().max(255).optional(),
              maximum_length: z.coerce.number().optional(),
              minimum_length: z.coerce.number().optional(),
            })
            .optional(),
          type: z.enum(["dropdown", "numeric", "text"]),
        }),
      )
      .optional(),
    custom_text: z
      .object({
        after_submit: z
          .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
          .optional(),
        shipping_address: z
          .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
          .optional(),
        submit: z
          .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
          .optional(),
        terms_of_service_acceptance: z
          .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
          .optional(),
      })
      .optional(),
    customer_creation: z.enum(["always", "if_required"]).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    inactive_message: z.string().max(500).optional(),
    invoice_creation: z
      .object({
        enabled: PermissiveBoolean,
        invoice_data: z
          .object({
            account_tax_ids: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            custom_fields: z
              .union([
                z.array(
                  z.object({
                    name: z.string().max(40),
                    value: z.string().max(140),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            description: z.string().max(1500).optional(),
            footer: z.string().max(5000).optional(),
            issuer: z
              .object({
                account: z.string().optional(),
                type: z.enum(["account", "self"]),
              })
              .optional(),
            metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
            rendering_options: z
              .union([
                z.object({
                  amount_tax_display: z
                    .enum(["", "exclude_tax", "include_inclusive_tax"])
                    .optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
          })
          .optional(),
      })
      .optional(),
    line_items: z.array(
      z.object({
        adjustable_quantity: z
          .object({
            enabled: PermissiveBoolean,
            maximum: z.coerce.number().optional(),
            minimum: z.coerce.number().optional(),
          })
          .optional(),
        price: z.string().max(5000),
        quantity: z.coerce.number(),
      }),
    ),
    metadata: z.record(z.string()).optional(),
    on_behalf_of: z.string().optional(),
    optional_items: z
      .array(
        z.object({
          adjustable_quantity: z
            .object({
              enabled: PermissiveBoolean,
              maximum: z.coerce.number().optional(),
              minimum: z.coerce.number().optional(),
            })
            .optional(),
          price: z.string().max(5000),
          quantity: z.coerce.number(),
        }),
      )
      .optional(),
    payment_intent_data: z
      .object({
        capture_method: z
          .enum(["automatic", "automatic_async", "manual"])
          .optional(),
        description: z.string().max(1000).optional(),
        metadata: z.record(z.string()).optional(),
        setup_future_usage: z.enum(["off_session", "on_session"]).optional(),
        statement_descriptor: z.string().max(22).optional(),
        statement_descriptor_suffix: z.string().max(22).optional(),
        transfer_group: z.string().max(5000).optional(),
      })
      .optional(),
    payment_method_collection: z.enum(["always", "if_required"]).optional(),
    payment_method_types: z
      .array(
        z.enum([
          "affirm",
          "afterpay_clearpay",
          "alipay",
          "alma",
          "au_becs_debit",
          "bacs_debit",
          "bancontact",
          "billie",
          "blik",
          "boleto",
          "card",
          "cashapp",
          "eps",
          "fpx",
          "giropay",
          "grabpay",
          "ideal",
          "klarna",
          "konbini",
          "link",
          "mobilepay",
          "multibanco",
          "oxxo",
          "p24",
          "pay_by_bank",
          "paynow",
          "paypal",
          "pix",
          "promptpay",
          "satispay",
          "sepa_debit",
          "sofort",
          "swish",
          "twint",
          "us_bank_account",
          "wechat_pay",
          "zip",
        ]),
      )
      .optional(),
    phone_number_collection: z
      .object({ enabled: PermissiveBoolean })
      .optional(),
    restrictions: z
      .object({ completed_sessions: z.object({ limit: z.coerce.number() }) })
      .optional(),
    shipping_address_collection: z
      .object({
        allowed_countries: z.array(
          z.enum([
            "AC",
            "AD",
            "AE",
            "AF",
            "AG",
            "AI",
            "AL",
            "AM",
            "AO",
            "AQ",
            "AR",
            "AT",
            "AU",
            "AW",
            "AX",
            "AZ",
            "BA",
            "BB",
            "BD",
            "BE",
            "BF",
            "BG",
            "BH",
            "BI",
            "BJ",
            "BL",
            "BM",
            "BN",
            "BO",
            "BQ",
            "BR",
            "BS",
            "BT",
            "BV",
            "BW",
            "BY",
            "BZ",
            "CA",
            "CD",
            "CF",
            "CG",
            "CH",
            "CI",
            "CK",
            "CL",
            "CM",
            "CN",
            "CO",
            "CR",
            "CV",
            "CW",
            "CY",
            "CZ",
            "DE",
            "DJ",
            "DK",
            "DM",
            "DO",
            "DZ",
            "EC",
            "EE",
            "EG",
            "EH",
            "ER",
            "ES",
            "ET",
            "FI",
            "FJ",
            "FK",
            "FO",
            "FR",
            "GA",
            "GB",
            "GD",
            "GE",
            "GF",
            "GG",
            "GH",
            "GI",
            "GL",
            "GM",
            "GN",
            "GP",
            "GQ",
            "GR",
            "GS",
            "GT",
            "GU",
            "GW",
            "GY",
            "HK",
            "HN",
            "HR",
            "HT",
            "HU",
            "ID",
            "IE",
            "IL",
            "IM",
            "IN",
            "IO",
            "IQ",
            "IS",
            "IT",
            "JE",
            "JM",
            "JO",
            "JP",
            "KE",
            "KG",
            "KH",
            "KI",
            "KM",
            "KN",
            "KR",
            "KW",
            "KY",
            "KZ",
            "LA",
            "LB",
            "LC",
            "LI",
            "LK",
            "LR",
            "LS",
            "LT",
            "LU",
            "LV",
            "LY",
            "MA",
            "MC",
            "MD",
            "ME",
            "MF",
            "MG",
            "MK",
            "ML",
            "MM",
            "MN",
            "MO",
            "MQ",
            "MR",
            "MS",
            "MT",
            "MU",
            "MV",
            "MW",
            "MX",
            "MY",
            "MZ",
            "NA",
            "NC",
            "NE",
            "NG",
            "NI",
            "NL",
            "NO",
            "NP",
            "NR",
            "NU",
            "NZ",
            "OM",
            "PA",
            "PE",
            "PF",
            "PG",
            "PH",
            "PK",
            "PL",
            "PM",
            "PN",
            "PR",
            "PS",
            "PT",
            "PY",
            "QA",
            "RE",
            "RO",
            "RS",
            "RU",
            "RW",
            "SA",
            "SB",
            "SC",
            "SD",
            "SE",
            "SG",
            "SH",
            "SI",
            "SJ",
            "SK",
            "SL",
            "SM",
            "SN",
            "SO",
            "SR",
            "SS",
            "ST",
            "SV",
            "SX",
            "SZ",
            "TA",
            "TC",
            "TD",
            "TF",
            "TG",
            "TH",
            "TJ",
            "TK",
            "TL",
            "TM",
            "TN",
            "TO",
            "TR",
            "TT",
            "TV",
            "TW",
            "TZ",
            "UA",
            "UG",
            "US",
            "UY",
            "UZ",
            "VA",
            "VC",
            "VE",
            "VG",
            "VN",
            "VU",
            "WF",
            "WS",
            "XK",
            "YE",
            "YT",
            "ZA",
            "ZM",
            "ZW",
            "ZZ",
          ]),
        ),
      })
      .optional(),
    shipping_options: z
      .array(z.object({ shipping_rate: z.string().max(5000).optional() }))
      .optional(),
    submit_type: z
      .enum(["auto", "book", "donate", "pay", "subscribe"])
      .optional(),
    subscription_data: z
      .object({
        description: z.string().max(500).optional(),
        invoice_settings: z
          .object({
            issuer: z
              .object({
                account: z.string().optional(),
                type: z.enum(["account", "self"]),
              })
              .optional(),
          })
          .optional(),
        metadata: z.record(z.string()).optional(),
        trial_period_days: z.coerce.number().optional(),
        trial_settings: z
          .object({
            end_behavior: z.object({
              missing_payment_method: z.enum([
                "cancel",
                "create_invoice",
                "pause",
              ]),
            }),
          })
          .optional(),
      })
      .optional(),
    tax_id_collection: z
      .object({
        enabled: PermissiveBoolean,
        required: z.enum(["if_supported", "never"]).optional(),
      })
      .optional(),
    transfer_data: z
      .object({ amount: z.coerce.number().optional(), destination: z.string() })
      .optional(),
  })

  router.post("postPaymentLinks", "/v1/payment_links", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPaymentLinksBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postPaymentLinks(input, postPaymentLinks.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPaymentLinks.validator(status, body)
    ctx.status = status
    return next()
  })

  const getPaymentLinksPaymentLinkParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  const getPaymentLinksPaymentLinkQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPaymentLinksPaymentLinkBodySchema = z.object({}).optional()

  router.get(
    "getPaymentLinksPaymentLink",
    "/v1/payment_links/:payment_link",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentLinksPaymentLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentLinksPaymentLinkQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentLinksPaymentLinkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentLinksPaymentLink(
          input,
          getPaymentLinksPaymentLink.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentLinksPaymentLink.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentLinksPaymentLinkParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  const postPaymentLinksPaymentLinkBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      after_completion: z
        .object({
          hosted_confirmation: z
            .object({ custom_message: z.string().max(500).optional() })
            .optional(),
          redirect: z.object({ url: z.string().max(2048) }).optional(),
          type: z.enum(["hosted_confirmation", "redirect"]),
        })
        .optional(),
      allow_promotion_codes: PermissiveBoolean.optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      billing_address_collection: z.enum(["auto", "required"]).optional(),
      custom_fields: z
        .union([
          z.array(
            z.object({
              dropdown: z
                .object({
                  default_value: z.string().max(100).optional(),
                  options: z.array(
                    z.object({
                      label: z.string().max(100),
                      value: z.string().max(100),
                    }),
                  ),
                })
                .optional(),
              key: z.string().max(200),
              label: z.object({
                custom: z.string().max(50),
                type: z.enum(["custom"]),
              }),
              numeric: z
                .object({
                  default_value: z.string().max(255).optional(),
                  maximum_length: z.coerce.number().optional(),
                  minimum_length: z.coerce.number().optional(),
                })
                .optional(),
              optional: PermissiveBoolean.optional(),
              text: z
                .object({
                  default_value: z.string().max(255).optional(),
                  maximum_length: z.coerce.number().optional(),
                  minimum_length: z.coerce.number().optional(),
                })
                .optional(),
              type: z.enum(["dropdown", "numeric", "text"]),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      custom_text: z
        .object({
          after_submit: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
          shipping_address: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
          submit: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
          terms_of_service_acceptance: z
            .union([z.object({ message: z.string().max(1200) }), z.enum([""])])
            .optional(),
        })
        .optional(),
      customer_creation: z.enum(["always", "if_required"]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      inactive_message: z.union([z.string().max(500), z.enum([""])]).optional(),
      invoice_creation: z
        .object({
          enabled: PermissiveBoolean,
          invoice_data: z
            .object({
              account_tax_ids: z
                .union([z.array(z.string().max(5000)), z.enum([""])])
                .optional(),
              custom_fields: z
                .union([
                  z.array(
                    z.object({
                      name: z.string().max(40),
                      value: z.string().max(140),
                    }),
                  ),
                  z.enum([""]),
                ])
                .optional(),
              description: z.string().max(1500).optional(),
              footer: z.string().max(5000).optional(),
              issuer: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
              metadata: z
                .union([z.record(z.string()), z.enum([""])])
                .optional(),
              rendering_options: z
                .union([
                  z.object({
                    amount_tax_display: z
                      .enum(["", "exclude_tax", "include_inclusive_tax"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      line_items: z
        .array(
          z.object({
            adjustable_quantity: z
              .object({
                enabled: PermissiveBoolean,
                maximum: z.coerce.number().optional(),
                minimum: z.coerce.number().optional(),
              })
              .optional(),
            id: z.string().max(5000),
            quantity: z.coerce.number().optional(),
          }),
        )
        .optional(),
      metadata: z.record(z.string()).optional(),
      payment_intent_data: z
        .object({
          description: z.union([z.string().max(1000), z.enum([""])]).optional(),
          metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
          statement_descriptor: z
            .union([z.string().max(22), z.enum([""])])
            .optional(),
          statement_descriptor_suffix: z
            .union([z.string().max(22), z.enum([""])])
            .optional(),
          transfer_group: z
            .union([z.string().max(5000), z.enum([""])])
            .optional(),
        })
        .optional(),
      payment_method_collection: z.enum(["always", "if_required"]).optional(),
      payment_method_types: z
        .union([
          z.array(
            z.enum([
              "affirm",
              "afterpay_clearpay",
              "alipay",
              "alma",
              "au_becs_debit",
              "bacs_debit",
              "bancontact",
              "billie",
              "blik",
              "boleto",
              "card",
              "cashapp",
              "eps",
              "fpx",
              "giropay",
              "grabpay",
              "ideal",
              "klarna",
              "konbini",
              "link",
              "mobilepay",
              "multibanco",
              "oxxo",
              "p24",
              "pay_by_bank",
              "paynow",
              "paypal",
              "pix",
              "promptpay",
              "satispay",
              "sepa_debit",
              "sofort",
              "swish",
              "twint",
              "us_bank_account",
              "wechat_pay",
              "zip",
            ]),
          ),
          z.enum([""]),
        ])
        .optional(),
      phone_number_collection: z
        .object({ enabled: PermissiveBoolean })
        .optional(),
      restrictions: z
        .union([
          z.object({
            completed_sessions: z.object({ limit: z.coerce.number() }),
          }),
          z.enum([""]),
        ])
        .optional(),
      shipping_address_collection: z
        .union([
          z.object({
            allowed_countries: z.array(
              z.enum([
                "AC",
                "AD",
                "AE",
                "AF",
                "AG",
                "AI",
                "AL",
                "AM",
                "AO",
                "AQ",
                "AR",
                "AT",
                "AU",
                "AW",
                "AX",
                "AZ",
                "BA",
                "BB",
                "BD",
                "BE",
                "BF",
                "BG",
                "BH",
                "BI",
                "BJ",
                "BL",
                "BM",
                "BN",
                "BO",
                "BQ",
                "BR",
                "BS",
                "BT",
                "BV",
                "BW",
                "BY",
                "BZ",
                "CA",
                "CD",
                "CF",
                "CG",
                "CH",
                "CI",
                "CK",
                "CL",
                "CM",
                "CN",
                "CO",
                "CR",
                "CV",
                "CW",
                "CY",
                "CZ",
                "DE",
                "DJ",
                "DK",
                "DM",
                "DO",
                "DZ",
                "EC",
                "EE",
                "EG",
                "EH",
                "ER",
                "ES",
                "ET",
                "FI",
                "FJ",
                "FK",
                "FO",
                "FR",
                "GA",
                "GB",
                "GD",
                "GE",
                "GF",
                "GG",
                "GH",
                "GI",
                "GL",
                "GM",
                "GN",
                "GP",
                "GQ",
                "GR",
                "GS",
                "GT",
                "GU",
                "GW",
                "GY",
                "HK",
                "HN",
                "HR",
                "HT",
                "HU",
                "ID",
                "IE",
                "IL",
                "IM",
                "IN",
                "IO",
                "IQ",
                "IS",
                "IT",
                "JE",
                "JM",
                "JO",
                "JP",
                "KE",
                "KG",
                "KH",
                "KI",
                "KM",
                "KN",
                "KR",
                "KW",
                "KY",
                "KZ",
                "LA",
                "LB",
                "LC",
                "LI",
                "LK",
                "LR",
                "LS",
                "LT",
                "LU",
                "LV",
                "LY",
                "MA",
                "MC",
                "MD",
                "ME",
                "MF",
                "MG",
                "MK",
                "ML",
                "MM",
                "MN",
                "MO",
                "MQ",
                "MR",
                "MS",
                "MT",
                "MU",
                "MV",
                "MW",
                "MX",
                "MY",
                "MZ",
                "NA",
                "NC",
                "NE",
                "NG",
                "NI",
                "NL",
                "NO",
                "NP",
                "NR",
                "NU",
                "NZ",
                "OM",
                "PA",
                "PE",
                "PF",
                "PG",
                "PH",
                "PK",
                "PL",
                "PM",
                "PN",
                "PR",
                "PS",
                "PT",
                "PY",
                "QA",
                "RE",
                "RO",
                "RS",
                "RU",
                "RW",
                "SA",
                "SB",
                "SC",
                "SD",
                "SE",
                "SG",
                "SH",
                "SI",
                "SJ",
                "SK",
                "SL",
                "SM",
                "SN",
                "SO",
                "SR",
                "SS",
                "ST",
                "SV",
                "SX",
                "SZ",
                "TA",
                "TC",
                "TD",
                "TF",
                "TG",
                "TH",
                "TJ",
                "TK",
                "TL",
                "TM",
                "TN",
                "TO",
                "TR",
                "TT",
                "TV",
                "TW",
                "TZ",
                "UA",
                "UG",
                "US",
                "UY",
                "UZ",
                "VA",
                "VC",
                "VE",
                "VG",
                "VN",
                "VU",
                "WF",
                "WS",
                "XK",
                "YE",
                "YT",
                "ZA",
                "ZM",
                "ZW",
                "ZZ",
              ]),
            ),
          }),
          z.enum([""]),
        ])
        .optional(),
      submit_type: z
        .enum(["auto", "book", "donate", "pay", "subscribe"])
        .optional(),
      subscription_data: z
        .object({
          invoice_settings: z
            .object({
              issuer: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
            })
            .optional(),
          metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
          trial_period_days: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
          trial_settings: z
            .union([
              z.object({
                end_behavior: z.object({
                  missing_payment_method: z.enum([
                    "cancel",
                    "create_invoice",
                    "pause",
                  ]),
                }),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      tax_id_collection: z
        .object({
          enabled: PermissiveBoolean,
          required: z.enum(["if_supported", "never"]).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postPaymentLinksPaymentLink",
    "/v1/payment_links/:payment_link",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentLinksPaymentLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentLinksPaymentLinkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentLinksPaymentLink(
          input,
          postPaymentLinksPaymentLink.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentLinksPaymentLink.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentLinksPaymentLinkLineItemsParamSchema = z.object({
    payment_link: z.string().max(5000),
  })

  const getPaymentLinksPaymentLinkLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getPaymentLinksPaymentLinkLineItemsBodySchema = z.object({}).optional()

  router.get(
    "getPaymentLinksPaymentLinkLineItems",
    "/v1/payment_links/:payment_link/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentLinksPaymentLinkLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentLinksPaymentLinkLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentLinksPaymentLinkLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentLinksPaymentLinkLineItems(
          input,
          getPaymentLinksPaymentLinkLineItems.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentLinksPaymentLinkLineItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodConfigurationsQuerySchema = z.object({
    application: z.union([z.string().max(100), z.enum([""])]).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getPaymentMethodConfigurationsBodySchema = z.object({}).optional()

  router.get(
    "getPaymentMethodConfigurations",
    "/v1/payment_method_configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getPaymentMethodConfigurationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentMethodConfigurations(
          input,
          getPaymentMethodConfigurations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodConfigurations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodConfigurationsBodySchema = z
    .object({
      acss_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      affirm: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      afterpay_clearpay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      alipay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      alma: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      amazon_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      apple_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      apple_pay_later: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      au_becs_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      bacs_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      bancontact: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      billie: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      blik: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      boleto: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      card: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      cartes_bancaires: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      cashapp: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      customer_balance: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      eps: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      fpx: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      giropay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      google_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      grabpay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      ideal: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      jcb: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      klarna: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      konbini: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      link: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      mobilepay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      multibanco: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      name: z.string().max(100).optional(),
      nz_bank_account: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      oxxo: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      p24: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      parent: z.string().max(100).optional(),
      pay_by_bank: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      paynow: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      paypal: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      promptpay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      revolut_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      satispay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      sepa_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      sofort: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      swish: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      twint: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      us_bank_account: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      wechat_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      zip: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postPaymentMethodConfigurations",
    "/v1/payment_method_configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodConfigurations(
          input,
          postPaymentMethodConfigurations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodConfigurations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getPaymentMethodConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPaymentMethodConfigurationsConfigurationBodySchema = z
    .object({})
    .optional()

  router.get(
    "getPaymentMethodConfigurationsConfiguration",
    "/v1/payment_method_configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentMethodConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentMethodConfigurationsConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentMethodConfigurationsConfiguration(
          input,
          getPaymentMethodConfigurationsConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodConfigurationsConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const postPaymentMethodConfigurationsConfigurationBodySchema = z
    .object({
      acss_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      active: PermissiveBoolean.optional(),
      affirm: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      afterpay_clearpay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      alipay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      alma: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      amazon_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      apple_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      apple_pay_later: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      au_becs_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      bacs_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      bancontact: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      billie: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      blik: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      boleto: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      card: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      cartes_bancaires: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      cashapp: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      customer_balance: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      eps: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      fpx: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      giropay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      google_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      grabpay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      ideal: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      jcb: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      klarna: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      konbini: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      link: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      mobilepay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      multibanco: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      name: z.string().max(100).optional(),
      nz_bank_account: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      oxxo: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      p24: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      pay_by_bank: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      paynow: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      paypal: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      promptpay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      revolut_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      satispay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      sepa_debit: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      sofort: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      swish: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      twint: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      us_bank_account: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      wechat_pay: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
      zip: z
        .object({
          display_preference: z
            .object({ preference: z.enum(["none", "off", "on"]).optional() })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postPaymentMethodConfigurationsConfiguration",
    "/v1/payment_method_configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodConfigurationsConfiguration(
          input,
          postPaymentMethodConfigurationsConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodConfigurationsConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodDomainsQuerySchema = z.object({
    domain_name: z.string().max(5000).optional(),
    enabled: PermissiveBoolean.optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getPaymentMethodDomainsBodySchema = z.object({}).optional()

  router.get(
    "getPaymentMethodDomains",
    "/v1/payment_method_domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getPaymentMethodDomainsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentMethodDomains(input, getPaymentMethodDomains.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodDomains.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodDomainsBodySchema = z.object({
    domain_name: z.string().max(5000),
    enabled: PermissiveBoolean.optional(),
    expand: z.array(z.string().max(5000)).optional(),
  })

  router.post(
    "postPaymentMethodDomains",
    "/v1/payment_method_domains",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodDomainsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodDomains(
          input,
          postPaymentMethodDomains.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodDomains.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodDomainsPaymentMethodDomainParamSchema = z.object({
    payment_method_domain: z.string().max(5000),
  })

  const getPaymentMethodDomainsPaymentMethodDomainQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPaymentMethodDomainsPaymentMethodDomainBodySchema = z
    .object({})
    .optional()

  router.get(
    "getPaymentMethodDomainsPaymentMethodDomain",
    "/v1/payment_method_domains/:payment_method_domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentMethodDomainsPaymentMethodDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentMethodDomainsPaymentMethodDomainQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodDomainsPaymentMethodDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentMethodDomainsPaymentMethodDomain(
          input,
          getPaymentMethodDomainsPaymentMethodDomain.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodDomainsPaymentMethodDomain.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodDomainsPaymentMethodDomainParamSchema = z.object({
    payment_method_domain: z.string().max(5000),
  })

  const postPaymentMethodDomainsPaymentMethodDomainBodySchema = z
    .object({
      enabled: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postPaymentMethodDomainsPaymentMethodDomain",
    "/v1/payment_method_domains/:payment_method_domain",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodDomainsPaymentMethodDomain(
          input,
          postPaymentMethodDomainsPaymentMethodDomain.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodDomainsPaymentMethodDomain.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodDomainsPaymentMethodDomainValidateParamSchema =
    z.object({ payment_method_domain: z.string().max(5000) })

  const postPaymentMethodDomainsPaymentMethodDomainValidateBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postPaymentMethodDomainsPaymentMethodDomainValidate",
    "/v1/payment_method_domains/:payment_method_domain/validate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainValidateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodDomainsPaymentMethodDomainValidateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodDomainsPaymentMethodDomainValidate(
          input,
          postPaymentMethodDomainsPaymentMethodDomainValidate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodDomainsPaymentMethodDomainValidate.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodsQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    type: z
      .enum([
        "acss_debit",
        "affirm",
        "afterpay_clearpay",
        "alipay",
        "alma",
        "amazon_pay",
        "au_becs_debit",
        "bacs_debit",
        "bancontact",
        "billie",
        "blik",
        "boleto",
        "card",
        "cashapp",
        "customer_balance",
        "eps",
        "fpx",
        "giropay",
        "grabpay",
        "ideal",
        "kakao_pay",
        "klarna",
        "konbini",
        "kr_card",
        "link",
        "mobilepay",
        "multibanco",
        "naver_pay",
        "nz_bank_account",
        "oxxo",
        "p24",
        "pay_by_bank",
        "payco",
        "paynow",
        "paypal",
        "pix",
        "promptpay",
        "revolut_pay",
        "samsung_pay",
        "satispay",
        "sepa_debit",
        "sofort",
        "swish",
        "twint",
        "us_bank_account",
        "wechat_pay",
        "zip",
      ])
      .optional(),
  })

  const getPaymentMethodsBodySchema = z.object({}).optional()

  router.get("getPaymentMethods", "/v1/payment_methods", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPaymentMethodsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPaymentMethodsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPaymentMethods(input, getPaymentMethods.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPaymentMethods.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPaymentMethodsBodySchema = z
    .object({
      acss_debit: z
        .object({
          account_number: z.string().max(5000),
          institution_number: z.string().max(5000),
          transit_number: z.string().max(5000),
        })
        .optional(),
      affirm: z.object({}).optional(),
      afterpay_clearpay: z.object({}).optional(),
      alipay: z.object({}).optional(),
      allow_redisplay: z.enum(["always", "limited", "unspecified"]).optional(),
      alma: z.object({}).optional(),
      amazon_pay: z.object({}).optional(),
      au_becs_debit: z
        .object({
          account_number: z.string().max(5000),
          bsb_number: z.string().max(5000),
        })
        .optional(),
      bacs_debit: z
        .object({
          account_number: z.string().max(5000).optional(),
          sort_code: z.string().max(5000).optional(),
        })
        .optional(),
      bancontact: z.object({}).optional(),
      billie: z.object({}).optional(),
      billing_details: z
        .object({
          address: z
            .union([
              z.object({
                city: z.string().max(5000).optional(),
                country: z.string().max(5000).optional(),
                line1: z.string().max(5000).optional(),
                line2: z.string().max(5000).optional(),
                postal_code: z.string().max(5000).optional(),
                state: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          email: z.union([z.string(), z.enum([""])]).optional(),
          name: z.union([z.string().max(5000), z.enum([""])]).optional(),
          phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
        })
        .optional(),
      blik: z.object({}).optional(),
      boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
      card: z
        .union([
          z.object({
            cvc: z.string().max(5000).optional(),
            exp_month: z.coerce.number(),
            exp_year: z.coerce.number(),
            networks: z
              .object({
                preferred: z
                  .enum(["cartes_bancaires", "mastercard", "visa"])
                  .optional(),
              })
              .optional(),
            number: z.string().max(5000),
          }),
          z.object({ token: z.string().max(5000) }),
        ])
        .optional(),
      cashapp: z.object({}).optional(),
      customer: z.string().max(5000).optional(),
      customer_balance: z.object({}).optional(),
      eps: z
        .object({
          bank: z
            .enum([
              "arzte_und_apotheker_bank",
              "austrian_anadi_bank_ag",
              "bank_austria",
              "bankhaus_carl_spangler",
              "bankhaus_schelhammer_und_schattera_ag",
              "bawag_psk_ag",
              "bks_bank_ag",
              "brull_kallmus_bank_ag",
              "btv_vier_lander_bank",
              "capital_bank_grawe_gruppe_ag",
              "deutsche_bank_ag",
              "dolomitenbank",
              "easybank_ag",
              "erste_bank_und_sparkassen",
              "hypo_alpeadriabank_international_ag",
              "hypo_bank_burgenland_aktiengesellschaft",
              "hypo_noe_lb_fur_niederosterreich_u_wien",
              "hypo_oberosterreich_salzburg_steiermark",
              "hypo_tirol_bank_ag",
              "hypo_vorarlberg_bank_ag",
              "marchfelder_bank",
              "oberbank_ag",
              "raiffeisen_bankengruppe_osterreich",
              "schoellerbank_ag",
              "sparda_bank_wien",
              "volksbank_gruppe",
              "volkskreditbank_ag",
              "vr_bank_braunau",
            ])
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      fpx: z
        .object({
          bank: z.enum([
            "affin_bank",
            "agrobank",
            "alliance_bank",
            "ambank",
            "bank_islam",
            "bank_muamalat",
            "bank_of_china",
            "bank_rakyat",
            "bsn",
            "cimb",
            "deutsche_bank",
            "hong_leong_bank",
            "hsbc",
            "kfh",
            "maybank2e",
            "maybank2u",
            "ocbc",
            "pb_enterprise",
            "public_bank",
            "rhb",
            "standard_chartered",
            "uob",
          ]),
        })
        .optional(),
      giropay: z.object({}).optional(),
      grabpay: z.object({}).optional(),
      ideal: z
        .object({
          bank: z
            .enum([
              "abn_amro",
              "asn_bank",
              "bunq",
              "handelsbanken",
              "ing",
              "knab",
              "moneyou",
              "n26",
              "nn",
              "rabobank",
              "regiobank",
              "revolut",
              "sns_bank",
              "triodos_bank",
              "van_lanschot",
              "yoursafe",
            ])
            .optional(),
        })
        .optional(),
      interac_present: z.object({}).optional(),
      kakao_pay: z.object({}).optional(),
      klarna: z
        .object({
          dob: z
            .object({
              day: z.coerce.number(),
              month: z.coerce.number(),
              year: z.coerce.number(),
            })
            .optional(),
        })
        .optional(),
      konbini: z.object({}).optional(),
      kr_card: z.object({}).optional(),
      link: z.object({}).optional(),
      metadata: z.record(z.string()).optional(),
      mobilepay: z.object({}).optional(),
      multibanco: z.object({}).optional(),
      naver_pay: z
        .object({ funding: z.enum(["card", "points"]).optional() })
        .optional(),
      nz_bank_account: z
        .object({
          account_holder_name: z.string().max(5000).optional(),
          account_number: z.string().max(5000),
          bank_code: z.string().max(5000),
          branch_code: z.string().max(5000),
          reference: z.string().max(128).optional(),
          suffix: z.string().max(5000),
        })
        .optional(),
      oxxo: z.object({}).optional(),
      p24: z
        .object({
          bank: z
            .enum([
              "alior_bank",
              "bank_millennium",
              "bank_nowy_bfg_sa",
              "bank_pekao_sa",
              "banki_spbdzielcze",
              "blik",
              "bnp_paribas",
              "boz",
              "citi_handlowy",
              "credit_agricole",
              "envelobank",
              "etransfer_pocztowy24",
              "getin_bank",
              "ideabank",
              "ing",
              "inteligo",
              "mbank_mtransfer",
              "nest_przelew",
              "noble_pay",
              "pbac_z_ipko",
              "plus_bank",
              "santander_przelew24",
              "tmobile_usbugi_bankowe",
              "toyota_bank",
              "velobank",
              "volkswagen_bank",
            ])
            .optional(),
        })
        .optional(),
      pay_by_bank: z.object({}).optional(),
      payco: z.object({}).optional(),
      payment_method: z.string().max(5000).optional(),
      paynow: z.object({}).optional(),
      paypal: z.object({}).optional(),
      pix: z.object({}).optional(),
      promptpay: z.object({}).optional(),
      radar_options: z
        .object({ session: z.string().max(5000).optional() })
        .optional(),
      revolut_pay: z.object({}).optional(),
      samsung_pay: z.object({}).optional(),
      satispay: z.object({}).optional(),
      sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
      sofort: z
        .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
        .optional(),
      swish: z.object({}).optional(),
      twint: z.object({}).optional(),
      type: z
        .enum([
          "acss_debit",
          "affirm",
          "afterpay_clearpay",
          "alipay",
          "alma",
          "amazon_pay",
          "au_becs_debit",
          "bacs_debit",
          "bancontact",
          "billie",
          "blik",
          "boleto",
          "card",
          "cashapp",
          "customer_balance",
          "eps",
          "fpx",
          "giropay",
          "grabpay",
          "ideal",
          "kakao_pay",
          "klarna",
          "konbini",
          "kr_card",
          "link",
          "mobilepay",
          "multibanco",
          "naver_pay",
          "nz_bank_account",
          "oxxo",
          "p24",
          "pay_by_bank",
          "payco",
          "paynow",
          "paypal",
          "pix",
          "promptpay",
          "revolut_pay",
          "samsung_pay",
          "satispay",
          "sepa_debit",
          "sofort",
          "swish",
          "twint",
          "us_bank_account",
          "wechat_pay",
          "zip",
        ])
        .optional(),
      us_bank_account: z
        .object({
          account_holder_type: z.enum(["company", "individual"]).optional(),
          account_number: z.string().max(5000).optional(),
          account_type: z.enum(["checking", "savings"]).optional(),
          financial_connections_account: z.string().max(5000).optional(),
          routing_number: z.string().max(5000).optional(),
        })
        .optional(),
      wechat_pay: z.object({}).optional(),
      zip: z.object({}).optional(),
    })
    .optional()

  router.post(
    "postPaymentMethods",
    "/v1/payment_methods",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethods(input, postPaymentMethods.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethods.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPaymentMethodsPaymentMethodParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  const getPaymentMethodsPaymentMethodQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPaymentMethodsPaymentMethodBodySchema = z.object({}).optional()

  router.get(
    "getPaymentMethodsPaymentMethod",
    "/v1/payment_methods/:payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPaymentMethodsPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPaymentMethodsPaymentMethodQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPaymentMethodsPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPaymentMethodsPaymentMethod(
          input,
          getPaymentMethodsPaymentMethod.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPaymentMethodsPaymentMethod.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodsPaymentMethodParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  const postPaymentMethodsPaymentMethodBodySchema = z
    .object({
      allow_redisplay: z.enum(["always", "limited", "unspecified"]).optional(),
      billing_details: z
        .object({
          address: z
            .union([
              z.object({
                city: z.string().max(5000).optional(),
                country: z.string().max(5000).optional(),
                line1: z.string().max(5000).optional(),
                line2: z.string().max(5000).optional(),
                postal_code: z.string().max(5000).optional(),
                state: z.string().max(5000).optional(),
              }),
              z.enum([""]),
            ])
            .optional(),
          email: z.union([z.string(), z.enum([""])]).optional(),
          name: z.union([z.string().max(5000), z.enum([""])]).optional(),
          phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
        })
        .optional(),
      card: z
        .object({
          exp_month: z.coerce.number().optional(),
          exp_year: z.coerce.number().optional(),
          networks: z
            .object({
              preferred: z
                .enum(["", "cartes_bancaires", "mastercard", "visa"])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      link: z.object({}).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      pay_by_bank: z.object({}).optional(),
      us_bank_account: z
        .object({
          account_holder_type: z.enum(["company", "individual"]).optional(),
          account_type: z.enum(["checking", "savings"]).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postPaymentMethodsPaymentMethod",
    "/v1/payment_methods/:payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodsPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodsPaymentMethod(
          input,
          postPaymentMethodsPaymentMethod.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodsPaymentMethod.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodsPaymentMethodAttachParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  const postPaymentMethodsPaymentMethodAttachBodySchema = z.object({
    customer: z.string().max(5000),
    expand: z.array(z.string().max(5000)).optional(),
  })

  router.post(
    "postPaymentMethodsPaymentMethodAttach",
    "/v1/payment_methods/:payment_method/attach",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodsPaymentMethodAttachParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsPaymentMethodAttachBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodsPaymentMethodAttach(
          input,
          postPaymentMethodsPaymentMethodAttach.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodsPaymentMethodAttach.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPaymentMethodsPaymentMethodDetachParamSchema = z.object({
    payment_method: z.string().max(5000),
  })

  const postPaymentMethodsPaymentMethodDetachBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postPaymentMethodsPaymentMethodDetach",
    "/v1/payment_methods/:payment_method/detach",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPaymentMethodsPaymentMethodDetachParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPaymentMethodsPaymentMethodDetachBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPaymentMethodsPaymentMethodDetach(
          input,
          postPaymentMethodsPaymentMethodDetach.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPaymentMethodsPaymentMethodDetach.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPayoutsQuerySchema = z.object({
    arrival_date: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    destination: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.string().max(5000).optional(),
  })

  const getPayoutsBodySchema = z.object({}).optional()

  router.get("getPayouts", "/v1/payouts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPayoutsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPayoutsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPayouts(input, getPayouts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPayouts.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPayoutsBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    description: z.string().max(5000).optional(),
    destination: z.string().optional(),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    method: z.enum(["instant", "standard"]).optional(),
    source_type: z.enum(["bank_account", "card", "fpx"]).optional(),
    statement_descriptor: z.string().max(22).optional(),
  })

  router.post("postPayouts", "/v1/payouts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPayoutsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postPayouts(input, postPayouts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPayouts.validator(status, body)
    ctx.status = status
    return next()
  })

  const getPayoutsPayoutParamSchema = z.object({ payout: z.string().max(5000) })

  const getPayoutsPayoutQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPayoutsPayoutBodySchema = z.object({}).optional()

  router.get("getPayoutsPayout", "/v1/payouts/:payout", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPayoutsPayoutParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getPayoutsPayoutQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPayoutsPayoutBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPayoutsPayout(input, getPayoutsPayout.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPayoutsPayout.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPayoutsPayoutParamSchema = z.object({
    payout: z.string().max(5000),
  })

  const postPayoutsPayoutBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post("postPayoutsPayout", "/v1/payouts/:payout", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postPayoutsPayoutParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postPayoutsPayoutBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postPayoutsPayout(input, postPayoutsPayout.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPayoutsPayout.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPayoutsPayoutCancelParamSchema = z.object({
    payout: z.string().max(5000),
  })

  const postPayoutsPayoutCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postPayoutsPayoutCancel",
    "/v1/payouts/:payout/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPayoutsPayoutCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPayoutsPayoutCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPayoutsPayoutCancel(input, postPayoutsPayoutCancel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPayoutsPayoutCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPayoutsPayoutReverseParamSchema = z.object({
    payout: z.string().max(5000),
  })

  const postPayoutsPayoutReverseBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
    })
    .optional()

  router.post(
    "postPayoutsPayoutReverse",
    "/v1/payouts/:payout/reverse",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPayoutsPayoutReverseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPayoutsPayoutReverseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPayoutsPayoutReverse(
          input,
          postPayoutsPayoutReverse.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPayoutsPayoutReverse.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPlansQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    product: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getPlansBodySchema = z.object({}).optional()

  router.get("getPlans", "/v1/plans", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPlansQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPlansBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPlans(input, getPlans.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPlans.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPlansBodySchema = z.object({
    active: PermissiveBoolean.optional(),
    amount: z.coerce.number().optional(),
    amount_decimal: z.string().optional(),
    billing_scheme: z.enum(["per_unit", "tiered"]).optional(),
    currency: z.string(),
    expand: z.array(z.string().max(5000)).optional(),
    id: z.string().max(5000).optional(),
    interval: z.enum(["day", "month", "week", "year"]),
    interval_count: z.coerce.number().optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    meter: z.string().max(5000).optional(),
    nickname: z.string().max(5000).optional(),
    product: z
      .union([
        z.object({
          active: PermissiveBoolean.optional(),
          id: z.string().max(5000).optional(),
          metadata: z.record(z.string()).optional(),
          name: z.string().max(5000),
          statement_descriptor: z.string().max(22).optional(),
          tax_code: z.string().max(5000).optional(),
          unit_label: z.string().max(12).optional(),
        }),
        z.string().max(5000),
      ])
      .optional(),
    tiers: z
      .array(
        z.object({
          flat_amount: z.coerce.number().optional(),
          flat_amount_decimal: z.string().optional(),
          unit_amount: z.coerce.number().optional(),
          unit_amount_decimal: z.string().optional(),
          up_to: z.union([z.enum(["inf"]), z.coerce.number()]),
        }),
      )
      .optional(),
    tiers_mode: z.enum(["graduated", "volume"]).optional(),
    transform_usage: z
      .object({ divide_by: z.coerce.number(), round: z.enum(["down", "up"]) })
      .optional(),
    trial_period_days: z.coerce.number().optional(),
    usage_type: z.enum(["licensed", "metered"]).optional(),
  })

  router.post("postPlans", "/v1/plans", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPlansBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postPlans(input, postPlans.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPlans.validator(status, body)
    ctx.status = status
    return next()
  })

  const deletePlansPlanParamSchema = z.object({ plan: z.string().max(5000) })

  const deletePlansPlanBodySchema = z.object({}).optional()

  router.delete("deletePlansPlan", "/v1/plans/:plan", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deletePlansPlanParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        deletePlansPlanBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .deletePlansPlan(input, deletePlansPlan.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deletePlansPlan.validator(status, body)
    ctx.status = status
    return next()
  })

  const getPlansPlanParamSchema = z.object({ plan: z.string().max(5000) })

  const getPlansPlanQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPlansPlanBodySchema = z.object({}).optional()

  router.get("getPlansPlan", "/v1/plans/:plan", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPlansPlanParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getPlansPlanQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPlansPlanBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPlansPlan(input, getPlansPlan.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPlansPlan.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPlansPlanParamSchema = z.object({ plan: z.string().max(5000) })

  const postPlansPlanBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      nickname: z.string().max(5000).optional(),
      product: z.string().max(5000).optional(),
      trial_period_days: z.coerce.number().optional(),
    })
    .optional()

  router.post("postPlansPlan", "/v1/plans/:plan", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postPlansPlanParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postPlansPlanBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postPlansPlan(input, postPlansPlan.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPlansPlan.validator(status, body)
    ctx.status = status
    return next()
  })

  const getPricesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    lookup_keys: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    product: z.string().max(5000).optional(),
    recurring: z
      .object({
        interval: z.enum(["day", "month", "week", "year"]).optional(),
        meter: z.string().max(5000).optional(),
        usage_type: z.enum(["licensed", "metered"]).optional(),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    type: z.enum(["one_time", "recurring"]).optional(),
  })

  const getPricesBodySchema = z.object({}).optional()

  router.get("getPrices", "/v1/prices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPricesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPricesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPrices(input, getPrices.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPrices.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPricesBodySchema = z.object({
    active: PermissiveBoolean.optional(),
    billing_scheme: z.enum(["per_unit", "tiered"]).optional(),
    currency: z.string(),
    currency_options: z
      .record(
        z.object({
          custom_unit_amount: z
            .object({
              enabled: PermissiveBoolean,
              maximum: z.coerce.number().optional(),
              minimum: z.coerce.number().optional(),
              preset: z.coerce.number().optional(),
            })
            .optional(),
          tax_behavior: z
            .enum(["exclusive", "inclusive", "unspecified"])
            .optional(),
          tiers: z
            .array(
              z.object({
                flat_amount: z.coerce.number().optional(),
                flat_amount_decimal: z.string().optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
                up_to: z.union([z.enum(["inf"]), z.coerce.number()]),
              }),
            )
            .optional(),
          unit_amount: z.coerce.number().optional(),
          unit_amount_decimal: z.string().optional(),
        }),
      )
      .optional(),
    custom_unit_amount: z
      .object({
        enabled: PermissiveBoolean,
        maximum: z.coerce.number().optional(),
        minimum: z.coerce.number().optional(),
        preset: z.coerce.number().optional(),
      })
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    lookup_key: z.string().max(200).optional(),
    metadata: z.record(z.string()).optional(),
    nickname: z.string().max(5000).optional(),
    product: z.string().max(5000).optional(),
    product_data: z
      .object({
        active: PermissiveBoolean.optional(),
        id: z.string().max(5000).optional(),
        metadata: z.record(z.string()).optional(),
        name: z.string().max(5000),
        statement_descriptor: z.string().max(22).optional(),
        tax_code: z.string().max(5000).optional(),
        unit_label: z.string().max(12).optional(),
      })
      .optional(),
    recurring: z
      .object({
        interval: z.enum(["day", "month", "week", "year"]),
        interval_count: z.coerce.number().optional(),
        meter: z.string().max(5000).optional(),
        usage_type: z.enum(["licensed", "metered"]).optional(),
      })
      .optional(),
    tax_behavior: z.enum(["exclusive", "inclusive", "unspecified"]).optional(),
    tiers: z
      .array(
        z.object({
          flat_amount: z.coerce.number().optional(),
          flat_amount_decimal: z.string().optional(),
          unit_amount: z.coerce.number().optional(),
          unit_amount_decimal: z.string().optional(),
          up_to: z.union([z.enum(["inf"]), z.coerce.number()]),
        }),
      )
      .optional(),
    tiers_mode: z.enum(["graduated", "volume"]).optional(),
    transfer_lookup_key: PermissiveBoolean.optional(),
    transform_quantity: z
      .object({ divide_by: z.coerce.number(), round: z.enum(["down", "up"]) })
      .optional(),
    unit_amount: z.coerce.number().optional(),
    unit_amount_decimal: z.string().optional(),
  })

  router.post("postPrices", "/v1/prices", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postPricesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postPrices(input, postPrices.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPrices.validator(status, body)
    ctx.status = status
    return next()
  })

  const getPricesSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  const getPricesSearchBodySchema = z.object({}).optional()

  router.get("getPricesSearch", "/v1/prices/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPricesSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPricesSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPricesSearch(input, getPricesSearch.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPricesSearch.validator(status, body)
    ctx.status = status
    return next()
  })

  const getPricesPriceParamSchema = z.object({ price: z.string().max(5000) })

  const getPricesPriceQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPricesPriceBodySchema = z.object({}).optional()

  router.get("getPricesPrice", "/v1/prices/:price", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPricesPriceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getPricesPriceQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPricesPriceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPricesPrice(input, getPricesPrice.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPricesPrice.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPricesPriceParamSchema = z.object({ price: z.string().max(5000) })

  const postPricesPriceBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      currency_options: z
        .union([
          z.record(
            z.object({
              custom_unit_amount: z
                .object({
                  enabled: PermissiveBoolean,
                  maximum: z.coerce.number().optional(),
                  minimum: z.coerce.number().optional(),
                  preset: z.coerce.number().optional(),
                })
                .optional(),
              tax_behavior: z
                .enum(["exclusive", "inclusive", "unspecified"])
                .optional(),
              tiers: z
                .array(
                  z.object({
                    flat_amount: z.coerce.number().optional(),
                    flat_amount_decimal: z.string().optional(),
                    unit_amount: z.coerce.number().optional(),
                    unit_amount_decimal: z.string().optional(),
                    up_to: z.union([z.enum(["inf"]), z.coerce.number()]),
                  }),
                )
                .optional(),
              unit_amount: z.coerce.number().optional(),
              unit_amount_decimal: z.string().optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      lookup_key: z.string().max(200).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      nickname: z.string().max(5000).optional(),
      tax_behavior: z
        .enum(["exclusive", "inclusive", "unspecified"])
        .optional(),
      transfer_lookup_key: PermissiveBoolean.optional(),
    })
    .optional()

  router.post("postPricesPrice", "/v1/prices/:price", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postPricesPriceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postPricesPriceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postPricesPrice(input, postPricesPrice.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postPricesPrice.validator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    ids: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    shippable: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
    url: z.string().max(5000).optional(),
  })

  const getProductsBodySchema = z.object({}).optional()

  router.get("getProducts", "/v1/products", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getProductsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getProductsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getProducts(input, getProducts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getProducts.validator(status, body)
    ctx.status = status
    return next()
  })

  const postProductsBodySchema = z.object({
    active: PermissiveBoolean.optional(),
    default_price_data: z
      .object({
        currency: z.string(),
        currency_options: z
          .record(
            z.object({
              custom_unit_amount: z
                .object({
                  enabled: PermissiveBoolean,
                  maximum: z.coerce.number().optional(),
                  minimum: z.coerce.number().optional(),
                  preset: z.coerce.number().optional(),
                })
                .optional(),
              tax_behavior: z
                .enum(["exclusive", "inclusive", "unspecified"])
                .optional(),
              tiers: z
                .array(
                  z.object({
                    flat_amount: z.coerce.number().optional(),
                    flat_amount_decimal: z.string().optional(),
                    unit_amount: z.coerce.number().optional(),
                    unit_amount_decimal: z.string().optional(),
                    up_to: z.union([z.enum(["inf"]), z.coerce.number()]),
                  }),
                )
                .optional(),
              unit_amount: z.coerce.number().optional(),
              unit_amount_decimal: z.string().optional(),
            }),
          )
          .optional(),
        custom_unit_amount: z
          .object({
            enabled: PermissiveBoolean,
            maximum: z.coerce.number().optional(),
            minimum: z.coerce.number().optional(),
            preset: z.coerce.number().optional(),
          })
          .optional(),
        metadata: z.record(z.string()).optional(),
        recurring: z
          .object({
            interval: z.enum(["day", "month", "week", "year"]),
            interval_count: z.coerce.number().optional(),
          })
          .optional(),
        tax_behavior: z
          .enum(["exclusive", "inclusive", "unspecified"])
          .optional(),
        unit_amount: z.coerce.number().optional(),
        unit_amount_decimal: z.string().optional(),
      })
      .optional(),
    description: z.string().max(40000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    id: z.string().max(5000).optional(),
    images: z.array(z.string()).optional(),
    marketing_features: z
      .array(z.object({ name: z.string().max(5000) }))
      .optional(),
    metadata: z.record(z.string()).optional(),
    name: z.string().max(5000),
    package_dimensions: z
      .object({
        height: z.coerce.number(),
        length: z.coerce.number(),
        weight: z.coerce.number(),
        width: z.coerce.number(),
      })
      .optional(),
    shippable: PermissiveBoolean.optional(),
    statement_descriptor: z.string().max(22).optional(),
    tax_code: z.string().optional(),
    unit_label: z.string().max(12).optional(),
    url: z.string().max(5000).optional(),
  })

  router.post("postProducts", "/v1/products", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postProductsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postProducts(input, postProducts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postProducts.validator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  const getProductsSearchBodySchema = z.object({}).optional()

  router.get("getProductsSearch", "/v1/products/search", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getProductsSearchQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getProductsSearchBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getProductsSearch(input, getProductsSearch.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getProductsSearch.validator(status, body)
    ctx.status = status
    return next()
  })

  const deleteProductsIdParamSchema = z.object({ id: z.string().max(5000) })

  const deleteProductsIdBodySchema = z.object({}).optional()

  router.delete("deleteProductsId", "/v1/products/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deleteProductsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        deleteProductsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .deleteProductsId(input, deleteProductsId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deleteProductsId.validator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsIdParamSchema = z.object({ id: z.string().max(5000) })

  const getProductsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getProductsIdBodySchema = z.object({}).optional()

  router.get("getProductsId", "/v1/products/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getProductsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getProductsIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getProductsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getProductsId(input, getProductsId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getProductsId.validator(status, body)
    ctx.status = status
    return next()
  })

  const postProductsIdParamSchema = z.object({ id: z.string().max(5000) })

  const postProductsIdBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      default_price: z.string().max(5000).optional(),
      description: z.union([z.string().max(40000), z.enum([""])]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      images: z.union([z.array(z.string()), z.enum([""])]).optional(),
      marketing_features: z
        .union([
          z.array(z.object({ name: z.string().max(5000) })),
          z.enum([""]),
        ])
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      name: z.string().max(5000).optional(),
      package_dimensions: z
        .union([
          z.object({
            height: z.coerce.number(),
            length: z.coerce.number(),
            weight: z.coerce.number(),
            width: z.coerce.number(),
          }),
          z.enum([""]),
        ])
        .optional(),
      shippable: PermissiveBoolean.optional(),
      statement_descriptor: z.string().max(22).optional(),
      tax_code: z.union([z.string(), z.enum([""])]).optional(),
      unit_label: z.union([z.string().max(12), z.enum([""])]).optional(),
      url: z.union([z.string(), z.enum([""])]).optional(),
    })
    .optional()

  router.post("postProductsId", "/v1/products/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postProductsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postProductsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postProductsId(input, postProductsId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postProductsId.validator(status, body)
    ctx.status = status
    return next()
  })

  const getProductsProductFeaturesParamSchema = z.object({
    product: z.string().max(5000),
  })

  const getProductsProductFeaturesQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getProductsProductFeaturesBodySchema = z.object({}).optional()

  router.get(
    "getProductsProductFeatures",
    "/v1/products/:product/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getProductsProductFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getProductsProductFeaturesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getProductsProductFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getProductsProductFeatures(
          input,
          getProductsProductFeatures.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getProductsProductFeatures.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postProductsProductFeaturesParamSchema = z.object({
    product: z.string().max(5000),
  })

  const postProductsProductFeaturesBodySchema = z.object({
    entitlement_feature: z.string().max(5000),
    expand: z.array(z.string().max(5000)).optional(),
  })

  router.post(
    "postProductsProductFeatures",
    "/v1/products/:product/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postProductsProductFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postProductsProductFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postProductsProductFeatures(
          input,
          postProductsProductFeatures.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postProductsProductFeatures.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteProductsProductFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
    product: z.string().max(5000),
  })

  const deleteProductsProductFeaturesIdBodySchema = z.object({}).optional()

  router.delete(
    "deleteProductsProductFeaturesId",
    "/v1/products/:product/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteProductsProductFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteProductsProductFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteProductsProductFeaturesId(
          input,
          deleteProductsProductFeaturesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteProductsProductFeaturesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getProductsProductFeaturesIdParamSchema = z.object({
    id: z.string().max(5000),
    product: z.string().max(5000),
  })

  const getProductsProductFeaturesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getProductsProductFeaturesIdBodySchema = z.object({}).optional()

  router.get(
    "getProductsProductFeaturesId",
    "/v1/products/:product/features/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getProductsProductFeaturesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getProductsProductFeaturesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getProductsProductFeaturesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getProductsProductFeaturesId(
          input,
          getProductsProductFeaturesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getProductsProductFeaturesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPromotionCodesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    code: z.string().max(5000).optional(),
    coupon: z.string().max(5000).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getPromotionCodesBodySchema = z.object({}).optional()

  router.get("getPromotionCodes", "/v1/promotion_codes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getPromotionCodesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getPromotionCodesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getPromotionCodes(input, getPromotionCodes.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPromotionCodes.validator(status, body)
    ctx.status = status
    return next()
  })

  const postPromotionCodesBodySchema = z.object({
    active: PermissiveBoolean.optional(),
    code: z.string().max(500).optional(),
    coupon: z.string().max(5000),
    customer: z.string().max(5000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    expires_at: z.coerce.number().optional(),
    max_redemptions: z.coerce.number().optional(),
    metadata: z.record(z.string()).optional(),
    restrictions: z
      .object({
        currency_options: z
          .record(z.object({ minimum_amount: z.coerce.number().optional() }))
          .optional(),
        first_time_transaction: PermissiveBoolean.optional(),
        minimum_amount: z.coerce.number().optional(),
        minimum_amount_currency: z.string().optional(),
      })
      .optional(),
  })

  router.post(
    "postPromotionCodes",
    "/v1/promotion_codes",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postPromotionCodesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPromotionCodes(input, postPromotionCodes.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPromotionCodes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPromotionCodesPromotionCodeParamSchema = z.object({
    promotion_code: z.string().max(5000),
  })

  const getPromotionCodesPromotionCodeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getPromotionCodesPromotionCodeBodySchema = z.object({}).optional()

  router.get(
    "getPromotionCodesPromotionCode",
    "/v1/promotion_codes/:promotion_code",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getPromotionCodesPromotionCodeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getPromotionCodesPromotionCodeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getPromotionCodesPromotionCodeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getPromotionCodesPromotionCode(
          input,
          getPromotionCodesPromotionCode.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getPromotionCodesPromotionCode.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postPromotionCodesPromotionCodeParamSchema = z.object({
    promotion_code: z.string().max(5000),
  })

  const postPromotionCodesPromotionCodeBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      restrictions: z
        .object({
          currency_options: z
            .record(z.object({ minimum_amount: z.coerce.number().optional() }))
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postPromotionCodesPromotionCode",
    "/v1/promotion_codes/:promotion_code",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postPromotionCodesPromotionCodeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postPromotionCodesPromotionCodeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postPromotionCodesPromotionCode(
          input,
          postPromotionCodesPromotionCode.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postPromotionCodesPromotionCode.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuerySchema = z.object({
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["accepted", "canceled", "draft", "open"]).optional(),
    test_clock: z.string().max(5000).optional(),
  })

  const getQuotesBodySchema = z.object({}).optional()

  router.get("getQuotes", "/v1/quotes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getQuotesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getQuotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getQuotes(input, getQuotes.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getQuotes.validator(status, body)
    ctx.status = status
    return next()
  })

  const postQuotesBodySchema = z
    .object({
      application_fee_amount: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      application_fee_percent: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      collection_method: z
        .enum(["charge_automatically", "send_invoice"])
        .optional(),
      customer: z.string().max(5000).optional(),
      default_tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      description: z.union([z.string().max(500), z.enum([""])]).optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      expires_at: z.coerce.number().optional(),
      footer: z.union([z.string().max(500), z.enum([""])]).optional(),
      from_quote: z
        .object({
          is_revision: PermissiveBoolean.optional(),
          quote: z.string().max(5000),
        })
        .optional(),
      header: z.union([z.string().max(50), z.enum([""])]).optional(),
      invoice_settings: z
        .object({
          days_until_due: z.coerce.number().optional(),
          issuer: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      line_items: z
        .array(
          z.object({
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                recurring: z
                  .object({
                    interval: z.enum(["day", "month", "week", "year"]),
                    interval_count: z.coerce.number().optional(),
                  })
                  .optional(),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      metadata: z.record(z.string()).optional(),
      on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
      subscription_data: z
        .object({
          description: z.string().max(500).optional(),
          effective_date: z
            .union([
              z.enum(["current_period_end"]),
              z.coerce.number(),
              z.enum([""]),
            ])
            .optional(),
          metadata: z.record(z.string()).optional(),
          trial_period_days: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
        })
        .optional(),
      test_clock: z.string().max(5000).optional(),
      transfer_data: z
        .union([
          z.object({
            amount: z.coerce.number().optional(),
            amount_percent: z.coerce.number().optional(),
            destination: z.string(),
          }),
          z.enum([""]),
        ])
        .optional(),
    })
    .optional()

  router.post("postQuotes", "/v1/quotes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postQuotesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postQuotes(input, postQuotes.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postQuotes.validator(status, body)
    ctx.status = status
    return next()
  })

  const getQuotesQuoteParamSchema = z.object({ quote: z.string().max(5000) })

  const getQuotesQuoteQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getQuotesQuoteBodySchema = z.object({}).optional()

  router.get("getQuotesQuote", "/v1/quotes/:quote", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getQuotesQuoteParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getQuotesQuoteQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getQuotesQuoteBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getQuotesQuote(input, getQuotesQuote.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getQuotesQuote.validator(status, body)
    ctx.status = status
    return next()
  })

  const postQuotesQuoteParamSchema = z.object({ quote: z.string().max(5000) })

  const postQuotesQuoteBodySchema = z
    .object({
      application_fee_amount: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      application_fee_percent: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      collection_method: z
        .enum(["charge_automatically", "send_invoice"])
        .optional(),
      customer: z.string().max(5000).optional(),
      default_tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      description: z.union([z.string().max(500), z.enum([""])]).optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      expires_at: z.coerce.number().optional(),
      footer: z.union([z.string().max(500), z.enum([""])]).optional(),
      header: z.union([z.string().max(50), z.enum([""])]).optional(),
      invoice_settings: z
        .object({
          days_until_due: z.coerce.number().optional(),
          issuer: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      line_items: z
        .array(
          z.object({
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            id: z.string().max(5000).optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                recurring: z
                  .object({
                    interval: z.enum(["day", "month", "week", "year"]),
                    interval_count: z.coerce.number().optional(),
                  })
                  .optional(),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      metadata: z.record(z.string()).optional(),
      on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
      subscription_data: z
        .object({
          description: z.union([z.string().max(500), z.enum([""])]).optional(),
          effective_date: z
            .union([
              z.enum(["current_period_end"]),
              z.coerce.number(),
              z.enum([""]),
            ])
            .optional(),
          metadata: z.record(z.string()).optional(),
          trial_period_days: z
            .union([z.coerce.number(), z.enum([""])])
            .optional(),
        })
        .optional(),
      transfer_data: z
        .union([
          z.object({
            amount: z.coerce.number().optional(),
            amount_percent: z.coerce.number().optional(),
            destination: z.string(),
          }),
          z.enum([""]),
        ])
        .optional(),
    })
    .optional()

  router.post("postQuotesQuote", "/v1/quotes/:quote", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postQuotesQuoteParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postQuotesQuoteBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postQuotesQuote(input, postQuotesQuote.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postQuotesQuote.validator(status, body)
    ctx.status = status
    return next()
  })

  const postQuotesQuoteAcceptParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const postQuotesQuoteAcceptBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postQuotesQuoteAccept",
    "/v1/quotes/:quote/accept",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postQuotesQuoteAcceptParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postQuotesQuoteAcceptBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postQuotesQuoteAccept(input, postQuotesQuoteAccept.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postQuotesQuoteAccept.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postQuotesQuoteCancelParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const postQuotesQuoteCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postQuotesQuoteCancel",
    "/v1/quotes/:quote/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postQuotesQuoteCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postQuotesQuoteCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postQuotesQuoteCancel(input, postQuotesQuoteCancel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postQuotesQuoteCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuoteComputedUpfrontLineItemsParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const getQuotesQuoteComputedUpfrontLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getQuotesQuoteComputedUpfrontLineItemsBodySchema = z
    .object({})
    .optional()

  router.get(
    "getQuotesQuoteComputedUpfrontLineItems",
    "/v1/quotes/:quote/computed_upfront_line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getQuotesQuoteComputedUpfrontLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getQuotesQuoteComputedUpfrontLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getQuotesQuoteComputedUpfrontLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getQuotesQuoteComputedUpfrontLineItems(
          input,
          getQuotesQuoteComputedUpfrontLineItems.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getQuotesQuoteComputedUpfrontLineItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postQuotesQuoteFinalizeParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const postQuotesQuoteFinalizeBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      expires_at: z.coerce.number().optional(),
    })
    .optional()

  router.post(
    "postQuotesQuoteFinalize",
    "/v1/quotes/:quote/finalize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postQuotesQuoteFinalizeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postQuotesQuoteFinalizeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postQuotesQuoteFinalize(input, postQuotesQuoteFinalize.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postQuotesQuoteFinalize.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuoteLineItemsParamSchema = z.object({
    quote: z.string().max(5000),
  })

  const getQuotesQuoteLineItemsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getQuotesQuoteLineItemsBodySchema = z.object({}).optional()

  router.get(
    "getQuotesQuoteLineItems",
    "/v1/quotes/:quote/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getQuotesQuoteLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getQuotesQuoteLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getQuotesQuoteLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getQuotesQuoteLineItems(input, getQuotesQuoteLineItems.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getQuotesQuoteLineItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getQuotesQuotePdfParamSchema = z.object({ quote: z.string().max(5000) })

  const getQuotesQuotePdfQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getQuotesQuotePdfBodySchema = z.object({}).optional()

  router.get(
    "getQuotesQuotePdf",
    "/v1/quotes/:quote/pdf",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getQuotesQuotePdfParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getQuotesQuotePdfQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getQuotesQuotePdfBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getQuotesQuotePdf(input, getQuotesQuotePdf.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getQuotesQuotePdf.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarEarlyFraudWarningsQuerySchema = z.object({
    charge: z.string().optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getRadarEarlyFraudWarningsBodySchema = z.object({}).optional()

  router.get(
    "getRadarEarlyFraudWarnings",
    "/v1/radar/early_fraud_warnings",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getRadarEarlyFraudWarningsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarEarlyFraudWarningsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getRadarEarlyFraudWarnings(
          input,
          getRadarEarlyFraudWarnings.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarEarlyFraudWarnings.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarEarlyFraudWarningsEarlyFraudWarningParamSchema = z.object({
    early_fraud_warning: z.string().max(5000),
  })

  const getRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getRadarEarlyFraudWarningsEarlyFraudWarningBodySchema = z
    .object({})
    .optional()

  router.get(
    "getRadarEarlyFraudWarningsEarlyFraudWarning",
    "/v1/radar/early_fraud_warnings/:early_fraud_warning",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getRadarEarlyFraudWarningsEarlyFraudWarningParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getRadarEarlyFraudWarningsEarlyFraudWarningQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarEarlyFraudWarningsEarlyFraudWarningBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getRadarEarlyFraudWarningsEarlyFraudWarning(
          input,
          getRadarEarlyFraudWarningsEarlyFraudWarning.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarEarlyFraudWarningsEarlyFraudWarning.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListItemsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    value: z.string().max(800).optional(),
    value_list: z.string().max(5000),
  })

  const getRadarValueListItemsBodySchema = z.object({}).optional()

  router.get(
    "getRadarValueListItems",
    "/v1/radar/value_list_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getRadarValueListItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getRadarValueListItems(input, getRadarValueListItems.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueListItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postRadarValueListItemsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    value: z.string().max(800),
    value_list: z.string().max(5000),
  })

  router.post(
    "postRadarValueListItems",
    "/v1/radar/value_list_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postRadarValueListItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postRadarValueListItems(input, postRadarValueListItems.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRadarValueListItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteRadarValueListItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const deleteRadarValueListItemsItemBodySchema = z.object({}).optional()

  router.delete(
    "deleteRadarValueListItemsItem",
    "/v1/radar/value_list_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteRadarValueListItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteRadarValueListItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteRadarValueListItemsItem(
          input,
          deleteRadarValueListItemsItem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteRadarValueListItemsItem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const getRadarValueListItemsItemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getRadarValueListItemsItemBodySchema = z.object({}).optional()

  router.get(
    "getRadarValueListItemsItem",
    "/v1/radar/value_list_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getRadarValueListItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getRadarValueListItemsItemQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getRadarValueListItemsItem(
          input,
          getRadarValueListItemsItem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueListItemsItem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListsQuerySchema = z.object({
    alias: z.string().max(100).optional(),
    contains: z.string().max(800).optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getRadarValueListsBodySchema = z.object({}).optional()

  router.get(
    "getRadarValueLists",
    "/v1/radar/value_lists",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getRadarValueListsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getRadarValueLists(input, getRadarValueLists.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueLists.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postRadarValueListsBodySchema = z.object({
    alias: z.string().max(100),
    expand: z.array(z.string().max(5000)).optional(),
    item_type: z
      .enum([
        "card_bin",
        "card_fingerprint",
        "case_sensitive_string",
        "country",
        "customer_id",
        "email",
        "ip_address",
        "sepa_debit_fingerprint",
        "string",
        "us_bank_account_fingerprint",
      ])
      .optional(),
    metadata: z.record(z.string()).optional(),
    name: z.string().max(100),
  })

  router.post(
    "postRadarValueLists",
    "/v1/radar/value_lists",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postRadarValueListsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postRadarValueLists(input, postRadarValueLists.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRadarValueLists.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  const deleteRadarValueListsValueListBodySchema = z.object({}).optional()

  router.delete(
    "deleteRadarValueListsValueList",
    "/v1/radar/value_lists/:value_list",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteRadarValueListsValueListParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteRadarValueListsValueListBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteRadarValueListsValueList(
          input,
          deleteRadarValueListsValueList.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteRadarValueListsValueList.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  const getRadarValueListsValueListQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getRadarValueListsValueListBodySchema = z.object({}).optional()

  router.get(
    "getRadarValueListsValueList",
    "/v1/radar/value_lists/:value_list",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getRadarValueListsValueListParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getRadarValueListsValueListQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getRadarValueListsValueListBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getRadarValueListsValueList(
          input,
          getRadarValueListsValueList.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getRadarValueListsValueList.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postRadarValueListsValueListParamSchema = z.object({
    value_list: z.string().max(5000),
  })

  const postRadarValueListsValueListBodySchema = z
    .object({
      alias: z.string().max(100).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      name: z.string().max(100).optional(),
    })
    .optional()

  router.post(
    "postRadarValueListsValueList",
    "/v1/radar/value_lists/:value_list",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postRadarValueListsValueListParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postRadarValueListsValueListBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postRadarValueListsValueList(
          input,
          postRadarValueListsValueList.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRadarValueListsValueList.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getRefundsQuerySchema = z.object({
    charge: z.string().optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_intent: z.string().max(5000).optional(),
    starting_after: z.string().optional(),
  })

  const getRefundsBodySchema = z.object({}).optional()

  router.get("getRefunds", "/v1/refunds", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getRefundsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getRefundsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getRefunds(input, getRefunds.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getRefunds.validator(status, body)
    ctx.status = status
    return next()
  })

  const postRefundsBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      charge: z.string().max(5000).optional(),
      currency: z.string().optional(),
      customer: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      instructions_email: z.string().optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      origin: z.enum(["customer_balance"]).optional(),
      payment_intent: z.string().max(5000).optional(),
      reason: z
        .enum(["duplicate", "fraudulent", "requested_by_customer"])
        .optional(),
      refund_application_fee: PermissiveBoolean.optional(),
      reverse_transfer: PermissiveBoolean.optional(),
    })
    .optional()

  router.post("postRefunds", "/v1/refunds", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postRefundsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postRefunds(input, postRefunds.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postRefunds.validator(status, body)
    ctx.status = status
    return next()
  })

  const getRefundsRefundParamSchema = z.object({ refund: z.string() })

  const getRefundsRefundQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getRefundsRefundBodySchema = z.object({}).optional()

  router.get("getRefundsRefund", "/v1/refunds/:refund", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getRefundsRefundParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getRefundsRefundQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getRefundsRefundBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getRefundsRefund(input, getRefundsRefund.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getRefundsRefund.validator(status, body)
    ctx.status = status
    return next()
  })

  const postRefundsRefundParamSchema = z.object({ refund: z.string() })

  const postRefundsRefundBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post("postRefundsRefund", "/v1/refunds/:refund", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postRefundsRefundParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postRefundsRefundBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postRefundsRefund(input, postRefundsRefund.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postRefundsRefund.validator(status, body)
    ctx.status = status
    return next()
  })

  const postRefundsRefundCancelParamSchema = z.object({ refund: z.string() })

  const postRefundsRefundCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postRefundsRefundCancel",
    "/v1/refunds/:refund/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postRefundsRefundCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postRefundsRefundCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postRefundsRefundCancel(input, postRefundsRefundCancel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postRefundsRefundCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportRunsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getReportingReportRunsBodySchema = z.object({}).optional()

  router.get(
    "getReportingReportRuns",
    "/v1/reporting/report_runs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getReportingReportRunsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportRunsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getReportingReportRuns(input, getReportingReportRuns.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportRuns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postReportingReportRunsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    parameters: z
      .object({
        columns: z.array(z.string().max(5000)).optional(),
        connected_account: z.string().optional(),
        currency: z.string().optional(),
        interval_end: z.coerce.number().optional(),
        interval_start: z.coerce.number().optional(),
        payout: z.string().optional(),
        reporting_category: z
          .enum([
            "advance",
            "advance_funding",
            "anticipation_repayment",
            "charge",
            "charge_failure",
            "climate_order_purchase",
            "climate_order_refund",
            "connect_collection_transfer",
            "connect_reserved_funds",
            "contribution",
            "dispute",
            "dispute_reversal",
            "fee",
            "financing_paydown",
            "financing_paydown_reversal",
            "financing_payout",
            "financing_payout_reversal",
            "issuing_authorization_hold",
            "issuing_authorization_release",
            "issuing_dispute",
            "issuing_transaction",
            "network_cost",
            "other_adjustment",
            "partial_capture_reversal",
            "payout",
            "payout_reversal",
            "platform_earning",
            "platform_earning_refund",
            "refund",
            "refund_failure",
            "risk_reserved_funds",
            "tax",
            "topup",
            "topup_reversal",
            "transfer",
            "transfer_reversal",
            "unreconciled_customer_funds",
          ])
          .optional(),
        timezone: z
          .enum([
            "Africa/Abidjan",
            "Africa/Accra",
            "Africa/Addis_Ababa",
            "Africa/Algiers",
            "Africa/Asmara",
            "Africa/Asmera",
            "Africa/Bamako",
            "Africa/Bangui",
            "Africa/Banjul",
            "Africa/Bissau",
            "Africa/Blantyre",
            "Africa/Brazzaville",
            "Africa/Bujumbura",
            "Africa/Cairo",
            "Africa/Casablanca",
            "Africa/Ceuta",
            "Africa/Conakry",
            "Africa/Dakar",
            "Africa/Dar_es_Salaam",
            "Africa/Djibouti",
            "Africa/Douala",
            "Africa/El_Aaiun",
            "Africa/Freetown",
            "Africa/Gaborone",
            "Africa/Harare",
            "Africa/Johannesburg",
            "Africa/Juba",
            "Africa/Kampala",
            "Africa/Khartoum",
            "Africa/Kigali",
            "Africa/Kinshasa",
            "Africa/Lagos",
            "Africa/Libreville",
            "Africa/Lome",
            "Africa/Luanda",
            "Africa/Lubumbashi",
            "Africa/Lusaka",
            "Africa/Malabo",
            "Africa/Maputo",
            "Africa/Maseru",
            "Africa/Mbabane",
            "Africa/Mogadishu",
            "Africa/Monrovia",
            "Africa/Nairobi",
            "Africa/Ndjamena",
            "Africa/Niamey",
            "Africa/Nouakchott",
            "Africa/Ouagadougou",
            "Africa/Porto-Novo",
            "Africa/Sao_Tome",
            "Africa/Timbuktu",
            "Africa/Tripoli",
            "Africa/Tunis",
            "Africa/Windhoek",
            "America/Adak",
            "America/Anchorage",
            "America/Anguilla",
            "America/Antigua",
            "America/Araguaina",
            "America/Argentina/Buenos_Aires",
            "America/Argentina/Catamarca",
            "America/Argentina/ComodRivadavia",
            "America/Argentina/Cordoba",
            "America/Argentina/Jujuy",
            "America/Argentina/La_Rioja",
            "America/Argentina/Mendoza",
            "America/Argentina/Rio_Gallegos",
            "America/Argentina/Salta",
            "America/Argentina/San_Juan",
            "America/Argentina/San_Luis",
            "America/Argentina/Tucuman",
            "America/Argentina/Ushuaia",
            "America/Aruba",
            "America/Asuncion",
            "America/Atikokan",
            "America/Atka",
            "America/Bahia",
            "America/Bahia_Banderas",
            "America/Barbados",
            "America/Belem",
            "America/Belize",
            "America/Blanc-Sablon",
            "America/Boa_Vista",
            "America/Bogota",
            "America/Boise",
            "America/Buenos_Aires",
            "America/Cambridge_Bay",
            "America/Campo_Grande",
            "America/Cancun",
            "America/Caracas",
            "America/Catamarca",
            "America/Cayenne",
            "America/Cayman",
            "America/Chicago",
            "America/Chihuahua",
            "America/Ciudad_Juarez",
            "America/Coral_Harbour",
            "America/Cordoba",
            "America/Costa_Rica",
            "America/Creston",
            "America/Cuiaba",
            "America/Curacao",
            "America/Danmarkshavn",
            "America/Dawson",
            "America/Dawson_Creek",
            "America/Denver",
            "America/Detroit",
            "America/Dominica",
            "America/Edmonton",
            "America/Eirunepe",
            "America/El_Salvador",
            "America/Ensenada",
            "America/Fort_Nelson",
            "America/Fort_Wayne",
            "America/Fortaleza",
            "America/Glace_Bay",
            "America/Godthab",
            "America/Goose_Bay",
            "America/Grand_Turk",
            "America/Grenada",
            "America/Guadeloupe",
            "America/Guatemala",
            "America/Guayaquil",
            "America/Guyana",
            "America/Halifax",
            "America/Havana",
            "America/Hermosillo",
            "America/Indiana/Indianapolis",
            "America/Indiana/Knox",
            "America/Indiana/Marengo",
            "America/Indiana/Petersburg",
            "America/Indiana/Tell_City",
            "America/Indiana/Vevay",
            "America/Indiana/Vincennes",
            "America/Indiana/Winamac",
            "America/Indianapolis",
            "America/Inuvik",
            "America/Iqaluit",
            "America/Jamaica",
            "America/Jujuy",
            "America/Juneau",
            "America/Kentucky/Louisville",
            "America/Kentucky/Monticello",
            "America/Knox_IN",
            "America/Kralendijk",
            "America/La_Paz",
            "America/Lima",
            "America/Los_Angeles",
            "America/Louisville",
            "America/Lower_Princes",
            "America/Maceio",
            "America/Managua",
            "America/Manaus",
            "America/Marigot",
            "America/Martinique",
            "America/Matamoros",
            "America/Mazatlan",
            "America/Mendoza",
            "America/Menominee",
            "America/Merida",
            "America/Metlakatla",
            "America/Mexico_City",
            "America/Miquelon",
            "America/Moncton",
            "America/Monterrey",
            "America/Montevideo",
            "America/Montreal",
            "America/Montserrat",
            "America/Nassau",
            "America/New_York",
            "America/Nipigon",
            "America/Nome",
            "America/Noronha",
            "America/North_Dakota/Beulah",
            "America/North_Dakota/Center",
            "America/North_Dakota/New_Salem",
            "America/Nuuk",
            "America/Ojinaga",
            "America/Panama",
            "America/Pangnirtung",
            "America/Paramaribo",
            "America/Phoenix",
            "America/Port-au-Prince",
            "America/Port_of_Spain",
            "America/Porto_Acre",
            "America/Porto_Velho",
            "America/Puerto_Rico",
            "America/Punta_Arenas",
            "America/Rainy_River",
            "America/Rankin_Inlet",
            "America/Recife",
            "America/Regina",
            "America/Resolute",
            "America/Rio_Branco",
            "America/Rosario",
            "America/Santa_Isabel",
            "America/Santarem",
            "America/Santiago",
            "America/Santo_Domingo",
            "America/Sao_Paulo",
            "America/Scoresbysund",
            "America/Shiprock",
            "America/Sitka",
            "America/St_Barthelemy",
            "America/St_Johns",
            "America/St_Kitts",
            "America/St_Lucia",
            "America/St_Thomas",
            "America/St_Vincent",
            "America/Swift_Current",
            "America/Tegucigalpa",
            "America/Thule",
            "America/Thunder_Bay",
            "America/Tijuana",
            "America/Toronto",
            "America/Tortola",
            "America/Vancouver",
            "America/Virgin",
            "America/Whitehorse",
            "America/Winnipeg",
            "America/Yakutat",
            "America/Yellowknife",
            "Antarctica/Casey",
            "Antarctica/Davis",
            "Antarctica/DumontDUrville",
            "Antarctica/Macquarie",
            "Antarctica/Mawson",
            "Antarctica/McMurdo",
            "Antarctica/Palmer",
            "Antarctica/Rothera",
            "Antarctica/South_Pole",
            "Antarctica/Syowa",
            "Antarctica/Troll",
            "Antarctica/Vostok",
            "Arctic/Longyearbyen",
            "Asia/Aden",
            "Asia/Almaty",
            "Asia/Amman",
            "Asia/Anadyr",
            "Asia/Aqtau",
            "Asia/Aqtobe",
            "Asia/Ashgabat",
            "Asia/Ashkhabad",
            "Asia/Atyrau",
            "Asia/Baghdad",
            "Asia/Bahrain",
            "Asia/Baku",
            "Asia/Bangkok",
            "Asia/Barnaul",
            "Asia/Beirut",
            "Asia/Bishkek",
            "Asia/Brunei",
            "Asia/Calcutta",
            "Asia/Chita",
            "Asia/Choibalsan",
            "Asia/Chongqing",
            "Asia/Chungking",
            "Asia/Colombo",
            "Asia/Dacca",
            "Asia/Damascus",
            "Asia/Dhaka",
            "Asia/Dili",
            "Asia/Dubai",
            "Asia/Dushanbe",
            "Asia/Famagusta",
            "Asia/Gaza",
            "Asia/Harbin",
            "Asia/Hebron",
            "Asia/Ho_Chi_Minh",
            "Asia/Hong_Kong",
            "Asia/Hovd",
            "Asia/Irkutsk",
            "Asia/Istanbul",
            "Asia/Jakarta",
            "Asia/Jayapura",
            "Asia/Jerusalem",
            "Asia/Kabul",
            "Asia/Kamchatka",
            "Asia/Karachi",
            "Asia/Kashgar",
            "Asia/Kathmandu",
            "Asia/Katmandu",
            "Asia/Khandyga",
            "Asia/Kolkata",
            "Asia/Krasnoyarsk",
            "Asia/Kuala_Lumpur",
            "Asia/Kuching",
            "Asia/Kuwait",
            "Asia/Macao",
            "Asia/Macau",
            "Asia/Magadan",
            "Asia/Makassar",
            "Asia/Manila",
            "Asia/Muscat",
            "Asia/Nicosia",
            "Asia/Novokuznetsk",
            "Asia/Novosibirsk",
            "Asia/Omsk",
            "Asia/Oral",
            "Asia/Phnom_Penh",
            "Asia/Pontianak",
            "Asia/Pyongyang",
            "Asia/Qatar",
            "Asia/Qostanay",
            "Asia/Qyzylorda",
            "Asia/Rangoon",
            "Asia/Riyadh",
            "Asia/Saigon",
            "Asia/Sakhalin",
            "Asia/Samarkand",
            "Asia/Seoul",
            "Asia/Shanghai",
            "Asia/Singapore",
            "Asia/Srednekolymsk",
            "Asia/Taipei",
            "Asia/Tashkent",
            "Asia/Tbilisi",
            "Asia/Tehran",
            "Asia/Tel_Aviv",
            "Asia/Thimbu",
            "Asia/Thimphu",
            "Asia/Tokyo",
            "Asia/Tomsk",
            "Asia/Ujung_Pandang",
            "Asia/Ulaanbaatar",
            "Asia/Ulan_Bator",
            "Asia/Urumqi",
            "Asia/Ust-Nera",
            "Asia/Vientiane",
            "Asia/Vladivostok",
            "Asia/Yakutsk",
            "Asia/Yangon",
            "Asia/Yekaterinburg",
            "Asia/Yerevan",
            "Atlantic/Azores",
            "Atlantic/Bermuda",
            "Atlantic/Canary",
            "Atlantic/Cape_Verde",
            "Atlantic/Faeroe",
            "Atlantic/Faroe",
            "Atlantic/Jan_Mayen",
            "Atlantic/Madeira",
            "Atlantic/Reykjavik",
            "Atlantic/South_Georgia",
            "Atlantic/St_Helena",
            "Atlantic/Stanley",
            "Australia/ACT",
            "Australia/Adelaide",
            "Australia/Brisbane",
            "Australia/Broken_Hill",
            "Australia/Canberra",
            "Australia/Currie",
            "Australia/Darwin",
            "Australia/Eucla",
            "Australia/Hobart",
            "Australia/LHI",
            "Australia/Lindeman",
            "Australia/Lord_Howe",
            "Australia/Melbourne",
            "Australia/NSW",
            "Australia/North",
            "Australia/Perth",
            "Australia/Queensland",
            "Australia/South",
            "Australia/Sydney",
            "Australia/Tasmania",
            "Australia/Victoria",
            "Australia/West",
            "Australia/Yancowinna",
            "Brazil/Acre",
            "Brazil/DeNoronha",
            "Brazil/East",
            "Brazil/West",
            "CET",
            "CST6CDT",
            "Canada/Atlantic",
            "Canada/Central",
            "Canada/Eastern",
            "Canada/Mountain",
            "Canada/Newfoundland",
            "Canada/Pacific",
            "Canada/Saskatchewan",
            "Canada/Yukon",
            "Chile/Continental",
            "Chile/EasterIsland",
            "Cuba",
            "EET",
            "EST",
            "EST5EDT",
            "Egypt",
            "Eire",
            "Etc/GMT",
            "Etc/GMT+0",
            "Etc/GMT+1",
            "Etc/GMT+10",
            "Etc/GMT+11",
            "Etc/GMT+12",
            "Etc/GMT+2",
            "Etc/GMT+3",
            "Etc/GMT+4",
            "Etc/GMT+5",
            "Etc/GMT+6",
            "Etc/GMT+7",
            "Etc/GMT+8",
            "Etc/GMT+9",
            "Etc/GMT-0",
            "Etc/GMT-1",
            "Etc/GMT-10",
            "Etc/GMT-11",
            "Etc/GMT-12",
            "Etc/GMT-13",
            "Etc/GMT-14",
            "Etc/GMT-2",
            "Etc/GMT-3",
            "Etc/GMT-4",
            "Etc/GMT-5",
            "Etc/GMT-6",
            "Etc/GMT-7",
            "Etc/GMT-8",
            "Etc/GMT-9",
            "Etc/GMT0",
            "Etc/Greenwich",
            "Etc/UCT",
            "Etc/UTC",
            "Etc/Universal",
            "Etc/Zulu",
            "Europe/Amsterdam",
            "Europe/Andorra",
            "Europe/Astrakhan",
            "Europe/Athens",
            "Europe/Belfast",
            "Europe/Belgrade",
            "Europe/Berlin",
            "Europe/Bratislava",
            "Europe/Brussels",
            "Europe/Bucharest",
            "Europe/Budapest",
            "Europe/Busingen",
            "Europe/Chisinau",
            "Europe/Copenhagen",
            "Europe/Dublin",
            "Europe/Gibraltar",
            "Europe/Guernsey",
            "Europe/Helsinki",
            "Europe/Isle_of_Man",
            "Europe/Istanbul",
            "Europe/Jersey",
            "Europe/Kaliningrad",
            "Europe/Kiev",
            "Europe/Kirov",
            "Europe/Kyiv",
            "Europe/Lisbon",
            "Europe/Ljubljana",
            "Europe/London",
            "Europe/Luxembourg",
            "Europe/Madrid",
            "Europe/Malta",
            "Europe/Mariehamn",
            "Europe/Minsk",
            "Europe/Monaco",
            "Europe/Moscow",
            "Europe/Nicosia",
            "Europe/Oslo",
            "Europe/Paris",
            "Europe/Podgorica",
            "Europe/Prague",
            "Europe/Riga",
            "Europe/Rome",
            "Europe/Samara",
            "Europe/San_Marino",
            "Europe/Sarajevo",
            "Europe/Saratov",
            "Europe/Simferopol",
            "Europe/Skopje",
            "Europe/Sofia",
            "Europe/Stockholm",
            "Europe/Tallinn",
            "Europe/Tirane",
            "Europe/Tiraspol",
            "Europe/Ulyanovsk",
            "Europe/Uzhgorod",
            "Europe/Vaduz",
            "Europe/Vatican",
            "Europe/Vienna",
            "Europe/Vilnius",
            "Europe/Volgograd",
            "Europe/Warsaw",
            "Europe/Zagreb",
            "Europe/Zaporozhye",
            "Europe/Zurich",
            "Factory",
            "GB",
            "GB-Eire",
            "GMT",
            "GMT+0",
            "GMT-0",
            "GMT0",
            "Greenwich",
            "HST",
            "Hongkong",
            "Iceland",
            "Indian/Antananarivo",
            "Indian/Chagos",
            "Indian/Christmas",
            "Indian/Cocos",
            "Indian/Comoro",
            "Indian/Kerguelen",
            "Indian/Mahe",
            "Indian/Maldives",
            "Indian/Mauritius",
            "Indian/Mayotte",
            "Indian/Reunion",
            "Iran",
            "Israel",
            "Jamaica",
            "Japan",
            "Kwajalein",
            "Libya",
            "MET",
            "MST",
            "MST7MDT",
            "Mexico/BajaNorte",
            "Mexico/BajaSur",
            "Mexico/General",
            "NZ",
            "NZ-CHAT",
            "Navajo",
            "PRC",
            "PST8PDT",
            "Pacific/Apia",
            "Pacific/Auckland",
            "Pacific/Bougainville",
            "Pacific/Chatham",
            "Pacific/Chuuk",
            "Pacific/Easter",
            "Pacific/Efate",
            "Pacific/Enderbury",
            "Pacific/Fakaofo",
            "Pacific/Fiji",
            "Pacific/Funafuti",
            "Pacific/Galapagos",
            "Pacific/Gambier",
            "Pacific/Guadalcanal",
            "Pacific/Guam",
            "Pacific/Honolulu",
            "Pacific/Johnston",
            "Pacific/Kanton",
            "Pacific/Kiritimati",
            "Pacific/Kosrae",
            "Pacific/Kwajalein",
            "Pacific/Majuro",
            "Pacific/Marquesas",
            "Pacific/Midway",
            "Pacific/Nauru",
            "Pacific/Niue",
            "Pacific/Norfolk",
            "Pacific/Noumea",
            "Pacific/Pago_Pago",
            "Pacific/Palau",
            "Pacific/Pitcairn",
            "Pacific/Pohnpei",
            "Pacific/Ponape",
            "Pacific/Port_Moresby",
            "Pacific/Rarotonga",
            "Pacific/Saipan",
            "Pacific/Samoa",
            "Pacific/Tahiti",
            "Pacific/Tarawa",
            "Pacific/Tongatapu",
            "Pacific/Truk",
            "Pacific/Wake",
            "Pacific/Wallis",
            "Pacific/Yap",
            "Poland",
            "Portugal",
            "ROC",
            "ROK",
            "Singapore",
            "Turkey",
            "UCT",
            "US/Alaska",
            "US/Aleutian",
            "US/Arizona",
            "US/Central",
            "US/East-Indiana",
            "US/Eastern",
            "US/Hawaii",
            "US/Indiana-Starke",
            "US/Michigan",
            "US/Mountain",
            "US/Pacific",
            "US/Pacific-New",
            "US/Samoa",
            "UTC",
            "Universal",
            "W-SU",
            "WET",
            "Zulu",
          ])
          .optional(),
      })
      .optional(),
    report_type: z.string(),
  })

  router.post(
    "postReportingReportRuns",
    "/v1/reporting/report_runs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postReportingReportRunsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postReportingReportRuns(input, postReportingReportRuns.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postReportingReportRuns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportRunsReportRunParamSchema = z.object({
    report_run: z.string().max(5000),
  })

  const getReportingReportRunsReportRunQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getReportingReportRunsReportRunBodySchema = z.object({}).optional()

  router.get(
    "getReportingReportRunsReportRun",
    "/v1/reporting/report_runs/:report_run",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getReportingReportRunsReportRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getReportingReportRunsReportRunQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportRunsReportRunBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getReportingReportRunsReportRun(
          input,
          getReportingReportRunsReportRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportRunsReportRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportTypesQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getReportingReportTypesBodySchema = z.object({}).optional()

  router.get(
    "getReportingReportTypes",
    "/v1/reporting/report_types",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getReportingReportTypesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportTypesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getReportingReportTypes(input, getReportingReportTypes.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportTypes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReportingReportTypesReportTypeParamSchema = z.object({
    report_type: z.string(),
  })

  const getReportingReportTypesReportTypeQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getReportingReportTypesReportTypeBodySchema = z.object({}).optional()

  router.get(
    "getReportingReportTypesReportType",
    "/v1/reporting/report_types/:report_type",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getReportingReportTypesReportTypeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getReportingReportTypesReportTypeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getReportingReportTypesReportTypeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getReportingReportTypesReportType(
          input,
          getReportingReportTypesReportType.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getReportingReportTypesReportType.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getReviewsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getReviewsBodySchema = z.object({}).optional()

  router.get("getReviews", "/v1/reviews", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getReviewsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getReviewsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getReviews(input, getReviews.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getReviews.validator(status, body)
    ctx.status = status
    return next()
  })

  const getReviewsReviewParamSchema = z.object({ review: z.string().max(5000) })

  const getReviewsReviewQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getReviewsReviewBodySchema = z.object({}).optional()

  router.get("getReviewsReview", "/v1/reviews/:review", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getReviewsReviewParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getReviewsReviewQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getReviewsReviewBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getReviewsReview(input, getReviewsReview.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getReviewsReview.validator(status, body)
    ctx.status = status
    return next()
  })

  const postReviewsReviewApproveParamSchema = z.object({
    review: z.string().max(5000),
  })

  const postReviewsReviewApproveBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postReviewsReviewApprove",
    "/v1/reviews/:review/approve",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postReviewsReviewApproveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postReviewsReviewApproveBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postReviewsReviewApprove(
          input,
          postReviewsReviewApprove.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postReviewsReviewApprove.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSetupAttemptsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    setup_intent: z.string().max(5000),
    starting_after: z.string().max(5000).optional(),
  })

  const getSetupAttemptsBodySchema = z.object({}).optional()

  router.get("getSetupAttempts", "/v1/setup_attempts", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getSetupAttemptsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSetupAttemptsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getSetupAttempts(input, getSetupAttempts.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSetupAttempts.validator(status, body)
    ctx.status = status
    return next()
  })

  const getSetupIntentsQuerySchema = z.object({
    attach_to_self: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    payment_method: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getSetupIntentsBodySchema = z.object({}).optional()

  router.get("getSetupIntents", "/v1/setup_intents", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getSetupIntentsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSetupIntentsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getSetupIntents(input, getSetupIntents.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSetupIntents.validator(status, body)
    ctx.status = status
    return next()
  })

  const postSetupIntentsBodySchema = z
    .object({
      attach_to_self: PermissiveBoolean.optional(),
      automatic_payment_methods: z
        .object({
          allow_redirects: z.enum(["always", "never"]).optional(),
          enabled: PermissiveBoolean,
        })
        .optional(),
      confirm: PermissiveBoolean.optional(),
      confirmation_token: z.string().max(5000).optional(),
      customer: z.string().max(5000).optional(),
      description: z.string().max(1000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      flow_directions: z.array(z.enum(["inbound", "outbound"])).optional(),
      mandate_data: z
        .union([
          z.object({
            customer_acceptance: z.object({
              accepted_at: z.coerce.number().optional(),
              offline: z.object({}).optional(),
              online: z
                .object({
                  ip_address: z.string(),
                  user_agent: z.string().max(5000),
                })
                .optional(),
              type: z.enum(["offline", "online"]),
            }),
          }),
          z.enum([""]),
        ])
        .optional(),
      metadata: z.record(z.string()).optional(),
      on_behalf_of: z.string().optional(),
      payment_method: z.string().max(5000).optional(),
      payment_method_configuration: z.string().max(100).optional(),
      payment_method_data: z
        .object({
          acss_debit: z
            .object({
              account_number: z.string().max(5000),
              institution_number: z.string().max(5000),
              transit_number: z.string().max(5000),
            })
            .optional(),
          affirm: z.object({}).optional(),
          afterpay_clearpay: z.object({}).optional(),
          alipay: z.object({}).optional(),
          allow_redisplay: z
            .enum(["always", "limited", "unspecified"])
            .optional(),
          alma: z.object({}).optional(),
          amazon_pay: z.object({}).optional(),
          au_becs_debit: z
            .object({
              account_number: z.string().max(5000),
              bsb_number: z.string().max(5000),
            })
            .optional(),
          bacs_debit: z
            .object({
              account_number: z.string().max(5000).optional(),
              sort_code: z.string().max(5000).optional(),
            })
            .optional(),
          bancontact: z.object({}).optional(),
          billie: z.object({}).optional(),
          billing_details: z
            .object({
              address: z
                .union([
                  z.object({
                    city: z.string().max(5000).optional(),
                    country: z.string().max(5000).optional(),
                    line1: z.string().max(5000).optional(),
                    line2: z.string().max(5000).optional(),
                    postal_code: z.string().max(5000).optional(),
                    state: z.string().max(5000).optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              email: z.union([z.string(), z.enum([""])]).optional(),
              name: z.union([z.string().max(5000), z.enum([""])]).optional(),
              phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
            })
            .optional(),
          blik: z.object({}).optional(),
          boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
          cashapp: z.object({}).optional(),
          customer_balance: z.object({}).optional(),
          eps: z
            .object({
              bank: z
                .enum([
                  "arzte_und_apotheker_bank",
                  "austrian_anadi_bank_ag",
                  "bank_austria",
                  "bankhaus_carl_spangler",
                  "bankhaus_schelhammer_und_schattera_ag",
                  "bawag_psk_ag",
                  "bks_bank_ag",
                  "brull_kallmus_bank_ag",
                  "btv_vier_lander_bank",
                  "capital_bank_grawe_gruppe_ag",
                  "deutsche_bank_ag",
                  "dolomitenbank",
                  "easybank_ag",
                  "erste_bank_und_sparkassen",
                  "hypo_alpeadriabank_international_ag",
                  "hypo_bank_burgenland_aktiengesellschaft",
                  "hypo_noe_lb_fur_niederosterreich_u_wien",
                  "hypo_oberosterreich_salzburg_steiermark",
                  "hypo_tirol_bank_ag",
                  "hypo_vorarlberg_bank_ag",
                  "marchfelder_bank",
                  "oberbank_ag",
                  "raiffeisen_bankengruppe_osterreich",
                  "schoellerbank_ag",
                  "sparda_bank_wien",
                  "volksbank_gruppe",
                  "volkskreditbank_ag",
                  "vr_bank_braunau",
                ])
                .optional(),
            })
            .optional(),
          fpx: z
            .object({
              bank: z.enum([
                "affin_bank",
                "agrobank",
                "alliance_bank",
                "ambank",
                "bank_islam",
                "bank_muamalat",
                "bank_of_china",
                "bank_rakyat",
                "bsn",
                "cimb",
                "deutsche_bank",
                "hong_leong_bank",
                "hsbc",
                "kfh",
                "maybank2e",
                "maybank2u",
                "ocbc",
                "pb_enterprise",
                "public_bank",
                "rhb",
                "standard_chartered",
                "uob",
              ]),
            })
            .optional(),
          giropay: z.object({}).optional(),
          grabpay: z.object({}).optional(),
          ideal: z
            .object({
              bank: z
                .enum([
                  "abn_amro",
                  "asn_bank",
                  "bunq",
                  "handelsbanken",
                  "ing",
                  "knab",
                  "moneyou",
                  "n26",
                  "nn",
                  "rabobank",
                  "regiobank",
                  "revolut",
                  "sns_bank",
                  "triodos_bank",
                  "van_lanschot",
                  "yoursafe",
                ])
                .optional(),
            })
            .optional(),
          interac_present: z.object({}).optional(),
          kakao_pay: z.object({}).optional(),
          klarna: z
            .object({
              dob: z
                .object({
                  day: z.coerce.number(),
                  month: z.coerce.number(),
                  year: z.coerce.number(),
                })
                .optional(),
            })
            .optional(),
          konbini: z.object({}).optional(),
          kr_card: z.object({}).optional(),
          link: z.object({}).optional(),
          metadata: z.record(z.string()).optional(),
          mobilepay: z.object({}).optional(),
          multibanco: z.object({}).optional(),
          naver_pay: z
            .object({ funding: z.enum(["card", "points"]).optional() })
            .optional(),
          nz_bank_account: z
            .object({
              account_holder_name: z.string().max(5000).optional(),
              account_number: z.string().max(5000),
              bank_code: z.string().max(5000),
              branch_code: z.string().max(5000),
              reference: z.string().max(128).optional(),
              suffix: z.string().max(5000),
            })
            .optional(),
          oxxo: z.object({}).optional(),
          p24: z
            .object({
              bank: z
                .enum([
                  "alior_bank",
                  "bank_millennium",
                  "bank_nowy_bfg_sa",
                  "bank_pekao_sa",
                  "banki_spbdzielcze",
                  "blik",
                  "bnp_paribas",
                  "boz",
                  "citi_handlowy",
                  "credit_agricole",
                  "envelobank",
                  "etransfer_pocztowy24",
                  "getin_bank",
                  "ideabank",
                  "ing",
                  "inteligo",
                  "mbank_mtransfer",
                  "nest_przelew",
                  "noble_pay",
                  "pbac_z_ipko",
                  "plus_bank",
                  "santander_przelew24",
                  "tmobile_usbugi_bankowe",
                  "toyota_bank",
                  "velobank",
                  "volkswagen_bank",
                ])
                .optional(),
            })
            .optional(),
          pay_by_bank: z.object({}).optional(),
          payco: z.object({}).optional(),
          paynow: z.object({}).optional(),
          paypal: z.object({}).optional(),
          pix: z.object({}).optional(),
          promptpay: z.object({}).optional(),
          radar_options: z
            .object({ session: z.string().max(5000).optional() })
            .optional(),
          revolut_pay: z.object({}).optional(),
          samsung_pay: z.object({}).optional(),
          satispay: z.object({}).optional(),
          sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
          sofort: z
            .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
            .optional(),
          swish: z.object({}).optional(),
          twint: z.object({}).optional(),
          type: z.enum([
            "acss_debit",
            "affirm",
            "afterpay_clearpay",
            "alipay",
            "alma",
            "amazon_pay",
            "au_becs_debit",
            "bacs_debit",
            "bancontact",
            "billie",
            "blik",
            "boleto",
            "cashapp",
            "customer_balance",
            "eps",
            "fpx",
            "giropay",
            "grabpay",
            "ideal",
            "kakao_pay",
            "klarna",
            "konbini",
            "kr_card",
            "link",
            "mobilepay",
            "multibanco",
            "naver_pay",
            "nz_bank_account",
            "oxxo",
            "p24",
            "pay_by_bank",
            "payco",
            "paynow",
            "paypal",
            "pix",
            "promptpay",
            "revolut_pay",
            "samsung_pay",
            "satispay",
            "sepa_debit",
            "sofort",
            "swish",
            "twint",
            "us_bank_account",
            "wechat_pay",
            "zip",
          ]),
          us_bank_account: z
            .object({
              account_holder_type: z.enum(["company", "individual"]).optional(),
              account_number: z.string().max(5000).optional(),
              account_type: z.enum(["checking", "savings"]).optional(),
              financial_connections_account: z.string().max(5000).optional(),
              routing_number: z.string().max(5000).optional(),
            })
            .optional(),
          wechat_pay: z.object({}).optional(),
          zip: z.object({}).optional(),
        })
        .optional(),
      payment_method_options: z
        .object({
          acss_debit: z
            .object({
              currency: z.enum(["cad", "usd"]).optional(),
              mandate_options: z
                .object({
                  custom_mandate_url: z
                    .union([z.string(), z.enum([""])])
                    .optional(),
                  default_for: z
                    .array(z.enum(["invoice", "subscription"]))
                    .optional(),
                  interval_description: z.string().max(500).optional(),
                  payment_schedule: z
                    .enum(["combined", "interval", "sporadic"])
                    .optional(),
                  transaction_type: z.enum(["business", "personal"]).optional(),
                })
                .optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            })
            .optional(),
          amazon_pay: z.object({}).optional(),
          bacs_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          card: z
            .object({
              mandate_options: z
                .object({
                  amount: z.coerce.number(),
                  amount_type: z.enum(["fixed", "maximum"]),
                  currency: z.string(),
                  description: z.string().max(200).optional(),
                  end_date: z.coerce.number().optional(),
                  interval: z.enum([
                    "day",
                    "month",
                    "sporadic",
                    "week",
                    "year",
                  ]),
                  interval_count: z.coerce.number().optional(),
                  reference: z.string().max(80),
                  start_date: z.coerce.number(),
                  supported_types: z.array(z.enum(["india"])).optional(),
                })
                .optional(),
              network: z
                .enum([
                  "amex",
                  "cartes_bancaires",
                  "diners",
                  "discover",
                  "eftpos_au",
                  "girocard",
                  "interac",
                  "jcb",
                  "link",
                  "mastercard",
                  "unionpay",
                  "unknown",
                  "visa",
                ])
                .optional(),
              request_three_d_secure: z
                .enum(["any", "automatic", "challenge"])
                .optional(),
              three_d_secure: z
                .object({
                  ares_trans_status: z
                    .enum(["A", "C", "I", "N", "R", "U", "Y"])
                    .optional(),
                  cryptogram: z.string().max(5000).optional(),
                  electronic_commerce_indicator: z
                    .enum(["01", "02", "05", "06", "07"])
                    .optional(),
                  network_options: z
                    .object({
                      cartes_bancaires: z
                        .object({
                          cb_avalgo: z.enum(["0", "1", "2", "3", "4", "A"]),
                          cb_exemption: z.string().max(4).optional(),
                          cb_score: z.coerce.number().optional(),
                        })
                        .optional(),
                    })
                    .optional(),
                  requestor_challenge_indicator: z.string().max(2).optional(),
                  transaction_id: z.string().max(5000).optional(),
                  version: z.enum(["1.0.2", "2.1.0", "2.2.0"]).optional(),
                })
                .optional(),
            })
            .optional(),
          card_present: z.object({}).optional(),
          link: z.object({}).optional(),
          paypal: z
            .object({ billing_agreement_id: z.string().max(5000).optional() })
            .optional(),
          sepa_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          us_bank_account: z
            .object({
              financial_connections: z
                .object({
                  filters: z
                    .object({
                      account_subcategories: z
                        .array(z.enum(["checking", "savings"]))
                        .optional(),
                    })
                    .optional(),
                  permissions: z
                    .array(
                      z.enum([
                        "balances",
                        "ownership",
                        "payment_method",
                        "transactions",
                      ]),
                    )
                    .optional(),
                  prefetch: z
                    .array(z.enum(["balances", "ownership", "transactions"]))
                    .optional(),
                  return_url: z.string().max(5000).optional(),
                })
                .optional(),
              mandate_options: z
                .object({ collection_method: z.enum(["", "paper"]).optional() })
                .optional(),
              networks: z
                .object({
                  requested: z
                    .array(z.enum(["ach", "us_domestic_wire"]))
                    .optional(),
                })
                .optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      payment_method_types: z.array(z.string().max(5000)).optional(),
      return_url: z.string().optional(),
      single_use: z
        .object({ amount: z.coerce.number(), currency: z.string() })
        .optional(),
      usage: z.enum(["off_session", "on_session"]).optional(),
      use_stripe_sdk: PermissiveBoolean.optional(),
    })
    .optional()

  router.post("postSetupIntents", "/v1/setup_intents", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postSetupIntentsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postSetupIntents(input, postSetupIntents.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSetupIntents.validator(status, body)
    ctx.status = status
    return next()
  })

  const getSetupIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const getSetupIntentsIntentQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getSetupIntentsIntentBodySchema = z.object({}).optional()

  router.get(
    "getSetupIntentsIntent",
    "/v1/setup_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSetupIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSetupIntentsIntentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSetupIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSetupIntentsIntent(input, getSetupIntentsIntent.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSetupIntentsIntent.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postSetupIntentsIntentBodySchema = z
    .object({
      attach_to_self: PermissiveBoolean.optional(),
      customer: z.string().max(5000).optional(),
      description: z.string().max(1000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      flow_directions: z.array(z.enum(["inbound", "outbound"])).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      payment_method: z.string().max(5000).optional(),
      payment_method_configuration: z.string().max(100).optional(),
      payment_method_data: z
        .object({
          acss_debit: z
            .object({
              account_number: z.string().max(5000),
              institution_number: z.string().max(5000),
              transit_number: z.string().max(5000),
            })
            .optional(),
          affirm: z.object({}).optional(),
          afterpay_clearpay: z.object({}).optional(),
          alipay: z.object({}).optional(),
          allow_redisplay: z
            .enum(["always", "limited", "unspecified"])
            .optional(),
          alma: z.object({}).optional(),
          amazon_pay: z.object({}).optional(),
          au_becs_debit: z
            .object({
              account_number: z.string().max(5000),
              bsb_number: z.string().max(5000),
            })
            .optional(),
          bacs_debit: z
            .object({
              account_number: z.string().max(5000).optional(),
              sort_code: z.string().max(5000).optional(),
            })
            .optional(),
          bancontact: z.object({}).optional(),
          billie: z.object({}).optional(),
          billing_details: z
            .object({
              address: z
                .union([
                  z.object({
                    city: z.string().max(5000).optional(),
                    country: z.string().max(5000).optional(),
                    line1: z.string().max(5000).optional(),
                    line2: z.string().max(5000).optional(),
                    postal_code: z.string().max(5000).optional(),
                    state: z.string().max(5000).optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              email: z.union([z.string(), z.enum([""])]).optional(),
              name: z.union([z.string().max(5000), z.enum([""])]).optional(),
              phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
            })
            .optional(),
          blik: z.object({}).optional(),
          boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
          cashapp: z.object({}).optional(),
          customer_balance: z.object({}).optional(),
          eps: z
            .object({
              bank: z
                .enum([
                  "arzte_und_apotheker_bank",
                  "austrian_anadi_bank_ag",
                  "bank_austria",
                  "bankhaus_carl_spangler",
                  "bankhaus_schelhammer_und_schattera_ag",
                  "bawag_psk_ag",
                  "bks_bank_ag",
                  "brull_kallmus_bank_ag",
                  "btv_vier_lander_bank",
                  "capital_bank_grawe_gruppe_ag",
                  "deutsche_bank_ag",
                  "dolomitenbank",
                  "easybank_ag",
                  "erste_bank_und_sparkassen",
                  "hypo_alpeadriabank_international_ag",
                  "hypo_bank_burgenland_aktiengesellschaft",
                  "hypo_noe_lb_fur_niederosterreich_u_wien",
                  "hypo_oberosterreich_salzburg_steiermark",
                  "hypo_tirol_bank_ag",
                  "hypo_vorarlberg_bank_ag",
                  "marchfelder_bank",
                  "oberbank_ag",
                  "raiffeisen_bankengruppe_osterreich",
                  "schoellerbank_ag",
                  "sparda_bank_wien",
                  "volksbank_gruppe",
                  "volkskreditbank_ag",
                  "vr_bank_braunau",
                ])
                .optional(),
            })
            .optional(),
          fpx: z
            .object({
              bank: z.enum([
                "affin_bank",
                "agrobank",
                "alliance_bank",
                "ambank",
                "bank_islam",
                "bank_muamalat",
                "bank_of_china",
                "bank_rakyat",
                "bsn",
                "cimb",
                "deutsche_bank",
                "hong_leong_bank",
                "hsbc",
                "kfh",
                "maybank2e",
                "maybank2u",
                "ocbc",
                "pb_enterprise",
                "public_bank",
                "rhb",
                "standard_chartered",
                "uob",
              ]),
            })
            .optional(),
          giropay: z.object({}).optional(),
          grabpay: z.object({}).optional(),
          ideal: z
            .object({
              bank: z
                .enum([
                  "abn_amro",
                  "asn_bank",
                  "bunq",
                  "handelsbanken",
                  "ing",
                  "knab",
                  "moneyou",
                  "n26",
                  "nn",
                  "rabobank",
                  "regiobank",
                  "revolut",
                  "sns_bank",
                  "triodos_bank",
                  "van_lanschot",
                  "yoursafe",
                ])
                .optional(),
            })
            .optional(),
          interac_present: z.object({}).optional(),
          kakao_pay: z.object({}).optional(),
          klarna: z
            .object({
              dob: z
                .object({
                  day: z.coerce.number(),
                  month: z.coerce.number(),
                  year: z.coerce.number(),
                })
                .optional(),
            })
            .optional(),
          konbini: z.object({}).optional(),
          kr_card: z.object({}).optional(),
          link: z.object({}).optional(),
          metadata: z.record(z.string()).optional(),
          mobilepay: z.object({}).optional(),
          multibanco: z.object({}).optional(),
          naver_pay: z
            .object({ funding: z.enum(["card", "points"]).optional() })
            .optional(),
          nz_bank_account: z
            .object({
              account_holder_name: z.string().max(5000).optional(),
              account_number: z.string().max(5000),
              bank_code: z.string().max(5000),
              branch_code: z.string().max(5000),
              reference: z.string().max(128).optional(),
              suffix: z.string().max(5000),
            })
            .optional(),
          oxxo: z.object({}).optional(),
          p24: z
            .object({
              bank: z
                .enum([
                  "alior_bank",
                  "bank_millennium",
                  "bank_nowy_bfg_sa",
                  "bank_pekao_sa",
                  "banki_spbdzielcze",
                  "blik",
                  "bnp_paribas",
                  "boz",
                  "citi_handlowy",
                  "credit_agricole",
                  "envelobank",
                  "etransfer_pocztowy24",
                  "getin_bank",
                  "ideabank",
                  "ing",
                  "inteligo",
                  "mbank_mtransfer",
                  "nest_przelew",
                  "noble_pay",
                  "pbac_z_ipko",
                  "plus_bank",
                  "santander_przelew24",
                  "tmobile_usbugi_bankowe",
                  "toyota_bank",
                  "velobank",
                  "volkswagen_bank",
                ])
                .optional(),
            })
            .optional(),
          pay_by_bank: z.object({}).optional(),
          payco: z.object({}).optional(),
          paynow: z.object({}).optional(),
          paypal: z.object({}).optional(),
          pix: z.object({}).optional(),
          promptpay: z.object({}).optional(),
          radar_options: z
            .object({ session: z.string().max(5000).optional() })
            .optional(),
          revolut_pay: z.object({}).optional(),
          samsung_pay: z.object({}).optional(),
          satispay: z.object({}).optional(),
          sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
          sofort: z
            .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
            .optional(),
          swish: z.object({}).optional(),
          twint: z.object({}).optional(),
          type: z.enum([
            "acss_debit",
            "affirm",
            "afterpay_clearpay",
            "alipay",
            "alma",
            "amazon_pay",
            "au_becs_debit",
            "bacs_debit",
            "bancontact",
            "billie",
            "blik",
            "boleto",
            "cashapp",
            "customer_balance",
            "eps",
            "fpx",
            "giropay",
            "grabpay",
            "ideal",
            "kakao_pay",
            "klarna",
            "konbini",
            "kr_card",
            "link",
            "mobilepay",
            "multibanco",
            "naver_pay",
            "nz_bank_account",
            "oxxo",
            "p24",
            "pay_by_bank",
            "payco",
            "paynow",
            "paypal",
            "pix",
            "promptpay",
            "revolut_pay",
            "samsung_pay",
            "satispay",
            "sepa_debit",
            "sofort",
            "swish",
            "twint",
            "us_bank_account",
            "wechat_pay",
            "zip",
          ]),
          us_bank_account: z
            .object({
              account_holder_type: z.enum(["company", "individual"]).optional(),
              account_number: z.string().max(5000).optional(),
              account_type: z.enum(["checking", "savings"]).optional(),
              financial_connections_account: z.string().max(5000).optional(),
              routing_number: z.string().max(5000).optional(),
            })
            .optional(),
          wechat_pay: z.object({}).optional(),
          zip: z.object({}).optional(),
        })
        .optional(),
      payment_method_options: z
        .object({
          acss_debit: z
            .object({
              currency: z.enum(["cad", "usd"]).optional(),
              mandate_options: z
                .object({
                  custom_mandate_url: z
                    .union([z.string(), z.enum([""])])
                    .optional(),
                  default_for: z
                    .array(z.enum(["invoice", "subscription"]))
                    .optional(),
                  interval_description: z.string().max(500).optional(),
                  payment_schedule: z
                    .enum(["combined", "interval", "sporadic"])
                    .optional(),
                  transaction_type: z.enum(["business", "personal"]).optional(),
                })
                .optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            })
            .optional(),
          amazon_pay: z.object({}).optional(),
          bacs_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          card: z
            .object({
              mandate_options: z
                .object({
                  amount: z.coerce.number(),
                  amount_type: z.enum(["fixed", "maximum"]),
                  currency: z.string(),
                  description: z.string().max(200).optional(),
                  end_date: z.coerce.number().optional(),
                  interval: z.enum([
                    "day",
                    "month",
                    "sporadic",
                    "week",
                    "year",
                  ]),
                  interval_count: z.coerce.number().optional(),
                  reference: z.string().max(80),
                  start_date: z.coerce.number(),
                  supported_types: z.array(z.enum(["india"])).optional(),
                })
                .optional(),
              network: z
                .enum([
                  "amex",
                  "cartes_bancaires",
                  "diners",
                  "discover",
                  "eftpos_au",
                  "girocard",
                  "interac",
                  "jcb",
                  "link",
                  "mastercard",
                  "unionpay",
                  "unknown",
                  "visa",
                ])
                .optional(),
              request_three_d_secure: z
                .enum(["any", "automatic", "challenge"])
                .optional(),
              three_d_secure: z
                .object({
                  ares_trans_status: z
                    .enum(["A", "C", "I", "N", "R", "U", "Y"])
                    .optional(),
                  cryptogram: z.string().max(5000).optional(),
                  electronic_commerce_indicator: z
                    .enum(["01", "02", "05", "06", "07"])
                    .optional(),
                  network_options: z
                    .object({
                      cartes_bancaires: z
                        .object({
                          cb_avalgo: z.enum(["0", "1", "2", "3", "4", "A"]),
                          cb_exemption: z.string().max(4).optional(),
                          cb_score: z.coerce.number().optional(),
                        })
                        .optional(),
                    })
                    .optional(),
                  requestor_challenge_indicator: z.string().max(2).optional(),
                  transaction_id: z.string().max(5000).optional(),
                  version: z.enum(["1.0.2", "2.1.0", "2.2.0"]).optional(),
                })
                .optional(),
            })
            .optional(),
          card_present: z.object({}).optional(),
          link: z.object({}).optional(),
          paypal: z
            .object({ billing_agreement_id: z.string().max(5000).optional() })
            .optional(),
          sepa_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          us_bank_account: z
            .object({
              financial_connections: z
                .object({
                  filters: z
                    .object({
                      account_subcategories: z
                        .array(z.enum(["checking", "savings"]))
                        .optional(),
                    })
                    .optional(),
                  permissions: z
                    .array(
                      z.enum([
                        "balances",
                        "ownership",
                        "payment_method",
                        "transactions",
                      ]),
                    )
                    .optional(),
                  prefetch: z
                    .array(z.enum(["balances", "ownership", "transactions"]))
                    .optional(),
                  return_url: z.string().max(5000).optional(),
                })
                .optional(),
              mandate_options: z
                .object({ collection_method: z.enum(["", "paper"]).optional() })
                .optional(),
              networks: z
                .object({
                  requested: z
                    .array(z.enum(["ach", "us_domestic_wire"]))
                    .optional(),
                })
                .optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      payment_method_types: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postSetupIntentsIntent",
    "/v1/setup_intents/:intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSetupIntentsIntent(input, postSetupIntentsIntent.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntent.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentCancelParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postSetupIntentsIntentCancelBodySchema = z
    .object({
      cancellation_reason: z
        .enum(["abandoned", "duplicate", "requested_by_customer"])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postSetupIntentsIntentCancel",
    "/v1/setup_intents/:intent/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSetupIntentsIntentCancel(
          input,
          postSetupIntentsIntentCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntentCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentConfirmParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postSetupIntentsIntentConfirmBodySchema = z
    .object({
      client_secret: z.string().max(5000).optional(),
      confirmation_token: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      mandate_data: z
        .union([
          z.object({
            customer_acceptance: z.object({
              accepted_at: z.coerce.number().optional(),
              offline: z.object({}).optional(),
              online: z
                .object({
                  ip_address: z.string(),
                  user_agent: z.string().max(5000),
                })
                .optional(),
              type: z.enum(["offline", "online"]),
            }),
          }),
          z.enum([""]),
          z.object({
            customer_acceptance: z.object({
              online: z.object({
                ip_address: z.string().optional(),
                user_agent: z.string().max(5000).optional(),
              }),
              type: z.enum(["online"]),
            }),
          }),
        ])
        .optional(),
      payment_method: z.string().max(5000).optional(),
      payment_method_data: z
        .object({
          acss_debit: z
            .object({
              account_number: z.string().max(5000),
              institution_number: z.string().max(5000),
              transit_number: z.string().max(5000),
            })
            .optional(),
          affirm: z.object({}).optional(),
          afterpay_clearpay: z.object({}).optional(),
          alipay: z.object({}).optional(),
          allow_redisplay: z
            .enum(["always", "limited", "unspecified"])
            .optional(),
          alma: z.object({}).optional(),
          amazon_pay: z.object({}).optional(),
          au_becs_debit: z
            .object({
              account_number: z.string().max(5000),
              bsb_number: z.string().max(5000),
            })
            .optional(),
          bacs_debit: z
            .object({
              account_number: z.string().max(5000).optional(),
              sort_code: z.string().max(5000).optional(),
            })
            .optional(),
          bancontact: z.object({}).optional(),
          billie: z.object({}).optional(),
          billing_details: z
            .object({
              address: z
                .union([
                  z.object({
                    city: z.string().max(5000).optional(),
                    country: z.string().max(5000).optional(),
                    line1: z.string().max(5000).optional(),
                    line2: z.string().max(5000).optional(),
                    postal_code: z.string().max(5000).optional(),
                    state: z.string().max(5000).optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              email: z.union([z.string(), z.enum([""])]).optional(),
              name: z.union([z.string().max(5000), z.enum([""])]).optional(),
              phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
            })
            .optional(),
          blik: z.object({}).optional(),
          boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
          cashapp: z.object({}).optional(),
          customer_balance: z.object({}).optional(),
          eps: z
            .object({
              bank: z
                .enum([
                  "arzte_und_apotheker_bank",
                  "austrian_anadi_bank_ag",
                  "bank_austria",
                  "bankhaus_carl_spangler",
                  "bankhaus_schelhammer_und_schattera_ag",
                  "bawag_psk_ag",
                  "bks_bank_ag",
                  "brull_kallmus_bank_ag",
                  "btv_vier_lander_bank",
                  "capital_bank_grawe_gruppe_ag",
                  "deutsche_bank_ag",
                  "dolomitenbank",
                  "easybank_ag",
                  "erste_bank_und_sparkassen",
                  "hypo_alpeadriabank_international_ag",
                  "hypo_bank_burgenland_aktiengesellschaft",
                  "hypo_noe_lb_fur_niederosterreich_u_wien",
                  "hypo_oberosterreich_salzburg_steiermark",
                  "hypo_tirol_bank_ag",
                  "hypo_vorarlberg_bank_ag",
                  "marchfelder_bank",
                  "oberbank_ag",
                  "raiffeisen_bankengruppe_osterreich",
                  "schoellerbank_ag",
                  "sparda_bank_wien",
                  "volksbank_gruppe",
                  "volkskreditbank_ag",
                  "vr_bank_braunau",
                ])
                .optional(),
            })
            .optional(),
          fpx: z
            .object({
              bank: z.enum([
                "affin_bank",
                "agrobank",
                "alliance_bank",
                "ambank",
                "bank_islam",
                "bank_muamalat",
                "bank_of_china",
                "bank_rakyat",
                "bsn",
                "cimb",
                "deutsche_bank",
                "hong_leong_bank",
                "hsbc",
                "kfh",
                "maybank2e",
                "maybank2u",
                "ocbc",
                "pb_enterprise",
                "public_bank",
                "rhb",
                "standard_chartered",
                "uob",
              ]),
            })
            .optional(),
          giropay: z.object({}).optional(),
          grabpay: z.object({}).optional(),
          ideal: z
            .object({
              bank: z
                .enum([
                  "abn_amro",
                  "asn_bank",
                  "bunq",
                  "handelsbanken",
                  "ing",
                  "knab",
                  "moneyou",
                  "n26",
                  "nn",
                  "rabobank",
                  "regiobank",
                  "revolut",
                  "sns_bank",
                  "triodos_bank",
                  "van_lanschot",
                  "yoursafe",
                ])
                .optional(),
            })
            .optional(),
          interac_present: z.object({}).optional(),
          kakao_pay: z.object({}).optional(),
          klarna: z
            .object({
              dob: z
                .object({
                  day: z.coerce.number(),
                  month: z.coerce.number(),
                  year: z.coerce.number(),
                })
                .optional(),
            })
            .optional(),
          konbini: z.object({}).optional(),
          kr_card: z.object({}).optional(),
          link: z.object({}).optional(),
          metadata: z.record(z.string()).optional(),
          mobilepay: z.object({}).optional(),
          multibanco: z.object({}).optional(),
          naver_pay: z
            .object({ funding: z.enum(["card", "points"]).optional() })
            .optional(),
          nz_bank_account: z
            .object({
              account_holder_name: z.string().max(5000).optional(),
              account_number: z.string().max(5000),
              bank_code: z.string().max(5000),
              branch_code: z.string().max(5000),
              reference: z.string().max(128).optional(),
              suffix: z.string().max(5000),
            })
            .optional(),
          oxxo: z.object({}).optional(),
          p24: z
            .object({
              bank: z
                .enum([
                  "alior_bank",
                  "bank_millennium",
                  "bank_nowy_bfg_sa",
                  "bank_pekao_sa",
                  "banki_spbdzielcze",
                  "blik",
                  "bnp_paribas",
                  "boz",
                  "citi_handlowy",
                  "credit_agricole",
                  "envelobank",
                  "etransfer_pocztowy24",
                  "getin_bank",
                  "ideabank",
                  "ing",
                  "inteligo",
                  "mbank_mtransfer",
                  "nest_przelew",
                  "noble_pay",
                  "pbac_z_ipko",
                  "plus_bank",
                  "santander_przelew24",
                  "tmobile_usbugi_bankowe",
                  "toyota_bank",
                  "velobank",
                  "volkswagen_bank",
                ])
                .optional(),
            })
            .optional(),
          pay_by_bank: z.object({}).optional(),
          payco: z.object({}).optional(),
          paynow: z.object({}).optional(),
          paypal: z.object({}).optional(),
          pix: z.object({}).optional(),
          promptpay: z.object({}).optional(),
          radar_options: z
            .object({ session: z.string().max(5000).optional() })
            .optional(),
          revolut_pay: z.object({}).optional(),
          samsung_pay: z.object({}).optional(),
          satispay: z.object({}).optional(),
          sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
          sofort: z
            .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
            .optional(),
          swish: z.object({}).optional(),
          twint: z.object({}).optional(),
          type: z.enum([
            "acss_debit",
            "affirm",
            "afterpay_clearpay",
            "alipay",
            "alma",
            "amazon_pay",
            "au_becs_debit",
            "bacs_debit",
            "bancontact",
            "billie",
            "blik",
            "boleto",
            "cashapp",
            "customer_balance",
            "eps",
            "fpx",
            "giropay",
            "grabpay",
            "ideal",
            "kakao_pay",
            "klarna",
            "konbini",
            "kr_card",
            "link",
            "mobilepay",
            "multibanco",
            "naver_pay",
            "nz_bank_account",
            "oxxo",
            "p24",
            "pay_by_bank",
            "payco",
            "paynow",
            "paypal",
            "pix",
            "promptpay",
            "revolut_pay",
            "samsung_pay",
            "satispay",
            "sepa_debit",
            "sofort",
            "swish",
            "twint",
            "us_bank_account",
            "wechat_pay",
            "zip",
          ]),
          us_bank_account: z
            .object({
              account_holder_type: z.enum(["company", "individual"]).optional(),
              account_number: z.string().max(5000).optional(),
              account_type: z.enum(["checking", "savings"]).optional(),
              financial_connections_account: z.string().max(5000).optional(),
              routing_number: z.string().max(5000).optional(),
            })
            .optional(),
          wechat_pay: z.object({}).optional(),
          zip: z.object({}).optional(),
        })
        .optional(),
      payment_method_options: z
        .object({
          acss_debit: z
            .object({
              currency: z.enum(["cad", "usd"]).optional(),
              mandate_options: z
                .object({
                  custom_mandate_url: z
                    .union([z.string(), z.enum([""])])
                    .optional(),
                  default_for: z
                    .array(z.enum(["invoice", "subscription"]))
                    .optional(),
                  interval_description: z.string().max(500).optional(),
                  payment_schedule: z
                    .enum(["combined", "interval", "sporadic"])
                    .optional(),
                  transaction_type: z.enum(["business", "personal"]).optional(),
                })
                .optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            })
            .optional(),
          amazon_pay: z.object({}).optional(),
          bacs_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          card: z
            .object({
              mandate_options: z
                .object({
                  amount: z.coerce.number(),
                  amount_type: z.enum(["fixed", "maximum"]),
                  currency: z.string(),
                  description: z.string().max(200).optional(),
                  end_date: z.coerce.number().optional(),
                  interval: z.enum([
                    "day",
                    "month",
                    "sporadic",
                    "week",
                    "year",
                  ]),
                  interval_count: z.coerce.number().optional(),
                  reference: z.string().max(80),
                  start_date: z.coerce.number(),
                  supported_types: z.array(z.enum(["india"])).optional(),
                })
                .optional(),
              network: z
                .enum([
                  "amex",
                  "cartes_bancaires",
                  "diners",
                  "discover",
                  "eftpos_au",
                  "girocard",
                  "interac",
                  "jcb",
                  "link",
                  "mastercard",
                  "unionpay",
                  "unknown",
                  "visa",
                ])
                .optional(),
              request_three_d_secure: z
                .enum(["any", "automatic", "challenge"])
                .optional(),
              three_d_secure: z
                .object({
                  ares_trans_status: z
                    .enum(["A", "C", "I", "N", "R", "U", "Y"])
                    .optional(),
                  cryptogram: z.string().max(5000).optional(),
                  electronic_commerce_indicator: z
                    .enum(["01", "02", "05", "06", "07"])
                    .optional(),
                  network_options: z
                    .object({
                      cartes_bancaires: z
                        .object({
                          cb_avalgo: z.enum(["0", "1", "2", "3", "4", "A"]),
                          cb_exemption: z.string().max(4).optional(),
                          cb_score: z.coerce.number().optional(),
                        })
                        .optional(),
                    })
                    .optional(),
                  requestor_challenge_indicator: z.string().max(2).optional(),
                  transaction_id: z.string().max(5000).optional(),
                  version: z.enum(["1.0.2", "2.1.0", "2.2.0"]).optional(),
                })
                .optional(),
            })
            .optional(),
          card_present: z.object({}).optional(),
          link: z.object({}).optional(),
          paypal: z
            .object({ billing_agreement_id: z.string().max(5000).optional() })
            .optional(),
          sepa_debit: z
            .object({
              mandate_options: z
                .object({
                  reference_prefix: z
                    .union([z.string().max(12), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          us_bank_account: z
            .object({
              financial_connections: z
                .object({
                  filters: z
                    .object({
                      account_subcategories: z
                        .array(z.enum(["checking", "savings"]))
                        .optional(),
                    })
                    .optional(),
                  permissions: z
                    .array(
                      z.enum([
                        "balances",
                        "ownership",
                        "payment_method",
                        "transactions",
                      ]),
                    )
                    .optional(),
                  prefetch: z
                    .array(z.enum(["balances", "ownership", "transactions"]))
                    .optional(),
                  return_url: z.string().max(5000).optional(),
                })
                .optional(),
              mandate_options: z
                .object({ collection_method: z.enum(["", "paper"]).optional() })
                .optional(),
              networks: z
                .object({
                  requested: z
                    .array(z.enum(["ach", "us_domestic_wire"]))
                    .optional(),
                })
                .optional(),
              verification_method: z
                .enum(["automatic", "instant", "microdeposits"])
                .optional(),
            })
            .optional(),
        })
        .optional(),
      return_url: z.string().optional(),
      use_stripe_sdk: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postSetupIntentsIntentConfirm",
    "/v1/setup_intents/:intent/confirm",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentConfirmParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentConfirmBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSetupIntentsIntentConfirm(
          input,
          postSetupIntentsIntentConfirm.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntentConfirm.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSetupIntentsIntentVerifyMicrodepositsParamSchema = z.object({
    intent: z.string().max(5000),
  })

  const postSetupIntentsIntentVerifyMicrodepositsBodySchema = z
    .object({
      amounts: z.array(z.coerce.number()).optional(),
      client_secret: z.string().max(5000).optional(),
      descriptor_code: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
    })
    .optional()

  router.post(
    "postSetupIntentsIntentVerifyMicrodeposits",
    "/v1/setup_intents/:intent/verify_microdeposits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSetupIntentsIntentVerifyMicrodepositsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSetupIntentsIntentVerifyMicrodepositsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSetupIntentsIntentVerifyMicrodeposits(
          input,
          postSetupIntentsIntentVerifyMicrodeposits.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSetupIntentsIntentVerifyMicrodeposits.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getShippingRatesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    currency: z.string().optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getShippingRatesBodySchema = z.object({}).optional()

  router.get("getShippingRates", "/v1/shipping_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getShippingRatesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getShippingRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getShippingRates(input, getShippingRates.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getShippingRates.validator(status, body)
    ctx.status = status
    return next()
  })

  const postShippingRatesBodySchema = z.object({
    delivery_estimate: z
      .object({
        maximum: z
          .object({
            unit: z.enum(["business_day", "day", "hour", "month", "week"]),
            value: z.coerce.number(),
          })
          .optional(),
        minimum: z
          .object({
            unit: z.enum(["business_day", "day", "hour", "month", "week"]),
            value: z.coerce.number(),
          })
          .optional(),
      })
      .optional(),
    display_name: z.string().max(100),
    expand: z.array(z.string().max(5000)).optional(),
    fixed_amount: z
      .object({
        amount: z.coerce.number(),
        currency: z.string(),
        currency_options: z
          .record(
            z.object({
              amount: z.coerce.number(),
              tax_behavior: z
                .enum(["exclusive", "inclusive", "unspecified"])
                .optional(),
            }),
          )
          .optional(),
      })
      .optional(),
    metadata: z.record(z.string()).optional(),
    tax_behavior: z.enum(["exclusive", "inclusive", "unspecified"]).optional(),
    tax_code: z.string().optional(),
    type: z.enum(["fixed_amount"]).optional(),
  })

  router.post("postShippingRates", "/v1/shipping_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postShippingRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postShippingRates(input, postShippingRates.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postShippingRates.validator(status, body)
    ctx.status = status
    return next()
  })

  const getShippingRatesShippingRateTokenParamSchema = z.object({
    shipping_rate_token: z.string().max(5000),
  })

  const getShippingRatesShippingRateTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getShippingRatesShippingRateTokenBodySchema = z.object({}).optional()

  router.get(
    "getShippingRatesShippingRateToken",
    "/v1/shipping_rates/:shipping_rate_token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getShippingRatesShippingRateTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getShippingRatesShippingRateTokenQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getShippingRatesShippingRateTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getShippingRatesShippingRateToken(
          input,
          getShippingRatesShippingRateToken.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getShippingRatesShippingRateToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postShippingRatesShippingRateTokenParamSchema = z.object({
    shipping_rate_token: z.string().max(5000),
  })

  const postShippingRatesShippingRateTokenBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      fixed_amount: z
        .object({
          currency_options: z
            .record(
              z.object({
                amount: z.coerce.number().optional(),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
              }),
            )
            .optional(),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      tax_behavior: z
        .enum(["exclusive", "inclusive", "unspecified"])
        .optional(),
    })
    .optional()

  router.post(
    "postShippingRatesShippingRateToken",
    "/v1/shipping_rates/:shipping_rate_token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postShippingRatesShippingRateTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postShippingRatesShippingRateTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postShippingRatesShippingRateToken(
          input,
          postShippingRatesShippingRateToken.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postShippingRatesShippingRateToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSigmaSavedQueriesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postSigmaSavedQueriesIdBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      name: z.string().max(5000).optional(),
      sql: z.string().max(100000).optional(),
    })
    .optional()

  router.post(
    "postSigmaSavedQueriesId",
    "/v1/sigma/saved_queries/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSigmaSavedQueriesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSigmaSavedQueriesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSigmaSavedQueriesId(input, postSigmaSavedQueriesId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSigmaSavedQueriesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSigmaScheduledQueryRunsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getSigmaScheduledQueryRunsBodySchema = z.object({}).optional()

  router.get(
    "getSigmaScheduledQueryRuns",
    "/v1/sigma/scheduled_query_runs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSigmaScheduledQueryRunsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSigmaScheduledQueryRunsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSigmaScheduledQueryRuns(
          input,
          getSigmaScheduledQueryRuns.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSigmaScheduledQueryRuns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSigmaScheduledQueryRunsScheduledQueryRunParamSchema = z.object({
    scheduled_query_run: z.string().max(5000),
  })

  const getSigmaScheduledQueryRunsScheduledQueryRunQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getSigmaScheduledQueryRunsScheduledQueryRunBodySchema = z
    .object({})
    .optional()

  router.get(
    "getSigmaScheduledQueryRunsScheduledQueryRun",
    "/v1/sigma/scheduled_query_runs/:scheduled_query_run",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSigmaScheduledQueryRunsScheduledQueryRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSigmaScheduledQueryRunsScheduledQueryRunQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSigmaScheduledQueryRunsScheduledQueryRunBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSigmaScheduledQueryRunsScheduledQueryRun(
          input,
          getSigmaScheduledQueryRunsScheduledQueryRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSigmaScheduledQueryRunsScheduledQueryRun.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSourcesBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      currency: z.string().optional(),
      customer: z.string().max(500).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      flow: z
        .enum(["code_verification", "none", "receiver", "redirect"])
        .optional(),
      mandate: z
        .object({
          acceptance: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              offline: z.object({ contact_email: z.string() }).optional(),
              online: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z.string().max(5000).optional(),
                })
                .optional(),
              status: z.enum(["accepted", "pending", "refused", "revoked"]),
              type: z.enum(["offline", "online"]).optional(),
              user_agent: z.string().max(5000).optional(),
            })
            .optional(),
          amount: z.union([z.coerce.number(), z.enum([""])]).optional(),
          currency: z.string().optional(),
          interval: z.enum(["one_time", "scheduled", "variable"]).optional(),
          notification_method: z
            .enum([
              "deprecated_none",
              "email",
              "manual",
              "none",
              "stripe_email",
            ])
            .optional(),
        })
        .optional(),
      metadata: z.record(z.string()).optional(),
      original_source: z.string().max(5000).optional(),
      owner: z
        .object({
          address: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          email: z.string().optional(),
          name: z.string().max(5000).optional(),
          phone: z.string().max(5000).optional(),
        })
        .optional(),
      receiver: z
        .object({
          refund_attributes_method: z
            .enum(["email", "manual", "none"])
            .optional(),
        })
        .optional(),
      redirect: z.object({ return_url: z.string() }).optional(),
      source_order: z
        .object({
          items: z
            .array(
              z.object({
                amount: z.coerce.number().optional(),
                currency: z.string().optional(),
                description: z.string().max(1000).optional(),
                parent: z.string().max(5000).optional(),
                quantity: z.coerce.number().optional(),
                type: z.enum(["discount", "shipping", "sku", "tax"]).optional(),
              }),
            )
            .optional(),
          shipping: z
            .object({
              address: z.object({
                city: z.string().max(5000).optional(),
                country: z.string().max(5000).optional(),
                line1: z.string().max(5000),
                line2: z.string().max(5000).optional(),
                postal_code: z.string().max(5000).optional(),
                state: z.string().max(5000).optional(),
              }),
              carrier: z.string().max(5000).optional(),
              name: z.string().max(5000).optional(),
              phone: z.string().max(5000).optional(),
              tracking_number: z.string().max(5000).optional(),
            })
            .optional(),
        })
        .optional(),
      statement_descriptor: z.string().max(5000).optional(),
      token: z.string().max(5000).optional(),
      type: z.string().max(5000).optional(),
      usage: z.enum(["reusable", "single_use"]).optional(),
    })
    .optional()

  router.post("postSources", "/v1/sources", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postSourcesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postSources(input, postSources.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSources.validator(status, body)
    ctx.status = status
    return next()
  })

  const getSourcesSourceParamSchema = z.object({ source: z.string().max(5000) })

  const getSourcesSourceQuerySchema = z.object({
    client_secret: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getSourcesSourceBodySchema = z.object({}).optional()

  router.get("getSourcesSource", "/v1/sources/:source", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getSourcesSourceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getSourcesSourceQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSourcesSourceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getSourcesSource(input, getSourcesSource.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSourcesSource.validator(status, body)
    ctx.status = status
    return next()
  })

  const postSourcesSourceParamSchema = z.object({
    source: z.string().max(5000),
  })

  const postSourcesSourceBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      mandate: z
        .object({
          acceptance: z
            .object({
              date: z.coerce.number().optional(),
              ip: z.string().optional(),
              offline: z.object({ contact_email: z.string() }).optional(),
              online: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z.string().max(5000).optional(),
                })
                .optional(),
              status: z.enum(["accepted", "pending", "refused", "revoked"]),
              type: z.enum(["offline", "online"]).optional(),
              user_agent: z.string().max(5000).optional(),
            })
            .optional(),
          amount: z.union([z.coerce.number(), z.enum([""])]).optional(),
          currency: z.string().optional(),
          interval: z.enum(["one_time", "scheduled", "variable"]).optional(),
          notification_method: z
            .enum([
              "deprecated_none",
              "email",
              "manual",
              "none",
              "stripe_email",
            ])
            .optional(),
        })
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      owner: z
        .object({
          address: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          email: z.string().optional(),
          name: z.string().max(5000).optional(),
          phone: z.string().max(5000).optional(),
        })
        .optional(),
      source_order: z
        .object({
          items: z
            .array(
              z.object({
                amount: z.coerce.number().optional(),
                currency: z.string().optional(),
                description: z.string().max(1000).optional(),
                parent: z.string().max(5000).optional(),
                quantity: z.coerce.number().optional(),
                type: z.enum(["discount", "shipping", "sku", "tax"]).optional(),
              }),
            )
            .optional(),
          shipping: z
            .object({
              address: z.object({
                city: z.string().max(5000).optional(),
                country: z.string().max(5000).optional(),
                line1: z.string().max(5000),
                line2: z.string().max(5000).optional(),
                postal_code: z.string().max(5000).optional(),
                state: z.string().max(5000).optional(),
              }),
              carrier: z.string().max(5000).optional(),
              name: z.string().max(5000).optional(),
              phone: z.string().max(5000).optional(),
              tracking_number: z.string().max(5000).optional(),
            })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post("postSourcesSource", "/v1/sources/:source", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postSourcesSourceParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postSourcesSourceBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postSourcesSource(input, postSourcesSource.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSourcesSource.validator(status, body)
    ctx.status = status
    return next()
  })

  const getSourcesSourceMandateNotificationsMandateNotificationParamSchema =
    z.object({
      mandate_notification: z.string().max(5000),
      source: z.string().max(5000),
    })

  const getSourcesSourceMandateNotificationsMandateNotificationQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getSourcesSourceMandateNotificationsMandateNotificationBodySchema = z
    .object({})
    .optional()

  router.get(
    "getSourcesSourceMandateNotificationsMandateNotification",
    "/v1/sources/:source/mandate_notifications/:mandate_notification",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSourcesSourceMandateNotificationsMandateNotificationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSourcesSourceMandateNotificationsMandateNotificationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSourcesSourceMandateNotificationsMandateNotificationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSourcesSourceMandateNotificationsMandateNotification(
          input,
          getSourcesSourceMandateNotificationsMandateNotification.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        getSourcesSourceMandateNotificationsMandateNotification.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getSourcesSourceSourceTransactionsParamSchema = z.object({
    source: z.string().max(5000),
  })

  const getSourcesSourceSourceTransactionsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getSourcesSourceSourceTransactionsBodySchema = z.object({}).optional()

  router.get(
    "getSourcesSourceSourceTransactions",
    "/v1/sources/:source/source_transactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSourcesSourceSourceTransactionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSourcesSourceSourceTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSourcesSourceSourceTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSourcesSourceSourceTransactions(
          input,
          getSourcesSourceSourceTransactions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSourcesSourceSourceTransactions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSourcesSourceSourceTransactionsSourceTransactionParamSchema =
    z.object({
      source: z.string().max(5000),
      source_transaction: z.string().max(5000),
    })

  const getSourcesSourceSourceTransactionsSourceTransactionQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getSourcesSourceSourceTransactionsSourceTransactionBodySchema = z
    .object({})
    .optional()

  router.get(
    "getSourcesSourceSourceTransactionsSourceTransaction",
    "/v1/sources/:source/source_transactions/:source_transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSourcesSourceSourceTransactionsSourceTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSourcesSourceSourceTransactionsSourceTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSourcesSourceSourceTransactionsSourceTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSourcesSourceSourceTransactionsSourceTransaction(
          input,
          getSourcesSourceSourceTransactionsSourceTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSourcesSourceSourceTransactionsSourceTransaction.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSourcesSourceVerifyParamSchema = z.object({
    source: z.string().max(5000),
  })

  const postSourcesSourceVerifyBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    values: z.array(z.string().max(5000)),
  })

  router.post(
    "postSourcesSourceVerify",
    "/v1/sources/:source/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSourcesSourceVerifyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSourcesSourceVerifyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSourcesSourceVerify(input, postSourcesSourceVerify.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSourcesSourceVerify.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionItemsQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
    subscription: z.string().max(5000),
  })

  const getSubscriptionItemsBodySchema = z.object({}).optional()

  router.get(
    "getSubscriptionItems",
    "/v1/subscription_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSubscriptionItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSubscriptionItems(input, getSubscriptionItems.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionItemsBodySchema = z.object({
    discounts: z
      .union([
        z.array(
          z.object({
            coupon: z.string().max(5000).optional(),
            discount: z.string().max(5000).optional(),
            promotion_code: z.string().max(5000).optional(),
          }),
        ),
        z.enum([""]),
      ])
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    payment_behavior: z
      .enum([
        "allow_incomplete",
        "default_incomplete",
        "error_if_incomplete",
        "pending_if_incomplete",
      ])
      .optional(),
    price: z.string().max(5000).optional(),
    price_data: z
      .object({
        currency: z.string(),
        product: z.string().max(5000),
        recurring: z.object({
          interval: z.enum(["day", "month", "week", "year"]),
          interval_count: z.coerce.number().optional(),
        }),
        tax_behavior: z
          .enum(["exclusive", "inclusive", "unspecified"])
          .optional(),
        unit_amount: z.coerce.number().optional(),
        unit_amount_decimal: z.string().optional(),
      })
      .optional(),
    proration_behavior: z
      .enum(["always_invoice", "create_prorations", "none"])
      .optional(),
    proration_date: z.coerce.number().optional(),
    quantity: z.coerce.number().optional(),
    subscription: z.string().max(5000),
    tax_rates: z
      .union([z.array(z.string().max(5000)), z.enum([""])])
      .optional(),
  })

  router.post(
    "postSubscriptionItems",
    "/v1/subscription_items",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postSubscriptionItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionItems(input, postSubscriptionItems.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const deleteSubscriptionItemsItemBodySchema = z
    .object({
      clear_usage: PermissiveBoolean.optional(),
      proration_behavior: z
        .enum(["always_invoice", "create_prorations", "none"])
        .optional(),
      proration_date: z.coerce.number().optional(),
    })
    .optional()

  router.delete(
    "deleteSubscriptionItemsItem",
    "/v1/subscription_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteSubscriptionItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteSubscriptionItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteSubscriptionItemsItem(
          input,
          deleteSubscriptionItemsItem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteSubscriptionItemsItem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const getSubscriptionItemsItemQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getSubscriptionItemsItemBodySchema = z.object({}).optional()

  router.get(
    "getSubscriptionItemsItem",
    "/v1/subscription_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSubscriptionItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSubscriptionItemsItemQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSubscriptionItemsItem(
          input,
          getSubscriptionItemsItem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionItemsItem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionItemsItemParamSchema = z.object({
    item: z.string().max(5000),
  })

  const postSubscriptionItemsItemBodySchema = z
    .object({
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      off_session: PermissiveBoolean.optional(),
      payment_behavior: z
        .enum([
          "allow_incomplete",
          "default_incomplete",
          "error_if_incomplete",
          "pending_if_incomplete",
        ])
        .optional(),
      price: z.string().max(5000).optional(),
      price_data: z
        .object({
          currency: z.string(),
          product: z.string().max(5000),
          recurring: z.object({
            interval: z.enum(["day", "month", "week", "year"]),
            interval_count: z.coerce.number().optional(),
          }),
          tax_behavior: z
            .enum(["exclusive", "inclusive", "unspecified"])
            .optional(),
          unit_amount: z.coerce.number().optional(),
          unit_amount_decimal: z.string().optional(),
        })
        .optional(),
      proration_behavior: z
        .enum(["always_invoice", "create_prorations", "none"])
        .optional(),
      proration_date: z.coerce.number().optional(),
      quantity: z.coerce.number().optional(),
      tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
    })
    .optional()

  router.post(
    "postSubscriptionItemsItem",
    "/v1/subscription_items/:item",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionItemsItemParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionItemsItemBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionItemsItem(
          input,
          postSubscriptionItemsItem.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionItemsItem.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionSchedulesQuerySchema = z.object({
    canceled_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    completed_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    released_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    scheduled: PermissiveBoolean.optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getSubscriptionSchedulesBodySchema = z.object({}).optional()

  router.get(
    "getSubscriptionSchedules",
    "/v1/subscription_schedules",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSubscriptionSchedulesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionSchedulesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSubscriptionSchedules(
          input,
          getSubscriptionSchedules.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionSchedules.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionSchedulesBodySchema = z
    .object({
      customer: z.string().max(5000).optional(),
      default_settings: z
        .object({
          application_fee_percent: z.coerce.number().optional(),
          automatic_tax: z
            .object({
              enabled: PermissiveBoolean,
              liability: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
            })
            .optional(),
          billing_cycle_anchor: z.enum(["automatic", "phase_start"]).optional(),
          collection_method: z
            .enum(["charge_automatically", "send_invoice"])
            .optional(),
          default_payment_method: z.string().max(5000).optional(),
          description: z.union([z.string().max(500), z.enum([""])]).optional(),
          invoice_settings: z
            .object({
              account_tax_ids: z
                .union([z.array(z.string().max(5000)), z.enum([""])])
                .optional(),
              days_until_due: z.coerce.number().optional(),
              issuer: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
            })
            .optional(),
          on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
          transfer_data: z
            .union([
              z.object({
                amount_percent: z.coerce.number().optional(),
                destination: z.string(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      end_behavior: z.enum(["cancel", "none", "release", "renew"]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      from_subscription: z.string().max(5000).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      phases: z
        .array(
          z.object({
            add_invoice_items: z
              .array(
                z.object({
                  discounts: z
                    .array(
                      z.object({
                        coupon: z.string().max(5000).optional(),
                        discount: z.string().max(5000).optional(),
                        promotion_code: z.string().max(5000).optional(),
                      }),
                    )
                    .optional(),
                  price: z.string().max(5000).optional(),
                  price_data: z
                    .object({
                      currency: z.string(),
                      product: z.string().max(5000),
                      tax_behavior: z
                        .enum(["exclusive", "inclusive", "unspecified"])
                        .optional(),
                      unit_amount: z.coerce.number().optional(),
                      unit_amount_decimal: z.string().optional(),
                    })
                    .optional(),
                  quantity: z.coerce.number().optional(),
                  tax_rates: z
                    .union([z.array(z.string().max(5000)), z.enum([""])])
                    .optional(),
                }),
              )
              .optional(),
            application_fee_percent: z.coerce.number().optional(),
            automatic_tax: z
              .object({
                enabled: PermissiveBoolean,
                liability: z
                  .object({
                    account: z.string().optional(),
                    type: z.enum(["account", "self"]),
                  })
                  .optional(),
              })
              .optional(),
            billing_cycle_anchor: z
              .enum(["automatic", "phase_start"])
              .optional(),
            collection_method: z
              .enum(["charge_automatically", "send_invoice"])
              .optional(),
            currency: z.string().optional(),
            default_payment_method: z.string().max(5000).optional(),
            default_tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            description: z
              .union([z.string().max(500), z.enum([""])])
              .optional(),
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            end_date: z.coerce.number().optional(),
            invoice_settings: z
              .object({
                account_tax_ids: z
                  .union([z.array(z.string().max(5000)), z.enum([""])])
                  .optional(),
                days_until_due: z.coerce.number().optional(),
                issuer: z
                  .object({
                    account: z.string().optional(),
                    type: z.enum(["account", "self"]),
                  })
                  .optional(),
              })
              .optional(),
            items: z.array(
              z.object({
                discounts: z
                  .union([
                    z.array(
                      z.object({
                        coupon: z.string().max(5000).optional(),
                        discount: z.string().max(5000).optional(),
                        promotion_code: z.string().max(5000).optional(),
                      }),
                    ),
                    z.enum([""]),
                  ])
                  .optional(),
                metadata: z.record(z.string()).optional(),
                price: z.string().max(5000).optional(),
                price_data: z
                  .object({
                    currency: z.string(),
                    product: z.string().max(5000),
                    recurring: z.object({
                      interval: z.enum(["day", "month", "week", "year"]),
                      interval_count: z.coerce.number().optional(),
                    }),
                    tax_behavior: z
                      .enum(["exclusive", "inclusive", "unspecified"])
                      .optional(),
                    unit_amount: z.coerce.number().optional(),
                    unit_amount_decimal: z.string().optional(),
                  })
                  .optional(),
                quantity: z.coerce.number().optional(),
                tax_rates: z
                  .union([z.array(z.string().max(5000)), z.enum([""])])
                  .optional(),
              }),
            ),
            iterations: z.coerce.number().optional(),
            metadata: z.record(z.string()).optional(),
            on_behalf_of: z.string().optional(),
            proration_behavior: z
              .enum(["always_invoice", "create_prorations", "none"])
              .optional(),
            transfer_data: z
              .object({
                amount_percent: z.coerce.number().optional(),
                destination: z.string(),
              })
              .optional(),
            trial: PermissiveBoolean.optional(),
            trial_end: z.coerce.number().optional(),
          }),
        )
        .optional(),
      start_date: z.union([z.coerce.number(), z.enum(["now"])]).optional(),
    })
    .optional()

  router.post(
    "postSubscriptionSchedules",
    "/v1/subscription_schedules",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionSchedules(
          input,
          postSubscriptionSchedules.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedules.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionSchedulesScheduleParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  const getSubscriptionSchedulesScheduleQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getSubscriptionSchedulesScheduleBodySchema = z.object({}).optional()

  router.get(
    "getSubscriptionSchedulesSchedule",
    "/v1/subscription_schedules/:schedule",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSubscriptionSchedulesScheduleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSubscriptionSchedulesScheduleQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionSchedulesScheduleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSubscriptionSchedulesSchedule(
          input,
          getSubscriptionSchedulesSchedule.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionSchedulesSchedule.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionSchedulesScheduleParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  const postSubscriptionSchedulesScheduleBodySchema = z
    .object({
      default_settings: z
        .object({
          application_fee_percent: z.coerce.number().optional(),
          automatic_tax: z
            .object({
              enabled: PermissiveBoolean,
              liability: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
            })
            .optional(),
          billing_cycle_anchor: z.enum(["automatic", "phase_start"]).optional(),
          collection_method: z
            .enum(["charge_automatically", "send_invoice"])
            .optional(),
          default_payment_method: z.string().max(5000).optional(),
          description: z.union([z.string().max(500), z.enum([""])]).optional(),
          invoice_settings: z
            .object({
              account_tax_ids: z
                .union([z.array(z.string().max(5000)), z.enum([""])])
                .optional(),
              days_until_due: z.coerce.number().optional(),
              issuer: z
                .object({
                  account: z.string().optional(),
                  type: z.enum(["account", "self"]),
                })
                .optional(),
            })
            .optional(),
          on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
          transfer_data: z
            .union([
              z.object({
                amount_percent: z.coerce.number().optional(),
                destination: z.string(),
              }),
              z.enum([""]),
            ])
            .optional(),
        })
        .optional(),
      end_behavior: z.enum(["cancel", "none", "release", "renew"]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      phases: z
        .array(
          z.object({
            add_invoice_items: z
              .array(
                z.object({
                  discounts: z
                    .array(
                      z.object({
                        coupon: z.string().max(5000).optional(),
                        discount: z.string().max(5000).optional(),
                        promotion_code: z.string().max(5000).optional(),
                      }),
                    )
                    .optional(),
                  price: z.string().max(5000).optional(),
                  price_data: z
                    .object({
                      currency: z.string(),
                      product: z.string().max(5000),
                      tax_behavior: z
                        .enum(["exclusive", "inclusive", "unspecified"])
                        .optional(),
                      unit_amount: z.coerce.number().optional(),
                      unit_amount_decimal: z.string().optional(),
                    })
                    .optional(),
                  quantity: z.coerce.number().optional(),
                  tax_rates: z
                    .union([z.array(z.string().max(5000)), z.enum([""])])
                    .optional(),
                }),
              )
              .optional(),
            application_fee_percent: z.coerce.number().optional(),
            automatic_tax: z
              .object({
                enabled: PermissiveBoolean,
                liability: z
                  .object({
                    account: z.string().optional(),
                    type: z.enum(["account", "self"]),
                  })
                  .optional(),
              })
              .optional(),
            billing_cycle_anchor: z
              .enum(["automatic", "phase_start"])
              .optional(),
            collection_method: z
              .enum(["charge_automatically", "send_invoice"])
              .optional(),
            default_payment_method: z.string().max(5000).optional(),
            default_tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
            description: z
              .union([z.string().max(500), z.enum([""])])
              .optional(),
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            end_date: z.union([z.coerce.number(), z.enum(["now"])]).optional(),
            invoice_settings: z
              .object({
                account_tax_ids: z
                  .union([z.array(z.string().max(5000)), z.enum([""])])
                  .optional(),
                days_until_due: z.coerce.number().optional(),
                issuer: z
                  .object({
                    account: z.string().optional(),
                    type: z.enum(["account", "self"]),
                  })
                  .optional(),
              })
              .optional(),
            items: z.array(
              z.object({
                discounts: z
                  .union([
                    z.array(
                      z.object({
                        coupon: z.string().max(5000).optional(),
                        discount: z.string().max(5000).optional(),
                        promotion_code: z.string().max(5000).optional(),
                      }),
                    ),
                    z.enum([""]),
                  ])
                  .optional(),
                metadata: z.record(z.string()).optional(),
                price: z.string().max(5000).optional(),
                price_data: z
                  .object({
                    currency: z.string(),
                    product: z.string().max(5000),
                    recurring: z.object({
                      interval: z.enum(["day", "month", "week", "year"]),
                      interval_count: z.coerce.number().optional(),
                    }),
                    tax_behavior: z
                      .enum(["exclusive", "inclusive", "unspecified"])
                      .optional(),
                    unit_amount: z.coerce.number().optional(),
                    unit_amount_decimal: z.string().optional(),
                  })
                  .optional(),
                quantity: z.coerce.number().optional(),
                tax_rates: z
                  .union([z.array(z.string().max(5000)), z.enum([""])])
                  .optional(),
              }),
            ),
            iterations: z.coerce.number().optional(),
            metadata: z.record(z.string()).optional(),
            on_behalf_of: z.string().optional(),
            proration_behavior: z
              .enum(["always_invoice", "create_prorations", "none"])
              .optional(),
            start_date: z
              .union([z.coerce.number(), z.enum(["now"])])
              .optional(),
            transfer_data: z
              .object({
                amount_percent: z.coerce.number().optional(),
                destination: z.string(),
              })
              .optional(),
            trial: PermissiveBoolean.optional(),
            trial_end: z.union([z.coerce.number(), z.enum(["now"])]).optional(),
          }),
        )
        .optional(),
      proration_behavior: z
        .enum(["always_invoice", "create_prorations", "none"])
        .optional(),
    })
    .optional()

  router.post(
    "postSubscriptionSchedulesSchedule",
    "/v1/subscription_schedules/:schedule",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionSchedulesScheduleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesScheduleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionSchedulesSchedule(
          input,
          postSubscriptionSchedulesSchedule.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedulesSchedule.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionSchedulesScheduleCancelParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  const postSubscriptionSchedulesScheduleCancelBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      invoice_now: PermissiveBoolean.optional(),
      prorate: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postSubscriptionSchedulesScheduleCancel",
    "/v1/subscription_schedules/:schedule/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionSchedulesScheduleCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesScheduleCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionSchedulesScheduleCancel(
          input,
          postSubscriptionSchedulesScheduleCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedulesScheduleCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionSchedulesScheduleReleaseParamSchema = z.object({
    schedule: z.string().max(5000),
  })

  const postSubscriptionSchedulesScheduleReleaseBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      preserve_cancel_date: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postSubscriptionSchedulesScheduleRelease",
    "/v1/subscription_schedules/:schedule/release",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionSchedulesScheduleReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionSchedulesScheduleReleaseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionSchedulesScheduleRelease(
          input,
          postSubscriptionSchedulesScheduleRelease.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionSchedulesScheduleRelease.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionsQuerySchema = z.object({
    automatic_tax: z.object({ enabled: PermissiveBoolean }).optional(),
    collection_method: z
      .enum(["charge_automatically", "send_invoice"])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    current_period_end: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    current_period_start: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    price: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum([
        "active",
        "all",
        "canceled",
        "ended",
        "incomplete",
        "incomplete_expired",
        "past_due",
        "paused",
        "trialing",
        "unpaid",
      ])
      .optional(),
    test_clock: z.string().max(5000).optional(),
  })

  const getSubscriptionsBodySchema = z.object({}).optional()

  router.get("getSubscriptions", "/v1/subscriptions", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getSubscriptionsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getSubscriptionsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getSubscriptions(input, getSubscriptions.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getSubscriptions.validator(status, body)
    ctx.status = status
    return next()
  })

  const postSubscriptionsBodySchema = z.object({
    add_invoice_items: z
      .array(
        z.object({
          discounts: z
            .array(
              z.object({
                coupon: z.string().max(5000).optional(),
                discount: z.string().max(5000).optional(),
                promotion_code: z.string().max(5000).optional(),
              }),
            )
            .optional(),
          price: z.string().max(5000).optional(),
          price_data: z
            .object({
              currency: z.string(),
              product: z.string().max(5000),
              tax_behavior: z
                .enum(["exclusive", "inclusive", "unspecified"])
                .optional(),
              unit_amount: z.coerce.number().optional(),
              unit_amount_decimal: z.string().optional(),
            })
            .optional(),
          quantity: z.coerce.number().optional(),
          tax_rates: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
        }),
      )
      .optional(),
    application_fee_percent: z
      .union([z.coerce.number(), z.enum([""])])
      .optional(),
    automatic_tax: z
      .object({
        enabled: PermissiveBoolean,
        liability: z
          .object({
            account: z.string().optional(),
            type: z.enum(["account", "self"]),
          })
          .optional(),
      })
      .optional(),
    backdate_start_date: z.coerce.number().optional(),
    billing_cycle_anchor: z.coerce.number().optional(),
    billing_cycle_anchor_config: z
      .object({
        day_of_month: z.coerce.number(),
        hour: z.coerce.number().optional(),
        minute: z.coerce.number().optional(),
        month: z.coerce.number().optional(),
        second: z.coerce.number().optional(),
      })
      .optional(),
    cancel_at: z.coerce.number().optional(),
    cancel_at_period_end: PermissiveBoolean.optional(),
    collection_method: z
      .enum(["charge_automatically", "send_invoice"])
      .optional(),
    currency: z.string().optional(),
    customer: z.string().max(5000),
    days_until_due: z.coerce.number().optional(),
    default_payment_method: z.string().max(5000).optional(),
    default_source: z.string().max(5000).optional(),
    default_tax_rates: z
      .union([z.array(z.string().max(5000)), z.enum([""])])
      .optional(),
    description: z.string().max(500).optional(),
    discounts: z
      .union([
        z.array(
          z.object({
            coupon: z.string().max(5000).optional(),
            discount: z.string().max(5000).optional(),
            promotion_code: z.string().max(5000).optional(),
          }),
        ),
        z.enum([""]),
      ])
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    invoice_settings: z
      .object({
        account_tax_ids: z
          .union([z.array(z.string().max(5000)), z.enum([""])])
          .optional(),
        issuer: z
          .object({
            account: z.string().optional(),
            type: z.enum(["account", "self"]),
          })
          .optional(),
      })
      .optional(),
    items: z
      .array(
        z.object({
          discounts: z
            .union([
              z.array(
                z.object({
                  coupon: z.string().max(5000).optional(),
                  discount: z.string().max(5000).optional(),
                  promotion_code: z.string().max(5000).optional(),
                }),
              ),
              z.enum([""]),
            ])
            .optional(),
          metadata: z.record(z.string()).optional(),
          price: z.string().max(5000).optional(),
          price_data: z
            .object({
              currency: z.string(),
              product: z.string().max(5000),
              recurring: z.object({
                interval: z.enum(["day", "month", "week", "year"]),
                interval_count: z.coerce.number().optional(),
              }),
              tax_behavior: z
                .enum(["exclusive", "inclusive", "unspecified"])
                .optional(),
              unit_amount: z.coerce.number().optional(),
              unit_amount_decimal: z.string().optional(),
            })
            .optional(),
          quantity: z.coerce.number().optional(),
          tax_rates: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
        }),
      )
      .optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    off_session: PermissiveBoolean.optional(),
    on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
    payment_behavior: z
      .enum([
        "allow_incomplete",
        "default_incomplete",
        "error_if_incomplete",
        "pending_if_incomplete",
      ])
      .optional(),
    payment_settings: z
      .object({
        payment_method_options: z
          .object({
            acss_debit: z
              .union([
                z.object({
                  mandate_options: z
                    .object({
                      transaction_type: z
                        .enum(["business", "personal"])
                        .optional(),
                    })
                    .optional(),
                  verification_method: z
                    .enum(["automatic", "instant", "microdeposits"])
                    .optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
            bancontact: z
              .union([
                z.object({
                  preferred_language: z
                    .enum(["de", "en", "fr", "nl"])
                    .optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
            card: z
              .union([
                z.object({
                  mandate_options: z
                    .object({
                      amount: z.coerce.number().optional(),
                      amount_type: z.enum(["fixed", "maximum"]).optional(),
                      description: z.string().max(200).optional(),
                    })
                    .optional(),
                  network: z
                    .enum([
                      "amex",
                      "cartes_bancaires",
                      "diners",
                      "discover",
                      "eftpos_au",
                      "girocard",
                      "interac",
                      "jcb",
                      "link",
                      "mastercard",
                      "unionpay",
                      "unknown",
                      "visa",
                    ])
                    .optional(),
                  request_three_d_secure: z
                    .enum(["any", "automatic", "challenge"])
                    .optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
            customer_balance: z
              .union([
                z.object({
                  bank_transfer: z
                    .object({
                      eu_bank_transfer: z
                        .object({ country: z.string().max(5000) })
                        .optional(),
                      type: z.string().optional(),
                    })
                    .optional(),
                  funding_type: z.string().optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
            konbini: z.union([z.object({}), z.enum([""])]).optional(),
            sepa_debit: z.union([z.object({}), z.enum([""])]).optional(),
            us_bank_account: z
              .union([
                z.object({
                  financial_connections: z
                    .object({
                      filters: z
                        .object({
                          account_subcategories: z
                            .array(z.enum(["checking", "savings"]))
                            .optional(),
                        })
                        .optional(),
                      permissions: z
                        .array(
                          z.enum([
                            "balances",
                            "ownership",
                            "payment_method",
                            "transactions",
                          ]),
                        )
                        .optional(),
                      prefetch: z
                        .array(
                          z.enum(["balances", "ownership", "transactions"]),
                        )
                        .optional(),
                    })
                    .optional(),
                  verification_method: z
                    .enum(["automatic", "instant", "microdeposits"])
                    .optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
          })
          .optional(),
        payment_method_types: z
          .union([
            z.array(
              z.enum([
                "ach_credit_transfer",
                "ach_debit",
                "acss_debit",
                "amazon_pay",
                "au_becs_debit",
                "bacs_debit",
                "bancontact",
                "boleto",
                "card",
                "cashapp",
                "customer_balance",
                "eps",
                "fpx",
                "giropay",
                "grabpay",
                "ideal",
                "jp_credit_transfer",
                "kakao_pay",
                "klarna",
                "konbini",
                "kr_card",
                "link",
                "multibanco",
                "naver_pay",
                "nz_bank_account",
                "p24",
                "payco",
                "paynow",
                "paypal",
                "promptpay",
                "revolut_pay",
                "sepa_credit_transfer",
                "sepa_debit",
                "sofort",
                "swish",
                "us_bank_account",
                "wechat_pay",
              ]),
            ),
            z.enum([""]),
          ])
          .optional(),
        save_default_payment_method: z
          .enum(["off", "on_subscription"])
          .optional(),
      })
      .optional(),
    pending_invoice_item_interval: z
      .union([
        z.object({
          interval: z.enum(["day", "month", "week", "year"]),
          interval_count: z.coerce.number().optional(),
        }),
        z.enum([""]),
      ])
      .optional(),
    proration_behavior: z
      .enum(["always_invoice", "create_prorations", "none"])
      .optional(),
    transfer_data: z
      .object({
        amount_percent: z.coerce.number().optional(),
        destination: z.string(),
      })
      .optional(),
    trial_end: z.union([z.enum(["now"]), z.coerce.number()]).optional(),
    trial_from_plan: PermissiveBoolean.optional(),
    trial_period_days: z.coerce.number().optional(),
    trial_settings: z
      .object({
        end_behavior: z.object({
          missing_payment_method: z.enum(["cancel", "create_invoice", "pause"]),
        }),
      })
      .optional(),
  })

  router.post("postSubscriptions", "/v1/subscriptions", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postSubscriptionsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postSubscriptions(input, postSubscriptions.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postSubscriptions.validator(status, body)
    ctx.status = status
    return next()
  })

  const getSubscriptionsSearchQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    page: z.string().max(5000).optional(),
    query: z.string().max(5000),
  })

  const getSubscriptionsSearchBodySchema = z.object({}).optional()

  router.get(
    "getSubscriptionsSearch",
    "/v1/subscriptions/search",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getSubscriptionsSearchQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionsSearchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSubscriptionsSearch(input, getSubscriptionsSearch.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionsSearch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  const deleteSubscriptionsSubscriptionExposedIdBodySchema = z
    .object({
      cancellation_details: z
        .object({
          comment: z.union([z.string().max(5000), z.enum([""])]).optional(),
          feedback: z
            .enum([
              "",
              "customer_service",
              "low_quality",
              "missing_features",
              "other",
              "switched_service",
              "too_complex",
              "too_expensive",
              "unused",
            ])
            .optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      invoice_now: PermissiveBoolean.optional(),
      prorate: PermissiveBoolean.optional(),
    })
    .optional()

  router.delete(
    "deleteSubscriptionsSubscriptionExposedId",
    "/v1/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteSubscriptionsSubscriptionExposedId(
          input,
          deleteSubscriptionsSubscriptionExposedId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteSubscriptionsSubscriptionExposedId.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  const getSubscriptionsSubscriptionExposedIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getSubscriptionsSubscriptionExposedIdBodySchema = z
    .object({})
    .optional()

  router.get(
    "getSubscriptionsSubscriptionExposedId",
    "/v1/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getSubscriptionsSubscriptionExposedIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getSubscriptionsSubscriptionExposedId(
          input,
          getSubscriptionsSubscriptionExposedId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getSubscriptionsSubscriptionExposedId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionsSubscriptionExposedIdParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  const postSubscriptionsSubscriptionExposedIdBodySchema = z
    .object({
      add_invoice_items: z
        .array(
          z.object({
            discounts: z
              .array(
                z.object({
                  coupon: z.string().max(5000).optional(),
                  discount: z.string().max(5000).optional(),
                  promotion_code: z.string().max(5000).optional(),
                }),
              )
              .optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      application_fee_percent: z
        .union([z.coerce.number(), z.enum([""])])
        .optional(),
      automatic_tax: z
        .object({
          enabled: PermissiveBoolean,
          liability: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      billing_cycle_anchor: z.enum(["now", "unchanged"]).optional(),
      cancel_at: z.union([z.coerce.number(), z.enum([""])]).optional(),
      cancel_at_period_end: PermissiveBoolean.optional(),
      cancellation_details: z
        .object({
          comment: z.union([z.string().max(5000), z.enum([""])]).optional(),
          feedback: z
            .enum([
              "",
              "customer_service",
              "low_quality",
              "missing_features",
              "other",
              "switched_service",
              "too_complex",
              "too_expensive",
              "unused",
            ])
            .optional(),
        })
        .optional(),
      collection_method: z
        .enum(["charge_automatically", "send_invoice"])
        .optional(),
      days_until_due: z.coerce.number().optional(),
      default_payment_method: z.string().max(5000).optional(),
      default_source: z.union([z.string().max(5000), z.enum([""])]).optional(),
      default_tax_rates: z
        .union([z.array(z.string().max(5000)), z.enum([""])])
        .optional(),
      description: z.union([z.string().max(500), z.enum([""])]).optional(),
      discounts: z
        .union([
          z.array(
            z.object({
              coupon: z.string().max(5000).optional(),
              discount: z.string().max(5000).optional(),
              promotion_code: z.string().max(5000).optional(),
            }),
          ),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      invoice_settings: z
        .object({
          account_tax_ids: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
          issuer: z
            .object({
              account: z.string().optional(),
              type: z.enum(["account", "self"]),
            })
            .optional(),
        })
        .optional(),
      items: z
        .array(
          z.object({
            clear_usage: PermissiveBoolean.optional(),
            deleted: PermissiveBoolean.optional(),
            discounts: z
              .union([
                z.array(
                  z.object({
                    coupon: z.string().max(5000).optional(),
                    discount: z.string().max(5000).optional(),
                    promotion_code: z.string().max(5000).optional(),
                  }),
                ),
                z.enum([""]),
              ])
              .optional(),
            id: z.string().max(5000).optional(),
            metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
            price: z.string().max(5000).optional(),
            price_data: z
              .object({
                currency: z.string(),
                product: z.string().max(5000),
                recurring: z.object({
                  interval: z.enum(["day", "month", "week", "year"]),
                  interval_count: z.coerce.number().optional(),
                }),
                tax_behavior: z
                  .enum(["exclusive", "inclusive", "unspecified"])
                  .optional(),
                unit_amount: z.coerce.number().optional(),
                unit_amount_decimal: z.string().optional(),
              })
              .optional(),
            quantity: z.coerce.number().optional(),
            tax_rates: z
              .union([z.array(z.string().max(5000)), z.enum([""])])
              .optional(),
          }),
        )
        .optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      off_session: PermissiveBoolean.optional(),
      on_behalf_of: z.union([z.string(), z.enum([""])]).optional(),
      pause_collection: z
        .union([
          z.object({
            behavior: z.enum(["keep_as_draft", "mark_uncollectible", "void"]),
            resumes_at: z.coerce.number().optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      payment_behavior: z
        .enum([
          "allow_incomplete",
          "default_incomplete",
          "error_if_incomplete",
          "pending_if_incomplete",
        ])
        .optional(),
      payment_settings: z
        .object({
          payment_method_options: z
            .object({
              acss_debit: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        transaction_type: z
                          .enum(["business", "personal"])
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              bancontact: z
                .union([
                  z.object({
                    preferred_language: z
                      .enum(["de", "en", "fr", "nl"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              card: z
                .union([
                  z.object({
                    mandate_options: z
                      .object({
                        amount: z.coerce.number().optional(),
                        amount_type: z.enum(["fixed", "maximum"]).optional(),
                        description: z.string().max(200).optional(),
                      })
                      .optional(),
                    network: z
                      .enum([
                        "amex",
                        "cartes_bancaires",
                        "diners",
                        "discover",
                        "eftpos_au",
                        "girocard",
                        "interac",
                        "jcb",
                        "link",
                        "mastercard",
                        "unionpay",
                        "unknown",
                        "visa",
                      ])
                      .optional(),
                    request_three_d_secure: z
                      .enum(["any", "automatic", "challenge"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              customer_balance: z
                .union([
                  z.object({
                    bank_transfer: z
                      .object({
                        eu_bank_transfer: z
                          .object({ country: z.string().max(5000) })
                          .optional(),
                        type: z.string().optional(),
                      })
                      .optional(),
                    funding_type: z.string().optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              konbini: z.union([z.object({}), z.enum([""])]).optional(),
              sepa_debit: z.union([z.object({}), z.enum([""])]).optional(),
              us_bank_account: z
                .union([
                  z.object({
                    financial_connections: z
                      .object({
                        filters: z
                          .object({
                            account_subcategories: z
                              .array(z.enum(["checking", "savings"]))
                              .optional(),
                          })
                          .optional(),
                        permissions: z
                          .array(
                            z.enum([
                              "balances",
                              "ownership",
                              "payment_method",
                              "transactions",
                            ]),
                          )
                          .optional(),
                        prefetch: z
                          .array(
                            z.enum(["balances", "ownership", "transactions"]),
                          )
                          .optional(),
                      })
                      .optional(),
                    verification_method: z
                      .enum(["automatic", "instant", "microdeposits"])
                      .optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
            })
            .optional(),
          payment_method_types: z
            .union([
              z.array(
                z.enum([
                  "ach_credit_transfer",
                  "ach_debit",
                  "acss_debit",
                  "amazon_pay",
                  "au_becs_debit",
                  "bacs_debit",
                  "bancontact",
                  "boleto",
                  "card",
                  "cashapp",
                  "customer_balance",
                  "eps",
                  "fpx",
                  "giropay",
                  "grabpay",
                  "ideal",
                  "jp_credit_transfer",
                  "kakao_pay",
                  "klarna",
                  "konbini",
                  "kr_card",
                  "link",
                  "multibanco",
                  "naver_pay",
                  "nz_bank_account",
                  "p24",
                  "payco",
                  "paynow",
                  "paypal",
                  "promptpay",
                  "revolut_pay",
                  "sepa_credit_transfer",
                  "sepa_debit",
                  "sofort",
                  "swish",
                  "us_bank_account",
                  "wechat_pay",
                ]),
              ),
              z.enum([""]),
            ])
            .optional(),
          save_default_payment_method: z
            .enum(["off", "on_subscription"])
            .optional(),
        })
        .optional(),
      pending_invoice_item_interval: z
        .union([
          z.object({
            interval: z.enum(["day", "month", "week", "year"]),
            interval_count: z.coerce.number().optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      proration_behavior: z
        .enum(["always_invoice", "create_prorations", "none"])
        .optional(),
      proration_date: z.coerce.number().optional(),
      transfer_data: z
        .union([
          z.object({
            amount_percent: z.coerce.number().optional(),
            destination: z.string(),
          }),
          z.enum([""]),
        ])
        .optional(),
      trial_end: z.union([z.enum(["now"]), z.coerce.number()]).optional(),
      trial_from_plan: PermissiveBoolean.optional(),
      trial_settings: z
        .object({
          end_behavior: z.object({
            missing_payment_method: z.enum([
              "cancel",
              "create_invoice",
              "pause",
            ]),
          }),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postSubscriptionsSubscriptionExposedId",
    "/v1/subscriptions/:subscription_exposed_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionsSubscriptionExposedIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionsSubscriptionExposedIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionsSubscriptionExposedId(
          input,
          postSubscriptionsSubscriptionExposedId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionsSubscriptionExposedId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteSubscriptionsSubscriptionExposedIdDiscountParamSchema = z.object({
    subscription_exposed_id: z.string().max(5000),
  })

  const deleteSubscriptionsSubscriptionExposedIdDiscountBodySchema = z
    .object({})
    .optional()

  router.delete(
    "deleteSubscriptionsSubscriptionExposedIdDiscount",
    "/v1/subscriptions/:subscription_exposed_id/discount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdDiscountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteSubscriptionsSubscriptionExposedIdDiscountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteSubscriptionsSubscriptionExposedIdDiscount(
          input,
          deleteSubscriptionsSubscriptionExposedIdDiscount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteSubscriptionsSubscriptionExposedIdDiscount.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postSubscriptionsSubscriptionResumeParamSchema = z.object({
    subscription: z.string().max(5000),
  })

  const postSubscriptionsSubscriptionResumeBodySchema = z
    .object({
      billing_cycle_anchor: z.enum(["now", "unchanged"]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      proration_behavior: z
        .enum(["always_invoice", "create_prorations", "none"])
        .optional(),
      proration_date: z.coerce.number().optional(),
    })
    .optional()

  router.post(
    "postSubscriptionsSubscriptionResume",
    "/v1/subscriptions/:subscription/resume",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postSubscriptionsSubscriptionResumeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postSubscriptionsSubscriptionResumeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postSubscriptionsSubscriptionResume(
          input,
          postSubscriptionsSubscriptionResume.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postSubscriptionsSubscriptionResume.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTaxCalculationsBodySchema = z.object({
    currency: z.string(),
    customer: z.string().max(5000).optional(),
    customer_details: z
      .object({
        address: z
          .object({
            city: z.union([z.string().max(5000), z.enum([""])]).optional(),
            country: z.string().max(5000),
            line1: z.union([z.string().max(5000), z.enum([""])]).optional(),
            line2: z.union([z.string().max(5000), z.enum([""])]).optional(),
            postal_code: z
              .union([z.string().max(5000), z.enum([""])])
              .optional(),
            state: z.union([z.string().max(5000), z.enum([""])]).optional(),
          })
          .optional(),
        address_source: z.enum(["billing", "shipping"]).optional(),
        ip_address: z.string().optional(),
        tax_ids: z
          .array(
            z.object({
              type: z.enum([
                "ad_nrt",
                "ae_trn",
                "al_tin",
                "am_tin",
                "ao_tin",
                "ar_cuit",
                "au_abn",
                "au_arn",
                "ba_tin",
                "bb_tin",
                "bg_uic",
                "bh_vat",
                "bo_tin",
                "br_cnpj",
                "br_cpf",
                "bs_tin",
                "by_tin",
                "ca_bn",
                "ca_gst_hst",
                "ca_pst_bc",
                "ca_pst_mb",
                "ca_pst_sk",
                "ca_qst",
                "cd_nif",
                "ch_uid",
                "ch_vat",
                "cl_tin",
                "cn_tin",
                "co_nit",
                "cr_tin",
                "de_stn",
                "do_rcn",
                "ec_ruc",
                "eg_tin",
                "es_cif",
                "eu_oss_vat",
                "eu_vat",
                "gb_vat",
                "ge_vat",
                "gn_nif",
                "hk_br",
                "hr_oib",
                "hu_tin",
                "id_npwp",
                "il_vat",
                "in_gst",
                "is_vat",
                "jp_cn",
                "jp_rn",
                "jp_trn",
                "ke_pin",
                "kh_tin",
                "kr_brn",
                "kz_bin",
                "li_uid",
                "li_vat",
                "ma_vat",
                "md_vat",
                "me_pib",
                "mk_vat",
                "mr_nif",
                "mx_rfc",
                "my_frp",
                "my_itn",
                "my_sst",
                "ng_tin",
                "no_vat",
                "no_voec",
                "np_pan",
                "nz_gst",
                "om_vat",
                "pe_ruc",
                "ph_tin",
                "ro_tin",
                "rs_pib",
                "ru_inn",
                "ru_kpp",
                "sa_vat",
                "sg_gst",
                "sg_uen",
                "si_tin",
                "sn_ninea",
                "sr_fin",
                "sv_nit",
                "th_vat",
                "tj_tin",
                "tr_tin",
                "tw_vat",
                "tz_vat",
                "ua_vat",
                "ug_tin",
                "us_ein",
                "uy_ruc",
                "uz_tin",
                "uz_vat",
                "ve_rif",
                "vn_tin",
                "za_vat",
                "zm_tin",
                "zw_tin",
              ]),
              value: z.string(),
            }),
          )
          .optional(),
        taxability_override: z
          .enum(["customer_exempt", "none", "reverse_charge"])
          .optional(),
      })
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    line_items: z.array(
      z.object({
        amount: z.coerce.number(),
        product: z.string().max(5000).optional(),
        quantity: z.coerce.number().optional(),
        reference: z.string().max(500).optional(),
        tax_behavior: z.enum(["exclusive", "inclusive"]).optional(),
        tax_code: z.string().optional(),
      }),
    ),
    ship_from_details: z
      .object({
        address: z.object({
          city: z.union([z.string().max(5000), z.enum([""])]).optional(),
          country: z.string().max(5000),
          line1: z.union([z.string().max(5000), z.enum([""])]).optional(),
          line2: z.union([z.string().max(5000), z.enum([""])]).optional(),
          postal_code: z.union([z.string().max(5000), z.enum([""])]).optional(),
          state: z.union([z.string().max(5000), z.enum([""])]).optional(),
        }),
      })
      .optional(),
    shipping_cost: z
      .object({
        amount: z.coerce.number().optional(),
        shipping_rate: z.string().max(5000).optional(),
        tax_behavior: z.enum(["exclusive", "inclusive"]).optional(),
        tax_code: z.string().optional(),
      })
      .optional(),
    tax_date: z.coerce.number().optional(),
  })

  router.post(
    "postTaxCalculations",
    "/v1/tax/calculations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxCalculationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTaxCalculations(input, postTaxCalculations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxCalculations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxCalculationsCalculationParamSchema = z.object({
    calculation: z.string().max(5000),
  })

  const getTaxCalculationsCalculationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTaxCalculationsCalculationBodySchema = z.object({}).optional()

  router.get(
    "getTaxCalculationsCalculation",
    "/v1/tax/calculations/:calculation",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxCalculationsCalculationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxCalculationsCalculationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxCalculationsCalculationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTaxCalculationsCalculation(
          input,
          getTaxCalculationsCalculation.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxCalculationsCalculation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxCalculationsCalculationLineItemsParamSchema = z.object({
    calculation: z.string().max(5000),
  })

  const getTaxCalculationsCalculationLineItemsQuerySchema = z.object({
    ending_before: z.string().max(500).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(500).optional(),
  })

  const getTaxCalculationsCalculationLineItemsBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTaxCalculationsCalculationLineItems",
    "/v1/tax/calculations/:calculation/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxCalculationsCalculationLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxCalculationsCalculationLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxCalculationsCalculationLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTaxCalculationsCalculationLineItems(
          input,
          getTaxCalculationsCalculationLineItems.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxCalculationsCalculationLineItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxRegistrationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["active", "all", "expired", "scheduled"]).optional(),
  })

  const getTaxRegistrationsBodySchema = z.object({}).optional()

  router.get(
    "getTaxRegistrations",
    "/v1/tax/registrations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTaxRegistrationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxRegistrationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTaxRegistrations(input, getTaxRegistrations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxRegistrations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTaxRegistrationsBodySchema = z.object({
    active_from: z.union([z.enum(["now"]), z.coerce.number()]),
    country: z.string().max(5000),
    country_options: z.object({
      ae: z.object({ type: z.enum(["standard"]) }).optional(),
      al: z.object({ type: z.enum(["standard"]) }).optional(),
      am: z.object({ type: z.enum(["simplified"]) }).optional(),
      ao: z.object({ type: z.enum(["standard"]) }).optional(),
      at: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      au: z.object({ type: z.enum(["standard"]) }).optional(),
      ba: z.object({ type: z.enum(["standard"]) }).optional(),
      bb: z.object({ type: z.enum(["standard"]) }).optional(),
      be: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      bg: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      bh: z.object({ type: z.enum(["standard"]) }).optional(),
      bs: z.object({ type: z.enum(["standard"]) }).optional(),
      by: z.object({ type: z.enum(["simplified"]) }).optional(),
      ca: z
        .object({
          province_standard: z
            .object({ province: z.string().max(5000) })
            .optional(),
          type: z.enum(["province_standard", "simplified", "standard"]),
        })
        .optional(),
      cd: z.object({ type: z.enum(["standard"]) }).optional(),
      ch: z.object({ type: z.enum(["standard"]) }).optional(),
      cl: z.object({ type: z.enum(["simplified"]) }).optional(),
      co: z.object({ type: z.enum(["simplified"]) }).optional(),
      cr: z.object({ type: z.enum(["simplified"]) }).optional(),
      cy: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      cz: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      de: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      dk: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      ec: z.object({ type: z.enum(["simplified"]) }).optional(),
      ee: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      eg: z.object({ type: z.enum(["simplified"]) }).optional(),
      es: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      fi: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      fr: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      gb: z.object({ type: z.enum(["standard"]) }).optional(),
      ge: z.object({ type: z.enum(["simplified"]) }).optional(),
      gn: z.object({ type: z.enum(["standard"]) }).optional(),
      gr: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      hr: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      hu: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      id: z.object({ type: z.enum(["simplified"]) }).optional(),
      ie: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      is: z.object({ type: z.enum(["standard"]) }).optional(),
      it: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      jp: z.object({ type: z.enum(["standard"]) }).optional(),
      ke: z.object({ type: z.enum(["simplified"]) }).optional(),
      kh: z.object({ type: z.enum(["simplified"]) }).optional(),
      kr: z.object({ type: z.enum(["simplified"]) }).optional(),
      kz: z.object({ type: z.enum(["simplified"]) }).optional(),
      lt: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      lu: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      lv: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      ma: z.object({ type: z.enum(["simplified"]) }).optional(),
      md: z.object({ type: z.enum(["simplified"]) }).optional(),
      me: z.object({ type: z.enum(["standard"]) }).optional(),
      mk: z.object({ type: z.enum(["standard"]) }).optional(),
      mr: z.object({ type: z.enum(["standard"]) }).optional(),
      mt: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      mx: z.object({ type: z.enum(["simplified"]) }).optional(),
      my: z.object({ type: z.enum(["simplified"]) }).optional(),
      ng: z.object({ type: z.enum(["simplified"]) }).optional(),
      nl: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      no: z.object({ type: z.enum(["standard"]) }).optional(),
      np: z.object({ type: z.enum(["simplified"]) }).optional(),
      nz: z.object({ type: z.enum(["standard"]) }).optional(),
      om: z.object({ type: z.enum(["standard"]) }).optional(),
      pe: z.object({ type: z.enum(["simplified"]) }).optional(),
      pl: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      pt: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      ro: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      rs: z.object({ type: z.enum(["standard"]) }).optional(),
      ru: z.object({ type: z.enum(["simplified"]) }).optional(),
      sa: z.object({ type: z.enum(["simplified"]) }).optional(),
      se: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      sg: z.object({ type: z.enum(["standard"]) }).optional(),
      si: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      sk: z
        .object({
          standard: z
            .object({
              place_of_supply_scheme: z.enum(["small_seller", "standard"]),
            })
            .optional(),
          type: z.enum(["ioss", "oss_non_union", "oss_union", "standard"]),
        })
        .optional(),
      sn: z.object({ type: z.enum(["simplified"]) }).optional(),
      sr: z.object({ type: z.enum(["standard"]) }).optional(),
      th: z.object({ type: z.enum(["simplified"]) }).optional(),
      tj: z.object({ type: z.enum(["simplified"]) }).optional(),
      tr: z.object({ type: z.enum(["simplified"]) }).optional(),
      tz: z.object({ type: z.enum(["simplified"]) }).optional(),
      ug: z.object({ type: z.enum(["simplified"]) }).optional(),
      us: z
        .object({
          local_amusement_tax: z
            .object({ jurisdiction: z.string().max(5000) })
            .optional(),
          local_lease_tax: z
            .object({ jurisdiction: z.string().max(5000) })
            .optional(),
          state: z.string().max(5000),
          state_sales_tax: z
            .object({
              elections: z.array(
                z.object({
                  jurisdiction: z.string().max(5000).optional(),
                  type: z.enum([
                    "local_use_tax",
                    "simplified_sellers_use_tax",
                    "single_local_use_tax",
                  ]),
                }),
              ),
            })
            .optional(),
          type: z.enum([
            "local_amusement_tax",
            "local_lease_tax",
            "state_communications_tax",
            "state_retail_delivery_fee",
            "state_sales_tax",
          ]),
        })
        .optional(),
      uy: z.object({ type: z.enum(["standard"]) }).optional(),
      uz: z.object({ type: z.enum(["simplified"]) }).optional(),
      vn: z.object({ type: z.enum(["simplified"]) }).optional(),
      za: z.object({ type: z.enum(["standard"]) }).optional(),
      zm: z.object({ type: z.enum(["simplified"]) }).optional(),
      zw: z.object({ type: z.enum(["standard"]) }).optional(),
    }),
    expand: z.array(z.string().max(5000)).optional(),
    expires_at: z.coerce.number().optional(),
  })

  router.post(
    "postTaxRegistrations",
    "/v1/tax/registrations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxRegistrationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTaxRegistrations(input, postTaxRegistrations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxRegistrations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxRegistrationsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTaxRegistrationsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTaxRegistrationsIdBodySchema = z.object({}).optional()

  router.get(
    "getTaxRegistrationsId",
    "/v1/tax/registrations/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxRegistrationsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxRegistrationsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxRegistrationsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTaxRegistrationsId(input, getTaxRegistrationsId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxRegistrationsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTaxRegistrationsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTaxRegistrationsIdBodySchema = z
    .object({
      active_from: z.union([z.enum(["now"]), z.coerce.number()]).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      expires_at: z
        .union([z.enum(["now"]), z.coerce.number(), z.enum([""])])
        .optional(),
    })
    .optional()

  router.post(
    "postTaxRegistrationsId",
    "/v1/tax/registrations/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTaxRegistrationsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTaxRegistrationsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTaxRegistrationsId(input, postTaxRegistrationsId.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxRegistrationsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxSettingsQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTaxSettingsBodySchema = z.object({}).optional()

  router.get("getTaxSettings", "/v1/tax/settings", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxSettingsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxSettingsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTaxSettings(input, getTaxSettings.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxSettings.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTaxSettingsBodySchema = z
    .object({
      defaults: z
        .object({
          tax_behavior: z
            .enum(["exclusive", "inclusive", "inferred_by_currency"])
            .optional(),
          tax_code: z.string().optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      head_office: z
        .object({
          address: z.object({
            city: z.string().max(5000).optional(),
            country: z.string().max(5000).optional(),
            line1: z.string().max(5000).optional(),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000).optional(),
            state: z.string().max(5000).optional(),
          }),
        })
        .optional(),
    })
    .optional()

  router.post("postTaxSettings", "/v1/tax/settings", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTaxSettingsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postTaxSettings(input, postTaxSettings.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTaxSettings.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTaxTransactionsCreateFromCalculationBodySchema = z.object({
    calculation: z.string().max(5000),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    posted_at: z.coerce.number().optional(),
    reference: z.string().max(500),
  })

  router.post(
    "postTaxTransactionsCreateFromCalculation",
    "/v1/tax/transactions/create_from_calculation",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxTransactionsCreateFromCalculationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTaxTransactionsCreateFromCalculation(
          input,
          postTaxTransactionsCreateFromCalculation.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxTransactionsCreateFromCalculation.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTaxTransactionsCreateReversalBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    flat_amount: z.coerce.number().optional(),
    line_items: z
      .array(
        z.object({
          amount: z.coerce.number(),
          amount_tax: z.coerce.number(),
          metadata: z.record(z.string()).optional(),
          original_line_item: z.string().max(5000),
          quantity: z.coerce.number().optional(),
          reference: z.string().max(500),
        }),
      )
      .optional(),
    metadata: z.record(z.string()).optional(),
    mode: z.enum(["full", "partial"]),
    original_transaction: z.string().max(5000),
    reference: z.string().max(500),
    shipping_cost: z
      .object({ amount: z.coerce.number(), amount_tax: z.coerce.number() })
      .optional(),
  })

  router.post(
    "postTaxTransactionsCreateReversal",
    "/v1/tax/transactions/create_reversal",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTaxTransactionsCreateReversalBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTaxTransactionsCreateReversal(
          input,
          postTaxTransactionsCreateReversal.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxTransactionsCreateReversal.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxTransactionsTransactionParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getTaxTransactionsTransactionQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTaxTransactionsTransactionBodySchema = z.object({}).optional()

  router.get(
    "getTaxTransactionsTransaction",
    "/v1/tax/transactions/:transaction",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxTransactionsTransactionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxTransactionsTransactionQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxTransactionsTransactionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTaxTransactionsTransaction(
          input,
          getTaxTransactionsTransaction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxTransactionsTransaction.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxTransactionsTransactionLineItemsParamSchema = z.object({
    transaction: z.string().max(5000),
  })

  const getTaxTransactionsTransactionLineItemsQuerySchema = z.object({
    ending_before: z.string().max(500).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(500).optional(),
  })

  const getTaxTransactionsTransactionLineItemsBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTaxTransactionsTransactionLineItems",
    "/v1/tax/transactions/:transaction/line_items",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxTransactionsTransactionLineItemsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxTransactionsTransactionLineItemsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxTransactionsTransactionLineItemsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTaxTransactionsTransactionLineItems(
          input,
          getTaxTransactionsTransactionLineItems.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxTransactionsTransactionLineItems.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTaxCodesQuerySchema = z.object({
    ending_before: z.string().optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().optional(),
  })

  const getTaxCodesBodySchema = z.object({}).optional()

  router.get("getTaxCodes", "/v1/tax_codes", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxCodesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxCodesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTaxCodes(input, getTaxCodes.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxCodes.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxCodesIdParamSchema = z.object({ id: z.string().max(5000) })

  const getTaxCodesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTaxCodesIdBodySchema = z.object({}).optional()

  router.get("getTaxCodesId", "/v1/tax_codes/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTaxCodesIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTaxCodesIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxCodesIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTaxCodesId(input, getTaxCodesId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxCodesId.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxIdsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    owner: z
      .object({
        account: z.string().optional(),
        customer: z.string().max(5000).optional(),
        type: z.enum(["account", "application", "customer", "self"]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getTaxIdsBodySchema = z.object({}).optional()

  router.get("getTaxIds", "/v1/tax_ids", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxIdsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxIdsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTaxIds(input, getTaxIds.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxIds.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTaxIdsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    owner: z
      .object({
        account: z.string().optional(),
        customer: z.string().max(5000).optional(),
        type: z.enum(["account", "application", "customer", "self"]),
      })
      .optional(),
    type: z.enum([
      "ad_nrt",
      "ae_trn",
      "al_tin",
      "am_tin",
      "ao_tin",
      "ar_cuit",
      "au_abn",
      "au_arn",
      "ba_tin",
      "bb_tin",
      "bg_uic",
      "bh_vat",
      "bo_tin",
      "br_cnpj",
      "br_cpf",
      "bs_tin",
      "by_tin",
      "ca_bn",
      "ca_gst_hst",
      "ca_pst_bc",
      "ca_pst_mb",
      "ca_pst_sk",
      "ca_qst",
      "cd_nif",
      "ch_uid",
      "ch_vat",
      "cl_tin",
      "cn_tin",
      "co_nit",
      "cr_tin",
      "de_stn",
      "do_rcn",
      "ec_ruc",
      "eg_tin",
      "es_cif",
      "eu_oss_vat",
      "eu_vat",
      "gb_vat",
      "ge_vat",
      "gn_nif",
      "hk_br",
      "hr_oib",
      "hu_tin",
      "id_npwp",
      "il_vat",
      "in_gst",
      "is_vat",
      "jp_cn",
      "jp_rn",
      "jp_trn",
      "ke_pin",
      "kh_tin",
      "kr_brn",
      "kz_bin",
      "li_uid",
      "li_vat",
      "ma_vat",
      "md_vat",
      "me_pib",
      "mk_vat",
      "mr_nif",
      "mx_rfc",
      "my_frp",
      "my_itn",
      "my_sst",
      "ng_tin",
      "no_vat",
      "no_voec",
      "np_pan",
      "nz_gst",
      "om_vat",
      "pe_ruc",
      "ph_tin",
      "ro_tin",
      "rs_pib",
      "ru_inn",
      "ru_kpp",
      "sa_vat",
      "sg_gst",
      "sg_uen",
      "si_tin",
      "sn_ninea",
      "sr_fin",
      "sv_nit",
      "th_vat",
      "tj_tin",
      "tr_tin",
      "tw_vat",
      "tz_vat",
      "ua_vat",
      "ug_tin",
      "us_ein",
      "uy_ruc",
      "uz_tin",
      "uz_vat",
      "ve_rif",
      "vn_tin",
      "za_vat",
      "zm_tin",
      "zw_tin",
    ]),
    value: z.string(),
  })

  router.post("postTaxIds", "/v1/tax_ids", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTaxIdsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postTaxIds(input, postTaxIds.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTaxIds.validator(status, body)
    ctx.status = status
    return next()
  })

  const deleteTaxIdsIdParamSchema = z.object({ id: z.string().max(5000) })

  const deleteTaxIdsIdBodySchema = z.object({}).optional()

  router.delete("deleteTaxIdsId", "/v1/tax_ids/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deleteTaxIdsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        deleteTaxIdsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .deleteTaxIdsId(input, deleteTaxIdsId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deleteTaxIdsId.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxIdsIdParamSchema = z.object({ id: z.string().max(5000) })

  const getTaxIdsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTaxIdsIdBodySchema = z.object({}).optional()

  router.get("getTaxIdsId", "/v1/tax_ids/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTaxIdsIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTaxIdsIdQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxIdsIdBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTaxIdsId(input, getTaxIdsId.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxIdsId.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxRatesQuerySchema = z.object({
    active: PermissiveBoolean.optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    inclusive: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getTaxRatesBodySchema = z.object({}).optional()

  router.get("getTaxRates", "/v1/tax_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTaxRatesQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTaxRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTaxRates(input, getTaxRates.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTaxRates.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTaxRatesBodySchema = z.object({
    active: PermissiveBoolean.optional(),
    country: z.string().max(5000).optional(),
    description: z.string().max(5000).optional(),
    display_name: z.string().max(50),
    expand: z.array(z.string().max(5000)).optional(),
    inclusive: PermissiveBoolean,
    jurisdiction: z.string().max(50).optional(),
    metadata: z.record(z.string()).optional(),
    percentage: z.coerce.number(),
    state: z.string().max(5000).optional(),
    tax_type: z
      .enum([
        "amusement_tax",
        "communications_tax",
        "gst",
        "hst",
        "igst",
        "jct",
        "lease_tax",
        "pst",
        "qst",
        "retail_delivery_fee",
        "rst",
        "sales_tax",
        "service_tax",
        "vat",
      ])
      .optional(),
  })

  router.post("postTaxRates", "/v1/tax_rates", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTaxRatesBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postTaxRates(input, postTaxRates.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTaxRates.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTaxRatesTaxRateParamSchema = z.object({
    tax_rate: z.string().max(5000),
  })

  const getTaxRatesTaxRateQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTaxRatesTaxRateBodySchema = z.object({}).optional()

  router.get(
    "getTaxRatesTaxRate",
    "/v1/tax_rates/:tax_rate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTaxRatesTaxRateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTaxRatesTaxRateQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTaxRatesTaxRateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTaxRatesTaxRate(input, getTaxRatesTaxRate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTaxRatesTaxRate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTaxRatesTaxRateParamSchema = z.object({
    tax_rate: z.string().max(5000),
  })

  const postTaxRatesTaxRateBodySchema = z
    .object({
      active: PermissiveBoolean.optional(),
      country: z.string().max(5000).optional(),
      description: z.string().max(5000).optional(),
      display_name: z.string().max(50).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      jurisdiction: z.string().max(50).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      state: z.string().max(5000).optional(),
      tax_type: z
        .enum([
          "amusement_tax",
          "communications_tax",
          "gst",
          "hst",
          "igst",
          "jct",
          "lease_tax",
          "pst",
          "qst",
          "retail_delivery_fee",
          "rst",
          "sales_tax",
          "service_tax",
          "vat",
        ])
        .optional(),
    })
    .optional()

  router.post(
    "postTaxRatesTaxRate",
    "/v1/tax_rates/:tax_rate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTaxRatesTaxRateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTaxRatesTaxRateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTaxRatesTaxRate(input, postTaxRatesTaxRate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTaxRatesTaxRate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalConfigurationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    is_account_default: PermissiveBoolean.optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getTerminalConfigurationsBodySchema = z.object({}).optional()

  router.get(
    "getTerminalConfigurations",
    "/v1/terminal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTerminalConfigurationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTerminalConfigurations(
          input,
          getTerminalConfigurations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalConfigurations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalConfigurationsBodySchema = z
    .object({
      bbpos_wisepos_e: z
        .object({
          splashscreen: z.union([z.string(), z.enum([""])]).optional(),
        })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      name: z.string().max(100).optional(),
      offline: z
        .union([z.object({ enabled: PermissiveBoolean }), z.enum([""])])
        .optional(),
      reboot_window: z
        .object({ end_hour: z.coerce.number(), start_hour: z.coerce.number() })
        .optional(),
      stripe_s700: z
        .object({
          splashscreen: z.union([z.string(), z.enum([""])]).optional(),
        })
        .optional(),
      tipping: z
        .union([
          z.object({
            aud: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            cad: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            chf: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            czk: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            dkk: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            eur: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            gbp: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            hkd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            jpy: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            myr: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            nok: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            nzd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            pln: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            sek: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            sgd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            usd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      verifone_p400: z
        .object({
          splashscreen: z.union([z.string(), z.enum([""])]).optional(),
        })
        .optional(),
      wifi: z
        .union([
          z.object({
            enterprise_eap_peap: z
              .object({
                ca_certificate_file: z.string().optional(),
                password: z.string().max(5000),
                ssid: z.string().max(5000),
                username: z.string().max(5000),
              })
              .optional(),
            enterprise_eap_tls: z
              .object({
                ca_certificate_file: z.string().optional(),
                client_certificate_file: z.string(),
                private_key_file: z.string(),
                private_key_file_password: z.string().max(5000).optional(),
                ssid: z.string().max(5000),
              })
              .optional(),
            personal_psk: z
              .object({
                password: z.string().max(63),
                ssid: z.string().max(5000),
              })
              .optional(),
            type: z.enum([
              "enterprise_eap_peap",
              "enterprise_eap_tls",
              "personal_psk",
            ]),
          }),
          z.enum([""]),
        ])
        .optional(),
    })
    .optional()

  router.post(
    "postTerminalConfigurations",
    "/v1/terminal/configurations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalConfigurationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalConfigurations(
          input,
          postTerminalConfigurations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalConfigurations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const deleteTerminalConfigurationsConfigurationBodySchema = z
    .object({})
    .optional()

  router.delete(
    "deleteTerminalConfigurationsConfiguration",
    "/v1/terminal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTerminalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTerminalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteTerminalConfigurationsConfiguration(
          input,
          deleteTerminalConfigurationsConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTerminalConfigurationsConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const getTerminalConfigurationsConfigurationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTerminalConfigurationsConfigurationBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTerminalConfigurationsConfiguration",
    "/v1/terminal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTerminalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTerminalConfigurationsConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTerminalConfigurationsConfiguration(
          input,
          getTerminalConfigurationsConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalConfigurationsConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalConfigurationsConfigurationParamSchema = z.object({
    configuration: z.string().max(5000),
  })

  const postTerminalConfigurationsConfigurationBodySchema = z
    .object({
      bbpos_wisepos_e: z
        .union([
          z.object({
            splashscreen: z.union([z.string(), z.enum([""])]).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      name: z.string().max(100).optional(),
      offline: z
        .union([z.object({ enabled: PermissiveBoolean }), z.enum([""])])
        .optional(),
      reboot_window: z
        .union([
          z.object({
            end_hour: z.coerce.number(),
            start_hour: z.coerce.number(),
          }),
          z.enum([""]),
        ])
        .optional(),
      stripe_s700: z
        .union([
          z.object({
            splashscreen: z.union([z.string(), z.enum([""])]).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      tipping: z
        .union([
          z.object({
            aud: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            cad: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            chf: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            czk: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            dkk: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            eur: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            gbp: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            hkd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            jpy: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            myr: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            nok: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            nzd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            pln: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            sek: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            sgd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
            usd: z
              .object({
                fixed_amounts: z.array(z.coerce.number()).optional(),
                percentages: z.array(z.coerce.number()).optional(),
                smart_tip_threshold: z.coerce.number().optional(),
              })
              .optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      verifone_p400: z
        .union([
          z.object({
            splashscreen: z.union([z.string(), z.enum([""])]).optional(),
          }),
          z.enum([""]),
        ])
        .optional(),
      wifi: z
        .union([
          z.object({
            enterprise_eap_peap: z
              .object({
                ca_certificate_file: z.string().optional(),
                password: z.string().max(5000),
                ssid: z.string().max(5000),
                username: z.string().max(5000),
              })
              .optional(),
            enterprise_eap_tls: z
              .object({
                ca_certificate_file: z.string().optional(),
                client_certificate_file: z.string(),
                private_key_file: z.string(),
                private_key_file_password: z.string().max(5000).optional(),
                ssid: z.string().max(5000),
              })
              .optional(),
            personal_psk: z
              .object({
                password: z.string().max(63),
                ssid: z.string().max(5000),
              })
              .optional(),
            type: z.enum([
              "enterprise_eap_peap",
              "enterprise_eap_tls",
              "personal_psk",
            ]),
          }),
          z.enum([""]),
        ])
        .optional(),
    })
    .optional()

  router.post(
    "postTerminalConfigurationsConfiguration",
    "/v1/terminal/configurations/:configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalConfigurationsConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalConfigurationsConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalConfigurationsConfiguration(
          input,
          postTerminalConfigurationsConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalConfigurationsConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalConnectionTokensBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      location: z.string().max(5000).optional(),
    })
    .optional()

  router.post(
    "postTerminalConnectionTokens",
    "/v1/terminal/connection_tokens",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalConnectionTokensBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalConnectionTokens(
          input,
          postTerminalConnectionTokens.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalConnectionTokens.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalLocationsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getTerminalLocationsBodySchema = z.object({}).optional()

  router.get(
    "getTerminalLocations",
    "/v1/terminal/locations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTerminalLocationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalLocationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTerminalLocations(input, getTerminalLocations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalLocations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalLocationsBodySchema = z.object({
    address: z.object({
      city: z.string().max(5000).optional(),
      country: z.string().max(5000),
      line1: z.string().max(5000).optional(),
      line2: z.string().max(5000).optional(),
      postal_code: z.string().max(5000).optional(),
      state: z.string().max(5000).optional(),
    }),
    configuration_overrides: z.string().max(500).optional(),
    display_name: z.string().max(1000),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
  })

  router.post(
    "postTerminalLocations",
    "/v1/terminal/locations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalLocationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalLocations(input, postTerminalLocations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalLocations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  const deleteTerminalLocationsLocationBodySchema = z.object({}).optional()

  router.delete(
    "deleteTerminalLocationsLocation",
    "/v1/terminal/locations/:location",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTerminalLocationsLocationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTerminalLocationsLocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteTerminalLocationsLocation(
          input,
          deleteTerminalLocationsLocation.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTerminalLocationsLocation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  const getTerminalLocationsLocationQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTerminalLocationsLocationBodySchema = z.object({}).optional()

  router.get(
    "getTerminalLocationsLocation",
    "/v1/terminal/locations/:location",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTerminalLocationsLocationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTerminalLocationsLocationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalLocationsLocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTerminalLocationsLocation(
          input,
          getTerminalLocationsLocation.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalLocationsLocation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalLocationsLocationParamSchema = z.object({
    location: z.string().max(5000),
  })

  const postTerminalLocationsLocationBodySchema = z
    .object({
      address: z
        .object({
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          line1: z.string().max(5000).optional(),
          line2: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
        })
        .optional(),
      configuration_overrides: z
        .union([z.string().max(1000), z.enum([""])])
        .optional(),
      display_name: z.string().max(1000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postTerminalLocationsLocation",
    "/v1/terminal/locations/:location",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalLocationsLocationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalLocationsLocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalLocationsLocation(
          input,
          postTerminalLocationsLocation.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalLocationsLocation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalReadersQuerySchema = z.object({
    device_type: z
      .enum([
        "bbpos_chipper2x",
        "bbpos_wisepad3",
        "bbpos_wisepos_e",
        "mobile_phone_reader",
        "simulated_wisepos_e",
        "stripe_m2",
        "stripe_s700",
        "verifone_P400",
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    location: z.string().max(5000).optional(),
    serial_number: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["offline", "online"]).optional(),
  })

  const getTerminalReadersBodySchema = z.object({}).optional()

  router.get(
    "getTerminalReaders",
    "/v1/terminal/readers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTerminalReadersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalReadersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTerminalReaders(input, getTerminalReaders.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalReaders.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    label: z.string().max(5000).optional(),
    location: z.string().max(5000).optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    registration_code: z.string().max(5000),
  })

  router.post(
    "postTerminalReaders",
    "/v1/terminal/readers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalReaders(input, postTerminalReaders.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReaders.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const deleteTerminalReadersReaderBodySchema = z.object({}).optional()

  router.delete(
    "deleteTerminalReadersReader",
    "/v1/terminal/readers/:reader",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTerminalReadersReaderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTerminalReadersReaderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteTerminalReadersReader(
          input,
          deleteTerminalReadersReader.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTerminalReadersReader.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const getTerminalReadersReaderQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTerminalReadersReaderBodySchema = z.object({}).optional()

  router.get(
    "getTerminalReadersReader",
    "/v1/terminal/readers/:reader",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTerminalReadersReaderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTerminalReadersReaderQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTerminalReadersReaderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTerminalReadersReader(
          input,
          getTerminalReadersReader.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTerminalReadersReader.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const postTerminalReadersReaderBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      label: z.union([z.string().max(5000), z.enum([""])]).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postTerminalReadersReader",
    "/v1/terminal/readers/:reader",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalReadersReader(
          input,
          postTerminalReadersReader.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReader.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderCancelActionParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const postTerminalReadersReaderCancelActionBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTerminalReadersReaderCancelAction",
    "/v1/terminal/readers/:reader/cancel_action",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderCancelActionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderCancelActionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalReadersReaderCancelAction(
          input,
          postTerminalReadersReaderCancelAction.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderCancelAction.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderProcessPaymentIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const postTerminalReadersReaderProcessPaymentIntentBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    payment_intent: z.string().max(5000),
    process_config: z
      .object({
        allow_redisplay: z
          .enum(["always", "limited", "unspecified"])
          .optional(),
        enable_customer_cancellation: PermissiveBoolean.optional(),
        skip_tipping: PermissiveBoolean.optional(),
        tipping: z
          .object({ amount_eligible: z.coerce.number().optional() })
          .optional(),
      })
      .optional(),
  })

  router.post(
    "postTerminalReadersReaderProcessPaymentIntent",
    "/v1/terminal/readers/:reader/process_payment_intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderProcessPaymentIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderProcessPaymentIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalReadersReaderProcessPaymentIntent(
          input,
          postTerminalReadersReaderProcessPaymentIntent.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderProcessPaymentIntent.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderProcessSetupIntentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const postTerminalReadersReaderProcessSetupIntentBodySchema = z.object({
    allow_redisplay: z.enum(["always", "limited", "unspecified"]),
    expand: z.array(z.string().max(5000)).optional(),
    process_config: z
      .object({ enable_customer_cancellation: PermissiveBoolean.optional() })
      .optional(),
    setup_intent: z.string().max(5000),
  })

  router.post(
    "postTerminalReadersReaderProcessSetupIntent",
    "/v1/terminal/readers/:reader/process_setup_intent",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderProcessSetupIntentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderProcessSetupIntentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalReadersReaderProcessSetupIntent(
          input,
          postTerminalReadersReaderProcessSetupIntent.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderProcessSetupIntent.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderRefundPaymentParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const postTerminalReadersReaderRefundPaymentBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      charge: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.record(z.string()).optional(),
      payment_intent: z.string().max(5000).optional(),
      refund_application_fee: PermissiveBoolean.optional(),
      refund_payment_config: z
        .object({ enable_customer_cancellation: PermissiveBoolean.optional() })
        .optional(),
      reverse_transfer: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postTerminalReadersReaderRefundPayment",
    "/v1/terminal/readers/:reader/refund_payment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderRefundPaymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderRefundPaymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalReadersReaderRefundPayment(
          input,
          postTerminalReadersReaderRefundPayment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderRefundPayment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTerminalReadersReaderSetReaderDisplayParamSchema = z.object({
    reader: z.string().max(5000),
  })

  const postTerminalReadersReaderSetReaderDisplayBodySchema = z.object({
    cart: z
      .object({
        currency: z.string(),
        line_items: z.array(
          z.object({
            amount: z.coerce.number(),
            description: z.string().max(5000),
            quantity: z.coerce.number(),
          }),
        ),
        tax: z.coerce.number().optional(),
        total: z.coerce.number(),
      })
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    type: z.enum(["cart"]),
  })

  router.post(
    "postTerminalReadersReaderSetReaderDisplay",
    "/v1/terminal/readers/:reader/set_reader_display",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTerminalReadersReaderSetReaderDisplayParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTerminalReadersReaderSetReaderDisplayBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTerminalReadersReaderSetReaderDisplay(
          input,
          postTerminalReadersReaderSetReaderDisplay.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTerminalReadersReaderSetReaderDisplay.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersConfirmationTokensBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      payment_method: z.string().max(5000).optional(),
      payment_method_data: z
        .object({
          acss_debit: z
            .object({
              account_number: z.string().max(5000),
              institution_number: z.string().max(5000),
              transit_number: z.string().max(5000),
            })
            .optional(),
          affirm: z.object({}).optional(),
          afterpay_clearpay: z.object({}).optional(),
          alipay: z.object({}).optional(),
          allow_redisplay: z
            .enum(["always", "limited", "unspecified"])
            .optional(),
          alma: z.object({}).optional(),
          amazon_pay: z.object({}).optional(),
          au_becs_debit: z
            .object({
              account_number: z.string().max(5000),
              bsb_number: z.string().max(5000),
            })
            .optional(),
          bacs_debit: z
            .object({
              account_number: z.string().max(5000).optional(),
              sort_code: z.string().max(5000).optional(),
            })
            .optional(),
          bancontact: z.object({}).optional(),
          billie: z.object({}).optional(),
          billing_details: z
            .object({
              address: z
                .union([
                  z.object({
                    city: z.string().max(5000).optional(),
                    country: z.string().max(5000).optional(),
                    line1: z.string().max(5000).optional(),
                    line2: z.string().max(5000).optional(),
                    postal_code: z.string().max(5000).optional(),
                    state: z.string().max(5000).optional(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              email: z.union([z.string(), z.enum([""])]).optional(),
              name: z.union([z.string().max(5000), z.enum([""])]).optional(),
              phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
            })
            .optional(),
          blik: z.object({}).optional(),
          boleto: z.object({ tax_id: z.string().max(5000) }).optional(),
          cashapp: z.object({}).optional(),
          customer_balance: z.object({}).optional(),
          eps: z
            .object({
              bank: z
                .enum([
                  "arzte_und_apotheker_bank",
                  "austrian_anadi_bank_ag",
                  "bank_austria",
                  "bankhaus_carl_spangler",
                  "bankhaus_schelhammer_und_schattera_ag",
                  "bawag_psk_ag",
                  "bks_bank_ag",
                  "brull_kallmus_bank_ag",
                  "btv_vier_lander_bank",
                  "capital_bank_grawe_gruppe_ag",
                  "deutsche_bank_ag",
                  "dolomitenbank",
                  "easybank_ag",
                  "erste_bank_und_sparkassen",
                  "hypo_alpeadriabank_international_ag",
                  "hypo_bank_burgenland_aktiengesellschaft",
                  "hypo_noe_lb_fur_niederosterreich_u_wien",
                  "hypo_oberosterreich_salzburg_steiermark",
                  "hypo_tirol_bank_ag",
                  "hypo_vorarlberg_bank_ag",
                  "marchfelder_bank",
                  "oberbank_ag",
                  "raiffeisen_bankengruppe_osterreich",
                  "schoellerbank_ag",
                  "sparda_bank_wien",
                  "volksbank_gruppe",
                  "volkskreditbank_ag",
                  "vr_bank_braunau",
                ])
                .optional(),
            })
            .optional(),
          fpx: z
            .object({
              bank: z.enum([
                "affin_bank",
                "agrobank",
                "alliance_bank",
                "ambank",
                "bank_islam",
                "bank_muamalat",
                "bank_of_china",
                "bank_rakyat",
                "bsn",
                "cimb",
                "deutsche_bank",
                "hong_leong_bank",
                "hsbc",
                "kfh",
                "maybank2e",
                "maybank2u",
                "ocbc",
                "pb_enterprise",
                "public_bank",
                "rhb",
                "standard_chartered",
                "uob",
              ]),
            })
            .optional(),
          giropay: z.object({}).optional(),
          grabpay: z.object({}).optional(),
          ideal: z
            .object({
              bank: z
                .enum([
                  "abn_amro",
                  "asn_bank",
                  "bunq",
                  "handelsbanken",
                  "ing",
                  "knab",
                  "moneyou",
                  "n26",
                  "nn",
                  "rabobank",
                  "regiobank",
                  "revolut",
                  "sns_bank",
                  "triodos_bank",
                  "van_lanschot",
                  "yoursafe",
                ])
                .optional(),
            })
            .optional(),
          interac_present: z.object({}).optional(),
          kakao_pay: z.object({}).optional(),
          klarna: z
            .object({
              dob: z
                .object({
                  day: z.coerce.number(),
                  month: z.coerce.number(),
                  year: z.coerce.number(),
                })
                .optional(),
            })
            .optional(),
          konbini: z.object({}).optional(),
          kr_card: z.object({}).optional(),
          link: z.object({}).optional(),
          metadata: z.record(z.string()).optional(),
          mobilepay: z.object({}).optional(),
          multibanco: z.object({}).optional(),
          naver_pay: z
            .object({ funding: z.enum(["card", "points"]).optional() })
            .optional(),
          nz_bank_account: z
            .object({
              account_holder_name: z.string().max(5000).optional(),
              account_number: z.string().max(5000),
              bank_code: z.string().max(5000),
              branch_code: z.string().max(5000),
              reference: z.string().max(128).optional(),
              suffix: z.string().max(5000),
            })
            .optional(),
          oxxo: z.object({}).optional(),
          p24: z
            .object({
              bank: z
                .enum([
                  "alior_bank",
                  "bank_millennium",
                  "bank_nowy_bfg_sa",
                  "bank_pekao_sa",
                  "banki_spbdzielcze",
                  "blik",
                  "bnp_paribas",
                  "boz",
                  "citi_handlowy",
                  "credit_agricole",
                  "envelobank",
                  "etransfer_pocztowy24",
                  "getin_bank",
                  "ideabank",
                  "ing",
                  "inteligo",
                  "mbank_mtransfer",
                  "nest_przelew",
                  "noble_pay",
                  "pbac_z_ipko",
                  "plus_bank",
                  "santander_przelew24",
                  "tmobile_usbugi_bankowe",
                  "toyota_bank",
                  "velobank",
                  "volkswagen_bank",
                ])
                .optional(),
            })
            .optional(),
          pay_by_bank: z.object({}).optional(),
          payco: z.object({}).optional(),
          paynow: z.object({}).optional(),
          paypal: z.object({}).optional(),
          pix: z.object({}).optional(),
          promptpay: z.object({}).optional(),
          radar_options: z
            .object({ session: z.string().max(5000).optional() })
            .optional(),
          revolut_pay: z.object({}).optional(),
          samsung_pay: z.object({}).optional(),
          satispay: z.object({}).optional(),
          sepa_debit: z.object({ iban: z.string().max(5000) }).optional(),
          sofort: z
            .object({ country: z.enum(["AT", "BE", "DE", "ES", "IT", "NL"]) })
            .optional(),
          swish: z.object({}).optional(),
          twint: z.object({}).optional(),
          type: z.enum([
            "acss_debit",
            "affirm",
            "afterpay_clearpay",
            "alipay",
            "alma",
            "amazon_pay",
            "au_becs_debit",
            "bacs_debit",
            "bancontact",
            "billie",
            "blik",
            "boleto",
            "cashapp",
            "customer_balance",
            "eps",
            "fpx",
            "giropay",
            "grabpay",
            "ideal",
            "kakao_pay",
            "klarna",
            "konbini",
            "kr_card",
            "link",
            "mobilepay",
            "multibanco",
            "naver_pay",
            "nz_bank_account",
            "oxxo",
            "p24",
            "pay_by_bank",
            "payco",
            "paynow",
            "paypal",
            "pix",
            "promptpay",
            "revolut_pay",
            "samsung_pay",
            "satispay",
            "sepa_debit",
            "sofort",
            "swish",
            "twint",
            "us_bank_account",
            "wechat_pay",
            "zip",
          ]),
          us_bank_account: z
            .object({
              account_holder_type: z.enum(["company", "individual"]).optional(),
              account_number: z.string().max(5000).optional(),
              account_type: z.enum(["checking", "savings"]).optional(),
              financial_connections_account: z.string().max(5000).optional(),
              routing_number: z.string().max(5000).optional(),
            })
            .optional(),
          wechat_pay: z.object({}).optional(),
          zip: z.object({}).optional(),
        })
        .optional(),
      return_url: z.string().optional(),
      setup_future_usage: z.enum(["off_session", "on_session"]).optional(),
      shipping: z
        .object({
          address: z.object({
            city: z.string().max(5000).optional(),
            country: z.string().max(5000).optional(),
            line1: z.string().max(5000).optional(),
            line2: z.string().max(5000).optional(),
            postal_code: z.string().max(5000).optional(),
            state: z.string().max(5000).optional(),
          }),
          name: z.string().max(5000),
          phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postTestHelpersConfirmationTokens",
    "/v1/test_helpers/confirmation_tokens",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersConfirmationTokensBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersConfirmationTokens(
          input,
          postTestHelpersConfirmationTokens.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersConfirmationTokens.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersCustomersCustomerFundCashBalanceParamSchema = z.object({
    customer: z.string().max(5000),
  })

  const postTestHelpersCustomersCustomerFundCashBalanceBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    expand: z.array(z.string().max(5000)).optional(),
    reference: z.string().max(5000).optional(),
  })

  router.post(
    "postTestHelpersCustomersCustomerFundCashBalance",
    "/v1/test_helpers/customers/:customer/fund_cash_balance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersCustomersCustomerFundCashBalanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersCustomersCustomerFundCashBalanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersCustomersCustomerFundCashBalance(
          input,
          postTestHelpersCustomersCustomerFundCashBalance.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersCustomersCustomerFundCashBalance.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsBodySchema = z.object({
    amount: z.coerce.number().optional(),
    amount_details: z
      .object({
        atm_fee: z.coerce.number().optional(),
        cashback_amount: z.coerce.number().optional(),
      })
      .optional(),
    authorization_method: z
      .enum(["chip", "contactless", "keyed_in", "online", "swipe"])
      .optional(),
    card: z.string().max(5000),
    currency: z.string().optional(),
    expand: z.array(z.string().max(5000)).optional(),
    fleet: z
      .object({
        cardholder_prompt_data: z
          .object({
            driver_id: z.string().max(5000).optional(),
            odometer: z.coerce.number().optional(),
            unspecified_id: z.string().max(5000).optional(),
            user_id: z.string().max(5000).optional(),
            vehicle_number: z.string().max(5000).optional(),
          })
          .optional(),
        purchase_type: z
          .enum([
            "fuel_and_non_fuel_purchase",
            "fuel_purchase",
            "non_fuel_purchase",
          ])
          .optional(),
        reported_breakdown: z
          .object({
            fuel: z
              .object({ gross_amount_decimal: z.string().optional() })
              .optional(),
            non_fuel: z
              .object({ gross_amount_decimal: z.string().optional() })
              .optional(),
            tax: z
              .object({
                local_amount_decimal: z.string().optional(),
                national_amount_decimal: z.string().optional(),
              })
              .optional(),
          })
          .optional(),
        service_type: z
          .enum(["full_service", "non_fuel_transaction", "self_service"])
          .optional(),
      })
      .optional(),
    fuel: z
      .object({
        industry_product_code: z.string().max(5000).optional(),
        quantity_decimal: z.string().optional(),
        type: z
          .enum([
            "diesel",
            "other",
            "unleaded_plus",
            "unleaded_regular",
            "unleaded_super",
          ])
          .optional(),
        unit: z
          .enum([
            "charging_minute",
            "imperial_gallon",
            "kilogram",
            "kilowatt_hour",
            "liter",
            "other",
            "pound",
            "us_gallon",
          ])
          .optional(),
        unit_cost_decimal: z.string().optional(),
      })
      .optional(),
    is_amount_controllable: PermissiveBoolean.optional(),
    merchant_amount: z.coerce.number().optional(),
    merchant_currency: z.string().optional(),
    merchant_data: z
      .object({
        category: z
          .enum([
            "ac_refrigeration_repair",
            "accounting_bookkeeping_services",
            "advertising_services",
            "agricultural_cooperative",
            "airlines_air_carriers",
            "airports_flying_fields",
            "ambulance_services",
            "amusement_parks_carnivals",
            "antique_reproductions",
            "antique_shops",
            "aquariums",
            "architectural_surveying_services",
            "art_dealers_and_galleries",
            "artists_supply_and_craft_shops",
            "auto_and_home_supply_stores",
            "auto_body_repair_shops",
            "auto_paint_shops",
            "auto_service_shops",
            "automated_cash_disburse",
            "automated_fuel_dispensers",
            "automobile_associations",
            "automotive_parts_and_accessories_stores",
            "automotive_tire_stores",
            "bail_and_bond_payments",
            "bakeries",
            "bands_orchestras",
            "barber_and_beauty_shops",
            "betting_casino_gambling",
            "bicycle_shops",
            "billiard_pool_establishments",
            "boat_dealers",
            "boat_rentals_and_leases",
            "book_stores",
            "books_periodicals_and_newspapers",
            "bowling_alleys",
            "bus_lines",
            "business_secretarial_schools",
            "buying_shopping_services",
            "cable_satellite_and_other_pay_television_and_radio",
            "camera_and_photographic_supply_stores",
            "candy_nut_and_confectionery_stores",
            "car_and_truck_dealers_new_used",
            "car_and_truck_dealers_used_only",
            "car_rental_agencies",
            "car_washes",
            "carpentry_services",
            "carpet_upholstery_cleaning",
            "caterers",
            "charitable_and_social_service_organizations_fundraising",
            "chemicals_and_allied_products",
            "child_care_services",
            "childrens_and_infants_wear_stores",
            "chiropodists_podiatrists",
            "chiropractors",
            "cigar_stores_and_stands",
            "civic_social_fraternal_associations",
            "cleaning_and_maintenance",
            "clothing_rental",
            "colleges_universities",
            "commercial_equipment",
            "commercial_footwear",
            "commercial_photography_art_and_graphics",
            "commuter_transport_and_ferries",
            "computer_network_services",
            "computer_programming",
            "computer_repair",
            "computer_software_stores",
            "computers_peripherals_and_software",
            "concrete_work_services",
            "construction_materials",
            "consulting_public_relations",
            "correspondence_schools",
            "cosmetic_stores",
            "counseling_services",
            "country_clubs",
            "courier_services",
            "court_costs",
            "credit_reporting_agencies",
            "cruise_lines",
            "dairy_products_stores",
            "dance_hall_studios_schools",
            "dating_escort_services",
            "dentists_orthodontists",
            "department_stores",
            "detective_agencies",
            "digital_goods_applications",
            "digital_goods_games",
            "digital_goods_large_volume",
            "digital_goods_media",
            "direct_marketing_catalog_merchant",
            "direct_marketing_combination_catalog_and_retail_merchant",
            "direct_marketing_inbound_telemarketing",
            "direct_marketing_insurance_services",
            "direct_marketing_other",
            "direct_marketing_outbound_telemarketing",
            "direct_marketing_subscription",
            "direct_marketing_travel",
            "discount_stores",
            "doctors",
            "door_to_door_sales",
            "drapery_window_covering_and_upholstery_stores",
            "drinking_places",
            "drug_stores_and_pharmacies",
            "drugs_drug_proprietaries_and_druggist_sundries",
            "dry_cleaners",
            "durable_goods",
            "duty_free_stores",
            "eating_places_restaurants",
            "educational_services",
            "electric_razor_stores",
            "electric_vehicle_charging",
            "electrical_parts_and_equipment",
            "electrical_services",
            "electronics_repair_shops",
            "electronics_stores",
            "elementary_secondary_schools",
            "emergency_services_gcas_visa_use_only",
            "employment_temp_agencies",
            "equipment_rental",
            "exterminating_services",
            "family_clothing_stores",
            "fast_food_restaurants",
            "financial_institutions",
            "fines_government_administrative_entities",
            "fireplace_fireplace_screens_and_accessories_stores",
            "floor_covering_stores",
            "florists",
            "florists_supplies_nursery_stock_and_flowers",
            "freezer_and_locker_meat_provisioners",
            "fuel_dealers_non_automotive",
            "funeral_services_crematories",
            "furniture_home_furnishings_and_equipment_stores_except_appliances",
            "furniture_repair_refinishing",
            "furriers_and_fur_shops",
            "general_services",
            "gift_card_novelty_and_souvenir_shops",
            "glass_paint_and_wallpaper_stores",
            "glassware_crystal_stores",
            "golf_courses_public",
            "government_licensed_horse_dog_racing_us_region_only",
            "government_licensed_online_casions_online_gambling_us_region_only",
            "government_owned_lotteries_non_us_region",
            "government_owned_lotteries_us_region_only",
            "government_services",
            "grocery_stores_supermarkets",
            "hardware_equipment_and_supplies",
            "hardware_stores",
            "health_and_beauty_spas",
            "hearing_aids_sales_and_supplies",
            "heating_plumbing_a_c",
            "hobby_toy_and_game_shops",
            "home_supply_warehouse_stores",
            "hospitals",
            "hotels_motels_and_resorts",
            "household_appliance_stores",
            "industrial_supplies",
            "information_retrieval_services",
            "insurance_default",
            "insurance_underwriting_premiums",
            "intra_company_purchases",
            "jewelry_stores_watches_clocks_and_silverware_stores",
            "landscaping_services",
            "laundries",
            "laundry_cleaning_services",
            "legal_services_attorneys",
            "luggage_and_leather_goods_stores",
            "lumber_building_materials_stores",
            "manual_cash_disburse",
            "marinas_service_and_supplies",
            "marketplaces",
            "masonry_stonework_and_plaster",
            "massage_parlors",
            "medical_and_dental_labs",
            "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
            "medical_services",
            "membership_organizations",
            "mens_and_boys_clothing_and_accessories_stores",
            "mens_womens_clothing_stores",
            "metal_service_centers",
            "miscellaneous_apparel_and_accessory_shops",
            "miscellaneous_auto_dealers",
            "miscellaneous_business_services",
            "miscellaneous_food_stores",
            "miscellaneous_general_merchandise",
            "miscellaneous_general_services",
            "miscellaneous_home_furnishing_specialty_stores",
            "miscellaneous_publishing_and_printing",
            "miscellaneous_recreation_services",
            "miscellaneous_repair_shops",
            "miscellaneous_specialty_retail",
            "mobile_home_dealers",
            "motion_picture_theaters",
            "motor_freight_carriers_and_trucking",
            "motor_homes_dealers",
            "motor_vehicle_supplies_and_new_parts",
            "motorcycle_shops_and_dealers",
            "motorcycle_shops_dealers",
            "music_stores_musical_instruments_pianos_and_sheet_music",
            "news_dealers_and_newsstands",
            "non_fi_money_orders",
            "non_fi_stored_value_card_purchase_load",
            "nondurable_goods",
            "nurseries_lawn_and_garden_supply_stores",
            "nursing_personal_care",
            "office_and_commercial_furniture",
            "opticians_eyeglasses",
            "optometrists_ophthalmologist",
            "orthopedic_goods_prosthetic_devices",
            "osteopaths",
            "package_stores_beer_wine_and_liquor",
            "paints_varnishes_and_supplies",
            "parking_lots_garages",
            "passenger_railways",
            "pawn_shops",
            "pet_shops_pet_food_and_supplies",
            "petroleum_and_petroleum_products",
            "photo_developing",
            "photographic_photocopy_microfilm_equipment_and_supplies",
            "photographic_studios",
            "picture_video_production",
            "piece_goods_notions_and_other_dry_goods",
            "plumbing_heating_equipment_and_supplies",
            "political_organizations",
            "postal_services_government_only",
            "precious_stones_and_metals_watches_and_jewelry",
            "professional_services",
            "public_warehousing_and_storage",
            "quick_copy_repro_and_blueprint",
            "railroads",
            "real_estate_agents_and_managers_rentals",
            "record_stores",
            "recreational_vehicle_rentals",
            "religious_goods_stores",
            "religious_organizations",
            "roofing_siding_sheet_metal",
            "secretarial_support_services",
            "security_brokers_dealers",
            "service_stations",
            "sewing_needlework_fabric_and_piece_goods_stores",
            "shoe_repair_hat_cleaning",
            "shoe_stores",
            "small_appliance_repair",
            "snowmobile_dealers",
            "special_trade_services",
            "specialty_cleaning",
            "sporting_goods_stores",
            "sporting_recreation_camps",
            "sports_and_riding_apparel_stores",
            "sports_clubs_fields",
            "stamp_and_coin_stores",
            "stationary_office_supplies_printing_and_writing_paper",
            "stationery_stores_office_and_school_supply_stores",
            "swimming_pools_sales",
            "t_ui_travel_germany",
            "tailors_alterations",
            "tax_payments_government_agencies",
            "tax_preparation_services",
            "taxicabs_limousines",
            "telecommunication_equipment_and_telephone_sales",
            "telecommunication_services",
            "telegraph_services",
            "tent_and_awning_shops",
            "testing_laboratories",
            "theatrical_ticket_agencies",
            "timeshares",
            "tire_retreading_and_repair",
            "tolls_bridge_fees",
            "tourist_attractions_and_exhibits",
            "towing_services",
            "trailer_parks_campgrounds",
            "transportation_services",
            "travel_agencies_tour_operators",
            "truck_stop_iteration",
            "truck_utility_trailer_rentals",
            "typesetting_plate_making_and_related_services",
            "typewriter_stores",
            "u_s_federal_government_agencies_or_departments",
            "uniforms_commercial_clothing",
            "used_merchandise_and_secondhand_stores",
            "utilities",
            "variety_stores",
            "veterinary_services",
            "video_amusement_game_supplies",
            "video_game_arcades",
            "video_tape_rental_stores",
            "vocational_trade_schools",
            "watch_jewelry_repair",
            "welding_repair",
            "wholesale_clubs",
            "wig_and_toupee_stores",
            "wires_money_orders",
            "womens_accessory_and_specialty_shops",
            "womens_ready_to_wear_stores",
            "wrecking_and_salvage_yards",
          ])
          .optional(),
        city: z.string().max(5000).optional(),
        country: z.string().max(5000).optional(),
        name: z.string().max(5000).optional(),
        network_id: z.string().max(5000).optional(),
        postal_code: z.string().max(5000).optional(),
        state: z.string().max(5000).optional(),
        terminal_id: z.string().max(5000).optional(),
        url: z.string().max(5000).optional(),
      })
      .optional(),
    network_data: z
      .object({ acquiring_institution_id: z.string().max(5000).optional() })
      .optional(),
    verification_data: z
      .object({
        address_line1_check: z
          .enum(["match", "mismatch", "not_provided"])
          .optional(),
        address_postal_code_check: z
          .enum(["match", "mismatch", "not_provided"])
          .optional(),
        authentication_exemption: z
          .object({
            claimed_by: z.enum(["acquirer", "issuer"]),
            type: z.enum([
              "low_value_transaction",
              "transaction_risk_analysis",
              "unknown",
            ]),
          })
          .optional(),
        cvc_check: z.enum(["match", "mismatch", "not_provided"]).optional(),
        expiry_check: z.enum(["match", "mismatch", "not_provided"]).optional(),
        three_d_secure: z
          .object({
            result: z.enum([
              "attempt_acknowledged",
              "authenticated",
              "failed",
              "required",
            ]),
          })
          .optional(),
      })
      .optional(),
    wallet: z.enum(["apple_pay", "google_pay", "samsung_pay"]).optional(),
  })

  router.post(
    "postTestHelpersIssuingAuthorizations",
    "/v1/test_helpers/issuing/authorizations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizations(
          input,
          postTestHelpersIssuingAuthorizations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingAuthorizations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema =
    z.object({ authorization: z.string().max(5000) })

  const postTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema = z
    .object({
      capture_amount: z.coerce.number().optional(),
      close_authorization: PermissiveBoolean.optional(),
      expand: z.array(z.string().max(5000)).optional(),
      purchase_details: z
        .object({
          fleet: z
            .object({
              cardholder_prompt_data: z
                .object({
                  driver_id: z.string().max(5000).optional(),
                  odometer: z.coerce.number().optional(),
                  unspecified_id: z.string().max(5000).optional(),
                  user_id: z.string().max(5000).optional(),
                  vehicle_number: z.string().max(5000).optional(),
                })
                .optional(),
              purchase_type: z
                .enum([
                  "fuel_and_non_fuel_purchase",
                  "fuel_purchase",
                  "non_fuel_purchase",
                ])
                .optional(),
              reported_breakdown: z
                .object({
                  fuel: z
                    .object({ gross_amount_decimal: z.string().optional() })
                    .optional(),
                  non_fuel: z
                    .object({ gross_amount_decimal: z.string().optional() })
                    .optional(),
                  tax: z
                    .object({
                      local_amount_decimal: z.string().optional(),
                      national_amount_decimal: z.string().optional(),
                    })
                    .optional(),
                })
                .optional(),
              service_type: z
                .enum(["full_service", "non_fuel_transaction", "self_service"])
                .optional(),
            })
            .optional(),
          flight: z
            .object({
              departure_at: z.coerce.number().optional(),
              passenger_name: z.string().max(5000).optional(),
              refundable: PermissiveBoolean.optional(),
              segments: z
                .array(
                  z.object({
                    arrival_airport_code: z.string().max(3).optional(),
                    carrier: z.string().max(5000).optional(),
                    departure_airport_code: z.string().max(3).optional(),
                    flight_number: z.string().max(5000).optional(),
                    service_class: z.string().max(5000).optional(),
                    stopover_allowed: PermissiveBoolean.optional(),
                  }),
                )
                .optional(),
              travel_agency: z.string().max(5000).optional(),
            })
            .optional(),
          fuel: z
            .object({
              industry_product_code: z.string().max(5000).optional(),
              quantity_decimal: z.string().optional(),
              type: z
                .enum([
                  "diesel",
                  "other",
                  "unleaded_plus",
                  "unleaded_regular",
                  "unleaded_super",
                ])
                .optional(),
              unit: z
                .enum([
                  "charging_minute",
                  "imperial_gallon",
                  "kilogram",
                  "kilowatt_hour",
                  "liter",
                  "other",
                  "pound",
                  "us_gallon",
                ])
                .optional(),
              unit_cost_decimal: z.string().optional(),
            })
            .optional(),
          lodging: z
            .object({
              check_in_at: z.coerce.number().optional(),
              nights: z.coerce.number().optional(),
            })
            .optional(),
          receipt: z
            .array(
              z.object({
                description: z.string().max(26).optional(),
                quantity: z.string().optional(),
                total: z.coerce.number().optional(),
                unit_cost: z.coerce.number().optional(),
              }),
            )
            .optional(),
          reference: z.string().max(5000).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationCapture",
    "/v1/test_helpers/issuing/authorizations/:authorization/capture",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationCaptureParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationCapture(
          input,
          postTestHelpersIssuingAuthorizationsAuthorizationCapture.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationCapture.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema =
    z.object({ authorization: z.string().max(5000) })

  const postTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationExpire",
    "/v1/test_helpers/issuing/authorizations/:authorization/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationExpire(
          input,
          postTestHelpersIssuingAuthorizationsAuthorizationExpire.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationExpire.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema =
    z.object({ authorization: z.string().max(5000) })

  const postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema =
    z.object({
      expand: z.array(z.string().max(5000)).optional(),
      final_amount: z.coerce.number(),
      fleet: z
        .object({
          cardholder_prompt_data: z
            .object({
              driver_id: z.string().max(5000).optional(),
              odometer: z.coerce.number().optional(),
              unspecified_id: z.string().max(5000).optional(),
              user_id: z.string().max(5000).optional(),
              vehicle_number: z.string().max(5000).optional(),
            })
            .optional(),
          purchase_type: z
            .enum([
              "fuel_and_non_fuel_purchase",
              "fuel_purchase",
              "non_fuel_purchase",
            ])
            .optional(),
          reported_breakdown: z
            .object({
              fuel: z
                .object({ gross_amount_decimal: z.string().optional() })
                .optional(),
              non_fuel: z
                .object({ gross_amount_decimal: z.string().optional() })
                .optional(),
              tax: z
                .object({
                  local_amount_decimal: z.string().optional(),
                  national_amount_decimal: z.string().optional(),
                })
                .optional(),
            })
            .optional(),
          service_type: z
            .enum(["full_service", "non_fuel_transaction", "self_service"])
            .optional(),
        })
        .optional(),
      fuel: z
        .object({
          industry_product_code: z.string().max(5000).optional(),
          quantity_decimal: z.string().optional(),
          type: z
            .enum([
              "diesel",
              "other",
              "unleaded_plus",
              "unleaded_regular",
              "unleaded_super",
            ])
            .optional(),
          unit: z
            .enum([
              "charging_minute",
              "imperial_gallon",
              "kilogram",
              "kilowatt_hour",
              "liter",
              "other",
              "pound",
              "us_gallon",
            ])
            .optional(),
          unit_cost_decimal: z.string().optional(),
        })
        .optional(),
    })

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount",
    "/v1/test_helpers/issuing/authorizations/:authorization/finalize_amount",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount(
          input,
          postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationFinalizeAmount.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema =
    z.object({ authorization: z.string().max(5000) })

  const postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema =
    z.object({
      confirmed: PermissiveBoolean,
      expand: z.array(z.string().max(5000)).optional(),
    })

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond",
    "/v1/test_helpers/issuing/authorizations/:authorization/fraud_challenges/respond",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespondBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond(
          input,
          postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationFraudChallengesRespond.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema =
    z.object({ authorization: z.string().max(5000) })

  const postTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema =
    z.object({
      expand: z.array(z.string().max(5000)).optional(),
      increment_amount: z.coerce.number(),
      is_amount_controllable: PermissiveBoolean.optional(),
    })

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationIncrement",
    "/v1/test_helpers/issuing/authorizations/:authorization/increment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationIncrementParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationIncrementBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationIncrement(
          input,
          postTestHelpersIssuingAuthorizationsAuthorizationIncrement.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationIncrement.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema =
    z.object({ authorization: z.string().max(5000) })

  const postTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      reverse_amount: z.coerce.number().optional(),
    })
    .optional()

  router.post(
    "postTestHelpersIssuingAuthorizationsAuthorizationReverse",
    "/v1/test_helpers/issuing/authorizations/:authorization/reverse",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationReverseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingAuthorizationsAuthorizationReverseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingAuthorizationsAuthorizationReverse(
          input,
          postTestHelpersIssuingAuthorizationsAuthorizationReverse.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingAuthorizationsAuthorizationReverse.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingDeliverParamSchema = z.object({
    card: z.string().max(5000),
  })

  const postTestHelpersIssuingCardsCardShippingDeliverBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersIssuingCardsCardShippingDeliver",
    "/v1/test_helpers/issuing/cards/:card/shipping/deliver",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingDeliverParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingDeliverBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingDeliver(
          input,
          postTestHelpersIssuingCardsCardShippingDeliver.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingDeliver.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingFailParamSchema = z.object({
    card: z.string().max(5000),
  })

  const postTestHelpersIssuingCardsCardShippingFailBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersIssuingCardsCardShippingFail",
    "/v1/test_helpers/issuing/cards/:card/shipping/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingFail(
          input,
          postTestHelpersIssuingCardsCardShippingFail.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingFail.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingReturnParamSchema = z.object({
    card: z.string().max(5000),
  })

  const postTestHelpersIssuingCardsCardShippingReturnBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersIssuingCardsCardShippingReturn",
    "/v1/test_helpers/issuing/cards/:card/shipping/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingReturn(
          input,
          postTestHelpersIssuingCardsCardShippingReturn.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingReturn.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingShipParamSchema = z.object({
    card: z.string().max(5000),
  })

  const postTestHelpersIssuingCardsCardShippingShipBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersIssuingCardsCardShippingShip",
    "/v1/test_helpers/issuing/cards/:card/shipping/ship",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingShipParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingShipBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingShip(
          input,
          postTestHelpersIssuingCardsCardShippingShip.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingShip.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingCardsCardShippingSubmitParamSchema = z.object({
    card: z.string().max(5000),
  })

  const postTestHelpersIssuingCardsCardShippingSubmitBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersIssuingCardsCardShippingSubmit",
    "/v1/test_helpers/issuing/cards/:card/shipping/submit",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingSubmitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingCardsCardShippingSubmitBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingCardsCardShippingSubmit(
          input,
          postTestHelpersIssuingCardsCardShippingSubmit.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingCardsCardShippingSubmit.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema =
    z.object({ personalization_design: z.string().max(5000) })

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema =
    z.object({ expand: z.array(z.string().max(5000)).optional() }).optional()

  router.post(
    "postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate",
    "/v1/test_helpers/issuing/personalization_designs/:personalization_design/activate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate(
          input,
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignActivate.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema =
    z.object({ personalization_design: z.string().max(5000) })

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema =
    z.object({ expand: z.array(z.string().max(5000)).optional() }).optional()

  router.post(
    "postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate",
    "/v1/test_helpers/issuing/personalization_designs/:personalization_design/deactivate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate(
          input,
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignDeactivate.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema =
    z.object({ personalization_design: z.string().max(5000) })

  const postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema =
    z.object({
      expand: z.array(z.string().max(5000)).optional(),
      rejection_reasons: z.object({
        card_logo: z
          .array(
            z.enum([
              "geographic_location",
              "inappropriate",
              "network_name",
              "non_binary_image",
              "non_fiat_currency",
              "other",
              "other_entity",
              "promotional_material",
            ]),
          )
          .optional(),
        carrier_text: z
          .array(
            z.enum([
              "geographic_location",
              "inappropriate",
              "network_name",
              "non_fiat_currency",
              "other",
              "other_entity",
              "promotional_material",
            ]),
          )
          .optional(),
      }),
    })

  router.post(
    "postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject",
    "/v1/test_helpers/issuing/personalization_designs/:personalization_design/reject",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignRejectBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject(
          input,
          postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingPersonalizationDesignsPersonalizationDesignReject.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingSettlementsBodySchema = z.object({
    bin: z.string().max(5000),
    clearing_date: z.coerce.number(),
    currency: z.string(),
    expand: z.array(z.string().max(5000)).optional(),
    interchange_fees_amount: z.coerce.number().optional(),
    net_total_amount: z.coerce.number(),
    network: z.enum(["maestro", "visa"]).optional(),
    network_settlement_identifier: z.string().max(5000).optional(),
    transaction_amount: z.coerce.number().optional(),
    transaction_count: z.coerce.number().optional(),
  })

  router.post(
    "postTestHelpersIssuingSettlements",
    "/v1/test_helpers/issuing/settlements",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingSettlementsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingSettlements(
          input,
          postTestHelpersIssuingSettlements.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingSettlements.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingSettlementsSettlementCompleteParamSchema =
    z.object({ settlement: z.string().max(5000) })

  const postTestHelpersIssuingSettlementsSettlementCompleteBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersIssuingSettlementsSettlementComplete",
    "/v1/test_helpers/issuing/settlements/:settlement/complete",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingSettlementsSettlementCompleteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingSettlementsSettlementCompleteBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingSettlementsSettlementComplete(
          input,
          postTestHelpersIssuingSettlementsSettlementComplete.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingSettlementsSettlementComplete.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingTransactionsCreateForceCaptureBodySchema =
    z.object({
      amount: z.coerce.number(),
      card: z.string().max(5000),
      currency: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      merchant_data: z
        .object({
          category: z
            .enum([
              "ac_refrigeration_repair",
              "accounting_bookkeeping_services",
              "advertising_services",
              "agricultural_cooperative",
              "airlines_air_carriers",
              "airports_flying_fields",
              "ambulance_services",
              "amusement_parks_carnivals",
              "antique_reproductions",
              "antique_shops",
              "aquariums",
              "architectural_surveying_services",
              "art_dealers_and_galleries",
              "artists_supply_and_craft_shops",
              "auto_and_home_supply_stores",
              "auto_body_repair_shops",
              "auto_paint_shops",
              "auto_service_shops",
              "automated_cash_disburse",
              "automated_fuel_dispensers",
              "automobile_associations",
              "automotive_parts_and_accessories_stores",
              "automotive_tire_stores",
              "bail_and_bond_payments",
              "bakeries",
              "bands_orchestras",
              "barber_and_beauty_shops",
              "betting_casino_gambling",
              "bicycle_shops",
              "billiard_pool_establishments",
              "boat_dealers",
              "boat_rentals_and_leases",
              "book_stores",
              "books_periodicals_and_newspapers",
              "bowling_alleys",
              "bus_lines",
              "business_secretarial_schools",
              "buying_shopping_services",
              "cable_satellite_and_other_pay_television_and_radio",
              "camera_and_photographic_supply_stores",
              "candy_nut_and_confectionery_stores",
              "car_and_truck_dealers_new_used",
              "car_and_truck_dealers_used_only",
              "car_rental_agencies",
              "car_washes",
              "carpentry_services",
              "carpet_upholstery_cleaning",
              "caterers",
              "charitable_and_social_service_organizations_fundraising",
              "chemicals_and_allied_products",
              "child_care_services",
              "childrens_and_infants_wear_stores",
              "chiropodists_podiatrists",
              "chiropractors",
              "cigar_stores_and_stands",
              "civic_social_fraternal_associations",
              "cleaning_and_maintenance",
              "clothing_rental",
              "colleges_universities",
              "commercial_equipment",
              "commercial_footwear",
              "commercial_photography_art_and_graphics",
              "commuter_transport_and_ferries",
              "computer_network_services",
              "computer_programming",
              "computer_repair",
              "computer_software_stores",
              "computers_peripherals_and_software",
              "concrete_work_services",
              "construction_materials",
              "consulting_public_relations",
              "correspondence_schools",
              "cosmetic_stores",
              "counseling_services",
              "country_clubs",
              "courier_services",
              "court_costs",
              "credit_reporting_agencies",
              "cruise_lines",
              "dairy_products_stores",
              "dance_hall_studios_schools",
              "dating_escort_services",
              "dentists_orthodontists",
              "department_stores",
              "detective_agencies",
              "digital_goods_applications",
              "digital_goods_games",
              "digital_goods_large_volume",
              "digital_goods_media",
              "direct_marketing_catalog_merchant",
              "direct_marketing_combination_catalog_and_retail_merchant",
              "direct_marketing_inbound_telemarketing",
              "direct_marketing_insurance_services",
              "direct_marketing_other",
              "direct_marketing_outbound_telemarketing",
              "direct_marketing_subscription",
              "direct_marketing_travel",
              "discount_stores",
              "doctors",
              "door_to_door_sales",
              "drapery_window_covering_and_upholstery_stores",
              "drinking_places",
              "drug_stores_and_pharmacies",
              "drugs_drug_proprietaries_and_druggist_sundries",
              "dry_cleaners",
              "durable_goods",
              "duty_free_stores",
              "eating_places_restaurants",
              "educational_services",
              "electric_razor_stores",
              "electric_vehicle_charging",
              "electrical_parts_and_equipment",
              "electrical_services",
              "electronics_repair_shops",
              "electronics_stores",
              "elementary_secondary_schools",
              "emergency_services_gcas_visa_use_only",
              "employment_temp_agencies",
              "equipment_rental",
              "exterminating_services",
              "family_clothing_stores",
              "fast_food_restaurants",
              "financial_institutions",
              "fines_government_administrative_entities",
              "fireplace_fireplace_screens_and_accessories_stores",
              "floor_covering_stores",
              "florists",
              "florists_supplies_nursery_stock_and_flowers",
              "freezer_and_locker_meat_provisioners",
              "fuel_dealers_non_automotive",
              "funeral_services_crematories",
              "furniture_home_furnishings_and_equipment_stores_except_appliances",
              "furniture_repair_refinishing",
              "furriers_and_fur_shops",
              "general_services",
              "gift_card_novelty_and_souvenir_shops",
              "glass_paint_and_wallpaper_stores",
              "glassware_crystal_stores",
              "golf_courses_public",
              "government_licensed_horse_dog_racing_us_region_only",
              "government_licensed_online_casions_online_gambling_us_region_only",
              "government_owned_lotteries_non_us_region",
              "government_owned_lotteries_us_region_only",
              "government_services",
              "grocery_stores_supermarkets",
              "hardware_equipment_and_supplies",
              "hardware_stores",
              "health_and_beauty_spas",
              "hearing_aids_sales_and_supplies",
              "heating_plumbing_a_c",
              "hobby_toy_and_game_shops",
              "home_supply_warehouse_stores",
              "hospitals",
              "hotels_motels_and_resorts",
              "household_appliance_stores",
              "industrial_supplies",
              "information_retrieval_services",
              "insurance_default",
              "insurance_underwriting_premiums",
              "intra_company_purchases",
              "jewelry_stores_watches_clocks_and_silverware_stores",
              "landscaping_services",
              "laundries",
              "laundry_cleaning_services",
              "legal_services_attorneys",
              "luggage_and_leather_goods_stores",
              "lumber_building_materials_stores",
              "manual_cash_disburse",
              "marinas_service_and_supplies",
              "marketplaces",
              "masonry_stonework_and_plaster",
              "massage_parlors",
              "medical_and_dental_labs",
              "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
              "medical_services",
              "membership_organizations",
              "mens_and_boys_clothing_and_accessories_stores",
              "mens_womens_clothing_stores",
              "metal_service_centers",
              "miscellaneous_apparel_and_accessory_shops",
              "miscellaneous_auto_dealers",
              "miscellaneous_business_services",
              "miscellaneous_food_stores",
              "miscellaneous_general_merchandise",
              "miscellaneous_general_services",
              "miscellaneous_home_furnishing_specialty_stores",
              "miscellaneous_publishing_and_printing",
              "miscellaneous_recreation_services",
              "miscellaneous_repair_shops",
              "miscellaneous_specialty_retail",
              "mobile_home_dealers",
              "motion_picture_theaters",
              "motor_freight_carriers_and_trucking",
              "motor_homes_dealers",
              "motor_vehicle_supplies_and_new_parts",
              "motorcycle_shops_and_dealers",
              "motorcycle_shops_dealers",
              "music_stores_musical_instruments_pianos_and_sheet_music",
              "news_dealers_and_newsstands",
              "non_fi_money_orders",
              "non_fi_stored_value_card_purchase_load",
              "nondurable_goods",
              "nurseries_lawn_and_garden_supply_stores",
              "nursing_personal_care",
              "office_and_commercial_furniture",
              "opticians_eyeglasses",
              "optometrists_ophthalmologist",
              "orthopedic_goods_prosthetic_devices",
              "osteopaths",
              "package_stores_beer_wine_and_liquor",
              "paints_varnishes_and_supplies",
              "parking_lots_garages",
              "passenger_railways",
              "pawn_shops",
              "pet_shops_pet_food_and_supplies",
              "petroleum_and_petroleum_products",
              "photo_developing",
              "photographic_photocopy_microfilm_equipment_and_supplies",
              "photographic_studios",
              "picture_video_production",
              "piece_goods_notions_and_other_dry_goods",
              "plumbing_heating_equipment_and_supplies",
              "political_organizations",
              "postal_services_government_only",
              "precious_stones_and_metals_watches_and_jewelry",
              "professional_services",
              "public_warehousing_and_storage",
              "quick_copy_repro_and_blueprint",
              "railroads",
              "real_estate_agents_and_managers_rentals",
              "record_stores",
              "recreational_vehicle_rentals",
              "religious_goods_stores",
              "religious_organizations",
              "roofing_siding_sheet_metal",
              "secretarial_support_services",
              "security_brokers_dealers",
              "service_stations",
              "sewing_needlework_fabric_and_piece_goods_stores",
              "shoe_repair_hat_cleaning",
              "shoe_stores",
              "small_appliance_repair",
              "snowmobile_dealers",
              "special_trade_services",
              "specialty_cleaning",
              "sporting_goods_stores",
              "sporting_recreation_camps",
              "sports_and_riding_apparel_stores",
              "sports_clubs_fields",
              "stamp_and_coin_stores",
              "stationary_office_supplies_printing_and_writing_paper",
              "stationery_stores_office_and_school_supply_stores",
              "swimming_pools_sales",
              "t_ui_travel_germany",
              "tailors_alterations",
              "tax_payments_government_agencies",
              "tax_preparation_services",
              "taxicabs_limousines",
              "telecommunication_equipment_and_telephone_sales",
              "telecommunication_services",
              "telegraph_services",
              "tent_and_awning_shops",
              "testing_laboratories",
              "theatrical_ticket_agencies",
              "timeshares",
              "tire_retreading_and_repair",
              "tolls_bridge_fees",
              "tourist_attractions_and_exhibits",
              "towing_services",
              "trailer_parks_campgrounds",
              "transportation_services",
              "travel_agencies_tour_operators",
              "truck_stop_iteration",
              "truck_utility_trailer_rentals",
              "typesetting_plate_making_and_related_services",
              "typewriter_stores",
              "u_s_federal_government_agencies_or_departments",
              "uniforms_commercial_clothing",
              "used_merchandise_and_secondhand_stores",
              "utilities",
              "variety_stores",
              "veterinary_services",
              "video_amusement_game_supplies",
              "video_game_arcades",
              "video_tape_rental_stores",
              "vocational_trade_schools",
              "watch_jewelry_repair",
              "welding_repair",
              "wholesale_clubs",
              "wig_and_toupee_stores",
              "wires_money_orders",
              "womens_accessory_and_specialty_shops",
              "womens_ready_to_wear_stores",
              "wrecking_and_salvage_yards",
            ])
            .optional(),
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          name: z.string().max(5000).optional(),
          network_id: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          terminal_id: z.string().max(5000).optional(),
          url: z.string().max(5000).optional(),
        })
        .optional(),
      purchase_details: z
        .object({
          fleet: z
            .object({
              cardholder_prompt_data: z
                .object({
                  driver_id: z.string().max(5000).optional(),
                  odometer: z.coerce.number().optional(),
                  unspecified_id: z.string().max(5000).optional(),
                  user_id: z.string().max(5000).optional(),
                  vehicle_number: z.string().max(5000).optional(),
                })
                .optional(),
              purchase_type: z
                .enum([
                  "fuel_and_non_fuel_purchase",
                  "fuel_purchase",
                  "non_fuel_purchase",
                ])
                .optional(),
              reported_breakdown: z
                .object({
                  fuel: z
                    .object({ gross_amount_decimal: z.string().optional() })
                    .optional(),
                  non_fuel: z
                    .object({ gross_amount_decimal: z.string().optional() })
                    .optional(),
                  tax: z
                    .object({
                      local_amount_decimal: z.string().optional(),
                      national_amount_decimal: z.string().optional(),
                    })
                    .optional(),
                })
                .optional(),
              service_type: z
                .enum(["full_service", "non_fuel_transaction", "self_service"])
                .optional(),
            })
            .optional(),
          flight: z
            .object({
              departure_at: z.coerce.number().optional(),
              passenger_name: z.string().max(5000).optional(),
              refundable: PermissiveBoolean.optional(),
              segments: z
                .array(
                  z.object({
                    arrival_airport_code: z.string().max(3).optional(),
                    carrier: z.string().max(5000).optional(),
                    departure_airport_code: z.string().max(3).optional(),
                    flight_number: z.string().max(5000).optional(),
                    service_class: z.string().max(5000).optional(),
                    stopover_allowed: PermissiveBoolean.optional(),
                  }),
                )
                .optional(),
              travel_agency: z.string().max(5000).optional(),
            })
            .optional(),
          fuel: z
            .object({
              industry_product_code: z.string().max(5000).optional(),
              quantity_decimal: z.string().optional(),
              type: z
                .enum([
                  "diesel",
                  "other",
                  "unleaded_plus",
                  "unleaded_regular",
                  "unleaded_super",
                ])
                .optional(),
              unit: z
                .enum([
                  "charging_minute",
                  "imperial_gallon",
                  "kilogram",
                  "kilowatt_hour",
                  "liter",
                  "other",
                  "pound",
                  "us_gallon",
                ])
                .optional(),
              unit_cost_decimal: z.string().optional(),
            })
            .optional(),
          lodging: z
            .object({
              check_in_at: z.coerce.number().optional(),
              nights: z.coerce.number().optional(),
            })
            .optional(),
          receipt: z
            .array(
              z.object({
                description: z.string().max(26).optional(),
                quantity: z.string().optional(),
                total: z.coerce.number().optional(),
                unit_cost: z.coerce.number().optional(),
              }),
            )
            .optional(),
          reference: z.string().max(5000).optional(),
        })
        .optional(),
    })

  router.post(
    "postTestHelpersIssuingTransactionsCreateForceCapture",
    "/v1/test_helpers/issuing/transactions/create_force_capture",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingTransactionsCreateForceCaptureBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingTransactionsCreateForceCapture(
          input,
          postTestHelpersIssuingTransactionsCreateForceCapture.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingTransactionsCreateForceCapture.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema =
    z.object({
      amount: z.coerce.number(),
      card: z.string().max(5000),
      currency: z.string().optional(),
      expand: z.array(z.string().max(5000)).optional(),
      merchant_data: z
        .object({
          category: z
            .enum([
              "ac_refrigeration_repair",
              "accounting_bookkeeping_services",
              "advertising_services",
              "agricultural_cooperative",
              "airlines_air_carriers",
              "airports_flying_fields",
              "ambulance_services",
              "amusement_parks_carnivals",
              "antique_reproductions",
              "antique_shops",
              "aquariums",
              "architectural_surveying_services",
              "art_dealers_and_galleries",
              "artists_supply_and_craft_shops",
              "auto_and_home_supply_stores",
              "auto_body_repair_shops",
              "auto_paint_shops",
              "auto_service_shops",
              "automated_cash_disburse",
              "automated_fuel_dispensers",
              "automobile_associations",
              "automotive_parts_and_accessories_stores",
              "automotive_tire_stores",
              "bail_and_bond_payments",
              "bakeries",
              "bands_orchestras",
              "barber_and_beauty_shops",
              "betting_casino_gambling",
              "bicycle_shops",
              "billiard_pool_establishments",
              "boat_dealers",
              "boat_rentals_and_leases",
              "book_stores",
              "books_periodicals_and_newspapers",
              "bowling_alleys",
              "bus_lines",
              "business_secretarial_schools",
              "buying_shopping_services",
              "cable_satellite_and_other_pay_television_and_radio",
              "camera_and_photographic_supply_stores",
              "candy_nut_and_confectionery_stores",
              "car_and_truck_dealers_new_used",
              "car_and_truck_dealers_used_only",
              "car_rental_agencies",
              "car_washes",
              "carpentry_services",
              "carpet_upholstery_cleaning",
              "caterers",
              "charitable_and_social_service_organizations_fundraising",
              "chemicals_and_allied_products",
              "child_care_services",
              "childrens_and_infants_wear_stores",
              "chiropodists_podiatrists",
              "chiropractors",
              "cigar_stores_and_stands",
              "civic_social_fraternal_associations",
              "cleaning_and_maintenance",
              "clothing_rental",
              "colleges_universities",
              "commercial_equipment",
              "commercial_footwear",
              "commercial_photography_art_and_graphics",
              "commuter_transport_and_ferries",
              "computer_network_services",
              "computer_programming",
              "computer_repair",
              "computer_software_stores",
              "computers_peripherals_and_software",
              "concrete_work_services",
              "construction_materials",
              "consulting_public_relations",
              "correspondence_schools",
              "cosmetic_stores",
              "counseling_services",
              "country_clubs",
              "courier_services",
              "court_costs",
              "credit_reporting_agencies",
              "cruise_lines",
              "dairy_products_stores",
              "dance_hall_studios_schools",
              "dating_escort_services",
              "dentists_orthodontists",
              "department_stores",
              "detective_agencies",
              "digital_goods_applications",
              "digital_goods_games",
              "digital_goods_large_volume",
              "digital_goods_media",
              "direct_marketing_catalog_merchant",
              "direct_marketing_combination_catalog_and_retail_merchant",
              "direct_marketing_inbound_telemarketing",
              "direct_marketing_insurance_services",
              "direct_marketing_other",
              "direct_marketing_outbound_telemarketing",
              "direct_marketing_subscription",
              "direct_marketing_travel",
              "discount_stores",
              "doctors",
              "door_to_door_sales",
              "drapery_window_covering_and_upholstery_stores",
              "drinking_places",
              "drug_stores_and_pharmacies",
              "drugs_drug_proprietaries_and_druggist_sundries",
              "dry_cleaners",
              "durable_goods",
              "duty_free_stores",
              "eating_places_restaurants",
              "educational_services",
              "electric_razor_stores",
              "electric_vehicle_charging",
              "electrical_parts_and_equipment",
              "electrical_services",
              "electronics_repair_shops",
              "electronics_stores",
              "elementary_secondary_schools",
              "emergency_services_gcas_visa_use_only",
              "employment_temp_agencies",
              "equipment_rental",
              "exterminating_services",
              "family_clothing_stores",
              "fast_food_restaurants",
              "financial_institutions",
              "fines_government_administrative_entities",
              "fireplace_fireplace_screens_and_accessories_stores",
              "floor_covering_stores",
              "florists",
              "florists_supplies_nursery_stock_and_flowers",
              "freezer_and_locker_meat_provisioners",
              "fuel_dealers_non_automotive",
              "funeral_services_crematories",
              "furniture_home_furnishings_and_equipment_stores_except_appliances",
              "furniture_repair_refinishing",
              "furriers_and_fur_shops",
              "general_services",
              "gift_card_novelty_and_souvenir_shops",
              "glass_paint_and_wallpaper_stores",
              "glassware_crystal_stores",
              "golf_courses_public",
              "government_licensed_horse_dog_racing_us_region_only",
              "government_licensed_online_casions_online_gambling_us_region_only",
              "government_owned_lotteries_non_us_region",
              "government_owned_lotteries_us_region_only",
              "government_services",
              "grocery_stores_supermarkets",
              "hardware_equipment_and_supplies",
              "hardware_stores",
              "health_and_beauty_spas",
              "hearing_aids_sales_and_supplies",
              "heating_plumbing_a_c",
              "hobby_toy_and_game_shops",
              "home_supply_warehouse_stores",
              "hospitals",
              "hotels_motels_and_resorts",
              "household_appliance_stores",
              "industrial_supplies",
              "information_retrieval_services",
              "insurance_default",
              "insurance_underwriting_premiums",
              "intra_company_purchases",
              "jewelry_stores_watches_clocks_and_silverware_stores",
              "landscaping_services",
              "laundries",
              "laundry_cleaning_services",
              "legal_services_attorneys",
              "luggage_and_leather_goods_stores",
              "lumber_building_materials_stores",
              "manual_cash_disburse",
              "marinas_service_and_supplies",
              "marketplaces",
              "masonry_stonework_and_plaster",
              "massage_parlors",
              "medical_and_dental_labs",
              "medical_dental_ophthalmic_and_hospital_equipment_and_supplies",
              "medical_services",
              "membership_organizations",
              "mens_and_boys_clothing_and_accessories_stores",
              "mens_womens_clothing_stores",
              "metal_service_centers",
              "miscellaneous_apparel_and_accessory_shops",
              "miscellaneous_auto_dealers",
              "miscellaneous_business_services",
              "miscellaneous_food_stores",
              "miscellaneous_general_merchandise",
              "miscellaneous_general_services",
              "miscellaneous_home_furnishing_specialty_stores",
              "miscellaneous_publishing_and_printing",
              "miscellaneous_recreation_services",
              "miscellaneous_repair_shops",
              "miscellaneous_specialty_retail",
              "mobile_home_dealers",
              "motion_picture_theaters",
              "motor_freight_carriers_and_trucking",
              "motor_homes_dealers",
              "motor_vehicle_supplies_and_new_parts",
              "motorcycle_shops_and_dealers",
              "motorcycle_shops_dealers",
              "music_stores_musical_instruments_pianos_and_sheet_music",
              "news_dealers_and_newsstands",
              "non_fi_money_orders",
              "non_fi_stored_value_card_purchase_load",
              "nondurable_goods",
              "nurseries_lawn_and_garden_supply_stores",
              "nursing_personal_care",
              "office_and_commercial_furniture",
              "opticians_eyeglasses",
              "optometrists_ophthalmologist",
              "orthopedic_goods_prosthetic_devices",
              "osteopaths",
              "package_stores_beer_wine_and_liquor",
              "paints_varnishes_and_supplies",
              "parking_lots_garages",
              "passenger_railways",
              "pawn_shops",
              "pet_shops_pet_food_and_supplies",
              "petroleum_and_petroleum_products",
              "photo_developing",
              "photographic_photocopy_microfilm_equipment_and_supplies",
              "photographic_studios",
              "picture_video_production",
              "piece_goods_notions_and_other_dry_goods",
              "plumbing_heating_equipment_and_supplies",
              "political_organizations",
              "postal_services_government_only",
              "precious_stones_and_metals_watches_and_jewelry",
              "professional_services",
              "public_warehousing_and_storage",
              "quick_copy_repro_and_blueprint",
              "railroads",
              "real_estate_agents_and_managers_rentals",
              "record_stores",
              "recreational_vehicle_rentals",
              "religious_goods_stores",
              "religious_organizations",
              "roofing_siding_sheet_metal",
              "secretarial_support_services",
              "security_brokers_dealers",
              "service_stations",
              "sewing_needlework_fabric_and_piece_goods_stores",
              "shoe_repair_hat_cleaning",
              "shoe_stores",
              "small_appliance_repair",
              "snowmobile_dealers",
              "special_trade_services",
              "specialty_cleaning",
              "sporting_goods_stores",
              "sporting_recreation_camps",
              "sports_and_riding_apparel_stores",
              "sports_clubs_fields",
              "stamp_and_coin_stores",
              "stationary_office_supplies_printing_and_writing_paper",
              "stationery_stores_office_and_school_supply_stores",
              "swimming_pools_sales",
              "t_ui_travel_germany",
              "tailors_alterations",
              "tax_payments_government_agencies",
              "tax_preparation_services",
              "taxicabs_limousines",
              "telecommunication_equipment_and_telephone_sales",
              "telecommunication_services",
              "telegraph_services",
              "tent_and_awning_shops",
              "testing_laboratories",
              "theatrical_ticket_agencies",
              "timeshares",
              "tire_retreading_and_repair",
              "tolls_bridge_fees",
              "tourist_attractions_and_exhibits",
              "towing_services",
              "trailer_parks_campgrounds",
              "transportation_services",
              "travel_agencies_tour_operators",
              "truck_stop_iteration",
              "truck_utility_trailer_rentals",
              "typesetting_plate_making_and_related_services",
              "typewriter_stores",
              "u_s_federal_government_agencies_or_departments",
              "uniforms_commercial_clothing",
              "used_merchandise_and_secondhand_stores",
              "utilities",
              "variety_stores",
              "veterinary_services",
              "video_amusement_game_supplies",
              "video_game_arcades",
              "video_tape_rental_stores",
              "vocational_trade_schools",
              "watch_jewelry_repair",
              "welding_repair",
              "wholesale_clubs",
              "wig_and_toupee_stores",
              "wires_money_orders",
              "womens_accessory_and_specialty_shops",
              "womens_ready_to_wear_stores",
              "wrecking_and_salvage_yards",
            ])
            .optional(),
          city: z.string().max(5000).optional(),
          country: z.string().max(5000).optional(),
          name: z.string().max(5000).optional(),
          network_id: z.string().max(5000).optional(),
          postal_code: z.string().max(5000).optional(),
          state: z.string().max(5000).optional(),
          terminal_id: z.string().max(5000).optional(),
          url: z.string().max(5000).optional(),
        })
        .optional(),
      purchase_details: z
        .object({
          fleet: z
            .object({
              cardholder_prompt_data: z
                .object({
                  driver_id: z.string().max(5000).optional(),
                  odometer: z.coerce.number().optional(),
                  unspecified_id: z.string().max(5000).optional(),
                  user_id: z.string().max(5000).optional(),
                  vehicle_number: z.string().max(5000).optional(),
                })
                .optional(),
              purchase_type: z
                .enum([
                  "fuel_and_non_fuel_purchase",
                  "fuel_purchase",
                  "non_fuel_purchase",
                ])
                .optional(),
              reported_breakdown: z
                .object({
                  fuel: z
                    .object({ gross_amount_decimal: z.string().optional() })
                    .optional(),
                  non_fuel: z
                    .object({ gross_amount_decimal: z.string().optional() })
                    .optional(),
                  tax: z
                    .object({
                      local_amount_decimal: z.string().optional(),
                      national_amount_decimal: z.string().optional(),
                    })
                    .optional(),
                })
                .optional(),
              service_type: z
                .enum(["full_service", "non_fuel_transaction", "self_service"])
                .optional(),
            })
            .optional(),
          flight: z
            .object({
              departure_at: z.coerce.number().optional(),
              passenger_name: z.string().max(5000).optional(),
              refundable: PermissiveBoolean.optional(),
              segments: z
                .array(
                  z.object({
                    arrival_airport_code: z.string().max(3).optional(),
                    carrier: z.string().max(5000).optional(),
                    departure_airport_code: z.string().max(3).optional(),
                    flight_number: z.string().max(5000).optional(),
                    service_class: z.string().max(5000).optional(),
                    stopover_allowed: PermissiveBoolean.optional(),
                  }),
                )
                .optional(),
              travel_agency: z.string().max(5000).optional(),
            })
            .optional(),
          fuel: z
            .object({
              industry_product_code: z.string().max(5000).optional(),
              quantity_decimal: z.string().optional(),
              type: z
                .enum([
                  "diesel",
                  "other",
                  "unleaded_plus",
                  "unleaded_regular",
                  "unleaded_super",
                ])
                .optional(),
              unit: z
                .enum([
                  "charging_minute",
                  "imperial_gallon",
                  "kilogram",
                  "kilowatt_hour",
                  "liter",
                  "other",
                  "pound",
                  "us_gallon",
                ])
                .optional(),
              unit_cost_decimal: z.string().optional(),
            })
            .optional(),
          lodging: z
            .object({
              check_in_at: z.coerce.number().optional(),
              nights: z.coerce.number().optional(),
            })
            .optional(),
          receipt: z
            .array(
              z.object({
                description: z.string().max(26).optional(),
                quantity: z.string().optional(),
                total: z.coerce.number().optional(),
                unit_cost: z.coerce.number().optional(),
              }),
            )
            .optional(),
          reference: z.string().max(5000).optional(),
        })
        .optional(),
    })

  router.post(
    "postTestHelpersIssuingTransactionsCreateUnlinkedRefund",
    "/v1/test_helpers/issuing/transactions/create_unlinked_refund",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingTransactionsCreateUnlinkedRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingTransactionsCreateUnlinkedRefund(
          input,
          postTestHelpersIssuingTransactionsCreateUnlinkedRefund.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersIssuingTransactionsCreateUnlinkedRefund.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersIssuingTransactionsTransactionRefundParamSchema =
    z.object({ transaction: z.string().max(5000) })

  const postTestHelpersIssuingTransactionsTransactionRefundBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      refund_amount: z.coerce.number().optional(),
    })
    .optional()

  router.post(
    "postTestHelpersIssuingTransactionsTransactionRefund",
    "/v1/test_helpers/issuing/transactions/:transaction/refund",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersIssuingTransactionsTransactionRefundParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersIssuingTransactionsTransactionRefundBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersIssuingTransactionsTransactionRefund(
          input,
          postTestHelpersIssuingTransactionsTransactionRefund.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersIssuingTransactionsTransactionRefund.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersRefundsRefundExpireParamSchema = z.object({
    refund: z.string(),
  })

  const postTestHelpersRefundsRefundExpireBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersRefundsRefundExpire",
    "/v1/test_helpers/refunds/:refund/expire",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersRefundsRefundExpireParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersRefundsRefundExpireBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersRefundsRefundExpire(
          input,
          postTestHelpersRefundsRefundExpire.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersRefundsRefundExpire.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema =
    z.object({ reader: z.string().max(5000) })

  const postTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema = z
    .object({
      amount_tip: z.coerce.number().optional(),
      card_present: z
        .object({ number: z.string().max(5000).optional() })
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      interac_present: z
        .object({ number: z.string().max(5000).optional() })
        .optional(),
      type: z.enum(["card_present", "interac_present"]).optional(),
    })
    .optional()

  router.post(
    "postTestHelpersTerminalReadersReaderPresentPaymentMethod",
    "/v1/test_helpers/terminal/readers/:reader/present_payment_method",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTerminalReadersReaderPresentPaymentMethodParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTerminalReadersReaderPresentPaymentMethodBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTerminalReadersReaderPresentPaymentMethod(
          input,
          postTestHelpersTerminalReadersReaderPresentPaymentMethod.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTerminalReadersReaderPresentPaymentMethod.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getTestHelpersTestClocksQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getTestHelpersTestClocksBodySchema = z.object({}).optional()

  router.get(
    "getTestHelpersTestClocks",
    "/v1/test_helpers/test_clocks",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTestHelpersTestClocksQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTestHelpersTestClocksBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTestHelpersTestClocks(
          input,
          getTestHelpersTestClocks.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTestHelpersTestClocks.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTestClocksBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    frozen_time: z.coerce.number(),
    name: z.string().max(300).optional(),
  })

  router.post(
    "postTestHelpersTestClocks",
    "/v1/test_helpers/test_clocks",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTestClocksBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTestClocks(
          input,
          postTestHelpersTestClocks.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTestClocks.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteTestHelpersTestClocksTestClockParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  const deleteTestHelpersTestClocksTestClockBodySchema = z.object({}).optional()

  router.delete(
    "deleteTestHelpersTestClocksTestClock",
    "/v1/test_helpers/test_clocks/:test_clock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteTestHelpersTestClocksTestClockParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteTestHelpersTestClocksTestClockBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteTestHelpersTestClocksTestClock(
          input,
          deleteTestHelpersTestClocksTestClock.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteTestHelpersTestClocksTestClock.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTestHelpersTestClocksTestClockParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  const getTestHelpersTestClocksTestClockQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTestHelpersTestClocksTestClockBodySchema = z.object({}).optional()

  router.get(
    "getTestHelpersTestClocksTestClock",
    "/v1/test_helpers/test_clocks/:test_clock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTestHelpersTestClocksTestClockParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTestHelpersTestClocksTestClockQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTestHelpersTestClocksTestClockBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTestHelpersTestClocksTestClock(
          input,
          getTestHelpersTestClocksTestClock.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTestHelpersTestClocksTestClock.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTestClocksTestClockAdvanceParamSchema = z.object({
    test_clock: z.string().max(5000),
  })

  const postTestHelpersTestClocksTestClockAdvanceBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    frozen_time: z.coerce.number(),
  })

  router.post(
    "postTestHelpersTestClocksTestClockAdvance",
    "/v1/test_helpers/test_clocks/:test_clock/advance",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTestClocksTestClockAdvanceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTestClocksTestClockAdvanceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTestClocksTestClockAdvance(
          input,
          postTestHelpersTestClocksTestClockAdvance.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTestClocksTestClockAdvance.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdFailParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTestHelpersTreasuryInboundTransfersIdFailBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      failure_details: z
        .object({
          code: z
            .enum([
              "account_closed",
              "account_frozen",
              "bank_account_restricted",
              "bank_ownership_changed",
              "debit_not_authorized",
              "incorrect_account_holder_address",
              "incorrect_account_holder_name",
              "incorrect_account_holder_tax_id",
              "insufficient_funds",
              "invalid_account_number",
              "invalid_currency",
              "no_account",
              "other",
            ])
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postTestHelpersTreasuryInboundTransfersIdFail",
    "/v1/test_helpers/treasury/inbound_transfers/:id/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryInboundTransfersIdFail(
          input,
          postTestHelpersTreasuryInboundTransfersIdFail.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryInboundTransfersIdFail.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdReturnParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTestHelpersTreasuryInboundTransfersIdReturnBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersTreasuryInboundTransfersIdReturn",
    "/v1/test_helpers/treasury/inbound_transfers/:id/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryInboundTransfersIdReturn(
          input,
          postTestHelpersTreasuryInboundTransfersIdReturn.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryInboundTransfersIdReturn.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryInboundTransfersIdSucceedParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTestHelpersTreasuryInboundTransfersIdSucceedBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersTreasuryInboundTransfersIdSucceed",
    "/v1/test_helpers/treasury/inbound_transfers/:id/succeed",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdSucceedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryInboundTransfersIdSucceedBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryInboundTransfersIdSucceed(
          input,
          postTestHelpersTreasuryInboundTransfersIdSucceed.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryInboundTransfersIdSucceed.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTestHelpersTreasuryOutboundPaymentsIdBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    tracking_details: z.object({
      ach: z.object({ trace_id: z.string().max(5000) }).optional(),
      type: z.enum(["ach", "us_domestic_wire"]),
      us_domestic_wire: z
        .object({
          chips: z.string().max(5000).optional(),
          imad: z.string().max(5000).optional(),
          omad: z.string().max(5000).optional(),
        })
        .optional(),
    }),
  })

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsId",
    "/v1/test_helpers/treasury/outbound_payments/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsId(
          input,
          postTestHelpersTreasuryOutboundPaymentsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryOutboundPaymentsId.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdFailParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTestHelpersTreasuryOutboundPaymentsIdFailBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsIdFail",
    "/v1/test_helpers/treasury/outbound_payments/:id/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsIdFail(
          input,
          postTestHelpersTreasuryOutboundPaymentsIdFail.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryOutboundPaymentsIdFail.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdPostParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTestHelpersTreasuryOutboundPaymentsIdPostBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsIdPost",
    "/v1/test_helpers/treasury/outbound_payments/:id/post",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsIdPost(
          input,
          postTestHelpersTreasuryOutboundPaymentsIdPost.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryOutboundPaymentsIdPost.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      returned_details: z
        .object({
          code: z
            .enum([
              "account_closed",
              "account_frozen",
              "bank_account_restricted",
              "bank_ownership_changed",
              "declined",
              "incorrect_account_holder_name",
              "invalid_account_number",
              "invalid_currency",
              "no_account",
              "other",
            ])
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postTestHelpersTreasuryOutboundPaymentsIdReturn",
    "/v1/test_helpers/treasury/outbound_payments/:id/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundPaymentsIdReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundPaymentsIdReturn(
          input,
          postTestHelpersTreasuryOutboundPaymentsIdReturn.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryOutboundPaymentsIdReturn.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema =
    z.object({ outbound_transfer: z.string().max(5000) })

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema =
    z.object({
      expand: z.array(z.string().max(5000)).optional(),
      tracking_details: z.object({
        ach: z.object({ trace_id: z.string().max(5000) }).optional(),
        type: z.enum(["ach", "us_domestic_wire"]),
        us_domestic_wire: z
          .object({
            chips: z.string().max(5000).optional(),
            imad: z.string().max(5000).optional(),
            omad: z.string().max(5000).optional(),
          })
          .optional(),
      }),
    })

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransfer",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransfer(
          input,
          postTestHelpersTreasuryOutboundTransfersOutboundTransfer.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransfer.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema =
    z.object({ outbound_transfer: z.string().max(5000) })

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema =
    z.object({ expand: z.array(z.string().max(5000)).optional() }).optional()

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransferFail",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/fail",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferFailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferFailBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransferFail(
          input,
          postTestHelpersTreasuryOutboundTransfersOutboundTransferFail.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransferFail.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema =
    z.object({ outbound_transfer: z.string().max(5000) })

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema =
    z.object({ expand: z.array(z.string().max(5000)).optional() }).optional()

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransferPost",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/post",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransferPost(
          input,
          postTestHelpersTreasuryOutboundTransfersOutboundTransferPost.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransferPost.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema =
    z.object({ outbound_transfer: z.string().max(5000) })

  const postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema =
    z
      .object({
        expand: z.array(z.string().max(5000)).optional(),
        returned_details: z
          .object({
            code: z
              .enum([
                "account_closed",
                "account_frozen",
                "bank_account_restricted",
                "bank_ownership_changed",
                "declined",
                "incorrect_account_holder_name",
                "invalid_account_number",
                "invalid_currency",
                "no_account",
                "other",
              ])
              .optional(),
          })
          .optional(),
      })
      .optional()

  router.post(
    "postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn",
    "/v1/test_helpers/treasury/outbound_transfers/:outbound_transfer/return",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryOutboundTransfersOutboundTransferReturnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn(
          input,
          postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryReceivedCreditsBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    description: z.string().max(5000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    financial_account: z.string(),
    initiating_payment_method_details: z
      .object({
        type: z.enum(["us_bank_account"]),
        us_bank_account: z
          .object({
            account_holder_name: z.string().max(5000).optional(),
            account_number: z.string().max(5000).optional(),
            routing_number: z.string().max(5000).optional(),
          })
          .optional(),
      })
      .optional(),
    network: z.enum(["ach", "us_domestic_wire"]),
  })

  router.post(
    "postTestHelpersTreasuryReceivedCredits",
    "/v1/test_helpers/treasury/received_credits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryReceivedCreditsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryReceivedCredits(
          input,
          postTestHelpersTreasuryReceivedCredits.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryReceivedCredits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTestHelpersTreasuryReceivedDebitsBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    description: z.string().max(5000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    financial_account: z.string(),
    initiating_payment_method_details: z
      .object({
        type: z.enum(["us_bank_account"]),
        us_bank_account: z
          .object({
            account_holder_name: z.string().max(5000).optional(),
            account_number: z.string().max(5000).optional(),
            routing_number: z.string().max(5000).optional(),
          })
          .optional(),
      })
      .optional(),
    network: z.enum(["ach"]),
  })

  router.post(
    "postTestHelpersTreasuryReceivedDebits",
    "/v1/test_helpers/treasury/received_debits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTestHelpersTreasuryReceivedDebitsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTestHelpersTreasuryReceivedDebits(
          input,
          postTestHelpersTreasuryReceivedDebits.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTestHelpersTreasuryReceivedDebits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTokensBodySchema = z
    .object({
      account: z
        .object({
          business_type: z
            .enum(["company", "government_entity", "individual", "non_profit"])
            .optional(),
          company: z
            .object({
              address: z
                .object({
                  city: z.string().max(100).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(200).optional(),
                  line2: z.string().max(200).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                })
                .optional(),
              address_kana: z
                .object({
                  city: z.string().max(5000).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(5000).optional(),
                  line2: z.string().max(5000).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                  town: z.string().max(5000).optional(),
                })
                .optional(),
              address_kanji: z
                .object({
                  city: z.string().max(5000).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(5000).optional(),
                  line2: z.string().max(5000).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                  town: z.string().max(5000).optional(),
                })
                .optional(),
              directors_provided: PermissiveBoolean.optional(),
              directorship_declaration: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z.string().max(5000).optional(),
                })
                .optional(),
              executives_provided: PermissiveBoolean.optional(),
              export_license_id: z.string().max(5000).optional(),
              export_purpose_code: z.string().max(5000).optional(),
              name: z.string().max(100).optional(),
              name_kana: z.string().max(100).optional(),
              name_kanji: z.string().max(100).optional(),
              owners_provided: PermissiveBoolean.optional(),
              ownership_declaration: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z.string().max(5000).optional(),
                })
                .optional(),
              ownership_declaration_shown_and_signed:
                PermissiveBoolean.optional(),
              ownership_exemption_reason: z
                .enum([
                  "",
                  "qualified_entity_exceeds_ownership_threshold",
                  "qualifies_as_financial_institution",
                ])
                .optional(),
              phone: z.string().max(5000).optional(),
              registration_number: z.string().max(5000).optional(),
              structure: z
                .enum([
                  "",
                  "free_zone_establishment",
                  "free_zone_llc",
                  "government_instrumentality",
                  "governmental_unit",
                  "incorporated_non_profit",
                  "incorporated_partnership",
                  "limited_liability_partnership",
                  "llc",
                  "multi_member_llc",
                  "private_company",
                  "private_corporation",
                  "private_partnership",
                  "public_company",
                  "public_corporation",
                  "public_partnership",
                  "registered_charity",
                  "single_member_llc",
                  "sole_establishment",
                  "sole_proprietorship",
                  "tax_exempt_government_instrumentality",
                  "unincorporated_association",
                  "unincorporated_non_profit",
                  "unincorporated_partnership",
                ])
                .optional(),
              tax_id: z.string().max(5000).optional(),
              tax_id_registrar: z.string().max(5000).optional(),
              vat_id: z.string().max(5000).optional(),
              verification: z
                .object({
                  document: z
                    .object({
                      back: z.string().max(500).optional(),
                      front: z.string().max(500).optional(),
                    })
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          individual: z
            .object({
              address: z
                .object({
                  city: z.string().max(100).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(200).optional(),
                  line2: z.string().max(200).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                })
                .optional(),
              address_kana: z
                .object({
                  city: z.string().max(5000).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(5000).optional(),
                  line2: z.string().max(5000).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                  town: z.string().max(5000).optional(),
                })
                .optional(),
              address_kanji: z
                .object({
                  city: z.string().max(5000).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(5000).optional(),
                  line2: z.string().max(5000).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                  town: z.string().max(5000).optional(),
                })
                .optional(),
              dob: z
                .union([
                  z.object({
                    day: z.coerce.number(),
                    month: z.coerce.number(),
                    year: z.coerce.number(),
                  }),
                  z.enum([""]),
                ])
                .optional(),
              email: z.string().optional(),
              first_name: z.string().max(100).optional(),
              first_name_kana: z.string().max(5000).optional(),
              first_name_kanji: z.string().max(5000).optional(),
              full_name_aliases: z
                .union([z.array(z.string().max(300)), z.enum([""])])
                .optional(),
              gender: z.string().optional(),
              id_number: z.string().max(5000).optional(),
              id_number_secondary: z.string().max(5000).optional(),
              last_name: z.string().max(100).optional(),
              last_name_kana: z.string().max(5000).optional(),
              last_name_kanji: z.string().max(5000).optional(),
              maiden_name: z.string().max(5000).optional(),
              metadata: z
                .union([z.record(z.string()), z.enum([""])])
                .optional(),
              phone: z.string().optional(),
              political_exposure: z.enum(["existing", "none"]).optional(),
              registered_address: z
                .object({
                  city: z.string().max(100).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(200).optional(),
                  line2: z.string().max(200).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                })
                .optional(),
              relationship: z
                .object({
                  director: PermissiveBoolean.optional(),
                  executive: PermissiveBoolean.optional(),
                  owner: PermissiveBoolean.optional(),
                  percent_ownership: z
                    .union([z.coerce.number(), z.enum([""])])
                    .optional(),
                  title: z.string().max(5000).optional(),
                })
                .optional(),
              ssn_last_4: z.string().max(5000).optional(),
              verification: z
                .object({
                  additional_document: z
                    .object({
                      back: z.string().max(500).optional(),
                      front: z.string().max(500).optional(),
                    })
                    .optional(),
                  document: z
                    .object({
                      back: z.string().max(500).optional(),
                      front: z.string().max(500).optional(),
                    })
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          tos_shown_and_accepted: PermissiveBoolean.optional(),
        })
        .optional(),
      bank_account: z
        .object({
          account_holder_name: z.string().max(5000).optional(),
          account_holder_type: z.enum(["company", "individual"]).optional(),
          account_number: z.string().max(5000),
          account_type: z
            .enum(["checking", "futsu", "savings", "toza"])
            .optional(),
          country: z.string().max(5000),
          currency: z.string().optional(),
          payment_method: z.string().max(5000).optional(),
          routing_number: z.string().max(5000).optional(),
        })
        .optional(),
      card: z
        .union([
          z.object({
            address_city: z.string().max(5000).optional(),
            address_country: z.string().max(5000).optional(),
            address_line1: z.string().max(5000).optional(),
            address_line2: z.string().max(5000).optional(),
            address_state: z.string().max(5000).optional(),
            address_zip: z.string().max(5000).optional(),
            currency: z.string().max(5000).optional(),
            cvc: z.string().max(5000).optional(),
            exp_month: z.string().max(5000),
            exp_year: z.string().max(5000),
            name: z.string().max(5000).optional(),
            networks: z
              .object({
                preferred: z
                  .enum(["cartes_bancaires", "mastercard", "visa"])
                  .optional(),
              })
              .optional(),
            number: z.string().max(5000),
          }),
          z.string().max(5000),
        ])
        .optional(),
      customer: z.string().max(5000).optional(),
      cvc_update: z.object({ cvc: z.string().max(5000) }).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      person: z
        .object({
          additional_tos_acceptances: z
            .object({
              account: z
                .object({
                  date: z.coerce.number().optional(),
                  ip: z.string().optional(),
                  user_agent: z
                    .union([z.string().max(5000), z.enum([""])])
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          address_kana: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          address_kanji: z
            .object({
              city: z.string().max(5000).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(5000).optional(),
              line2: z.string().max(5000).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
              town: z.string().max(5000).optional(),
            })
            .optional(),
          dob: z
            .union([
              z.object({
                day: z.coerce.number(),
                month: z.coerce.number(),
                year: z.coerce.number(),
              }),
              z.enum([""]),
            ])
            .optional(),
          documents: z
            .object({
              company_authorization: z
                .object({
                  files: z
                    .array(z.union([z.string().max(500), z.enum([""])]))
                    .optional(),
                })
                .optional(),
              passport: z
                .object({
                  files: z
                    .array(z.union([z.string().max(500), z.enum([""])]))
                    .optional(),
                })
                .optional(),
              visa: z
                .object({
                  files: z
                    .array(z.union([z.string().max(500), z.enum([""])]))
                    .optional(),
                })
                .optional(),
            })
            .optional(),
          email: z.string().optional(),
          first_name: z.string().max(5000).optional(),
          first_name_kana: z.string().max(5000).optional(),
          first_name_kanji: z.string().max(5000).optional(),
          full_name_aliases: z
            .union([z.array(z.string().max(5000)), z.enum([""])])
            .optional(),
          gender: z.string().optional(),
          id_number: z.string().max(5000).optional(),
          id_number_secondary: z.string().max(5000).optional(),
          last_name: z.string().max(5000).optional(),
          last_name_kana: z.string().max(5000).optional(),
          last_name_kanji: z.string().max(5000).optional(),
          maiden_name: z.string().max(5000).optional(),
          metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
          nationality: z.string().max(5000).optional(),
          phone: z.string().optional(),
          political_exposure: z.enum(["existing", "none"]).optional(),
          registered_address: z
            .object({
              city: z.string().max(100).optional(),
              country: z.string().max(5000).optional(),
              line1: z.string().max(200).optional(),
              line2: z.string().max(200).optional(),
              postal_code: z.string().max(5000).optional(),
              state: z.string().max(5000).optional(),
            })
            .optional(),
          relationship: z
            .object({
              authorizer: PermissiveBoolean.optional(),
              director: PermissiveBoolean.optional(),
              executive: PermissiveBoolean.optional(),
              legal_guardian: PermissiveBoolean.optional(),
              owner: PermissiveBoolean.optional(),
              percent_ownership: z
                .union([z.coerce.number(), z.enum([""])])
                .optional(),
              representative: PermissiveBoolean.optional(),
              title: z.string().max(5000).optional(),
            })
            .optional(),
          ssn_last_4: z.string().optional(),
          verification: z
            .object({
              additional_document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
              document: z
                .object({
                  back: z.string().max(500).optional(),
                  front: z.string().max(500).optional(),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      pii: z.object({ id_number: z.string().max(5000).optional() }).optional(),
    })
    .optional()

  router.post("postTokens", "/v1/tokens", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTokensBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postTokens(input, postTokens.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTokens.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTokensTokenParamSchema = z.object({ token: z.string().max(5000) })

  const getTokensTokenQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTokensTokenBodySchema = z.object({}).optional()

  router.get("getTokensToken", "/v1/tokens/:token", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTokensTokenParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTokensTokenQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTokensTokenBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTokensToken(input, getTokensToken.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTokensToken.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTopupsQuerySchema = z.object({
    amount: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "failed", "pending", "succeeded"]).optional(),
  })

  const getTopupsBodySchema = z.object({}).optional()

  router.get("getTopups", "/v1/topups", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTopupsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTopupsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTopups(input, getTopups.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTopups.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTopupsBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    description: z.string().max(5000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    source: z.string().max(5000).optional(),
    statement_descriptor: z.string().max(15).optional(),
    transfer_group: z.string().optional(),
  })

  router.post("postTopups", "/v1/topups", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTopupsBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postTopups(input, postTopups.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTopups.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTopupsTopupParamSchema = z.object({ topup: z.string().max(5000) })

  const getTopupsTopupQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTopupsTopupBodySchema = z.object({}).optional()

  router.get("getTopupsTopup", "/v1/topups/:topup", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getTopupsTopupParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        getTopupsTopupQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTopupsTopupBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTopupsTopup(input, getTopupsTopup.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTopupsTopup.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTopupsTopupParamSchema = z.object({ topup: z.string().max(5000) })

  const postTopupsTopupBodySchema = z
    .object({
      description: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post("postTopupsTopup", "/v1/topups/:topup", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        postTopupsTopupParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        postTopupsTopupBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postTopupsTopup(input, postTopupsTopup.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTopupsTopup.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTopupsTopupCancelParamSchema = z.object({
    topup: z.string().max(5000),
  })

  const postTopupsTopupCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTopupsTopupCancel",
    "/v1/topups/:topup/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTopupsTopupCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTopupsTopupCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTopupsTopupCancel(input, postTopupsTopupCancel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTopupsTopupCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTransfersQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    destination: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    transfer_group: z.string().max(5000).optional(),
  })

  const getTransfersBodySchema = z.object({}).optional()

  router.get("getTransfers", "/v1/transfers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTransfersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: parseRequestInput(
        getTransfersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .getTransfers(input, getTransfers.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTransfers.validator(status, body)
    ctx.status = status
    return next()
  })

  const postTransfersBodySchema = z.object({
    amount: z.coerce.number().optional(),
    currency: z.string(),
    description: z.string().max(5000).optional(),
    destination: z.string(),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    source_transaction: z.string().optional(),
    source_type: z.enum(["bank_account", "card", "fpx"]).optional(),
    transfer_group: z.string().optional(),
  })

  router.post("postTransfers", "/v1/transfers", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        postTransfersBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .postTransfers(input, postTransfers.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = postTransfers.validator(status, body)
    ctx.status = status
    return next()
  })

  const getTransfersIdReversalsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTransfersIdReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getTransfersIdReversalsBodySchema = z.object({}).optional()

  router.get(
    "getTransfersIdReversals",
    "/v1/transfers/:id/reversals",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTransfersIdReversalsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTransfersIdReversalsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTransfersIdReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTransfersIdReversals(input, getTransfersIdReversals.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTransfersIdReversals.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTransfersIdReversalsParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTransfersIdReversalsBodySchema = z
    .object({
      amount: z.coerce.number().optional(),
      description: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      refund_application_fee: PermissiveBoolean.optional(),
    })
    .optional()

  router.post(
    "postTransfersIdReversals",
    "/v1/transfers/:id/reversals",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTransfersIdReversalsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTransfersIdReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTransfersIdReversals(
          input,
          postTransfersIdReversals.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTransfersIdReversals.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTransfersTransferParamSchema = z.object({
    transfer: z.string().max(5000),
  })

  const getTransfersTransferQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTransfersTransferBodySchema = z.object({}).optional()

  router.get(
    "getTransfersTransfer",
    "/v1/transfers/:transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTransfersTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTransfersTransferQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTransfersTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTransfersTransfer(input, getTransfersTransfer.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTransfersTransfer.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTransfersTransferParamSchema = z.object({
    transfer: z.string().max(5000),
  })

  const postTransfersTransferBodySchema = z
    .object({
      description: z.string().max(5000).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postTransfersTransfer",
    "/v1/transfers/:transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTransfersTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTransfersTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTransfersTransfer(input, postTransfersTransfer.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTransfersTransfer.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTransfersTransferReversalsIdParamSchema = z.object({
    id: z.string().max(5000),
    transfer: z.string().max(5000),
  })

  const getTransfersTransferReversalsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTransfersTransferReversalsIdBodySchema = z.object({}).optional()

  router.get(
    "getTransfersTransferReversalsId",
    "/v1/transfers/:transfer/reversals/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTransfersTransferReversalsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTransfersTransferReversalsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTransfersTransferReversalsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTransfersTransferReversalsId(
          input,
          getTransfersTransferReversalsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTransfersTransferReversalsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTransfersTransferReversalsIdParamSchema = z.object({
    id: z.string().max(5000),
    transfer: z.string().max(5000),
  })

  const postTransfersTransferReversalsIdBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    })
    .optional()

  router.post(
    "postTransfersTransferReversalsId",
    "/v1/transfers/:transfer/reversals/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTransfersTransferReversalsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTransfersTransferReversalsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTransfersTransferReversalsId(
          input,
          postTransfersTransferReversalsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTransfersTransferReversalsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryCreditReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    received_credit: z.string().max(5000).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "posted", "processing"]).optional(),
  })

  const getTreasuryCreditReversalsBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryCreditReversals",
    "/v1/treasury/credit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryCreditReversalsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryCreditReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryCreditReversals(
          input,
          getTreasuryCreditReversals.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryCreditReversals.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryCreditReversalsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    received_credit: z.string().max(5000),
  })

  router.post(
    "postTreasuryCreditReversals",
    "/v1/treasury/credit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryCreditReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryCreditReversals(
          input,
          postTreasuryCreditReversals.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryCreditReversals.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryCreditReversalsCreditReversalParamSchema = z.object({
    credit_reversal: z.string().max(5000),
  })

  const getTreasuryCreditReversalsCreditReversalQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryCreditReversalsCreditReversalBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTreasuryCreditReversalsCreditReversal",
    "/v1/treasury/credit_reversals/:credit_reversal",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryCreditReversalsCreditReversalParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryCreditReversalsCreditReversalQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryCreditReversalsCreditReversalBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryCreditReversalsCreditReversal(
          input,
          getTreasuryCreditReversalsCreditReversal.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryCreditReversalsCreditReversal.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryDebitReversalsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    received_debit: z.string().max(5000).optional(),
    resolution: z.enum(["lost", "won"]).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["canceled", "completed", "processing"]).optional(),
  })

  const getTreasuryDebitReversalsBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryDebitReversals",
    "/v1/treasury/debit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryDebitReversalsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryDebitReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryDebitReversals(
          input,
          getTreasuryDebitReversals.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryDebitReversals.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryDebitReversalsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.record(z.string()).optional(),
    received_debit: z.string().max(5000),
  })

  router.post(
    "postTreasuryDebitReversals",
    "/v1/treasury/debit_reversals",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryDebitReversalsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryDebitReversals(
          input,
          postTreasuryDebitReversals.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryDebitReversals.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryDebitReversalsDebitReversalParamSchema = z.object({
    debit_reversal: z.string().max(5000),
  })

  const getTreasuryDebitReversalsDebitReversalQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryDebitReversalsDebitReversalBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTreasuryDebitReversalsDebitReversal",
    "/v1/treasury/debit_reversals/:debit_reversal",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryDebitReversalsDebitReversalParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryDebitReversalsDebitReversalQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryDebitReversalsDebitReversalBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryDebitReversalsDebitReversal(
          input,
          getTreasuryDebitReversalsDebitReversal.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryDebitReversalsDebitReversal.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryFinancialAccountsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getTreasuryFinancialAccountsBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryFinancialAccounts",
    "/v1/treasury/financial_accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryFinancialAccountsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryFinancialAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryFinancialAccounts(
          input,
          getTreasuryFinancialAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryFinancialAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryFinancialAccountsBodySchema = z.object({
    expand: z.array(z.string().max(5000)).optional(),
    features: z
      .object({
        card_issuing: z.object({ requested: PermissiveBoolean }).optional(),
        deposit_insurance: z
          .object({ requested: PermissiveBoolean })
          .optional(),
        financial_addresses: z
          .object({
            aba: z.object({ requested: PermissiveBoolean }).optional(),
          })
          .optional(),
        inbound_transfers: z
          .object({
            ach: z.object({ requested: PermissiveBoolean }).optional(),
          })
          .optional(),
        intra_stripe_flows: z
          .object({ requested: PermissiveBoolean })
          .optional(),
        outbound_payments: z
          .object({
            ach: z.object({ requested: PermissiveBoolean }).optional(),
            us_domestic_wire: z
              .object({ requested: PermissiveBoolean })
              .optional(),
          })
          .optional(),
        outbound_transfers: z
          .object({
            ach: z.object({ requested: PermissiveBoolean }).optional(),
            us_domestic_wire: z
              .object({ requested: PermissiveBoolean })
              .optional(),
          })
          .optional(),
      })
      .optional(),
    metadata: z.record(z.string()).optional(),
    nickname: z.union([z.string().max(5000), z.enum([""])]).optional(),
    platform_restrictions: z
      .object({
        inbound_flows: z.enum(["restricted", "unrestricted"]).optional(),
        outbound_flows: z.enum(["restricted", "unrestricted"]).optional(),
      })
      .optional(),
    supported_currencies: z.array(z.string().max(5000)),
  })

  router.post(
    "postTreasuryFinancialAccounts",
    "/v1/treasury/financial_accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryFinancialAccounts(
          input,
          postTreasuryFinancialAccounts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryFinancialAccounts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryFinancialAccountsFinancialAccountParamSchema = z.object({
    financial_account: z.string().max(5000),
  })

  const getTreasuryFinancialAccountsFinancialAccountQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryFinancialAccountsFinancialAccountBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTreasuryFinancialAccountsFinancialAccount",
    "/v1/treasury/financial_accounts/:financial_account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryFinancialAccountsFinancialAccount(
          input,
          getTreasuryFinancialAccountsFinancialAccount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryFinancialAccountsFinancialAccount.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountParamSchema = z.object({
    financial_account: z.string().max(5000),
  })

  const postTreasuryFinancialAccountsFinancialAccountBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      features: z
        .object({
          card_issuing: z.object({ requested: PermissiveBoolean }).optional(),
          deposit_insurance: z
            .object({ requested: PermissiveBoolean })
            .optional(),
          financial_addresses: z
            .object({
              aba: z.object({ requested: PermissiveBoolean }).optional(),
            })
            .optional(),
          inbound_transfers: z
            .object({
              ach: z.object({ requested: PermissiveBoolean }).optional(),
            })
            .optional(),
          intra_stripe_flows: z
            .object({ requested: PermissiveBoolean })
            .optional(),
          outbound_payments: z
            .object({
              ach: z.object({ requested: PermissiveBoolean }).optional(),
              us_domestic_wire: z
                .object({ requested: PermissiveBoolean })
                .optional(),
            })
            .optional(),
          outbound_transfers: z
            .object({
              ach: z.object({ requested: PermissiveBoolean }).optional(),
              us_domestic_wire: z
                .object({ requested: PermissiveBoolean })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      forwarding_settings: z
        .object({
          financial_account: z.string().optional(),
          payment_method: z.string().max(5000).optional(),
          type: z.enum(["financial_account", "payment_method"]),
        })
        .optional(),
      metadata: z.record(z.string()).optional(),
      nickname: z.union([z.string().max(5000), z.enum([""])]).optional(),
      platform_restrictions: z
        .object({
          inbound_flows: z.enum(["restricted", "unrestricted"]).optional(),
          outbound_flows: z.enum(["restricted", "unrestricted"]).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postTreasuryFinancialAccountsFinancialAccount",
    "/v1/treasury/financial_accounts/:financial_account",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryFinancialAccountsFinancialAccount(
          input,
          postTreasuryFinancialAccountsFinancialAccount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryFinancialAccountsFinancialAccount.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountCloseParamSchema =
    z.object({ financial_account: z.string().max(5000) })

  const postTreasuryFinancialAccountsFinancialAccountCloseBodySchema = z
    .object({
      expand: z.array(z.string().max(5000)).optional(),
      forwarding_settings: z
        .object({
          financial_account: z.string().optional(),
          payment_method: z.string().max(5000).optional(),
          type: z.enum(["financial_account", "payment_method"]),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postTreasuryFinancialAccountsFinancialAccountClose",
    "/v1/treasury/financial_accounts/:financial_account/close",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountCloseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountCloseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryFinancialAccountsFinancialAccountClose(
          input,
          postTreasuryFinancialAccountsFinancialAccountClose.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryFinancialAccountsFinancialAccountClose.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema =
    z.object({ financial_account: z.string().max(5000) })

  const getTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema =
    z.object({
      expand: z
        .preprocess(
          (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
          z.array(z.string().max(5000)),
        )
        .optional(),
    })

  const getTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTreasuryFinancialAccountsFinancialAccountFeatures",
    "/v1/treasury/financial_accounts/:financial_account/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountFeaturesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryFinancialAccountsFinancialAccountFeatures(
          input,
          getTreasuryFinancialAccountsFinancialAccountFeatures.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryFinancialAccountsFinancialAccountFeatures.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema =
    z.object({ financial_account: z.string().max(5000) })

  const postTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema = z
    .object({
      card_issuing: z.object({ requested: PermissiveBoolean }).optional(),
      deposit_insurance: z.object({ requested: PermissiveBoolean }).optional(),
      expand: z.array(z.string().max(5000)).optional(),
      financial_addresses: z
        .object({ aba: z.object({ requested: PermissiveBoolean }).optional() })
        .optional(),
      inbound_transfers: z
        .object({ ach: z.object({ requested: PermissiveBoolean }).optional() })
        .optional(),
      intra_stripe_flows: z.object({ requested: PermissiveBoolean }).optional(),
      outbound_payments: z
        .object({
          ach: z.object({ requested: PermissiveBoolean }).optional(),
          us_domestic_wire: z
            .object({ requested: PermissiveBoolean })
            .optional(),
        })
        .optional(),
      outbound_transfers: z
        .object({
          ach: z.object({ requested: PermissiveBoolean }).optional(),
          us_domestic_wire: z
            .object({ requested: PermissiveBoolean })
            .optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "postTreasuryFinancialAccountsFinancialAccountFeatures",
    "/v1/treasury/financial_accounts/:financial_account/features",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountFeaturesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryFinancialAccountsFinancialAccountFeaturesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryFinancialAccountsFinancialAccountFeatures(
          input,
          postTreasuryFinancialAccountsFinancialAccountFeatures.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        postTreasuryFinancialAccountsFinancialAccountFeatures.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryInboundTransfersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "processing", "succeeded"])
      .optional(),
  })

  const getTreasuryInboundTransfersBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryInboundTransfers",
    "/v1/treasury/inbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryInboundTransfersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryInboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryInboundTransfers(
          input,
          getTreasuryInboundTransfers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryInboundTransfers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryInboundTransfersBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    description: z.string().max(5000).optional(),
    expand: z.array(z.string().max(5000)).optional(),
    financial_account: z.string(),
    metadata: z.record(z.string()).optional(),
    origin_payment_method: z.string().max(5000),
    statement_descriptor: z.string().max(10).optional(),
  })

  router.post(
    "postTreasuryInboundTransfers",
    "/v1/treasury/inbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryInboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryInboundTransfers(
          input,
          postTreasuryInboundTransfers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryInboundTransfers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryInboundTransfersIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryInboundTransfersIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryInboundTransfersIdBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryInboundTransfersId",
    "/v1/treasury/inbound_transfers/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryInboundTransfersIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryInboundTransfersIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryInboundTransfersIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryInboundTransfersId(
          input,
          getTreasuryInboundTransfersId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryInboundTransfersId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryInboundTransfersInboundTransferCancelParamSchema = z.object(
    { inbound_transfer: z.string().max(5000) },
  )

  const postTreasuryInboundTransfersInboundTransferCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTreasuryInboundTransfersInboundTransferCancel",
    "/v1/treasury/inbound_transfers/:inbound_transfer/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryInboundTransfersInboundTransferCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryInboundTransfersInboundTransferCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryInboundTransfersInboundTransferCancel(
          input,
          postTreasuryInboundTransfersInboundTransferCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryInboundTransfersInboundTransferCancel.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundPaymentsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    customer: z.string().max(5000).optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "posted", "processing", "returned"])
      .optional(),
  })

  const getTreasuryOutboundPaymentsBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryOutboundPayments",
    "/v1/treasury/outbound_payments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryOutboundPaymentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundPaymentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryOutboundPayments(
          input,
          getTreasuryOutboundPayments.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundPayments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryOutboundPaymentsBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    customer: z.string().max(5000).optional(),
    description: z.string().max(5000).optional(),
    destination_payment_method: z.string().max(5000).optional(),
    destination_payment_method_data: z
      .object({
        billing_details: z
          .object({
            address: z
              .union([
                z.object({
                  city: z.string().max(5000).optional(),
                  country: z.string().max(5000).optional(),
                  line1: z.string().max(5000).optional(),
                  line2: z.string().max(5000).optional(),
                  postal_code: z.string().max(5000).optional(),
                  state: z.string().max(5000).optional(),
                }),
                z.enum([""]),
              ])
              .optional(),
            email: z.union([z.string(), z.enum([""])]).optional(),
            name: z.union([z.string().max(5000), z.enum([""])]).optional(),
            phone: z.union([z.string().max(5000), z.enum([""])]).optional(),
          })
          .optional(),
        financial_account: z.string().optional(),
        metadata: z.record(z.string()).optional(),
        type: z.enum(["financial_account", "us_bank_account"]),
        us_bank_account: z
          .object({
            account_holder_type: z.enum(["company", "individual"]).optional(),
            account_number: z.string().max(5000).optional(),
            account_type: z.enum(["checking", "savings"]).optional(),
            financial_connections_account: z.string().max(5000).optional(),
            routing_number: z.string().max(5000).optional(),
          })
          .optional(),
      })
      .optional(),
    destination_payment_method_options: z
      .object({
        us_bank_account: z
          .union([
            z.object({
              network: z.enum(["ach", "us_domestic_wire"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
      })
      .optional(),
    end_user_details: z
      .object({ ip_address: z.string().optional(), present: PermissiveBoolean })
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    financial_account: z.string(),
    metadata: z.record(z.string()).optional(),
    statement_descriptor: z.string().max(5000).optional(),
  })

  router.post(
    "postTreasuryOutboundPayments",
    "/v1/treasury/outbound_payments",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundPaymentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryOutboundPayments(
          input,
          postTreasuryOutboundPayments.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryOutboundPayments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundPaymentsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryOutboundPaymentsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryOutboundPaymentsIdBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryOutboundPaymentsId",
    "/v1/treasury/outbound_payments/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryOutboundPaymentsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryOutboundPaymentsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundPaymentsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryOutboundPaymentsId(
          input,
          getTreasuryOutboundPaymentsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundPaymentsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryOutboundPaymentsIdCancelParamSchema = z.object({
    id: z.string().max(5000),
  })

  const postTreasuryOutboundPaymentsIdCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTreasuryOutboundPaymentsIdCancel",
    "/v1/treasury/outbound_payments/:id/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryOutboundPaymentsIdCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundPaymentsIdCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryOutboundPaymentsIdCancel(
          input,
          postTreasuryOutboundPaymentsIdCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryOutboundPaymentsIdCancel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundTransfersQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z
      .enum(["canceled", "failed", "posted", "processing", "returned"])
      .optional(),
  })

  const getTreasuryOutboundTransfersBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryOutboundTransfers",
    "/v1/treasury/outbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryOutboundTransfersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryOutboundTransfers(
          input,
          getTreasuryOutboundTransfers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundTransfers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postTreasuryOutboundTransfersBodySchema = z.object({
    amount: z.coerce.number(),
    currency: z.string(),
    description: z.string().max(5000).optional(),
    destination_payment_method: z.string().max(5000).optional(),
    destination_payment_method_data: z
      .object({
        financial_account: z.string().optional(),
        type: z.enum(["financial_account"]),
      })
      .optional(),
    destination_payment_method_options: z
      .object({
        us_bank_account: z
          .union([
            z.object({
              network: z.enum(["ach", "us_domestic_wire"]).optional(),
            }),
            z.enum([""]),
          ])
          .optional(),
      })
      .optional(),
    expand: z.array(z.string().max(5000)).optional(),
    financial_account: z.string(),
    metadata: z.record(z.string()).optional(),
    statement_descriptor: z.string().max(5000).optional(),
  })

  router.post(
    "postTreasuryOutboundTransfers",
    "/v1/treasury/outbound_transfers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundTransfersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryOutboundTransfers(
          input,
          postTreasuryOutboundTransfers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryOutboundTransfers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryOutboundTransfersOutboundTransferParamSchema = z.object({
    outbound_transfer: z.string().max(5000),
  })

  const getTreasuryOutboundTransfersOutboundTransferQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryOutboundTransfersOutboundTransferBodySchema = z
    .object({})
    .optional()

  router.get(
    "getTreasuryOutboundTransfersOutboundTransfer",
    "/v1/treasury/outbound_transfers/:outbound_transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryOutboundTransfersOutboundTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryOutboundTransfersOutboundTransferQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryOutboundTransfersOutboundTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryOutboundTransfersOutboundTransfer(
          input,
          getTreasuryOutboundTransfersOutboundTransfer.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryOutboundTransfersOutboundTransfer.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const postTreasuryOutboundTransfersOutboundTransferCancelParamSchema =
    z.object({ outbound_transfer: z.string().max(5000) })

  const postTreasuryOutboundTransfersOutboundTransferCancelBodySchema = z
    .object({ expand: z.array(z.string().max(5000)).optional() })
    .optional()

  router.post(
    "postTreasuryOutboundTransfersOutboundTransferCancel",
    "/v1/treasury/outbound_transfers/:outbound_transfer/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postTreasuryOutboundTransfersOutboundTransferCancelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postTreasuryOutboundTransfersOutboundTransferCancelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postTreasuryOutboundTransfersOutboundTransferCancel(
          input,
          postTreasuryOutboundTransfersOutboundTransferCancel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postTreasuryOutboundTransfersOutboundTransferCancel.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedCreditsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    linked_flows: z
      .object({
        source_flow_type: z.enum([
          "credit_reversal",
          "other",
          "outbound_payment",
          "outbound_transfer",
          "payout",
        ]),
      })
      .optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["failed", "succeeded"]).optional(),
  })

  const getTreasuryReceivedCreditsBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryReceivedCredits",
    "/v1/treasury/received_credits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryReceivedCreditsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedCreditsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryReceivedCredits(
          input,
          getTreasuryReceivedCredits.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedCredits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedCreditsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryReceivedCreditsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryReceivedCreditsIdBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryReceivedCreditsId",
    "/v1/treasury/received_credits/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryReceivedCreditsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryReceivedCreditsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedCreditsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryReceivedCreditsId(
          input,
          getTreasuryReceivedCreditsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedCreditsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedDebitsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["failed", "succeeded"]).optional(),
  })

  const getTreasuryReceivedDebitsBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryReceivedDebits",
    "/v1/treasury/received_debits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryReceivedDebitsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedDebitsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryReceivedDebits(
          input,
          getTreasuryReceivedDebits.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedDebits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryReceivedDebitsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryReceivedDebitsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryReceivedDebitsIdBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryReceivedDebitsId",
    "/v1/treasury/received_debits/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryReceivedDebitsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryReceivedDebitsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryReceivedDebitsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryReceivedDebitsId(
          input,
          getTreasuryReceivedDebitsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryReceivedDebitsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionEntriesQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    effective_at: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    order_by: z.enum(["created", "effective_at"]).optional(),
    starting_after: z.string().max(5000).optional(),
    transaction: z.string().max(5000).optional(),
  })

  const getTreasuryTransactionEntriesBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryTransactionEntries",
    "/v1/treasury/transaction_entries",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryTransactionEntriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionEntriesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryTransactionEntries(
          input,
          getTreasuryTransactionEntries.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactionEntries.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionEntriesIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryTransactionEntriesIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryTransactionEntriesIdBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryTransactionEntriesId",
    "/v1/treasury/transaction_entries/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryTransactionEntriesIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryTransactionEntriesIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionEntriesIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryTransactionEntriesId(
          input,
          getTreasuryTransactionEntriesId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactionEntriesId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionsQuerySchema = z.object({
    created: z
      .union([
        z.object({
          gt: z.coerce.number().optional(),
          gte: z.coerce.number().optional(),
          lt: z.coerce.number().optional(),
          lte: z.coerce.number().optional(),
        }),
        z.coerce.number(),
      ])
      .optional(),
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    financial_account: z.string(),
    limit: z.coerce.number().optional(),
    order_by: z.enum(["created", "posted_at"]).optional(),
    starting_after: z.string().max(5000).optional(),
    status: z.enum(["open", "posted", "void"]).optional(),
    status_transitions: z
      .object({
        posted_at: z
          .union([
            z.object({
              gt: z.coerce.number().optional(),
              gte: z.coerce.number().optional(),
              lt: z.coerce.number().optional(),
              lte: z.coerce.number().optional(),
            }),
            z.coerce.number(),
          ])
          .optional(),
      })
      .optional(),
  })

  const getTreasuryTransactionsBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryTransactions",
    "/v1/treasury/transactions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getTreasuryTransactionsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryTransactions(input, getTreasuryTransactions.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getTreasuryTransactionsIdParamSchema = z.object({
    id: z.string().max(5000),
  })

  const getTreasuryTransactionsIdQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getTreasuryTransactionsIdBodySchema = z.object({}).optional()

  router.get(
    "getTreasuryTransactionsId",
    "/v1/treasury/transactions/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getTreasuryTransactionsIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getTreasuryTransactionsIdQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getTreasuryTransactionsIdBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getTreasuryTransactionsId(
          input,
          getTreasuryTransactionsId.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getTreasuryTransactionsId.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getWebhookEndpointsQuerySchema = z.object({
    ending_before: z.string().max(5000).optional(),
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
    limit: z.coerce.number().optional(),
    starting_after: z.string().max(5000).optional(),
  })

  const getWebhookEndpointsBodySchema = z.object({}).optional()

  router.get(
    "getWebhookEndpoints",
    "/v1/webhook_endpoints",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getWebhookEndpointsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getWebhookEndpointsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getWebhookEndpoints(input, getWebhookEndpoints.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWebhookEndpoints.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postWebhookEndpointsBodySchema = z.object({
    api_version: z
      .enum([
        "2011-01-01",
        "2011-06-21",
        "2011-06-28",
        "2011-08-01",
        "2011-09-15",
        "2011-11-17",
        "2012-02-23",
        "2012-03-25",
        "2012-06-18",
        "2012-06-28",
        "2012-07-09",
        "2012-09-24",
        "2012-10-26",
        "2012-11-07",
        "2013-02-11",
        "2013-02-13",
        "2013-07-05",
        "2013-08-12",
        "2013-08-13",
        "2013-10-29",
        "2013-12-03",
        "2014-01-31",
        "2014-03-13",
        "2014-03-28",
        "2014-05-19",
        "2014-06-13",
        "2014-06-17",
        "2014-07-22",
        "2014-07-26",
        "2014-08-04",
        "2014-08-20",
        "2014-09-08",
        "2014-10-07",
        "2014-11-05",
        "2014-11-20",
        "2014-12-08",
        "2014-12-17",
        "2014-12-22",
        "2015-01-11",
        "2015-01-26",
        "2015-02-10",
        "2015-02-16",
        "2015-02-18",
        "2015-03-24",
        "2015-04-07",
        "2015-06-15",
        "2015-07-07",
        "2015-07-13",
        "2015-07-28",
        "2015-08-07",
        "2015-08-19",
        "2015-09-03",
        "2015-09-08",
        "2015-09-23",
        "2015-10-01",
        "2015-10-12",
        "2015-10-16",
        "2016-02-03",
        "2016-02-19",
        "2016-02-22",
        "2016-02-23",
        "2016-02-29",
        "2016-03-07",
        "2016-06-15",
        "2016-07-06",
        "2016-10-19",
        "2017-01-27",
        "2017-02-14",
        "2017-04-06",
        "2017-05-25",
        "2017-06-05",
        "2017-08-15",
        "2017-12-14",
        "2018-01-23",
        "2018-02-05",
        "2018-02-06",
        "2018-02-28",
        "2018-05-21",
        "2018-07-27",
        "2018-08-23",
        "2018-09-06",
        "2018-09-24",
        "2018-10-31",
        "2018-11-08",
        "2019-02-11",
        "2019-02-19",
        "2019-03-14",
        "2019-05-16",
        "2019-08-14",
        "2019-09-09",
        "2019-10-08",
        "2019-10-17",
        "2019-11-05",
        "2019-12-03",
        "2020-03-02",
        "2020-08-27",
        "2022-08-01",
        "2022-11-15",
        "2023-08-16",
        "2023-10-16",
        "2024-04-10",
        "2024-06-20",
        "2024-09-30.acacia",
        "2024-10-28.acacia",
        "2024-11-20.acacia",
        "2024-12-18.acacia",
        "2025-01-27.acacia",
        "2025-02-24.acacia",
        "2025-03-01.dashboard",
        "2025-03-31.basil",
      ])
      .optional(),
    connect: PermissiveBoolean.optional(),
    description: z.union([z.string().max(5000), z.enum([""])]).optional(),
    enabled_events: z.array(
      z.enum([
        "*",
        "account.application.authorized",
        "account.application.deauthorized",
        "account.external_account.created",
        "account.external_account.deleted",
        "account.external_account.updated",
        "account.updated",
        "application_fee.created",
        "application_fee.refund.updated",
        "application_fee.refunded",
        "balance.available",
        "billing.alert.triggered",
        "billing_portal.configuration.created",
        "billing_portal.configuration.updated",
        "billing_portal.session.created",
        "capability.updated",
        "cash_balance.funds_available",
        "charge.captured",
        "charge.dispute.closed",
        "charge.dispute.created",
        "charge.dispute.funds_reinstated",
        "charge.dispute.funds_withdrawn",
        "charge.dispute.updated",
        "charge.expired",
        "charge.failed",
        "charge.pending",
        "charge.refund.updated",
        "charge.refunded",
        "charge.succeeded",
        "charge.updated",
        "checkout.session.async_payment_failed",
        "checkout.session.async_payment_succeeded",
        "checkout.session.completed",
        "checkout.session.expired",
        "climate.order.canceled",
        "climate.order.created",
        "climate.order.delayed",
        "climate.order.delivered",
        "climate.order.product_substituted",
        "climate.product.created",
        "climate.product.pricing_updated",
        "coupon.created",
        "coupon.deleted",
        "coupon.updated",
        "credit_note.created",
        "credit_note.updated",
        "credit_note.voided",
        "customer.created",
        "customer.deleted",
        "customer.discount.created",
        "customer.discount.deleted",
        "customer.discount.updated",
        "customer.source.created",
        "customer.source.deleted",
        "customer.source.expiring",
        "customer.source.updated",
        "customer.subscription.created",
        "customer.subscription.deleted",
        "customer.subscription.paused",
        "customer.subscription.pending_update_applied",
        "customer.subscription.pending_update_expired",
        "customer.subscription.resumed",
        "customer.subscription.trial_will_end",
        "customer.subscription.updated",
        "customer.tax_id.created",
        "customer.tax_id.deleted",
        "customer.tax_id.updated",
        "customer.updated",
        "customer_cash_balance_transaction.created",
        "entitlements.active_entitlement_summary.updated",
        "file.created",
        "financial_connections.account.created",
        "financial_connections.account.deactivated",
        "financial_connections.account.disconnected",
        "financial_connections.account.reactivated",
        "financial_connections.account.refreshed_balance",
        "financial_connections.account.refreshed_ownership",
        "financial_connections.account.refreshed_transactions",
        "identity.verification_session.canceled",
        "identity.verification_session.created",
        "identity.verification_session.processing",
        "identity.verification_session.redacted",
        "identity.verification_session.requires_input",
        "identity.verification_session.verified",
        "invoice.created",
        "invoice.deleted",
        "invoice.finalization_failed",
        "invoice.finalized",
        "invoice.marked_uncollectible",
        "invoice.overdue",
        "invoice.overpaid",
        "invoice.paid",
        "invoice.payment_action_required",
        "invoice.payment_failed",
        "invoice.payment_succeeded",
        "invoice.sent",
        "invoice.upcoming",
        "invoice.updated",
        "invoice.voided",
        "invoice.will_be_due",
        "invoiceitem.created",
        "invoiceitem.deleted",
        "issuing_authorization.created",
        "issuing_authorization.request",
        "issuing_authorization.updated",
        "issuing_card.created",
        "issuing_card.updated",
        "issuing_cardholder.created",
        "issuing_cardholder.updated",
        "issuing_dispute.closed",
        "issuing_dispute.created",
        "issuing_dispute.funds_reinstated",
        "issuing_dispute.funds_rescinded",
        "issuing_dispute.submitted",
        "issuing_dispute.updated",
        "issuing_personalization_design.activated",
        "issuing_personalization_design.deactivated",
        "issuing_personalization_design.rejected",
        "issuing_personalization_design.updated",
        "issuing_token.created",
        "issuing_token.updated",
        "issuing_transaction.created",
        "issuing_transaction.purchase_details_receipt_updated",
        "issuing_transaction.updated",
        "mandate.updated",
        "payment_intent.amount_capturable_updated",
        "payment_intent.canceled",
        "payment_intent.created",
        "payment_intent.partially_funded",
        "payment_intent.payment_failed",
        "payment_intent.processing",
        "payment_intent.requires_action",
        "payment_intent.succeeded",
        "payment_link.created",
        "payment_link.updated",
        "payment_method.attached",
        "payment_method.automatically_updated",
        "payment_method.detached",
        "payment_method.updated",
        "payout.canceled",
        "payout.created",
        "payout.failed",
        "payout.paid",
        "payout.reconciliation_completed",
        "payout.updated",
        "person.created",
        "person.deleted",
        "person.updated",
        "plan.created",
        "plan.deleted",
        "plan.updated",
        "price.created",
        "price.deleted",
        "price.updated",
        "product.created",
        "product.deleted",
        "product.updated",
        "promotion_code.created",
        "promotion_code.updated",
        "quote.accepted",
        "quote.canceled",
        "quote.created",
        "quote.finalized",
        "radar.early_fraud_warning.created",
        "radar.early_fraud_warning.updated",
        "refund.created",
        "refund.failed",
        "refund.updated",
        "reporting.report_run.failed",
        "reporting.report_run.succeeded",
        "reporting.report_type.updated",
        "review.closed",
        "review.opened",
        "setup_intent.canceled",
        "setup_intent.created",
        "setup_intent.requires_action",
        "setup_intent.setup_failed",
        "setup_intent.succeeded",
        "sigma.scheduled_query_run.created",
        "source.canceled",
        "source.chargeable",
        "source.failed",
        "source.mandate_notification",
        "source.refund_attributes_required",
        "source.transaction.created",
        "source.transaction.updated",
        "subscription_schedule.aborted",
        "subscription_schedule.canceled",
        "subscription_schedule.completed",
        "subscription_schedule.created",
        "subscription_schedule.expiring",
        "subscription_schedule.released",
        "subscription_schedule.updated",
        "tax.settings.updated",
        "tax_rate.created",
        "tax_rate.updated",
        "terminal.reader.action_failed",
        "terminal.reader.action_succeeded",
        "test_helpers.test_clock.advancing",
        "test_helpers.test_clock.created",
        "test_helpers.test_clock.deleted",
        "test_helpers.test_clock.internal_failure",
        "test_helpers.test_clock.ready",
        "topup.canceled",
        "topup.created",
        "topup.failed",
        "topup.reversed",
        "topup.succeeded",
        "transfer.created",
        "transfer.reversed",
        "transfer.updated",
        "treasury.credit_reversal.created",
        "treasury.credit_reversal.posted",
        "treasury.debit_reversal.completed",
        "treasury.debit_reversal.created",
        "treasury.debit_reversal.initial_credit_granted",
        "treasury.financial_account.closed",
        "treasury.financial_account.created",
        "treasury.financial_account.features_status_updated",
        "treasury.inbound_transfer.canceled",
        "treasury.inbound_transfer.created",
        "treasury.inbound_transfer.failed",
        "treasury.inbound_transfer.succeeded",
        "treasury.outbound_payment.canceled",
        "treasury.outbound_payment.created",
        "treasury.outbound_payment.expected_arrival_date_updated",
        "treasury.outbound_payment.failed",
        "treasury.outbound_payment.posted",
        "treasury.outbound_payment.returned",
        "treasury.outbound_payment.tracking_details_updated",
        "treasury.outbound_transfer.canceled",
        "treasury.outbound_transfer.created",
        "treasury.outbound_transfer.expected_arrival_date_updated",
        "treasury.outbound_transfer.failed",
        "treasury.outbound_transfer.posted",
        "treasury.outbound_transfer.returned",
        "treasury.outbound_transfer.tracking_details_updated",
        "treasury.received_credit.created",
        "treasury.received_credit.failed",
        "treasury.received_credit.succeeded",
        "treasury.received_debit.created",
      ]),
    ),
    expand: z.array(z.string().max(5000)).optional(),
    metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
    url: z.string(),
  })

  router.post(
    "postWebhookEndpoints",
    "/v1/webhook_endpoints",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          postWebhookEndpointsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postWebhookEndpoints(input, postWebhookEndpoints.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postWebhookEndpoints.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  const deleteWebhookEndpointsWebhookEndpointBodySchema = z
    .object({})
    .optional()

  router.delete(
    "deleteWebhookEndpointsWebhookEndpoint",
    "/v1/webhook_endpoints/:webhook_endpoint",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteWebhookEndpointsWebhookEndpointParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deleteWebhookEndpointsWebhookEndpointBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deleteWebhookEndpointsWebhookEndpoint(
          input,
          deleteWebhookEndpointsWebhookEndpoint.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteWebhookEndpointsWebhookEndpoint.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  const getWebhookEndpointsWebhookEndpointQuerySchema = z.object({
    expand: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string().max(5000)),
      )
      .optional(),
  })

  const getWebhookEndpointsWebhookEndpointBodySchema = z.object({}).optional()

  router.get(
    "getWebhookEndpointsWebhookEndpoint",
    "/v1/webhook_endpoints/:webhook_endpoint",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWebhookEndpointsWebhookEndpointParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWebhookEndpointsWebhookEndpointQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          getWebhookEndpointsWebhookEndpointBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .getWebhookEndpointsWebhookEndpoint(
          input,
          getWebhookEndpointsWebhookEndpoint.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWebhookEndpointsWebhookEndpoint.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const postWebhookEndpointsWebhookEndpointParamSchema = z.object({
    webhook_endpoint: z.string().max(5000),
  })

  const postWebhookEndpointsWebhookEndpointBodySchema = z
    .object({
      description: z.union([z.string().max(5000), z.enum([""])]).optional(),
      disabled: PermissiveBoolean.optional(),
      enabled_events: z
        .array(
          z.enum([
            "*",
            "account.application.authorized",
            "account.application.deauthorized",
            "account.external_account.created",
            "account.external_account.deleted",
            "account.external_account.updated",
            "account.updated",
            "application_fee.created",
            "application_fee.refund.updated",
            "application_fee.refunded",
            "balance.available",
            "billing.alert.triggered",
            "billing_portal.configuration.created",
            "billing_portal.configuration.updated",
            "billing_portal.session.created",
            "capability.updated",
            "cash_balance.funds_available",
            "charge.captured",
            "charge.dispute.closed",
            "charge.dispute.created",
            "charge.dispute.funds_reinstated",
            "charge.dispute.funds_withdrawn",
            "charge.dispute.updated",
            "charge.expired",
            "charge.failed",
            "charge.pending",
            "charge.refund.updated",
            "charge.refunded",
            "charge.succeeded",
            "charge.updated",
            "checkout.session.async_payment_failed",
            "checkout.session.async_payment_succeeded",
            "checkout.session.completed",
            "checkout.session.expired",
            "climate.order.canceled",
            "climate.order.created",
            "climate.order.delayed",
            "climate.order.delivered",
            "climate.order.product_substituted",
            "climate.product.created",
            "climate.product.pricing_updated",
            "coupon.created",
            "coupon.deleted",
            "coupon.updated",
            "credit_note.created",
            "credit_note.updated",
            "credit_note.voided",
            "customer.created",
            "customer.deleted",
            "customer.discount.created",
            "customer.discount.deleted",
            "customer.discount.updated",
            "customer.source.created",
            "customer.source.deleted",
            "customer.source.expiring",
            "customer.source.updated",
            "customer.subscription.created",
            "customer.subscription.deleted",
            "customer.subscription.paused",
            "customer.subscription.pending_update_applied",
            "customer.subscription.pending_update_expired",
            "customer.subscription.resumed",
            "customer.subscription.trial_will_end",
            "customer.subscription.updated",
            "customer.tax_id.created",
            "customer.tax_id.deleted",
            "customer.tax_id.updated",
            "customer.updated",
            "customer_cash_balance_transaction.created",
            "entitlements.active_entitlement_summary.updated",
            "file.created",
            "financial_connections.account.created",
            "financial_connections.account.deactivated",
            "financial_connections.account.disconnected",
            "financial_connections.account.reactivated",
            "financial_connections.account.refreshed_balance",
            "financial_connections.account.refreshed_ownership",
            "financial_connections.account.refreshed_transactions",
            "identity.verification_session.canceled",
            "identity.verification_session.created",
            "identity.verification_session.processing",
            "identity.verification_session.redacted",
            "identity.verification_session.requires_input",
            "identity.verification_session.verified",
            "invoice.created",
            "invoice.deleted",
            "invoice.finalization_failed",
            "invoice.finalized",
            "invoice.marked_uncollectible",
            "invoice.overdue",
            "invoice.overpaid",
            "invoice.paid",
            "invoice.payment_action_required",
            "invoice.payment_failed",
            "invoice.payment_succeeded",
            "invoice.sent",
            "invoice.upcoming",
            "invoice.updated",
            "invoice.voided",
            "invoice.will_be_due",
            "invoiceitem.created",
            "invoiceitem.deleted",
            "issuing_authorization.created",
            "issuing_authorization.request",
            "issuing_authorization.updated",
            "issuing_card.created",
            "issuing_card.updated",
            "issuing_cardholder.created",
            "issuing_cardholder.updated",
            "issuing_dispute.closed",
            "issuing_dispute.created",
            "issuing_dispute.funds_reinstated",
            "issuing_dispute.funds_rescinded",
            "issuing_dispute.submitted",
            "issuing_dispute.updated",
            "issuing_personalization_design.activated",
            "issuing_personalization_design.deactivated",
            "issuing_personalization_design.rejected",
            "issuing_personalization_design.updated",
            "issuing_token.created",
            "issuing_token.updated",
            "issuing_transaction.created",
            "issuing_transaction.purchase_details_receipt_updated",
            "issuing_transaction.updated",
            "mandate.updated",
            "payment_intent.amount_capturable_updated",
            "payment_intent.canceled",
            "payment_intent.created",
            "payment_intent.partially_funded",
            "payment_intent.payment_failed",
            "payment_intent.processing",
            "payment_intent.requires_action",
            "payment_intent.succeeded",
            "payment_link.created",
            "payment_link.updated",
            "payment_method.attached",
            "payment_method.automatically_updated",
            "payment_method.detached",
            "payment_method.updated",
            "payout.canceled",
            "payout.created",
            "payout.failed",
            "payout.paid",
            "payout.reconciliation_completed",
            "payout.updated",
            "person.created",
            "person.deleted",
            "person.updated",
            "plan.created",
            "plan.deleted",
            "plan.updated",
            "price.created",
            "price.deleted",
            "price.updated",
            "product.created",
            "product.deleted",
            "product.updated",
            "promotion_code.created",
            "promotion_code.updated",
            "quote.accepted",
            "quote.canceled",
            "quote.created",
            "quote.finalized",
            "radar.early_fraud_warning.created",
            "radar.early_fraud_warning.updated",
            "refund.created",
            "refund.failed",
            "refund.updated",
            "reporting.report_run.failed",
            "reporting.report_run.succeeded",
            "reporting.report_type.updated",
            "review.closed",
            "review.opened",
            "setup_intent.canceled",
            "setup_intent.created",
            "setup_intent.requires_action",
            "setup_intent.setup_failed",
            "setup_intent.succeeded",
            "sigma.scheduled_query_run.created",
            "source.canceled",
            "source.chargeable",
            "source.failed",
            "source.mandate_notification",
            "source.refund_attributes_required",
            "source.transaction.created",
            "source.transaction.updated",
            "subscription_schedule.aborted",
            "subscription_schedule.canceled",
            "subscription_schedule.completed",
            "subscription_schedule.created",
            "subscription_schedule.expiring",
            "subscription_schedule.released",
            "subscription_schedule.updated",
            "tax.settings.updated",
            "tax_rate.created",
            "tax_rate.updated",
            "terminal.reader.action_failed",
            "terminal.reader.action_succeeded",
            "test_helpers.test_clock.advancing",
            "test_helpers.test_clock.created",
            "test_helpers.test_clock.deleted",
            "test_helpers.test_clock.internal_failure",
            "test_helpers.test_clock.ready",
            "topup.canceled",
            "topup.created",
            "topup.failed",
            "topup.reversed",
            "topup.succeeded",
            "transfer.created",
            "transfer.reversed",
            "transfer.updated",
            "treasury.credit_reversal.created",
            "treasury.credit_reversal.posted",
            "treasury.debit_reversal.completed",
            "treasury.debit_reversal.created",
            "treasury.debit_reversal.initial_credit_granted",
            "treasury.financial_account.closed",
            "treasury.financial_account.created",
            "treasury.financial_account.features_status_updated",
            "treasury.inbound_transfer.canceled",
            "treasury.inbound_transfer.created",
            "treasury.inbound_transfer.failed",
            "treasury.inbound_transfer.succeeded",
            "treasury.outbound_payment.canceled",
            "treasury.outbound_payment.created",
            "treasury.outbound_payment.expected_arrival_date_updated",
            "treasury.outbound_payment.failed",
            "treasury.outbound_payment.posted",
            "treasury.outbound_payment.returned",
            "treasury.outbound_payment.tracking_details_updated",
            "treasury.outbound_transfer.canceled",
            "treasury.outbound_transfer.created",
            "treasury.outbound_transfer.expected_arrival_date_updated",
            "treasury.outbound_transfer.failed",
            "treasury.outbound_transfer.posted",
            "treasury.outbound_transfer.returned",
            "treasury.outbound_transfer.tracking_details_updated",
            "treasury.received_credit.created",
            "treasury.received_credit.failed",
            "treasury.received_credit.succeeded",
            "treasury.received_debit.created",
          ]),
        )
        .optional(),
      expand: z.array(z.string().max(5000)).optional(),
      metadata: z.union([z.record(z.string()), z.enum([""])]).optional(),
      url: z.string().optional(),
    })
    .optional()

  router.post(
    "postWebhookEndpointsWebhookEndpoint",
    "/v1/webhook_endpoints/:webhook_endpoint",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          postWebhookEndpointsWebhookEndpointParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          postWebhookEndpointsWebhookEndpointBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .postWebhookEndpointsWebhookEndpoint(
          input,
          postWebhookEndpointsWebhookEndpoint.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = postWebhookEndpointsWebhookEndpoint.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Stripe API
  return startServer(config)
}
