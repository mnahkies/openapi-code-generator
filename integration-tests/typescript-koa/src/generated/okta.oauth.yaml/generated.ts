/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AuthorizeCustomAsParamSchema,
  t_AuthorizeCustomAsQuerySchema,
  t_AuthorizeCustomAsWithPostBodySchema,
  t_AuthorizeCustomAsWithPostParamSchema,
  t_AuthorizeQuerySchema,
  t_AuthorizeWithPostBodySchema,
  t_BackchannelAuthorizeResponse,
  t_BcAuthorizeBodySchema,
  t_BcAuthorizeCustomAsBodySchema,
  t_BcAuthorizeCustomAsParamSchema,
  t_ChallengeBodySchema,
  t_ChallengeCustomAsBodySchema,
  t_ChallengeCustomAsParamSchema,
  t_ChallengeResponse,
  t_Client,
  t_CreateClientBodySchema,
  t_DeleteClientParamSchema,
  t_DeviceAuthorizeBodySchema,
  t_DeviceAuthorizeCustomAsBodySchema,
  t_DeviceAuthorizeCustomAsParamSchema,
  t_DeviceAuthorizeResponse,
  t_Error,
  t_GenerateNewClientSecretParamSchema,
  t_GetClientParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
  t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationQuerySchema,
  t_GlobalTokenRevocationBodySchema,
  t_IntrospectBodySchema,
  t_IntrospectCustomAsBodySchema,
  t_IntrospectCustomAsParamSchema,
  t_IntrospectionResponse,
  t_ListClientsQuerySchema,
  t_LogoutCustomAsParamSchema,
  t_LogoutCustomAsQuerySchema,
  t_LogoutCustomAsWithPostBodySchema,
  t_LogoutCustomAsWithPostParamSchema,
  t_LogoutQuerySchema,
  t_LogoutWithPostBodySchema,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OauthKeysCustomAsParamSchema,
  t_OauthKeysQuerySchema,
  t_OidcMetadata,
  t_OobAuthenticateBodySchema,
  t_OobAuthenticateCustomAsBodySchema,
  t_OobAuthenticateCustomAsParamSchema,
  t_OobAuthenticateResponse,
  t_ParBodySchema,
  t_ParCustomAsBodySchema,
  t_ParCustomAsParamSchema,
  t_ParOptionsCustomAsHeaderSchema,
  t_ParOptionsCustomAsParamSchema,
  t_ParOptionsHeaderSchema,
  t_ParResponse,
  t_ReplaceClientBodySchema,
  t_ReplaceClientParamSchema,
  t_RevokeBodySchema,
  t_RevokeCustomAsBodySchema,
  t_RevokeCustomAsParamSchema,
  t_TokenBodySchema,
  t_TokenCustomAsBodySchema,
  t_TokenCustomAsParamSchema,
  t_TokenOptionsCustomAsHeaderSchema,
  t_TokenOptionsCustomAsParamSchema,
  t_TokenOptionsHeaderSchema,
  t_TokenResponse,
  t_UserInfo,
  t_UserinfoCustomAsParamSchema,
} from "./models"
import {
  s_AcrValue,
  s_AmrValue,
  s_AuthorizeWithPost,
  s_BackchannelAuthorizeRequest,
  s_BackchannelAuthorizeResponse,
  s_ChallengeRequest,
  s_ChallengeResponse,
  s_Client,
  s_CodeChallengeMethod,
  s_DeviceAuthorizeRequest,
  s_DeviceAuthorizeResponse,
  s_Error,
  s_GlobalTokenRevocationRequest,
  s_IntrospectionRequest,
  s_IntrospectionResponse,
  s_LogoutWithPost,
  s_OAuthError,
  s_OAuthKeys,
  s_OAuthMetadata,
  s_OidcMetadata,
  s_OobAuthenticateRequest,
  s_OobAuthenticateResponse,
  s_ParRequest,
  s_ParResponse,
  s_Prompt,
  s_ResponseMode,
  s_ResponseTypesSupported,
  s_RevokeRequest,
  s_TokenRequest,
  s_TokenResponse,
  s_UserInfo,
} from "./schemas"
import KoaRouter, { RouterContext } from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  KoaRuntimeResponder,
  KoaRuntimeResponse,
  Params,
  Response,
  ServerConfig,
  r,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod"
import { z } from "zod"

const getWellKnownOpenIdConfigurationResponder = {
  with200: r.with200<t_OidcMetadata>,
  with400: r.with400<t_Error>,
  withStatus: r.withStatus,
}

type GetWellKnownOpenIdConfigurationResponder =
  typeof getWellKnownOpenIdConfigurationResponder & KoaRuntimeResponder

const getWellKnownOpenIdConfigurationResponseValidator =
  responseValidationFactory(
    [
      ["200", s_OidcMetadata],
      ["400", s_Error],
    ],
    undefined,
  )

export type GetWellKnownOpenIdConfiguration = (
  params: Params<
    void,
    t_GetWellKnownOpenIdConfigurationQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OidcMetadata>
  | Response<400, t_Error>
>

const authorizeResponder = {
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type AuthorizeResponder = typeof authorizeResponder & KoaRuntimeResponder

const authorizeResponseValidator = responseValidationFactory(
  [["429", s_Error]],
  undefined,
)

export type Authorize = (
  params: Params<void, t_AuthorizeQuerySchema, void, void>,
  respond: AuthorizeResponder,
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const authorizeWithPostResponder = {
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type AuthorizeWithPostResponder = typeof authorizeWithPostResponder &
  KoaRuntimeResponder

const authorizeWithPostResponseValidator = responseValidationFactory(
  [["429", s_Error]],
  undefined,
)

export type AuthorizeWithPost = (
  params: Params<void, void, t_AuthorizeWithPostBodySchema, void>,
  respond: AuthorizeWithPostResponder,
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const bcAuthorizeResponder = {
  with200: r.with200<t_BackchannelAuthorizeResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type BcAuthorizeResponder = typeof bcAuthorizeResponder & KoaRuntimeResponder

const bcAuthorizeResponseValidator = responseValidationFactory(
  [
    ["200", s_BackchannelAuthorizeResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type BcAuthorize = (
  params: Params<void, void, t_BcAuthorizeBodySchema, void>,
  respond: BcAuthorizeResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_BackchannelAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const challengeResponder = {
  with200: r.with200<t_ChallengeResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with403: r.with403<t_OAuthError>,
  with429: r.with429<t_OAuthError>,
  withStatus: r.withStatus,
}

type ChallengeResponder = typeof challengeResponder & KoaRuntimeResponder

const challengeResponseValidator = responseValidationFactory(
  [
    ["200", s_ChallengeResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["403", s_OAuthError],
    ["429", s_OAuthError],
  ],
  undefined,
)

export type Challenge = (
  params: Params<void, void, t_ChallengeBodySchema, void>,
  respond: ChallengeResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ChallengeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const listClientsResponder = {
  with200: r.with200<t_Client[]>,
  with403: r.with403<t_Error>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type ListClientsResponder = typeof listClientsResponder & KoaRuntimeResponder

const listClientsResponseValidator = responseValidationFactory(
  [
    ["200", z.array(s_Client)],
    ["403", s_Error],
    ["429", s_Error],
  ],
  undefined,
)

export type ListClients = (
  params: Params<void, t_ListClientsQuerySchema, void, void>,
  respond: ListClientsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client[]>
  | Response<403, t_Error>
  | Response<429, t_Error>
>

const createClientResponder = {
  with201: r.with201<t_Client>,
  with400: r.with400<t_Error>,
  with403: r.with403<t_Error>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type CreateClientResponder = typeof createClientResponder & KoaRuntimeResponder

const createClientResponseValidator = responseValidationFactory(
  [
    ["201", s_Client],
    ["400", s_Error],
    ["403", s_Error],
    ["429", s_Error],
  ],
  undefined,
)

export type CreateClient = (
  params: Params<void, void, t_CreateClientBodySchema, void>,
  respond: CreateClientResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_Client>
  | Response<400, t_Error>
  | Response<403, t_Error>
  | Response<429, t_Error>
>

const getClientResponder = {
  with200: r.with200<t_Client>,
  with403: r.with403<t_Error>,
  with404: r.with404<t_Error>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type GetClientResponder = typeof getClientResponder & KoaRuntimeResponder

const getClientResponseValidator = responseValidationFactory(
  [
    ["200", s_Client],
    ["403", s_Error],
    ["404", s_Error],
    ["429", s_Error],
  ],
  undefined,
)

export type GetClient = (
  params: Params<t_GetClientParamSchema, void, void, void>,
  respond: GetClientResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const replaceClientResponder = {
  with200: r.with200<t_Client>,
  with400: r.with400<t_Error>,
  with403: r.with403<t_Error>,
  with404: r.with404<t_Error>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type ReplaceClientResponder = typeof replaceClientResponder &
  KoaRuntimeResponder

const replaceClientResponseValidator = responseValidationFactory(
  [
    ["200", s_Client],
    ["400", s_Error],
    ["403", s_Error],
    ["404", s_Error],
    ["429", s_Error],
  ],
  undefined,
)

export type ReplaceClient = (
  params: Params<
    t_ReplaceClientParamSchema,
    void,
    t_ReplaceClientBodySchema,
    void
  >,
  respond: ReplaceClientResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<400, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const deleteClientResponder = {
  with204: r.with204<void>,
  with403: r.with403<t_Error>,
  with404: r.with404<t_Error>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type DeleteClientResponder = typeof deleteClientResponder & KoaRuntimeResponder

const deleteClientResponseValidator = responseValidationFactory(
  [
    ["204", z.undefined()],
    ["403", s_Error],
    ["404", s_Error],
    ["429", s_Error],
  ],
  undefined,
)

export type DeleteClient = (
  params: Params<t_DeleteClientParamSchema, void, void, void>,
  respond: DeleteClientResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const generateNewClientSecretResponder = {
  with200: r.with200<t_Client>,
  with403: r.with403<t_Error>,
  with404: r.with404<t_Error>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type GenerateNewClientSecretResponder =
  typeof generateNewClientSecretResponder & KoaRuntimeResponder

const generateNewClientSecretResponseValidator = responseValidationFactory(
  [
    ["200", s_Client],
    ["403", s_Error],
    ["404", s_Error],
    ["429", s_Error],
  ],
  undefined,
)

export type GenerateNewClientSecret = (
  params: Params<t_GenerateNewClientSecretParamSchema, void, void, void>,
  respond: GenerateNewClientSecretResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const deviceAuthorizeResponder = {
  with200: r.with200<t_DeviceAuthorizeResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type DeviceAuthorizeResponder = typeof deviceAuthorizeResponder &
  KoaRuntimeResponder

const deviceAuthorizeResponseValidator = responseValidationFactory(
  [
    ["200", s_DeviceAuthorizeResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type DeviceAuthorize = (
  params: Params<void, void, t_DeviceAuthorizeBodySchema, void>,
  respond: DeviceAuthorizeResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_DeviceAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const globalTokenRevocationResponder = {
  with204: r.with204<void>,
  with400: r.with400<void>,
  with403: r.with403<t_Error>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type GlobalTokenRevocationResponder = typeof globalTokenRevocationResponder &
  KoaRuntimeResponder

const globalTokenRevocationResponseValidator = responseValidationFactory(
  [
    ["204", z.undefined()],
    ["400", z.undefined()],
    ["403", s_Error],
    ["429", s_Error],
  ],
  undefined,
)

export type GlobalTokenRevocation = (
  params: Params<void, void, t_GlobalTokenRevocationBodySchema, void>,
  respond: GlobalTokenRevocationResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, void>
  | Response<403, t_Error>
  | Response<429, t_Error>
>

const introspectResponder = {
  with200: r.with200<t_IntrospectionResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type IntrospectResponder = typeof introspectResponder & KoaRuntimeResponder

const introspectResponseValidator = responseValidationFactory(
  [
    ["200", s_IntrospectionResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type Introspect = (
  params: Params<void, void, t_IntrospectBodySchema, void>,
  respond: IntrospectResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_IntrospectionResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const oauthKeysResponder = {
  with200: r.with200<t_OAuthKeys>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type OauthKeysResponder = typeof oauthKeysResponder & KoaRuntimeResponder

const oauthKeysResponseValidator = responseValidationFactory(
  [
    ["200", s_OAuthKeys],
    ["429", s_Error],
  ],
  undefined,
)

export type OauthKeys = (
  params: Params<void, t_OauthKeysQuerySchema, void, void>,
  respond: OauthKeysResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthKeys>
  | Response<429, t_Error>
>

const logoutResponder = {
  with200: r.with200<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type LogoutResponder = typeof logoutResponder & KoaRuntimeResponder

const logoutResponseValidator = responseValidationFactory(
  [
    ["200", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type Logout = (
  params: Params<void, t_LogoutQuerySchema, void, void>,
  respond: LogoutResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const logoutWithPostResponder = {
  with200: r.with200<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type LogoutWithPostResponder = typeof logoutWithPostResponder &
  KoaRuntimeResponder

const logoutWithPostResponseValidator = responseValidationFactory(
  [
    ["200", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type LogoutWithPost = (
  params: Params<void, void, t_LogoutWithPostBodySchema, void>,
  respond: LogoutWithPostResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const oobAuthenticateResponder = {
  with200: r.with200<t_OobAuthenticateResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with403: r.with403<t_OAuthError>,
  with429: r.with429<t_OAuthError>,
  withStatus: r.withStatus,
}

type OobAuthenticateResponder = typeof oobAuthenticateResponder &
  KoaRuntimeResponder

const oobAuthenticateResponseValidator = responseValidationFactory(
  [
    ["200", s_OobAuthenticateResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["403", s_OAuthError],
    ["429", s_OAuthError],
  ],
  undefined,
)

export type OobAuthenticate = (
  params: Params<void, void, t_OobAuthenticateBodySchema, void>,
  respond: OobAuthenticateResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OobAuthenticateResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const parOptionsResponder = {
  with204: r.with204<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type ParOptionsResponder = typeof parOptionsResponder & KoaRuntimeResponder

const parOptionsResponseValidator = responseValidationFactory(
  [
    ["204", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type ParOptions = (
  params: Params<void, void, void, t_ParOptionsHeaderSchema>,
  respond: ParOptionsResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const parResponder = {
  with200: r.with200<t_ParResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with403: r.with403<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type ParResponder = typeof parResponder & KoaRuntimeResponder

const parResponseValidator = responseValidationFactory(
  [
    ["200", s_ParResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["403", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type Par = (
  params: Params<void, void, t_ParBodySchema, void>,
  respond: ParResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ParResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_Error>
>

const revokeResponder = {
  with200: r.with200<void>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type RevokeResponder = typeof revokeResponder & KoaRuntimeResponder

const revokeResponseValidator = responseValidationFactory(
  [
    ["200", z.undefined()],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type Revoke = (
  params: Params<void, void, t_RevokeBodySchema, void>,
  respond: RevokeResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const tokenOptionsResponder = {
  with204: r.with204<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type TokenOptionsResponder = typeof tokenOptionsResponder & KoaRuntimeResponder

const tokenOptionsResponseValidator = responseValidationFactory(
  [
    ["204", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type TokenOptions = (
  params: Params<void, void, void, t_TokenOptionsHeaderSchema>,
  respond: TokenOptionsResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const tokenResponder = {
  with200: r.with200<t_TokenResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type TokenResponder = typeof tokenResponder & KoaRuntimeResponder

const tokenResponseValidator = responseValidationFactory(
  [
    ["200", s_TokenResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type Token = (
  params: Params<void, void, t_TokenBodySchema, void>,
  respond: TokenResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_TokenResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const userinfoResponder = {
  with200: r.with200<t_UserInfo>,
  with401: r.with401<void>,
  with403: r.with403<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type UserinfoResponder = typeof userinfoResponder & KoaRuntimeResponder

const userinfoResponseValidator = responseValidationFactory(
  [
    ["200", s_UserInfo],
    ["401", z.undefined()],
    ["403", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type Userinfo = (
  params: Params<void, void, void, void>,
  respond: UserinfoResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_UserInfo>
  | Response<401, void>
  | Response<403, void>
  | Response<429, t_Error>
>

const getWellKnownOAuthConfigurationCustomAsResponder = {
  with200: r.with200<t_OAuthMetadata>,
  with400: r.with400<t_Error>,
  with404: r.with404<t_Error>,
  withStatus: r.withStatus,
}

type GetWellKnownOAuthConfigurationCustomAsResponder =
  typeof getWellKnownOAuthConfigurationCustomAsResponder & KoaRuntimeResponder

const getWellKnownOAuthConfigurationCustomAsResponseValidator =
  responseValidationFactory(
    [
      ["200", s_OAuthMetadata],
      ["400", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

export type GetWellKnownOAuthConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
    t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOAuthConfigurationCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthMetadata>
  | Response<400, t_Error>
  | Response<404, t_Error>
>

const getWellKnownOpenIdConfigurationCustomAsResponder = {
  with200: r.with200<t_OidcMetadata>,
  with400: r.with400<t_Error>,
  with404: r.with404<t_Error>,
  withStatus: r.withStatus,
}

type GetWellKnownOpenIdConfigurationCustomAsResponder =
  typeof getWellKnownOpenIdConfigurationCustomAsResponder & KoaRuntimeResponder

const getWellKnownOpenIdConfigurationCustomAsResponseValidator =
  responseValidationFactory(
    [
      ["200", s_OidcMetadata],
      ["400", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

export type GetWellKnownOpenIdConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
    t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OidcMetadata>
  | Response<400, t_Error>
  | Response<404, t_Error>
>

const authorizeCustomAsResponder = {
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type AuthorizeCustomAsResponder = typeof authorizeCustomAsResponder &
  KoaRuntimeResponder

const authorizeCustomAsResponseValidator = responseValidationFactory(
  [["429", s_Error]],
  undefined,
)

export type AuthorizeCustomAs = (
  params: Params<
    t_AuthorizeCustomAsParamSchema,
    t_AuthorizeCustomAsQuerySchema,
    void,
    void
  >,
  respond: AuthorizeCustomAsResponder,
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const authorizeCustomAsWithPostResponder = {
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type AuthorizeCustomAsWithPostResponder =
  typeof authorizeCustomAsWithPostResponder & KoaRuntimeResponder

const authorizeCustomAsWithPostResponseValidator = responseValidationFactory(
  [["429", s_Error]],
  undefined,
)

export type AuthorizeCustomAsWithPost = (
  params: Params<
    t_AuthorizeCustomAsWithPostParamSchema,
    void,
    t_AuthorizeCustomAsWithPostBodySchema,
    void
  >,
  respond: AuthorizeCustomAsWithPostResponder,
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const bcAuthorizeCustomAsResponder = {
  with200: r.with200<t_BackchannelAuthorizeResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type BcAuthorizeCustomAsResponder = typeof bcAuthorizeCustomAsResponder &
  KoaRuntimeResponder

const bcAuthorizeCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_BackchannelAuthorizeResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type BcAuthorizeCustomAs = (
  params: Params<
    t_BcAuthorizeCustomAsParamSchema,
    void,
    t_BcAuthorizeCustomAsBodySchema,
    void
  >,
  respond: BcAuthorizeCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_BackchannelAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const challengeCustomAsResponder = {
  with200: r.with200<t_ChallengeResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with403: r.with403<t_OAuthError>,
  with429: r.with429<t_OAuthError>,
  withStatus: r.withStatus,
}

type ChallengeCustomAsResponder = typeof challengeCustomAsResponder &
  KoaRuntimeResponder

const challengeCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_ChallengeResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["403", s_OAuthError],
    ["429", s_OAuthError],
  ],
  undefined,
)

export type ChallengeCustomAs = (
  params: Params<
    t_ChallengeCustomAsParamSchema,
    void,
    t_ChallengeCustomAsBodySchema,
    void
  >,
  respond: ChallengeCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ChallengeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const deviceAuthorizeCustomAsResponder = {
  with200: r.with200<t_DeviceAuthorizeResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type DeviceAuthorizeCustomAsResponder =
  typeof deviceAuthorizeCustomAsResponder & KoaRuntimeResponder

const deviceAuthorizeCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_DeviceAuthorizeResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type DeviceAuthorizeCustomAs = (
  params: Params<
    t_DeviceAuthorizeCustomAsParamSchema,
    void,
    t_DeviceAuthorizeCustomAsBodySchema,
    void
  >,
  respond: DeviceAuthorizeCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_DeviceAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const introspectCustomAsResponder = {
  with200: r.with200<t_IntrospectionResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type IntrospectCustomAsResponder = typeof introspectCustomAsResponder &
  KoaRuntimeResponder

const introspectCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_IntrospectionResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type IntrospectCustomAs = (
  params: Params<
    t_IntrospectCustomAsParamSchema,
    void,
    t_IntrospectCustomAsBodySchema,
    void
  >,
  respond: IntrospectCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_IntrospectionResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const oauthKeysCustomAsResponder = {
  with200: r.with200<t_OAuthKeys>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type OauthKeysCustomAsResponder = typeof oauthKeysCustomAsResponder &
  KoaRuntimeResponder

const oauthKeysCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_OAuthKeys],
    ["429", s_Error],
  ],
  undefined,
)

export type OauthKeysCustomAs = (
  params: Params<t_OauthKeysCustomAsParamSchema, void, void, void>,
  respond: OauthKeysCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthKeys>
  | Response<429, t_Error>
>

const logoutCustomAsResponder = {
  with200: r.with200<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type LogoutCustomAsResponder = typeof logoutCustomAsResponder &
  KoaRuntimeResponder

const logoutCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type LogoutCustomAs = (
  params: Params<
    t_LogoutCustomAsParamSchema,
    t_LogoutCustomAsQuerySchema,
    void,
    void
  >,
  respond: LogoutCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const logoutCustomAsWithPostResponder = {
  with200: r.with200<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type LogoutCustomAsWithPostResponder = typeof logoutCustomAsWithPostResponder &
  KoaRuntimeResponder

const logoutCustomAsWithPostResponseValidator = responseValidationFactory(
  [
    ["200", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type LogoutCustomAsWithPost = (
  params: Params<
    t_LogoutCustomAsWithPostParamSchema,
    void,
    t_LogoutCustomAsWithPostBodySchema,
    void
  >,
  respond: LogoutCustomAsWithPostResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const oobAuthenticateCustomAsResponder = {
  with200: r.with200<t_OobAuthenticateResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with403: r.with403<t_OAuthError>,
  with429: r.with429<t_OAuthError>,
  withStatus: r.withStatus,
}

type OobAuthenticateCustomAsResponder =
  typeof oobAuthenticateCustomAsResponder & KoaRuntimeResponder

const oobAuthenticateCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_OobAuthenticateResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["403", s_OAuthError],
    ["429", s_OAuthError],
  ],
  undefined,
)

export type OobAuthenticateCustomAs = (
  params: Params<
    t_OobAuthenticateCustomAsParamSchema,
    void,
    t_OobAuthenticateCustomAsBodySchema,
    void
  >,
  respond: OobAuthenticateCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OobAuthenticateResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const parOptionsCustomAsResponder = {
  with204: r.with204<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type ParOptionsCustomAsResponder = typeof parOptionsCustomAsResponder &
  KoaRuntimeResponder

const parOptionsCustomAsResponseValidator = responseValidationFactory(
  [
    ["204", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type ParOptionsCustomAs = (
  params: Params<
    t_ParOptionsCustomAsParamSchema,
    void,
    void,
    t_ParOptionsCustomAsHeaderSchema
  >,
  respond: ParOptionsCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const parCustomAsResponder = {
  with200: r.with200<t_ParResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with403: r.with403<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type ParCustomAsResponder = typeof parCustomAsResponder & KoaRuntimeResponder

const parCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_ParResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["403", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type ParCustomAs = (
  params: Params<t_ParCustomAsParamSchema, void, t_ParCustomAsBodySchema, void>,
  respond: ParCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ParResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_Error>
>

const revokeCustomAsResponder = {
  with200: r.with200<void>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type RevokeCustomAsResponder = typeof revokeCustomAsResponder &
  KoaRuntimeResponder

const revokeCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", z.undefined()],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type RevokeCustomAs = (
  params: Params<
    t_RevokeCustomAsParamSchema,
    void,
    t_RevokeCustomAsBodySchema,
    void
  >,
  respond: RevokeCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const tokenOptionsCustomAsResponder = {
  with204: r.with204<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type TokenOptionsCustomAsResponder = typeof tokenOptionsCustomAsResponder &
  KoaRuntimeResponder

const tokenOptionsCustomAsResponseValidator = responseValidationFactory(
  [
    ["204", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type TokenOptionsCustomAs = (
  params: Params<
    t_TokenOptionsCustomAsParamSchema,
    void,
    void,
    t_TokenOptionsCustomAsHeaderSchema
  >,
  respond: TokenOptionsCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const tokenCustomAsResponder = {
  with200: r.with200<t_TokenResponse>,
  with400: r.with400<t_OAuthError>,
  with401: r.with401<t_OAuthError>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type TokenCustomAsResponder = typeof tokenCustomAsResponder &
  KoaRuntimeResponder

const tokenCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_TokenResponse],
    ["400", s_OAuthError],
    ["401", s_OAuthError],
    ["429", s_Error],
  ],
  undefined,
)

export type TokenCustomAs = (
  params: Params<
    t_TokenCustomAsParamSchema,
    void,
    t_TokenCustomAsBodySchema,
    void
  >,
  respond: TokenCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_TokenResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const userinfoCustomAsResponder = {
  with200: r.with200<t_UserInfo>,
  with401: r.with401<void>,
  with403: r.with403<void>,
  with429: r.with429<t_Error>,
  withStatus: r.withStatus,
}

type UserinfoCustomAsResponder = typeof userinfoCustomAsResponder &
  KoaRuntimeResponder

const userinfoCustomAsResponseValidator = responseValidationFactory(
  [
    ["200", s_UserInfo],
    ["401", z.undefined()],
    ["403", z.undefined()],
    ["429", s_Error],
  ],
  undefined,
)

export type UserinfoCustomAs = (
  params: Params<t_UserinfoCustomAsParamSchema, void, void, void>,
  respond: UserinfoCustomAsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_UserInfo>
  | Response<401, void>
  | Response<403, void>
  | Response<429, t_Error>
>

export type Implementation = {
  getWellKnownOpenIdConfiguration: GetWellKnownOpenIdConfiguration
  authorize: Authorize
  authorizeWithPost: AuthorizeWithPost
  bcAuthorize: BcAuthorize
  challenge: Challenge
  listClients: ListClients
  createClient: CreateClient
  getClient: GetClient
  replaceClient: ReplaceClient
  deleteClient: DeleteClient
  generateNewClientSecret: GenerateNewClientSecret
  deviceAuthorize: DeviceAuthorize
  globalTokenRevocation: GlobalTokenRevocation
  introspect: Introspect
  oauthKeys: OauthKeys
  logout: Logout
  logoutWithPost: LogoutWithPost
  oobAuthenticate: OobAuthenticate
  parOptions: ParOptions
  par: Par
  revoke: Revoke
  tokenOptions: TokenOptions
  token: Token
  userinfo: Userinfo
  getWellKnownOAuthConfigurationCustomAs: GetWellKnownOAuthConfigurationCustomAs
  getWellKnownOpenIdConfigurationCustomAs: GetWellKnownOpenIdConfigurationCustomAs
  authorizeCustomAs: AuthorizeCustomAs
  authorizeCustomAsWithPost: AuthorizeCustomAsWithPost
  bcAuthorizeCustomAs: BcAuthorizeCustomAs
  challengeCustomAs: ChallengeCustomAs
  deviceAuthorizeCustomAs: DeviceAuthorizeCustomAs
  introspectCustomAs: IntrospectCustomAs
  oauthKeysCustomAs: OauthKeysCustomAs
  logoutCustomAs: LogoutCustomAs
  logoutCustomAsWithPost: LogoutCustomAsWithPost
  oobAuthenticateCustomAs: OobAuthenticateCustomAs
  parOptionsCustomAs: ParOptionsCustomAs
  parCustomAs: ParCustomAs
  revokeCustomAs: RevokeCustomAs
  tokenOptionsCustomAs: TokenOptionsCustomAs
  tokenCustomAs: TokenCustomAs
  userinfoCustomAs: UserinfoCustomAs
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const getWellKnownOpenIdConfigurationQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  router.get(
    "getWellKnownOpenIdConfiguration",
    "/.well-known/openid-configuration",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getWellKnownOpenIdConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .getWellKnownOpenIdConfiguration(
          input,
          getWellKnownOpenIdConfigurationResponder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOpenIdConfigurationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const authorizeQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  router.get("authorize", "/oauth2/v1/authorize", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        authorizeQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .authorize(input, authorizeResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = authorizeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const authorizeWithPostBodySchema = s_AuthorizeWithPost

  router.post(
    "authorizeWithPost",
    "/oauth2/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          authorizeWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .authorizeWithPost(input, authorizeWithPostResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeWithPostResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const bcAuthorizeBodySchema = s_BackchannelAuthorizeRequest

  router.post("bcAuthorize", "/oauth2/v1/bc/authorize", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        bcAuthorizeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .bcAuthorize(input, bcAuthorizeResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = bcAuthorizeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const challengeBodySchema = s_ChallengeRequest

  router.post("challenge", "/oauth2/v1/challenge", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        challengeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .challenge(input, challengeResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = challengeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const listClientsQuerySchema = z.object({
    after: z.string().optional(),
    limit: z.coerce.number().min(1).max(200).optional().default(20),
    q: z.string().optional(),
  })

  router.get("listClients", "/oauth2/v1/clients", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        listClientsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .listClients(input, listClientsResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = listClientsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createClientBodySchema = s_Client

  router.post("createClient", "/oauth2/v1/clients", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        createClientBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .createClient(input, createClientResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = createClientResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getClientParamSchema = z.object({ clientId: z.string() })

  router.get("getClient", "/oauth2/v1/clients/:clientId", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getClientParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .getClient(input, getClientResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getClientResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const replaceClientParamSchema = z.object({ clientId: z.string() })

  const replaceClientBodySchema = s_Client

  router.put(
    "replaceClient",
    "/oauth2/v1/clients/:clientId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          replaceClientParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          replaceClientBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .replaceClient(input, replaceClientResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = replaceClientResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteClientParamSchema = z.object({ clientId: z.string() })

  router.delete(
    "deleteClient",
    "/oauth2/v1/clients/:clientId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteClientParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .deleteClient(input, deleteClientResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteClientResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const generateNewClientSecretParamSchema = z.object({ clientId: z.string() })

  router.post(
    "generateNewClientSecret",
    "/oauth2/v1/clients/:clientId/lifecycle/newSecret",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          generateNewClientSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .generateNewClientSecret(input, generateNewClientSecretResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = generateNewClientSecretResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deviceAuthorizeBodySchema = s_DeviceAuthorizeRequest

  router.post(
    "deviceAuthorize",
    "/oauth2/v1/device/authorize",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          deviceAuthorizeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deviceAuthorize(input, deviceAuthorizeResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deviceAuthorizeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const globalTokenRevocationBodySchema = s_GlobalTokenRevocationRequest

  router.post(
    "globalTokenRevocation",
    "/oauth2/v1/global-token-revocation",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          globalTokenRevocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .globalTokenRevocation(input, globalTokenRevocationResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = globalTokenRevocationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const introspectBodySchema = s_IntrospectionRequest

  router.post("introspect", "/oauth2/v1/introspect", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        introspectBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .introspect(input, introspectResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = introspectResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const oauthKeysQuerySchema = z.object({ client_id: z.string().optional() })

  router.get("oauthKeys", "/oauth2/v1/keys", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        oauthKeysQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .oauthKeys(input, oauthKeysResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = oauthKeysResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const logoutQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  router.get("logout", "/oauth2/v1/logout", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        logoutQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .logout(input, logoutResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = logoutResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const logoutWithPostBodySchema = s_LogoutWithPost

  router.post("logoutWithPost", "/oauth2/v1/logout", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        logoutWithPostBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .logoutWithPost(input, logoutWithPostResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = logoutWithPostResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const oobAuthenticateBodySchema = s_OobAuthenticateRequest

  router.post(
    "oobAuthenticate",
    "/oauth2/v1/oob-authenticate",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          oobAuthenticateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .oobAuthenticate(input, oobAuthenticateResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oobAuthenticateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parOptionsHeaderSchema = z.object({ origin: z.string().optional() })

  router.options("parOptions", "/oauth2/v1/par", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: parseRequestInput(
        parOptionsHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const response = await implementation
      .parOptions(input, parOptionsResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = parOptionsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const parBodySchema = s_ParRequest

  router.post("par", "/oauth2/v1/par", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        parBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .par(input, parResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = parResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const revokeBodySchema = s_RevokeRequest

  router.post("revoke", "/oauth2/v1/revoke", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        revokeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .revoke(input, revokeResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = revokeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const tokenOptionsHeaderSchema = z.object({ origin: z.string().optional() })

  router.options("tokenOptions", "/oauth2/v1/token", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: parseRequestInput(
        tokenOptionsHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const response = await implementation
      .tokenOptions(input, tokenOptionsResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = tokenOptionsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const tokenBodySchema = s_TokenRequest

  router.post("token", "/oauth2/v1/token", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        tokenBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .token(input, tokenResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = tokenResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  router.get("userinfo", "/oauth2/v1/userinfo", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .userinfo(input, userinfoResponder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = userinfoResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getWellKnownOAuthConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOAuthConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  router.get(
    "getWellKnownOAuthConfigurationCustomAs",
    "/oauth2/:authorizationServerId/.well-known/oauth-authorization-server",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWellKnownOAuthConfigurationCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWellKnownOAuthConfigurationCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .getWellKnownOAuthConfigurationCustomAs(
          input,
          getWellKnownOAuthConfigurationCustomAsResponder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOAuthConfigurationCustomAsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getWellKnownOpenIdConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOpenIdConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  router.get(
    "getWellKnownOpenIdConfigurationCustomAs",
    "/oauth2/:authorizationServerId/.well-known/openid-configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWellKnownOpenIdConfigurationCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWellKnownOpenIdConfigurationCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .getWellKnownOpenIdConfigurationCustomAs(
          input,
          getWellKnownOpenIdConfigurationCustomAsResponder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOpenIdConfigurationCustomAsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const authorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  router.get(
    "authorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          authorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          authorizeCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .authorizeCustomAs(input, authorizeCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const authorizeCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsWithPostBodySchema = s_AuthorizeWithPost

  router.post(
    "authorizeCustomAsWithPost",
    "/oauth2/:authorizationServerId/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          authorizeCustomAsWithPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          authorizeCustomAsWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .authorizeCustomAsWithPost(
          input,
          authorizeCustomAsWithPostResponder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeCustomAsWithPostResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const bcAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const bcAuthorizeCustomAsBodySchema = s_BackchannelAuthorizeRequest

  router.post(
    "bcAuthorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/bc/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          bcAuthorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          bcAuthorizeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .bcAuthorizeCustomAs(input, bcAuthorizeCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = bcAuthorizeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const challengeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const challengeCustomAsBodySchema = s_ChallengeRequest

  router.post(
    "challengeCustomAs",
    "/oauth2/:authorizationServerId/v1/challenge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          challengeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          challengeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .challengeCustomAs(input, challengeCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = challengeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deviceAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const deviceAuthorizeCustomAsBodySchema = s_DeviceAuthorizeRequest

  router.post(
    "deviceAuthorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/device/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deviceAuthorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deviceAuthorizeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deviceAuthorizeCustomAs(input, deviceAuthorizeCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deviceAuthorizeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const introspectCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const introspectCustomAsBodySchema = s_IntrospectionRequest

  router.post(
    "introspectCustomAs",
    "/oauth2/:authorizationServerId/v1/introspect",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          introspectCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          introspectCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .introspectCustomAs(input, introspectCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = introspectCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oauthKeysCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  router.get(
    "oauthKeysCustomAs",
    "/oauth2/:authorizationServerId/v1/keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oauthKeysCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .oauthKeysCustomAs(input, oauthKeysCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oauthKeysCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const logoutCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  router.get(
    "logoutCustomAs",
    "/oauth2/:authorizationServerId/v1/logout",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          logoutCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          logoutCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .logoutCustomAs(input, logoutCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = logoutCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const logoutCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsWithPostBodySchema = s_LogoutWithPost

  router.post(
    "logoutCustomAsWithPost",
    "/oauth2/:authorizationServerId/v1/logout",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          logoutCustomAsWithPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          logoutCustomAsWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .logoutCustomAsWithPost(input, logoutCustomAsWithPostResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = logoutCustomAsWithPostResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oobAuthenticateCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oobAuthenticateCustomAsBodySchema = s_OobAuthenticateRequest

  router.post(
    "oobAuthenticateCustomAs",
    "/oauth2/:authorizationServerId/v1/oob-authenticate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oobAuthenticateCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          oobAuthenticateCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .oobAuthenticateCustomAs(input, oobAuthenticateCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oobAuthenticateCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const parOptionsCustomAsHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  router.options(
    "parOptionsCustomAs",
    "/oauth2/:authorizationServerId/v1/par",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          parOptionsCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: parseRequestInput(
          parOptionsCustomAsHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const response = await implementation
        .parOptionsCustomAs(input, parOptionsCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = parOptionsCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parCustomAsParamSchema = z.object({ authorizationServerId: z.string() })

  const parCustomAsBodySchema = s_ParRequest

  router.post(
    "parCustomAs",
    "/oauth2/:authorizationServerId/v1/par",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          parCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          parCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .parCustomAs(input, parCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = parCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const revokeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const revokeCustomAsBodySchema = s_RevokeRequest

  router.post(
    "revokeCustomAs",
    "/oauth2/:authorizationServerId/v1/revoke",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          revokeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          revokeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .revokeCustomAs(input, revokeCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = revokeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const tokenOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const tokenOptionsCustomAsHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  router.options(
    "tokenOptionsCustomAs",
    "/oauth2/:authorizationServerId/v1/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          tokenOptionsCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: parseRequestInput(
          tokenOptionsCustomAsHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const response = await implementation
        .tokenOptionsCustomAs(input, tokenOptionsCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = tokenOptionsCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const tokenCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const tokenCustomAsBodySchema = s_TokenRequest

  router.post(
    "tokenCustomAs",
    "/oauth2/:authorizationServerId/v1/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          tokenCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          tokenCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .tokenCustomAs(input, tokenCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = tokenCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const userinfoCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  router.get(
    "userinfoCustomAs",
    "/oauth2/:authorizationServerId/v1/userinfo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          userinfoCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .userinfoCustomAs(input, userinfoCustomAsResponder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = userinfoCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Okta OpenID Connect & OAuth 2.0
  return startServer(config)
}
