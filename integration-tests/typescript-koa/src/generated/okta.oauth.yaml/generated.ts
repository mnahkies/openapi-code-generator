/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import KoaRouter, {type RouterContext} from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  type KoaRuntimeResponder,
  KoaRuntimeResponse,
  type Params,
  type Response,
  type ServerConfig,
  SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod-v4"
import type {Next} from "koa"
import {z} from "zod/v4"
import type {
  t_AuthorizeCustomAsParamSchema,
  t_AuthorizeCustomAsQuerySchema,
  t_AuthorizeCustomAsWithPostBodySchema,
  t_AuthorizeCustomAsWithPostParamSchema,
  t_AuthorizeQuerySchema,
  t_AuthorizeWithPostBodySchema,
  t_BackchannelAuthorizeResponse,
  t_BcAuthorizeBodySchema,
  t_BcAuthorizeCustomAsBodySchema,
  t_BcAuthorizeCustomAsParamSchema,
  t_ChallengeBodySchema,
  t_ChallengeCustomAsBodySchema,
  t_ChallengeCustomAsParamSchema,
  t_ChallengeResponse,
  t_Client,
  t_CreateClientBodySchema,
  t_DeleteClientParamSchema,
  t_DeviceAuthorizeBodySchema,
  t_DeviceAuthorizeCustomAsBodySchema,
  t_DeviceAuthorizeCustomAsParamSchema,
  t_DeviceAuthorizeResponse,
  t_Error,
  t_GenerateNewClientSecretParamSchema,
  t_GetClientParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
  t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationQuerySchema,
  t_GlobalTokenRevocationBodySchema,
  t_IntrospectBodySchema,
  t_IntrospectCustomAsBodySchema,
  t_IntrospectCustomAsParamSchema,
  t_IntrospectionResponse,
  t_ListClientsQuerySchema,
  t_LogoutCustomAsParamSchema,
  t_LogoutCustomAsQuerySchema,
  t_LogoutCustomAsWithPostBodySchema,
  t_LogoutCustomAsWithPostParamSchema,
  t_LogoutQuerySchema,
  t_LogoutWithPostBodySchema,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OauthKeysCustomAsParamSchema,
  t_OauthKeysQuerySchema,
  t_OidcMetadata,
  t_OobAuthenticateBodySchema,
  t_OobAuthenticateCustomAsBodySchema,
  t_OobAuthenticateCustomAsParamSchema,
  t_OobAuthenticateResponse,
  t_ParBodySchema,
  t_ParCustomAsBodySchema,
  t_ParCustomAsParamSchema,
  t_ParOptionsCustomAsHeaderSchema,
  t_ParOptionsCustomAsParamSchema,
  t_ParOptionsHeaderSchema,
  t_ParResponse,
  t_ReplaceClientBodySchema,
  t_ReplaceClientParamSchema,
  t_RevokeBodySchema,
  t_RevokeCustomAsBodySchema,
  t_RevokeCustomAsParamSchema,
  t_TokenBodySchema,
  t_TokenCustomAsBodySchema,
  t_TokenCustomAsParamSchema,
  t_TokenOptionsCustomAsHeaderSchema,
  t_TokenOptionsCustomAsParamSchema,
  t_TokenOptionsHeaderSchema,
  t_TokenResponse,
  t_UserInfo,
  t_UserinfoCustomAsParamSchema,
} from "./models"
import {
  s_AcrValue,
  s_AmrValue,
  s_AuthorizeWithPost,
  s_BackchannelAuthorizeRequest,
  s_BackchannelAuthorizeResponse,
  s_ChallengeRequest,
  s_ChallengeResponse,
  s_Client,
  s_CodeChallengeMethod,
  s_DeviceAuthorizeRequest,
  s_DeviceAuthorizeResponse,
  s_Error,
  s_GlobalTokenRevocationRequest,
  s_IntrospectionRequest,
  s_IntrospectionResponse,
  s_LogoutWithPost,
  s_OAuthError,
  s_OAuthKeys,
  s_OAuthMetadata,
  s_OidcMetadata,
  s_OobAuthenticateRequest,
  s_OobAuthenticateResponse,
  s_ParRequest,
  s_ParResponse,
  s_Prompt,
  s_ResponseMode,
  s_ResponseTypesSupported,
  s_RevokeRequest,
  s_TokenRequest,
  s_TokenResponse,
  s_UserInfo,
} from "./schemas"

export type GetWellKnownOpenIdConfigurationResponder = {
  with200(): KoaRuntimeResponse<t_OidcMetadata>
  with400(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetWellKnownOpenIdConfiguration = (
  params: Params<
    void,
    t_GetWellKnownOpenIdConfigurationQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OidcMetadata>
  | Response<400, t_Error>
  | typeof SkipResponse
>

export type AuthorizeResponder = {
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type Authorize = (
  params: Params<void, t_AuthorizeQuerySchema, void, void>,
  respond: AuthorizeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<429, t_Error> | typeof SkipResponse
>

export type AuthorizeWithPostResponder = {
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type AuthorizeWithPost = (
  params: Params<void, void, t_AuthorizeWithPostBodySchema, void>,
  respond: AuthorizeWithPostResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<429, t_Error> | typeof SkipResponse
>

export type BcAuthorizeResponder = {
  with200(): KoaRuntimeResponse<t_BackchannelAuthorizeResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type BcAuthorize = (
  params: Params<void, void, t_BcAuthorizeBodySchema, void>,
  respond: BcAuthorizeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_BackchannelAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type ChallengeResponder = {
  with200(): KoaRuntimeResponse<t_ChallengeResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with403(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_OAuthError>
} & KoaRuntimeResponder

export type Challenge = (
  params: Params<void, void, t_ChallengeBodySchema, void>,
  respond: ChallengeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ChallengeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
  | typeof SkipResponse
>

export type ListClientsResponder = {
  with200(): KoaRuntimeResponse<t_Client[]>
  with403(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ListClients = (
  params: Params<void, t_ListClientsQuerySchema, void, void>,
  respond: ListClientsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client[]>
  | Response<403, t_Error>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type CreateClientResponder = {
  with201(): KoaRuntimeResponse<t_Client>
  with400(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type CreateClient = (
  params: Params<void, void, t_CreateClientBodySchema, void>,
  respond: CreateClientResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_Client>
  | Response<400, t_Error>
  | Response<403, t_Error>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type GetClientResponder = {
  with200(): KoaRuntimeResponse<t_Client>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetClient = (
  params: Params<t_GetClientParamSchema, void, void, void>,
  respond: GetClientResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type ReplaceClientResponder = {
  with200(): KoaRuntimeResponse<t_Client>
  with400(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ReplaceClient = (
  params: Params<
    t_ReplaceClientParamSchema,
    void,
    t_ReplaceClientBodySchema,
    void
  >,
  respond: ReplaceClientResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<400, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type DeleteClientResponder = {
  with204(): KoaRuntimeResponse<void>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeleteClient = (
  params: Params<t_DeleteClientParamSchema, void, void, void>,
  respond: DeleteClientResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type GenerateNewClientSecretResponder = {
  with200(): KoaRuntimeResponse<t_Client>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GenerateNewClientSecret = (
  params: Params<t_GenerateNewClientSecretParamSchema, void, void, void>,
  respond: GenerateNewClientSecretResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type DeviceAuthorizeResponder = {
  with200(): KoaRuntimeResponse<t_DeviceAuthorizeResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeviceAuthorize = (
  params: Params<void, void, t_DeviceAuthorizeBodySchema, void>,
  respond: DeviceAuthorizeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_DeviceAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type GlobalTokenRevocationResponder = {
  with204(): KoaRuntimeResponse<void>
  with400(): KoaRuntimeResponse<void>
  with403(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GlobalTokenRevocation = (
  params: Params<void, void, t_GlobalTokenRevocationBodySchema, void>,
  respond: GlobalTokenRevocationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, void>
  | Response<403, t_Error>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type IntrospectResponder = {
  with200(): KoaRuntimeResponse<t_IntrospectionResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type Introspect = (
  params: Params<void, void, t_IntrospectBodySchema, void>,
  respond: IntrospectResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_IntrospectionResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type OauthKeysResponder = {
  with200(): KoaRuntimeResponse<t_OAuthKeys>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type OauthKeys = (
  params: Params<void, t_OauthKeysQuerySchema, void, void>,
  respond: OauthKeysResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthKeys>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type LogoutResponder = {
  with200(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type Logout = (
  params: Params<void, t_LogoutQuerySchema, void, void>,
  respond: LogoutResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type LogoutWithPostResponder = {
  with200(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type LogoutWithPost = (
  params: Params<void, void, t_LogoutWithPostBodySchema, void>,
  respond: LogoutWithPostResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type OobAuthenticateResponder = {
  with200(): KoaRuntimeResponse<t_OobAuthenticateResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with403(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_OAuthError>
} & KoaRuntimeResponder

export type OobAuthenticate = (
  params: Params<void, void, t_OobAuthenticateBodySchema, void>,
  respond: OobAuthenticateResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OobAuthenticateResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
  | typeof SkipResponse
>

export type ParOptionsResponder = {
  with204(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ParOptions = (
  params: Params<void, void, void, t_ParOptionsHeaderSchema>,
  respond: ParOptionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type ParResponder = {
  with200(): KoaRuntimeResponse<t_ParResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with403(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type Par = (
  params: Params<void, void, t_ParBodySchema, void>,
  respond: ParResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ParResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type RevokeResponder = {
  with200(): KoaRuntimeResponse<void>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type Revoke = (
  params: Params<void, void, t_RevokeBodySchema, void>,
  respond: RevokeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type TokenOptionsResponder = {
  with204(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type TokenOptions = (
  params: Params<void, void, void, t_TokenOptionsHeaderSchema>,
  respond: TokenOptionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type TokenResponder = {
  with200(): KoaRuntimeResponse<t_TokenResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type Token = (
  params: Params<void, void, t_TokenBodySchema, void>,
  respond: TokenResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_TokenResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type UserinfoResponder = {
  with200(): KoaRuntimeResponse<t_UserInfo>
  with401(): KoaRuntimeResponse<void>
  with403(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type Userinfo = (
  params: Params<void, void, void, void>,
  respond: UserinfoResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_UserInfo>
  | Response<401, void>
  | Response<403, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type GetWellKnownOAuthConfigurationCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_OAuthMetadata>
  with400(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetWellKnownOAuthConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
    t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOAuthConfigurationCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthMetadata>
  | Response<400, t_Error>
  | Response<404, t_Error>
  | typeof SkipResponse
>

export type GetWellKnownOpenIdConfigurationCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_OidcMetadata>
  with400(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetWellKnownOpenIdConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
    t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OidcMetadata>
  | Response<400, t_Error>
  | Response<404, t_Error>
  | typeof SkipResponse
>

export type AuthorizeCustomAsResponder = {
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type AuthorizeCustomAs = (
  params: Params<
    t_AuthorizeCustomAsParamSchema,
    t_AuthorizeCustomAsQuerySchema,
    void,
    void
  >,
  respond: AuthorizeCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<429, t_Error> | typeof SkipResponse
>

export type AuthorizeCustomAsWithPostResponder = {
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type AuthorizeCustomAsWithPost = (
  params: Params<
    t_AuthorizeCustomAsWithPostParamSchema,
    void,
    t_AuthorizeCustomAsWithPostBodySchema,
    void
  >,
  respond: AuthorizeCustomAsWithPostResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<429, t_Error> | typeof SkipResponse
>

export type BcAuthorizeCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_BackchannelAuthorizeResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type BcAuthorizeCustomAs = (
  params: Params<
    t_BcAuthorizeCustomAsParamSchema,
    void,
    t_BcAuthorizeCustomAsBodySchema,
    void
  >,
  respond: BcAuthorizeCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_BackchannelAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type ChallengeCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_ChallengeResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with403(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_OAuthError>
} & KoaRuntimeResponder

export type ChallengeCustomAs = (
  params: Params<
    t_ChallengeCustomAsParamSchema,
    void,
    t_ChallengeCustomAsBodySchema,
    void
  >,
  respond: ChallengeCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ChallengeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
  | typeof SkipResponse
>

export type DeviceAuthorizeCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_DeviceAuthorizeResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeviceAuthorizeCustomAs = (
  params: Params<
    t_DeviceAuthorizeCustomAsParamSchema,
    void,
    t_DeviceAuthorizeCustomAsBodySchema,
    void
  >,
  respond: DeviceAuthorizeCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_DeviceAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type IntrospectCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_IntrospectionResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type IntrospectCustomAs = (
  params: Params<
    t_IntrospectCustomAsParamSchema,
    void,
    t_IntrospectCustomAsBodySchema,
    void
  >,
  respond: IntrospectCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_IntrospectionResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type OauthKeysCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_OAuthKeys>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type OauthKeysCustomAs = (
  params: Params<t_OauthKeysCustomAsParamSchema, void, void, void>,
  respond: OauthKeysCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthKeys>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type LogoutCustomAsResponder = {
  with200(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type LogoutCustomAs = (
  params: Params<
    t_LogoutCustomAsParamSchema,
    t_LogoutCustomAsQuerySchema,
    void,
    void
  >,
  respond: LogoutCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type LogoutCustomAsWithPostResponder = {
  with200(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type LogoutCustomAsWithPost = (
  params: Params<
    t_LogoutCustomAsWithPostParamSchema,
    void,
    t_LogoutCustomAsWithPostBodySchema,
    void
  >,
  respond: LogoutCustomAsWithPostResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type OobAuthenticateCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_OobAuthenticateResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with403(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_OAuthError>
} & KoaRuntimeResponder

export type OobAuthenticateCustomAs = (
  params: Params<
    t_OobAuthenticateCustomAsParamSchema,
    void,
    t_OobAuthenticateCustomAsBodySchema,
    void
  >,
  respond: OobAuthenticateCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OobAuthenticateResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
  | typeof SkipResponse
>

export type ParOptionsCustomAsResponder = {
  with204(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ParOptionsCustomAs = (
  params: Params<
    t_ParOptionsCustomAsParamSchema,
    void,
    void,
    t_ParOptionsCustomAsHeaderSchema
  >,
  respond: ParOptionsCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type ParCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_ParResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with403(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ParCustomAs = (
  params: Params<t_ParCustomAsParamSchema, void, t_ParCustomAsBodySchema, void>,
  respond: ParCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ParResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type RevokeCustomAsResponder = {
  with200(): KoaRuntimeResponse<void>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type RevokeCustomAs = (
  params: Params<
    t_RevokeCustomAsParamSchema,
    void,
    t_RevokeCustomAsBodySchema,
    void
  >,
  respond: RevokeCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type TokenOptionsCustomAsResponder = {
  with204(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type TokenOptionsCustomAs = (
  params: Params<
    t_TokenOptionsCustomAsParamSchema,
    void,
    void,
    t_TokenOptionsCustomAsHeaderSchema
  >,
  respond: TokenOptionsCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type TokenCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_TokenResponse>
  with400(): KoaRuntimeResponse<t_OAuthError>
  with401(): KoaRuntimeResponse<t_OAuthError>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type TokenCustomAs = (
  params: Params<
    t_TokenCustomAsParamSchema,
    void,
    t_TokenCustomAsBodySchema,
    void
  >,
  respond: TokenCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_TokenResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type UserinfoCustomAsResponder = {
  with200(): KoaRuntimeResponse<t_UserInfo>
  with401(): KoaRuntimeResponse<void>
  with403(): KoaRuntimeResponse<void>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type UserinfoCustomAs = (
  params: Params<t_UserinfoCustomAsParamSchema, void, void, void>,
  respond: UserinfoCustomAsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_UserInfo>
  | Response<401, void>
  | Response<403, void>
  | Response<429, t_Error>
  | typeof SkipResponse
>

export type Implementation = {
  getWellKnownOpenIdConfiguration: GetWellKnownOpenIdConfiguration
  authorize: Authorize
  authorizeWithPost: AuthorizeWithPost
  bcAuthorize: BcAuthorize
  challenge: Challenge
  listClients: ListClients
  createClient: CreateClient
  getClient: GetClient
  replaceClient: ReplaceClient
  deleteClient: DeleteClient
  generateNewClientSecret: GenerateNewClientSecret
  deviceAuthorize: DeviceAuthorize
  globalTokenRevocation: GlobalTokenRevocation
  introspect: Introspect
  oauthKeys: OauthKeys
  logout: Logout
  logoutWithPost: LogoutWithPost
  oobAuthenticate: OobAuthenticate
  parOptions: ParOptions
  par: Par
  revoke: Revoke
  tokenOptions: TokenOptions
  token: Token
  userinfo: Userinfo
  getWellKnownOAuthConfigurationCustomAs: GetWellKnownOAuthConfigurationCustomAs
  getWellKnownOpenIdConfigurationCustomAs: GetWellKnownOpenIdConfigurationCustomAs
  authorizeCustomAs: AuthorizeCustomAs
  authorizeCustomAsWithPost: AuthorizeCustomAsWithPost
  bcAuthorizeCustomAs: BcAuthorizeCustomAs
  challengeCustomAs: ChallengeCustomAs
  deviceAuthorizeCustomAs: DeviceAuthorizeCustomAs
  introspectCustomAs: IntrospectCustomAs
  oauthKeysCustomAs: OauthKeysCustomAs
  logoutCustomAs: LogoutCustomAs
  logoutCustomAsWithPost: LogoutCustomAsWithPost
  oobAuthenticateCustomAs: OobAuthenticateCustomAs
  parOptionsCustomAs: ParOptionsCustomAs
  parCustomAs: ParCustomAs
  revokeCustomAs: RevokeCustomAs
  tokenOptionsCustomAs: TokenOptionsCustomAs
  tokenCustomAs: TokenCustomAs
  userinfoCustomAs: UserinfoCustomAs
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const getWellKnownOpenIdConfigurationQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOpenIdConfigurationResponseValidator =
    responseValidationFactory(
      [
        ["200", s_OidcMetadata],
        ["400", s_Error],
      ],
      undefined,
    )

  router.get(
    "getWellKnownOpenIdConfiguration",
    "/.well-known/openid-configuration",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getWellKnownOpenIdConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_OidcMetadata>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getWellKnownOpenIdConfiguration(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOpenIdConfigurationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const authorizeQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  const authorizeResponseValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  router.get("authorize", "/oauth2/v1/authorize", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        authorizeQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .authorize(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = authorizeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const authorizeWithPostBodySchema = s_AuthorizeWithPost

  const authorizeWithPostResponseValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  router.post(
    "authorizeWithPost",
    "/oauth2/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          authorizeWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .authorizeWithPost(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeWithPostResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const bcAuthorizeBodySchema = s_BackchannelAuthorizeRequest

  const bcAuthorizeResponseValidator = responseValidationFactory(
    [
      ["200", s_BackchannelAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post("bcAuthorize", "/oauth2/v1/bc/authorize", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        bcAuthorizeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_BackchannelAuthorizeResponse>(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_OAuthError>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_OAuthError>(401)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .bcAuthorize(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = bcAuthorizeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const challengeBodySchema = s_ChallengeRequest

  const challengeResponseValidator = responseValidationFactory(
    [
      ["200", s_ChallengeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  router.post("challenge", "/oauth2/v1/challenge", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        challengeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_ChallengeResponse>(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_OAuthError>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_OAuthError>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_OAuthError>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_OAuthError>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .challenge(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = challengeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const listClientsQuerySchema = z.object({
    after: z.string().optional(),
    limit: z.coerce.number().min(1).max(200).optional().default(20),
    q: z.string().optional(),
  })

  const listClientsResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_Client)],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get("listClients", "/oauth2/v1/clients", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        listClientsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Client[]>(200)
      },
      with403() {
        return new KoaRuntimeResponse<t_Error>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .listClients(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = listClientsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createClientBodySchema = s_Client

  const createClientResponseValidator = responseValidationFactory(
    [
      ["201", s_Client],
      ["400", s_Error],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post("createClient", "/oauth2/v1/clients", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        createClientBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with201() {
        return new KoaRuntimeResponse<t_Client>(201)
      },
      with400() {
        return new KoaRuntimeResponse<t_Error>(400)
      },
      with403() {
        return new KoaRuntimeResponse<t_Error>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .createClient(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = createClientResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getClientParamSchema = z.object({clientId: z.string()})

  const getClientResponseValidator = responseValidationFactory(
    [
      ["200", s_Client],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get("getClient", "/oauth2/v1/clients/:clientId", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getClientParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Client>(200)
      },
      with403() {
        return new KoaRuntimeResponse<t_Error>(403)
      },
      with404() {
        return new KoaRuntimeResponse<t_Error>(404)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getClient(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getClientResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const replaceClientParamSchema = z.object({clientId: z.string()})

  const replaceClientBodySchema = s_Client

  const replaceClientResponseValidator = responseValidationFactory(
    [
      ["200", s_Client],
      ["400", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.put(
    "replaceClient",
    "/oauth2/v1/clients/:clientId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          replaceClientParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          replaceClientBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Client>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .replaceClient(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = replaceClientResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteClientParamSchema = z.object({clientId: z.string()})

  const deleteClientResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.delete(
    "deleteClient",
    "/oauth2/v1/clients/:clientId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteClientParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteClient(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteClientResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const generateNewClientSecretParamSchema = z.object({clientId: z.string()})

  const generateNewClientSecretResponseValidator = responseValidationFactory(
    [
      ["200", s_Client],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "generateNewClientSecret",
    "/oauth2/v1/clients/:clientId/lifecycle/newSecret",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          generateNewClientSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Client>(200)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .generateNewClientSecret(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = generateNewClientSecretResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deviceAuthorizeBodySchema = s_DeviceAuthorizeRequest

  const deviceAuthorizeResponseValidator = responseValidationFactory(
    [
      ["200", s_DeviceAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "deviceAuthorize",
    "/oauth2/v1/device/authorize",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          deviceAuthorizeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_DeviceAuthorizeResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deviceAuthorize(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deviceAuthorizeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const globalTokenRevocationBodySchema = s_GlobalTokenRevocationRequest

  const globalTokenRevocationResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", z.undefined()],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "globalTokenRevocation",
    "/oauth2/v1/global-token-revocation",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          globalTokenRevocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with400() {
          return new KoaRuntimeResponse<void>(400)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .globalTokenRevocation(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = globalTokenRevocationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const introspectBodySchema = s_IntrospectionRequest

  const introspectResponseValidator = responseValidationFactory(
    [
      ["200", s_IntrospectionResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post("introspect", "/oauth2/v1/introspect", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        introspectBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_IntrospectionResponse>(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_OAuthError>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_OAuthError>(401)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .introspect(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = introspectResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const oauthKeysQuerySchema = z.object({client_id: z.string().optional()})

  const oauthKeysResponseValidator = responseValidationFactory(
    [
      ["200", s_OAuthKeys],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get("oauthKeys", "/oauth2/v1/keys", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        oauthKeysQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_OAuthKeys>(200)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .oauthKeys(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = oauthKeysResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const logoutQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  const logoutResponseValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get("logout", "/oauth2/v1/logout", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        logoutQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<void>(200)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .logout(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = logoutResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const logoutWithPostBodySchema = s_LogoutWithPost

  const logoutWithPostResponseValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post("logoutWithPost", "/oauth2/v1/logout", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        logoutWithPostBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<void>(200)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .logoutWithPost(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = logoutWithPostResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const oobAuthenticateBodySchema = s_OobAuthenticateRequest

  const oobAuthenticateResponseValidator = responseValidationFactory(
    [
      ["200", s_OobAuthenticateResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  router.post(
    "oobAuthenticate",
    "/oauth2/v1/oob-authenticate",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          oobAuthenticateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_OobAuthenticateResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_OAuthError>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_OAuthError>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .oobAuthenticate(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oobAuthenticateResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parOptionsHeaderSchema = z.object({origin: z.string().optional()})

  const parOptionsResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.options("parOptions", "/oauth2/v1/par", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: parseRequestInput(
        parOptionsHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const responder = {
      with204() {
        return new KoaRuntimeResponse<void>(204)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .parOptions(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = parOptionsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const parBodySchema = s_ParRequest

  const parResponseValidator = responseValidationFactory(
    [
      ["200", s_ParResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post("par", "/oauth2/v1/par", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        parBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_ParResponse>(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_OAuthError>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_OAuthError>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_OAuthError>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .par(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = parResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const revokeBodySchema = s_RevokeRequest

  const revokeResponseValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post("revoke", "/oauth2/v1/revoke", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        revokeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<void>(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_OAuthError>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_OAuthError>(401)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .revoke(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = revokeResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const tokenOptionsHeaderSchema = z.object({origin: z.string().optional()})

  const tokenOptionsResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.options("tokenOptions", "/oauth2/v1/token", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: parseRequestInput(
        tokenOptionsHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const responder = {
      with204() {
        return new KoaRuntimeResponse<void>(204)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .tokenOptions(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = tokenOptionsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const tokenBodySchema = s_TokenRequest

  const tokenResponseValidator = responseValidationFactory(
    [
      ["200", s_TokenResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post("token", "/oauth2/v1/token", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        tokenBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_TokenResponse>(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_OAuthError>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_OAuthError>(401)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .token(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = tokenResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const userinfoResponseValidator = responseValidationFactory(
    [
      ["200", s_UserInfo],
      ["401", z.undefined()],
      ["403", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get("userinfo", "/oauth2/v1/userinfo", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_UserInfo>(200)
      },
      with401() {
        return new KoaRuntimeResponse<void>(401)
      },
      with403() {
        return new KoaRuntimeResponse<void>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_Error>(429)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .userinfo(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = userinfoResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getWellKnownOAuthConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOAuthConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOAuthConfigurationCustomAsResponseValidator =
    responseValidationFactory(
      [
        ["200", s_OAuthMetadata],
        ["400", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.get(
    "getWellKnownOAuthConfigurationCustomAs",
    "/oauth2/:authorizationServerId/.well-known/oauth-authorization-server",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWellKnownOAuthConfigurationCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWellKnownOAuthConfigurationCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_OAuthMetadata>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getWellKnownOAuthConfigurationCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOAuthConfigurationCustomAsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const getWellKnownOpenIdConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOpenIdConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOpenIdConfigurationCustomAsResponseValidator =
    responseValidationFactory(
      [
        ["200", s_OidcMetadata],
        ["400", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.get(
    "getWellKnownOpenIdConfigurationCustomAs",
    "/oauth2/:authorizationServerId/.well-known/openid-configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWellKnownOpenIdConfigurationCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWellKnownOpenIdConfigurationCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_OidcMetadata>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getWellKnownOpenIdConfigurationCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOpenIdConfigurationCustomAsResponseValidator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const authorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  const authorizeCustomAsResponseValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  router.get(
    "authorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          authorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          authorizeCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .authorizeCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const authorizeCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsWithPostBodySchema = s_AuthorizeWithPost

  const authorizeCustomAsWithPostResponseValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  router.post(
    "authorizeCustomAsWithPost",
    "/oauth2/:authorizationServerId/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          authorizeCustomAsWithPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          authorizeCustomAsWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .authorizeCustomAsWithPost(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeCustomAsWithPostResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const bcAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const bcAuthorizeCustomAsBodySchema = s_BackchannelAuthorizeRequest

  const bcAuthorizeCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_BackchannelAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "bcAuthorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/bc/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          bcAuthorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          bcAuthorizeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_BackchannelAuthorizeResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .bcAuthorizeCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = bcAuthorizeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const challengeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const challengeCustomAsBodySchema = s_ChallengeRequest

  const challengeCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_ChallengeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  router.post(
    "challengeCustomAs",
    "/oauth2/:authorizationServerId/v1/challenge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          challengeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          challengeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_ChallengeResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_OAuthError>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_OAuthError>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .challengeCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = challengeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deviceAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const deviceAuthorizeCustomAsBodySchema = s_DeviceAuthorizeRequest

  const deviceAuthorizeCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_DeviceAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "deviceAuthorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/device/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deviceAuthorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deviceAuthorizeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_DeviceAuthorizeResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deviceAuthorizeCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deviceAuthorizeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const introspectCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const introspectCustomAsBodySchema = s_IntrospectionRequest

  const introspectCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_IntrospectionResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "introspectCustomAs",
    "/oauth2/:authorizationServerId/v1/introspect",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          introspectCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          introspectCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_IntrospectionResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .introspectCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = introspectCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oauthKeysCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oauthKeysCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_OAuthKeys],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get(
    "oauthKeysCustomAs",
    "/oauth2/:authorizationServerId/v1/keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oauthKeysCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_OAuthKeys>(200)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .oauthKeysCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oauthKeysCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const logoutCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  const logoutCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get(
    "logoutCustomAs",
    "/oauth2/:authorizationServerId/v1/logout",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          logoutCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          logoutCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<void>(200)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .logoutCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = logoutCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const logoutCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsWithPostBodySchema = s_LogoutWithPost

  const logoutCustomAsWithPostResponseValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "logoutCustomAsWithPost",
    "/oauth2/:authorizationServerId/v1/logout",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          logoutCustomAsWithPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          logoutCustomAsWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<void>(200)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .logoutCustomAsWithPost(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = logoutCustomAsWithPostResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oobAuthenticateCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oobAuthenticateCustomAsBodySchema = s_OobAuthenticateRequest

  const oobAuthenticateCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_OobAuthenticateResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  router.post(
    "oobAuthenticateCustomAs",
    "/oauth2/:authorizationServerId/v1/oob-authenticate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oobAuthenticateCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          oobAuthenticateCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_OobAuthenticateResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_OAuthError>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_OAuthError>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .oobAuthenticateCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oobAuthenticateCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const parOptionsCustomAsHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const parOptionsCustomAsResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.options(
    "parOptionsCustomAs",
    "/oauth2/:authorizationServerId/v1/par",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          parOptionsCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: parseRequestInput(
          parOptionsCustomAsHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .parOptionsCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = parOptionsCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parCustomAsParamSchema = z.object({authorizationServerId: z.string()})

  const parCustomAsBodySchema = s_ParRequest

  const parCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_ParResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "parCustomAs",
    "/oauth2/:authorizationServerId/v1/par",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          parCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          parCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_ParResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_OAuthError>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .parCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = parCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const revokeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const revokeCustomAsBodySchema = s_RevokeRequest

  const revokeCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "revokeCustomAs",
    "/oauth2/:authorizationServerId/v1/revoke",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          revokeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          revokeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<void>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .revokeCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = revokeCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const tokenOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const tokenOptionsCustomAsHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const tokenOptionsCustomAsResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.options(
    "tokenOptionsCustomAs",
    "/oauth2/:authorizationServerId/v1/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          tokenOptionsCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: parseRequestInput(
          tokenOptionsCustomAsHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .tokenOptionsCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = tokenOptionsCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const tokenCustomAsParamSchema = z.object({authorizationServerId: z.string()})

  const tokenCustomAsBodySchema = s_TokenRequest

  const tokenCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_TokenResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  router.post(
    "tokenCustomAs",
    "/oauth2/:authorizationServerId/v1/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          tokenCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          tokenCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_TokenResponse>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_OAuthError>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_OAuthError>(401)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .tokenCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = tokenCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const userinfoCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const userinfoCustomAsResponseValidator = responseValidationFactory(
    [
      ["200", s_UserInfo],
      ["401", z.undefined()],
      ["403", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get(
    "userinfoCustomAs",
    "/oauth2/:authorizationServerId/v1/userinfo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          userinfoCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_UserInfo>(200)
        },
        with401() {
          return new KoaRuntimeResponse<void>(401)
        },
        with403() {
          return new KoaRuntimeResponse<void>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .userinfoCustomAs(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = userinfoCustomAsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Okta OpenID Connect & OAuth 2.0
  return startServer(config)
}
