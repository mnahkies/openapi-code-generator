/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AuthorizeCustomAsParamSchema,
  t_AuthorizeCustomAsQuerySchema,
  t_AuthorizeCustomAsWithPostBodySchema,
  t_AuthorizeCustomAsWithPostParamSchema,
  t_AuthorizeQuerySchema,
  t_AuthorizeWithPostBodySchema,
  t_BackchannelAuthorizeResponse,
  t_BcAuthorizeBodySchema,
  t_BcAuthorizeCustomAsBodySchema,
  t_BcAuthorizeCustomAsParamSchema,
  t_ChallengeBodySchema,
  t_ChallengeCustomAsBodySchema,
  t_ChallengeCustomAsParamSchema,
  t_ChallengeResponse,
  t_Client,
  t_CreateClientBodySchema,
  t_DeleteClientParamSchema,
  t_DeviceAuthorizeBodySchema,
  t_DeviceAuthorizeCustomAsBodySchema,
  t_DeviceAuthorizeCustomAsParamSchema,
  t_DeviceAuthorizeResponse,
  t_Error,
  t_GenerateNewClientSecretParamSchema,
  t_GetClientParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
  t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationQuerySchema,
  t_GlobalTokenRevocationBodySchema,
  t_IntrospectBodySchema,
  t_IntrospectCustomAsBodySchema,
  t_IntrospectCustomAsParamSchema,
  t_IntrospectionResponse,
  t_ListClientsQuerySchema,
  t_LogoutCustomAsParamSchema,
  t_LogoutCustomAsQuerySchema,
  t_LogoutCustomAsWithPostBodySchema,
  t_LogoutCustomAsWithPostParamSchema,
  t_LogoutQuerySchema,
  t_LogoutWithPostBodySchema,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OauthKeysCustomAsParamSchema,
  t_OauthKeysQuerySchema,
  t_OidcMetadata,
  t_OobAuthenticateBodySchema,
  t_OobAuthenticateCustomAsBodySchema,
  t_OobAuthenticateCustomAsParamSchema,
  t_OobAuthenticateResponse,
  t_ParBodySchema,
  t_ParCustomAsBodySchema,
  t_ParCustomAsParamSchema,
  t_ParOptionsCustomAsHeaderSchema,
  t_ParOptionsCustomAsParamSchema,
  t_ParOptionsHeaderSchema,
  t_ParResponse,
  t_ReplaceClientBodySchema,
  t_ReplaceClientParamSchema,
  t_RevokeBodySchema,
  t_RevokeCustomAsBodySchema,
  t_RevokeCustomAsParamSchema,
  t_TokenBodySchema,
  t_TokenCustomAsBodySchema,
  t_TokenCustomAsParamSchema,
  t_TokenOptionsCustomAsHeaderSchema,
  t_TokenOptionsCustomAsParamSchema,
  t_TokenOptionsHeaderSchema,
  t_TokenResponse,
  t_UserInfo,
  t_UserinfoCustomAsParamSchema,
} from "./models"
import {
  s_AcrValue,
  s_AmrValue,
  s_AuthorizeWithPost,
  s_BackchannelAuthorizeRequest,
  s_BackchannelAuthorizeResponse,
  s_ChallengeRequest,
  s_ChallengeResponse,
  s_Client,
  s_CodeChallengeMethod,
  s_DeviceAuthorizeRequest,
  s_DeviceAuthorizeResponse,
  s_Error,
  s_GlobalTokenRevocationRequest,
  s_IntrospectionRequest,
  s_IntrospectionResponse,
  s_LogoutWithPost,
  s_OAuthError,
  s_OAuthKeys,
  s_OAuthMetadata,
  s_OidcMetadata,
  s_OobAuthenticateRequest,
  s_OobAuthenticateResponse,
  s_ParRequest,
  s_ParResponse,
  s_Prompt,
  s_ResponseMode,
  s_ResponseTypesSupported,
  s_RevokeRequest,
  s_TokenRequest,
  s_TokenResponse,
  s_UserInfo,
} from "./schemas"
import KoaRouter, { RouterContext } from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  KoaRuntimeResponse,
  Params,
  Response,
  ServerConfig,
  b,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import { parseRequestInput } from "@nahkies/typescript-koa-runtime/zod"
import { z } from "zod"

const getWellKnownOpenIdConfiguration = b((r) => ({
  with200: r.with200<t_OidcMetadata>(s_OidcMetadata),
  with400: r.with400<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type GetWellKnownOpenIdConfiguration = (
  params: Params<
    void,
    t_GetWellKnownOpenIdConfigurationQuerySchema,
    void,
    void
  >,
  respond: (typeof getWellKnownOpenIdConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OidcMetadata>
  | Response<400, t_Error>
>

const authorize = b((r) => ({
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type Authorize = (
  params: Params<void, t_AuthorizeQuerySchema, void, void>,
  respond: (typeof authorize)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const authorizeWithPost = b((r) => ({
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type AuthorizeWithPost = (
  params: Params<void, void, t_AuthorizeWithPostBodySchema, void>,
  respond: (typeof authorizeWithPost)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const bcAuthorize = b((r) => ({
  with200: r.with200<t_BackchannelAuthorizeResponse>(
    s_BackchannelAuthorizeResponse,
  ),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type BcAuthorize = (
  params: Params<void, void, t_BcAuthorizeBodySchema, void>,
  respond: (typeof bcAuthorize)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_BackchannelAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const challenge = b((r) => ({
  with200: r.with200<t_ChallengeResponse>(s_ChallengeResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with403: r.with403<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_OAuthError>(s_OAuthError),
  withStatus: r.withStatus,
}))

export type Challenge = (
  params: Params<void, void, t_ChallengeBodySchema, void>,
  respond: (typeof challenge)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ChallengeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const listClients = b((r) => ({
  with200: r.with200<t_Client[]>(z.array(s_Client)),
  with403: r.with403<t_Error>(s_Error),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type ListClients = (
  params: Params<void, t_ListClientsQuerySchema, void, void>,
  respond: (typeof listClients)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client[]>
  | Response<403, t_Error>
  | Response<429, t_Error>
>

const createClient = b((r) => ({
  with201: r.with201<t_Client>(s_Client),
  with400: r.with400<t_Error>(s_Error),
  with403: r.with403<t_Error>(s_Error),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type CreateClient = (
  params: Params<void, void, t_CreateClientBodySchema, void>,
  respond: (typeof createClient)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_Client>
  | Response<400, t_Error>
  | Response<403, t_Error>
  | Response<429, t_Error>
>

const getClient = b((r) => ({
  with200: r.with200<t_Client>(s_Client),
  with403: r.with403<t_Error>(s_Error),
  with404: r.with404<t_Error>(s_Error),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type GetClient = (
  params: Params<t_GetClientParamSchema, void, void, void>,
  respond: (typeof getClient)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const replaceClient = b((r) => ({
  with200: r.with200<t_Client>(s_Client),
  with400: r.with400<t_Error>(s_Error),
  with403: r.with403<t_Error>(s_Error),
  with404: r.with404<t_Error>(s_Error),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type ReplaceClient = (
  params: Params<
    t_ReplaceClientParamSchema,
    void,
    t_ReplaceClientBodySchema,
    void
  >,
  respond: (typeof replaceClient)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<400, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const deleteClient = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_Error>(s_Error),
  with404: r.with404<t_Error>(s_Error),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type DeleteClient = (
  params: Params<t_DeleteClientParamSchema, void, void, void>,
  respond: (typeof deleteClient)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const generateNewClientSecret = b((r) => ({
  with200: r.with200<t_Client>(s_Client),
  with403: r.with403<t_Error>(s_Error),
  with404: r.with404<t_Error>(s_Error),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type GenerateNewClientSecret = (
  params: Params<t_GenerateNewClientSecretParamSchema, void, void, void>,
  respond: (typeof generateNewClientSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Client>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<429, t_Error>
>

const deviceAuthorize = b((r) => ({
  with200: r.with200<t_DeviceAuthorizeResponse>(s_DeviceAuthorizeResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type DeviceAuthorize = (
  params: Params<void, void, t_DeviceAuthorizeBodySchema, void>,
  respond: (typeof deviceAuthorize)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_DeviceAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const globalTokenRevocation = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with400: r.with400<void>(z.undefined()),
  with403: r.with403<t_Error>(s_Error),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type GlobalTokenRevocation = (
  params: Params<void, void, t_GlobalTokenRevocationBodySchema, void>,
  respond: (typeof globalTokenRevocation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, void>
  | Response<403, t_Error>
  | Response<429, t_Error>
>

const introspect = b((r) => ({
  with200: r.with200<t_IntrospectionResponse>(s_IntrospectionResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type Introspect = (
  params: Params<void, void, t_IntrospectBodySchema, void>,
  respond: (typeof introspect)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_IntrospectionResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const oauthKeys = b((r) => ({
  with200: r.with200<t_OAuthKeys>(s_OAuthKeys),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type OauthKeys = (
  params: Params<void, t_OauthKeysQuerySchema, void, void>,
  respond: (typeof oauthKeys)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthKeys>
  | Response<429, t_Error>
>

const logout = b((r) => ({
  with200: r.with200<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type Logout = (
  params: Params<void, t_LogoutQuerySchema, void, void>,
  respond: (typeof logout)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const logoutWithPost = b((r) => ({
  with200: r.with200<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type LogoutWithPost = (
  params: Params<void, void, t_LogoutWithPostBodySchema, void>,
  respond: (typeof logoutWithPost)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const oobAuthenticate = b((r) => ({
  with200: r.with200<t_OobAuthenticateResponse>(s_OobAuthenticateResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with403: r.with403<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_OAuthError>(s_OAuthError),
  withStatus: r.withStatus,
}))

export type OobAuthenticate = (
  params: Params<void, void, t_OobAuthenticateBodySchema, void>,
  respond: (typeof oobAuthenticate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OobAuthenticateResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const parOptions = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type ParOptions = (
  params: Params<void, void, void, t_ParOptionsHeaderSchema>,
  respond: (typeof parOptions)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const par = b((r) => ({
  with200: r.with200<t_ParResponse>(s_ParResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with403: r.with403<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type Par = (
  params: Params<void, void, t_ParBodySchema, void>,
  respond: (typeof par)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ParResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_Error>
>

const revoke = b((r) => ({
  with200: r.with200<void>(z.undefined()),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type Revoke = (
  params: Params<void, void, t_RevokeBodySchema, void>,
  respond: (typeof revoke)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const tokenOptions = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type TokenOptions = (
  params: Params<void, void, void, t_TokenOptionsHeaderSchema>,
  respond: (typeof tokenOptions)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const token = b((r) => ({
  with200: r.with200<t_TokenResponse>(s_TokenResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type Token = (
  params: Params<void, void, t_TokenBodySchema, void>,
  respond: (typeof token)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_TokenResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const userinfo = b((r) => ({
  with200: r.with200<t_UserInfo>(s_UserInfo),
  with401: r.with401<void>(z.undefined()),
  with403: r.with403<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type Userinfo = (
  params: Params<void, void, void, void>,
  respond: (typeof userinfo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_UserInfo>
  | Response<401, void>
  | Response<403, void>
  | Response<429, t_Error>
>

const getWellKnownOAuthConfigurationCustomAs = b((r) => ({
  with200: r.with200<t_OAuthMetadata>(s_OAuthMetadata),
  with400: r.with400<t_Error>(s_Error),
  with404: r.with404<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type GetWellKnownOAuthConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
    t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: (typeof getWellKnownOAuthConfigurationCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthMetadata>
  | Response<400, t_Error>
  | Response<404, t_Error>
>

const getWellKnownOpenIdConfigurationCustomAs = b((r) => ({
  with200: r.with200<t_OidcMetadata>(s_OidcMetadata),
  with400: r.with400<t_Error>(s_Error),
  with404: r.with404<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type GetWellKnownOpenIdConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
    t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: (typeof getWellKnownOpenIdConfigurationCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OidcMetadata>
  | Response<400, t_Error>
  | Response<404, t_Error>
>

const authorizeCustomAs = b((r) => ({
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type AuthorizeCustomAs = (
  params: Params<
    t_AuthorizeCustomAsParamSchema,
    t_AuthorizeCustomAsQuerySchema,
    void,
    void
  >,
  respond: (typeof authorizeCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const authorizeCustomAsWithPost = b((r) => ({
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type AuthorizeCustomAsWithPost = (
  params: Params<
    t_AuthorizeCustomAsWithPostParamSchema,
    void,
    t_AuthorizeCustomAsWithPostBodySchema,
    void
  >,
  respond: (typeof authorizeCustomAsWithPost)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<429, t_Error>>

const bcAuthorizeCustomAs = b((r) => ({
  with200: r.with200<t_BackchannelAuthorizeResponse>(
    s_BackchannelAuthorizeResponse,
  ),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type BcAuthorizeCustomAs = (
  params: Params<
    t_BcAuthorizeCustomAsParamSchema,
    void,
    t_BcAuthorizeCustomAsBodySchema,
    void
  >,
  respond: (typeof bcAuthorizeCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_BackchannelAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const challengeCustomAs = b((r) => ({
  with200: r.with200<t_ChallengeResponse>(s_ChallengeResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with403: r.with403<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_OAuthError>(s_OAuthError),
  withStatus: r.withStatus,
}))

export type ChallengeCustomAs = (
  params: Params<
    t_ChallengeCustomAsParamSchema,
    void,
    t_ChallengeCustomAsBodySchema,
    void
  >,
  respond: (typeof challengeCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ChallengeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const deviceAuthorizeCustomAs = b((r) => ({
  with200: r.with200<t_DeviceAuthorizeResponse>(s_DeviceAuthorizeResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type DeviceAuthorizeCustomAs = (
  params: Params<
    t_DeviceAuthorizeCustomAsParamSchema,
    void,
    t_DeviceAuthorizeCustomAsBodySchema,
    void
  >,
  respond: (typeof deviceAuthorizeCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_DeviceAuthorizeResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const introspectCustomAs = b((r) => ({
  with200: r.with200<t_IntrospectionResponse>(s_IntrospectionResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type IntrospectCustomAs = (
  params: Params<
    t_IntrospectCustomAsParamSchema,
    void,
    t_IntrospectCustomAsBodySchema,
    void
  >,
  respond: (typeof introspectCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_IntrospectionResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const oauthKeysCustomAs = b((r) => ({
  with200: r.with200<t_OAuthKeys>(s_OAuthKeys),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type OauthKeysCustomAs = (
  params: Params<t_OauthKeysCustomAsParamSchema, void, void, void>,
  respond: (typeof oauthKeysCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OAuthKeys>
  | Response<429, t_Error>
>

const logoutCustomAs = b((r) => ({
  with200: r.with200<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type LogoutCustomAs = (
  params: Params<
    t_LogoutCustomAsParamSchema,
    t_LogoutCustomAsQuerySchema,
    void,
    void
  >,
  respond: (typeof logoutCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const logoutCustomAsWithPost = b((r) => ({
  with200: r.with200<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type LogoutCustomAsWithPost = (
  params: Params<
    t_LogoutCustomAsWithPostParamSchema,
    void,
    t_LogoutCustomAsWithPostBodySchema,
    void
  >,
  respond: (typeof logoutCustomAsWithPost)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, void> | Response<429, t_Error>
>

const oobAuthenticateCustomAs = b((r) => ({
  with200: r.with200<t_OobAuthenticateResponse>(s_OobAuthenticateResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with403: r.with403<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_OAuthError>(s_OAuthError),
  withStatus: r.withStatus,
}))

export type OobAuthenticateCustomAs = (
  params: Params<
    t_OobAuthenticateCustomAsParamSchema,
    void,
    t_OobAuthenticateCustomAsBodySchema,
    void
  >,
  respond: (typeof oobAuthenticateCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_OobAuthenticateResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_OAuthError>
>

const parOptionsCustomAs = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type ParOptionsCustomAs = (
  params: Params<
    t_ParOptionsCustomAsParamSchema,
    void,
    void,
    t_ParOptionsCustomAsHeaderSchema
  >,
  respond: (typeof parOptionsCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const parCustomAs = b((r) => ({
  with200: r.with200<t_ParResponse>(s_ParResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with403: r.with403<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type ParCustomAs = (
  params: Params<t_ParCustomAsParamSchema, void, t_ParCustomAsBodySchema, void>,
  respond: (typeof parCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ParResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<403, t_OAuthError>
  | Response<429, t_Error>
>

const revokeCustomAs = b((r) => ({
  with200: r.with200<void>(z.undefined()),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type RevokeCustomAs = (
  params: Params<
    t_RevokeCustomAsParamSchema,
    void,
    t_RevokeCustomAsBodySchema,
    void
  >,
  respond: (typeof revokeCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, void>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const tokenOptionsCustomAs = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type TokenOptionsCustomAs = (
  params: Params<
    t_TokenOptionsCustomAsParamSchema,
    void,
    void,
    t_TokenOptionsCustomAsHeaderSchema
  >,
  respond: (typeof tokenOptionsCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<429, t_Error>
>

const tokenCustomAs = b((r) => ({
  with200: r.with200<t_TokenResponse>(s_TokenResponse),
  with400: r.with400<t_OAuthError>(s_OAuthError),
  with401: r.with401<t_OAuthError>(s_OAuthError),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type TokenCustomAs = (
  params: Params<
    t_TokenCustomAsParamSchema,
    void,
    t_TokenCustomAsBodySchema,
    void
  >,
  respond: (typeof tokenCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_TokenResponse>
  | Response<400, t_OAuthError>
  | Response<401, t_OAuthError>
  | Response<429, t_Error>
>

const userinfoCustomAs = b((r) => ({
  with200: r.with200<t_UserInfo>(s_UserInfo),
  with401: r.with401<void>(z.undefined()),
  with403: r.with403<void>(z.undefined()),
  with429: r.with429<t_Error>(s_Error),
  withStatus: r.withStatus,
}))

export type UserinfoCustomAs = (
  params: Params<t_UserinfoCustomAsParamSchema, void, void, void>,
  respond: (typeof userinfoCustomAs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_UserInfo>
  | Response<401, void>
  | Response<403, void>
  | Response<429, t_Error>
>

export type Implementation = {
  getWellKnownOpenIdConfiguration: GetWellKnownOpenIdConfiguration
  authorize: Authorize
  authorizeWithPost: AuthorizeWithPost
  bcAuthorize: BcAuthorize
  challenge: Challenge
  listClients: ListClients
  createClient: CreateClient
  getClient: GetClient
  replaceClient: ReplaceClient
  deleteClient: DeleteClient
  generateNewClientSecret: GenerateNewClientSecret
  deviceAuthorize: DeviceAuthorize
  globalTokenRevocation: GlobalTokenRevocation
  introspect: Introspect
  oauthKeys: OauthKeys
  logout: Logout
  logoutWithPost: LogoutWithPost
  oobAuthenticate: OobAuthenticate
  parOptions: ParOptions
  par: Par
  revoke: Revoke
  tokenOptions: TokenOptions
  token: Token
  userinfo: Userinfo
  getWellKnownOAuthConfigurationCustomAs: GetWellKnownOAuthConfigurationCustomAs
  getWellKnownOpenIdConfigurationCustomAs: GetWellKnownOpenIdConfigurationCustomAs
  authorizeCustomAs: AuthorizeCustomAs
  authorizeCustomAsWithPost: AuthorizeCustomAsWithPost
  bcAuthorizeCustomAs: BcAuthorizeCustomAs
  challengeCustomAs: ChallengeCustomAs
  deviceAuthorizeCustomAs: DeviceAuthorizeCustomAs
  introspectCustomAs: IntrospectCustomAs
  oauthKeysCustomAs: OauthKeysCustomAs
  logoutCustomAs: LogoutCustomAs
  logoutCustomAsWithPost: LogoutCustomAsWithPost
  oobAuthenticateCustomAs: OobAuthenticateCustomAs
  parOptionsCustomAs: ParOptionsCustomAs
  parCustomAs: ParCustomAs
  revokeCustomAs: RevokeCustomAs
  tokenOptionsCustomAs: TokenOptionsCustomAs
  tokenCustomAs: TokenCustomAs
  userinfoCustomAs: UserinfoCustomAs
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const getWellKnownOpenIdConfigurationQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  router.get(
    "getWellKnownOpenIdConfiguration",
    "/.well-known/openid-configuration",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          getWellKnownOpenIdConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .getWellKnownOpenIdConfiguration(
          input,
          getWellKnownOpenIdConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOpenIdConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const authorizeQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  router.get("authorize", "/oauth2/v1/authorize", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        authorizeQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .authorize(input, authorize.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = authorize.validator(status, body)
    ctx.status = status
    return next()
  })

  const authorizeWithPostBodySchema = s_AuthorizeWithPost

  router.post(
    "authorizeWithPost",
    "/oauth2/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          authorizeWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .authorizeWithPost(input, authorizeWithPost.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeWithPost.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const bcAuthorizeBodySchema = s_BackchannelAuthorizeRequest

  router.post("bcAuthorize", "/oauth2/v1/bc/authorize", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        bcAuthorizeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .bcAuthorize(input, bcAuthorize.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = bcAuthorize.validator(status, body)
    ctx.status = status
    return next()
  })

  const challengeBodySchema = s_ChallengeRequest

  router.post("challenge", "/oauth2/v1/challenge", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        challengeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .challenge(input, challenge.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = challenge.validator(status, body)
    ctx.status = status
    return next()
  })

  const listClientsQuerySchema = z.object({
    after: z.string().optional(),
    limit: z.coerce.number().min(1).max(200).optional().default(20),
    q: z.string().optional(),
  })

  router.get("listClients", "/oauth2/v1/clients", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        listClientsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .listClients(input, listClients.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = listClients.validator(status, body)
    ctx.status = status
    return next()
  })

  const createClientBodySchema = s_Client

  router.post("createClient", "/oauth2/v1/clients", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        createClientBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .createClient(input, createClient.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = createClient.validator(status, body)
    ctx.status = status
    return next()
  })

  const getClientParamSchema = z.object({ clientId: z.string() })

  router.get("getClient", "/oauth2/v1/clients/:clientId", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getClientParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .getClient(input, getClient.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getClient.validator(status, body)
    ctx.status = status
    return next()
  })

  const replaceClientParamSchema = z.object({ clientId: z.string() })

  const replaceClientBodySchema = s_Client

  router.put(
    "replaceClient",
    "/oauth2/v1/clients/:clientId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          replaceClientParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          replaceClientBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .replaceClient(input, replaceClient.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = replaceClient.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteClientParamSchema = z.object({ clientId: z.string() })

  router.delete(
    "deleteClient",
    "/oauth2/v1/clients/:clientId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteClientParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .deleteClient(input, deleteClient.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteClient.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const generateNewClientSecretParamSchema = z.object({ clientId: z.string() })

  router.post(
    "generateNewClientSecret",
    "/oauth2/v1/clients/:clientId/lifecycle/newSecret",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          generateNewClientSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .generateNewClientSecret(input, generateNewClientSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = generateNewClientSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deviceAuthorizeBodySchema = s_DeviceAuthorizeRequest

  router.post(
    "deviceAuthorize",
    "/oauth2/v1/device/authorize",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          deviceAuthorizeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deviceAuthorize(input, deviceAuthorize.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deviceAuthorize.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const globalTokenRevocationBodySchema = s_GlobalTokenRevocationRequest

  router.post(
    "globalTokenRevocation",
    "/oauth2/v1/global-token-revocation",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          globalTokenRevocationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .globalTokenRevocation(input, globalTokenRevocation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = globalTokenRevocation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const introspectBodySchema = s_IntrospectionRequest

  router.post("introspect", "/oauth2/v1/introspect", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        introspectBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .introspect(input, introspect.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = introspect.validator(status, body)
    ctx.status = status
    return next()
  })

  const oauthKeysQuerySchema = z.object({ client_id: z.string().optional() })

  router.get("oauthKeys", "/oauth2/v1/keys", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        oauthKeysQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .oauthKeys(input, oauthKeys.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = oauthKeys.validator(status, body)
    ctx.status = status
    return next()
  })

  const logoutQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  router.get("logout", "/oauth2/v1/logout", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        logoutQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .logout(input, logout.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = logout.validator(status, body)
    ctx.status = status
    return next()
  })

  const logoutWithPostBodySchema = s_LogoutWithPost

  router.post("logoutWithPost", "/oauth2/v1/logout", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        logoutWithPostBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .logoutWithPost(input, logoutWithPost.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = logoutWithPost.validator(status, body)
    ctx.status = status
    return next()
  })

  const oobAuthenticateBodySchema = s_OobAuthenticateRequest

  router.post(
    "oobAuthenticate",
    "/oauth2/v1/oob-authenticate",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          oobAuthenticateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .oobAuthenticate(input, oobAuthenticate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oobAuthenticate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parOptionsHeaderSchema = z.object({ origin: z.string().optional() })

  router.options("parOptions", "/oauth2/v1/par", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: parseRequestInput(
        parOptionsHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const response = await implementation
      .parOptions(input, parOptions.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = parOptions.validator(status, body)
    ctx.status = status
    return next()
  })

  const parBodySchema = s_ParRequest

  router.post("par", "/oauth2/v1/par", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        parBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .par(input, par.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = par.validator(status, body)
    ctx.status = status
    return next()
  })

  const revokeBodySchema = s_RevokeRequest

  router.post("revoke", "/oauth2/v1/revoke", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        revokeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .revoke(input, revoke.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = revoke.validator(status, body)
    ctx.status = status
    return next()
  })

  const tokenOptionsHeaderSchema = z.object({ origin: z.string().optional() })

  router.options("tokenOptions", "/oauth2/v1/token", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: parseRequestInput(
        tokenOptionsHeaderSchema,
        Reflect.get(ctx.request, "headers"),
        RequestInputType.RequestHeader,
      ),
    }

    const response = await implementation
      .tokenOptions(input, tokenOptions.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = tokenOptions.validator(status, body)
    ctx.status = status
    return next()
  })

  const tokenBodySchema = s_TokenRequest

  router.post("token", "/oauth2/v1/token", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        tokenBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .token(input, token.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = token.validator(status, body)
    ctx.status = status
    return next()
  })

  router.get("userinfo", "/oauth2/v1/userinfo", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .userinfo(input, userinfo.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = userinfo.validator(status, body)
    ctx.status = status
    return next()
  })

  const getWellKnownOAuthConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOAuthConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  router.get(
    "getWellKnownOAuthConfigurationCustomAs",
    "/oauth2/:authorizationServerId/.well-known/oauth-authorization-server",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWellKnownOAuthConfigurationCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWellKnownOAuthConfigurationCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .getWellKnownOAuthConfigurationCustomAs(
          input,
          getWellKnownOAuthConfigurationCustomAs.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOAuthConfigurationCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getWellKnownOpenIdConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOpenIdConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  router.get(
    "getWellKnownOpenIdConfigurationCustomAs",
    "/oauth2/:authorizationServerId/.well-known/openid-configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getWellKnownOpenIdConfigurationCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getWellKnownOpenIdConfigurationCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .getWellKnownOpenIdConfigurationCustomAs(
          input,
          getWellKnownOpenIdConfigurationCustomAs.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getWellKnownOpenIdConfigurationCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const authorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  router.get(
    "authorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          authorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          authorizeCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .authorizeCustomAs(input, authorizeCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const authorizeCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsWithPostBodySchema = s_AuthorizeWithPost

  router.post(
    "authorizeCustomAsWithPost",
    "/oauth2/:authorizationServerId/v1/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          authorizeCustomAsWithPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          authorizeCustomAsWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .authorizeCustomAsWithPost(
          input,
          authorizeCustomAsWithPost.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = authorizeCustomAsWithPost.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const bcAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const bcAuthorizeCustomAsBodySchema = s_BackchannelAuthorizeRequest

  router.post(
    "bcAuthorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/bc/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          bcAuthorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          bcAuthorizeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .bcAuthorizeCustomAs(input, bcAuthorizeCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = bcAuthorizeCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const challengeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const challengeCustomAsBodySchema = s_ChallengeRequest

  router.post(
    "challengeCustomAs",
    "/oauth2/:authorizationServerId/v1/challenge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          challengeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          challengeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .challengeCustomAs(input, challengeCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = challengeCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deviceAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const deviceAuthorizeCustomAsBodySchema = s_DeviceAuthorizeRequest

  router.post(
    "deviceAuthorizeCustomAs",
    "/oauth2/:authorizationServerId/v1/device/authorize",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deviceAuthorizeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          deviceAuthorizeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .deviceAuthorizeCustomAs(input, deviceAuthorizeCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deviceAuthorizeCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const introspectCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const introspectCustomAsBodySchema = s_IntrospectionRequest

  router.post(
    "introspectCustomAs",
    "/oauth2/:authorizationServerId/v1/introspect",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          introspectCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          introspectCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .introspectCustomAs(input, introspectCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = introspectCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oauthKeysCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  router.get(
    "oauthKeysCustomAs",
    "/oauth2/:authorizationServerId/v1/keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oauthKeysCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .oauthKeysCustomAs(input, oauthKeysCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oauthKeysCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const logoutCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  router.get(
    "logoutCustomAs",
    "/oauth2/:authorizationServerId/v1/logout",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          logoutCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          logoutCustomAsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .logoutCustomAs(input, logoutCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = logoutCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const logoutCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsWithPostBodySchema = s_LogoutWithPost

  router.post(
    "logoutCustomAsWithPost",
    "/oauth2/:authorizationServerId/v1/logout",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          logoutCustomAsWithPostParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          logoutCustomAsWithPostBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .logoutCustomAsWithPost(input, logoutCustomAsWithPost.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = logoutCustomAsWithPost.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oobAuthenticateCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oobAuthenticateCustomAsBodySchema = s_OobAuthenticateRequest

  router.post(
    "oobAuthenticateCustomAs",
    "/oauth2/:authorizationServerId/v1/oob-authenticate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oobAuthenticateCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          oobAuthenticateCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .oobAuthenticateCustomAs(input, oobAuthenticateCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oobAuthenticateCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const parOptionsCustomAsHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  router.options(
    "parOptionsCustomAs",
    "/oauth2/:authorizationServerId/v1/par",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          parOptionsCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: parseRequestInput(
          parOptionsCustomAsHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const response = await implementation
        .parOptionsCustomAs(input, parOptionsCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = parOptionsCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const parCustomAsParamSchema = z.object({ authorizationServerId: z.string() })

  const parCustomAsBodySchema = s_ParRequest

  router.post(
    "parCustomAs",
    "/oauth2/:authorizationServerId/v1/par",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          parCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          parCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .parCustomAs(input, parCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = parCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const revokeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const revokeCustomAsBodySchema = s_RevokeRequest

  router.post(
    "revokeCustomAs",
    "/oauth2/:authorizationServerId/v1/revoke",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          revokeCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          revokeCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .revokeCustomAs(input, revokeCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = revokeCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const tokenOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const tokenOptionsCustomAsHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  router.options(
    "tokenOptionsCustomAs",
    "/oauth2/:authorizationServerId/v1/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          tokenOptionsCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: parseRequestInput(
          tokenOptionsCustomAsHeaderSchema,
          Reflect.get(ctx.request, "headers"),
          RequestInputType.RequestHeader,
        ),
      }

      const response = await implementation
        .tokenOptionsCustomAs(input, tokenOptionsCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = tokenOptionsCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const tokenCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const tokenCustomAsBodySchema = s_TokenRequest

  router.post(
    "tokenCustomAs",
    "/oauth2/:authorizationServerId/v1/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          tokenCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          tokenCustomAsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .tokenCustomAs(input, tokenCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = tokenCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const userinfoCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  router.get(
    "userinfoCustomAs",
    "/oauth2/:authorizationServerId/v1/userinfo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          userinfoCustomAsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .userinfoCustomAs(input, userinfoCustomAs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = userinfoCustomAs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Okta OpenID Connect & OAuth 2.0
  return startServer(config)
}
