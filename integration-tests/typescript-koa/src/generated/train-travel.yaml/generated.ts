/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_Booking,
  t_BookingPayment,
  t_CreateBookingBodySchema,
  t_CreateBookingPaymentBodySchema,
  t_CreateBookingPaymentParamSchema,
  t_DeleteBookingParamSchema,
  t_GetBookingParamSchema,
  t_GetBookingsQuerySchema,
  t_GetStationsQuerySchema,
  t_GetTripsQuerySchema,
  t_Links_Booking,
  t_Links_Pagination,
  t_Links_Self,
  t_Problem,
  t_Station,
  t_Trip,
  t_Wrapper_Collection,
} from "./models"
import {
  PermissiveBoolean,
  s_Booking,
  s_BookingPayment,
  s_Links_Booking,
  s_Links_Pagination,
  s_Links_Self,
  s_Problem,
  s_Station,
  s_Trip,
  s_Wrapper_Collection,
} from "./schemas"
import KoaRouter, { RouterContext } from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  KoaRuntimeResponder,
  KoaRuntimeResponse,
  Response,
  ServerConfig,
  StatusCode,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  Params,
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod"
import { z } from "zod"

export type GetStationsResponder = {
  with200(): KoaRuntimeResponse<
    t_Wrapper_Collection & {
      data?: t_Station[]
    } & {
      links?: t_Links_Self & t_Links_Pagination
    }
  >
  with400(): KoaRuntimeResponse<t_Problem>
  with401(): KoaRuntimeResponse<t_Problem>
  with403(): KoaRuntimeResponse<t_Problem>
  with429(): KoaRuntimeResponse<t_Problem>
  with500(): KoaRuntimeResponse<t_Problem>
} & KoaRuntimeResponder

export type GetStations = (
  params: Params<void, t_GetStationsQuerySchema, void, void>,
  respond: GetStationsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      t_Wrapper_Collection & {
        data?: t_Station[]
      } & {
        links?: t_Links_Self & t_Links_Pagination
      }
    >
  | Response<400, t_Problem>
  | Response<401, t_Problem>
  | Response<403, t_Problem>
  | Response<429, t_Problem>
  | Response<500, t_Problem>
>

export type GetTripsResponder = {
  with200(): KoaRuntimeResponse<
    t_Wrapper_Collection & {
      data?: t_Trip[]
    } & {
      links?: t_Links_Self & t_Links_Pagination
    }
  >
  with400(): KoaRuntimeResponse<t_Problem>
  with401(): KoaRuntimeResponse<t_Problem>
  with403(): KoaRuntimeResponse<t_Problem>
  with429(): KoaRuntimeResponse<t_Problem>
  with500(): KoaRuntimeResponse<t_Problem>
} & KoaRuntimeResponder

export type GetTrips = (
  params: Params<void, t_GetTripsQuerySchema, void, void>,
  respond: GetTripsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      t_Wrapper_Collection & {
        data?: t_Trip[]
      } & {
        links?: t_Links_Self & t_Links_Pagination
      }
    >
  | Response<400, t_Problem>
  | Response<401, t_Problem>
  | Response<403, t_Problem>
  | Response<429, t_Problem>
  | Response<500, t_Problem>
>

export type GetBookingsResponder = {
  with200(): KoaRuntimeResponse<
    t_Wrapper_Collection & {
      data?: t_Booking[]
    } & {
      links?: t_Links_Self & t_Links_Pagination
    }
  >
  with400(): KoaRuntimeResponse<t_Problem>
  with401(): KoaRuntimeResponse<t_Problem>
  with403(): KoaRuntimeResponse<t_Problem>
  with429(): KoaRuntimeResponse<t_Problem>
  with500(): KoaRuntimeResponse<t_Problem>
} & KoaRuntimeResponder

export type GetBookings = (
  params: Params<void, t_GetBookingsQuerySchema, void, void>,
  respond: GetBookingsResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      t_Wrapper_Collection & {
        data?: t_Booking[]
      } & {
        links?: t_Links_Self & t_Links_Pagination
      }
    >
  | Response<400, t_Problem>
  | Response<401, t_Problem>
  | Response<403, t_Problem>
  | Response<429, t_Problem>
  | Response<500, t_Problem>
>

export type CreateBookingResponder = {
  with201(): KoaRuntimeResponse<
    t_Booking & {
      links?: t_Links_Self
    }
  >
  with400(): KoaRuntimeResponse<t_Problem>
  with401(): KoaRuntimeResponse<t_Problem>
  with404(): KoaRuntimeResponse<t_Problem>
  with409(): KoaRuntimeResponse<t_Problem>
  with429(): KoaRuntimeResponse<t_Problem>
  with500(): KoaRuntimeResponse<t_Problem>
} & KoaRuntimeResponder

export type CreateBooking = (
  params: Params<void, void, t_CreateBookingBodySchema, void>,
  respond: CreateBookingResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      t_Booking & {
        links?: t_Links_Self
      }
    >
  | Response<400, t_Problem>
  | Response<401, t_Problem>
  | Response<404, t_Problem>
  | Response<409, t_Problem>
  | Response<429, t_Problem>
  | Response<500, t_Problem>
>

export type GetBookingResponder = {
  with200(): KoaRuntimeResponse<
    t_Booking & {
      links?: t_Links_Self
    }
  >
  with400(): KoaRuntimeResponse<t_Problem>
  with401(): KoaRuntimeResponse<t_Problem>
  with403(): KoaRuntimeResponse<t_Problem>
  with404(): KoaRuntimeResponse<t_Problem>
  with429(): KoaRuntimeResponse<t_Problem>
  with500(): KoaRuntimeResponse<t_Problem>
} & KoaRuntimeResponder

export type GetBooking = (
  params: Params<t_GetBookingParamSchema, void, void, void>,
  respond: GetBookingResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      t_Booking & {
        links?: t_Links_Self
      }
    >
  | Response<400, t_Problem>
  | Response<401, t_Problem>
  | Response<403, t_Problem>
  | Response<404, t_Problem>
  | Response<429, t_Problem>
  | Response<500, t_Problem>
>

export type DeleteBookingResponder = {
  with204(): KoaRuntimeResponse<void>
  with400(): KoaRuntimeResponse<t_Problem>
  with401(): KoaRuntimeResponse<t_Problem>
  with403(): KoaRuntimeResponse<t_Problem>
  with404(): KoaRuntimeResponse<t_Problem>
  with429(): KoaRuntimeResponse<t_Problem>
  with500(): KoaRuntimeResponse<t_Problem>
} & KoaRuntimeResponder

export type DeleteBooking = (
  params: Params<t_DeleteBookingParamSchema, void, void, void>,
  respond: DeleteBookingResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, t_Problem>
  | Response<401, t_Problem>
  | Response<403, t_Problem>
  | Response<404, t_Problem>
  | Response<429, t_Problem>
  | Response<500, t_Problem>
>

export type CreateBookingPaymentResponder = {
  with200(): KoaRuntimeResponse<
    t_BookingPayment & {
      links?: t_Links_Booking
    }
  >
  with400(): KoaRuntimeResponse<t_Problem>
  with401(): KoaRuntimeResponse<t_Problem>
  with403(): KoaRuntimeResponse<t_Problem>
  with429(): KoaRuntimeResponse<t_Problem>
  with500(): KoaRuntimeResponse<t_Problem>
} & KoaRuntimeResponder

export type CreateBookingPayment = (
  params: Params<
    t_CreateBookingPaymentParamSchema,
    void,
    t_CreateBookingPaymentBodySchema,
    void
  >,
  respond: CreateBookingPaymentResponder,
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      t_BookingPayment & {
        links?: t_Links_Booking
      }
    >
  | Response<400, t_Problem>
  | Response<401, t_Problem>
  | Response<403, t_Problem>
  | Response<429, t_Problem>
  | Response<500, t_Problem>
>

export type Implementation = {
  getStations: GetStations
  getTrips: GetTrips
  getBookings: GetBookings
  createBooking: CreateBooking
  getBooking: GetBooking
  deleteBooking: DeleteBooking
  createBookingPayment: CreateBookingPayment
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const getStationsQuerySchema = z.object({
    page: z.coerce.number().min(1).optional().default(1),
    limit: z.coerce.number().min(1).max(100).optional().default(10),
    coordinates: z.string().optional(),
    search: z.string().optional(),
    country: z.string().optional(),
  })

  const getStationsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        s_Wrapper_Collection
          .merge(z.object({ data: z.array(s_Station).optional() }))
          .merge(
            z.object({
              links: s_Links_Self.merge(s_Links_Pagination).optional(),
            }),
          ),
      ],
      ["400", s_Problem],
      ["401", s_Problem],
      ["403", s_Problem],
      ["429", s_Problem],
      ["500", s_Problem],
    ],
    undefined,
  )

  router.get("getStations", "/stations", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getStationsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<
          t_Wrapper_Collection & {
            data?: t_Station[]
          } & {
            links?: t_Links_Self & t_Links_Pagination
          }
        >(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_Problem>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Problem>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_Problem>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_Problem>(429)
      },
      with500() {
        return new KoaRuntimeResponse<t_Problem>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getStations(input, responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getStationsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getTripsQuerySchema = z.object({
    page: z.coerce.number().min(1).optional().default(1),
    limit: z.coerce.number().min(1).max(100).optional().default(10),
    origin: z.string(),
    destination: z.string(),
    date: z.string().datetime({ offset: true }),
    bicycles: PermissiveBoolean.optional().default(false),
    dogs: PermissiveBoolean.optional().default(false),
  })

  const getTripsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        s_Wrapper_Collection
          .merge(z.object({ data: z.array(s_Trip).optional() }))
          .merge(
            z.object({
              links: s_Links_Self.merge(s_Links_Pagination).optional(),
            }),
          ),
      ],
      ["400", s_Problem],
      ["401", s_Problem],
      ["403", s_Problem],
      ["429", s_Problem],
      ["500", s_Problem],
    ],
    undefined,
  )

  router.get("getTrips", "/trips", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getTripsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<
          t_Wrapper_Collection & {
            data?: t_Trip[]
          } & {
            links?: t_Links_Self & t_Links_Pagination
          }
        >(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_Problem>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Problem>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_Problem>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_Problem>(429)
      },
      with500() {
        return new KoaRuntimeResponse<t_Problem>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getTrips(input, responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getTripsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getBookingsQuerySchema = z.object({
    page: z.coerce.number().min(1).optional().default(1),
    limit: z.coerce.number().min(1).max(100).optional().default(10),
  })

  const getBookingsResponseValidator = responseValidationFactory(
    [
      [
        "200",
        s_Wrapper_Collection
          .merge(z.object({ data: z.array(s_Booking).optional() }))
          .merge(
            z.object({
              links: s_Links_Self.merge(s_Links_Pagination).optional(),
            }),
          ),
      ],
      ["400", s_Problem],
      ["401", s_Problem],
      ["403", s_Problem],
      ["429", s_Problem],
      ["500", s_Problem],
    ],
    undefined,
  )

  router.get("getBookings", "/bookings", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        getBookingsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<
          t_Wrapper_Collection & {
            data?: t_Booking[]
          } & {
            links?: t_Links_Self & t_Links_Pagination
          }
        >(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_Problem>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Problem>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_Problem>(403)
      },
      with429() {
        return new KoaRuntimeResponse<t_Problem>(429)
      },
      with500() {
        return new KoaRuntimeResponse<t_Problem>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getBookings(input, responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBookingsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createBookingBodySchema = s_Booking

  const createBookingResponseValidator = responseValidationFactory(
    [
      ["201", s_Booking.merge(z.object({ links: s_Links_Self.optional() }))],
      ["400", s_Problem],
      ["401", s_Problem],
      ["404", s_Problem],
      ["409", s_Problem],
      ["429", s_Problem],
      ["500", s_Problem],
    ],
    undefined,
  )

  router.post("createBooking", "/bookings", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        createBookingBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with201() {
        return new KoaRuntimeResponse<
          t_Booking & {
            links?: t_Links_Self
          }
        >(201)
      },
      with400() {
        return new KoaRuntimeResponse<t_Problem>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Problem>(401)
      },
      with404() {
        return new KoaRuntimeResponse<t_Problem>(404)
      },
      with409() {
        return new KoaRuntimeResponse<t_Problem>(409)
      },
      with429() {
        return new KoaRuntimeResponse<t_Problem>(429)
      },
      with500() {
        return new KoaRuntimeResponse<t_Problem>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .createBooking(input, responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = createBookingResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getBookingParamSchema = z.object({ bookingId: z.string() })

  const getBookingResponseValidator = responseValidationFactory(
    [
      ["200", s_Booking.merge(z.object({ links: s_Links_Self.optional() }))],
      ["400", s_Problem],
      ["401", s_Problem],
      ["403", s_Problem],
      ["404", s_Problem],
      ["429", s_Problem],
      ["500", s_Problem],
    ],
    undefined,
  )

  router.get("getBooking", "/bookings/:bookingId", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getBookingParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<
          t_Booking & {
            links?: t_Links_Self
          }
        >(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_Problem>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Problem>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_Problem>(403)
      },
      with404() {
        return new KoaRuntimeResponse<t_Problem>(404)
      },
      with429() {
        return new KoaRuntimeResponse<t_Problem>(429)
      },
      with500() {
        return new KoaRuntimeResponse<t_Problem>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getBooking(input, responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getBookingResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteBookingParamSchema = z.object({ bookingId: z.string() })

  const deleteBookingResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", s_Problem],
      ["401", s_Problem],
      ["403", s_Problem],
      ["404", s_Problem],
      ["429", s_Problem],
      ["500", s_Problem],
    ],
    undefined,
  )

  router.delete("deleteBooking", "/bookings/:bookingId", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deleteBookingParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with204() {
        return new KoaRuntimeResponse<void>(204)
      },
      with400() {
        return new KoaRuntimeResponse<t_Problem>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Problem>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_Problem>(403)
      },
      with404() {
        return new KoaRuntimeResponse<t_Problem>(404)
      },
      with429() {
        return new KoaRuntimeResponse<t_Problem>(429)
      },
      with500() {
        return new KoaRuntimeResponse<t_Problem>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .deleteBooking(input, responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deleteBookingResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createBookingPaymentParamSchema = z.object({ bookingId: z.string() })

  const createBookingPaymentBodySchema = s_BookingPayment

  const createBookingPaymentResponseValidator = responseValidationFactory(
    [
      [
        "200",
        s_BookingPayment.merge(z.object({ links: s_Links_Booking.optional() })),
      ],
      ["400", s_Problem],
      ["401", s_Problem],
      ["403", s_Problem],
      ["429", s_Problem],
      ["500", s_Problem],
    ],
    undefined,
  )

  router.post(
    "createBookingPayment",
    "/bookings/:bookingId/payment",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          createBookingPaymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          createBookingPaymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<
            t_BookingPayment & {
              links?: t_Links_Booking
            }
          >(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Problem>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_Problem>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Problem>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_Problem>(429)
        },
        with500() {
          return new KoaRuntimeResponse<t_Problem>(500)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .createBookingPayment(input, responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = createBookingPaymentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Train Travel API
  return startServer(config)
}
