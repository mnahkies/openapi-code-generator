/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  EmptyObject,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
  t_ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsAddSelectedRepoToOrgSecretParamSchema,
  t_ActionsAddSelectedRepoToOrgVariableParamSchema,
  t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema,
  t_ActionsApproveWorkflowRunParamSchema,
  t_ActionsCancelWorkflowRunParamSchema,
  t_ActionsCreateEnvironmentVariableBodySchema,
  t_ActionsCreateEnvironmentVariableParamSchema,
  t_ActionsCreateHostedRunnerForOrgBodySchema,
  t_ActionsCreateHostedRunnerForOrgParamSchema,
  t_ActionsCreateOrUpdateEnvironmentSecretBodySchema,
  t_ActionsCreateOrUpdateEnvironmentSecretParamSchema,
  t_ActionsCreateOrUpdateOrgSecretBodySchema,
  t_ActionsCreateOrUpdateOrgSecretParamSchema,
  t_ActionsCreateOrUpdateRepoSecretBodySchema,
  t_ActionsCreateOrUpdateRepoSecretParamSchema,
  t_ActionsCreateOrgVariableBodySchema,
  t_ActionsCreateOrgVariableParamSchema,
  t_ActionsCreateRegistrationTokenForOrgParamSchema,
  t_ActionsCreateRegistrationTokenForRepoParamSchema,
  t_ActionsCreateRemoveTokenForOrgParamSchema,
  t_ActionsCreateRemoveTokenForRepoParamSchema,
  t_ActionsCreateRepoVariableBodySchema,
  t_ActionsCreateRepoVariableParamSchema,
  t_ActionsCreateSelfHostedRunnerGroupForOrgBodySchema,
  t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema,
  t_ActionsCreateWorkflowDispatchBodySchema,
  t_ActionsCreateWorkflowDispatchParamSchema,
  t_ActionsDeleteActionsCacheByIdParamSchema,
  t_ActionsDeleteActionsCacheByKeyParamSchema,
  t_ActionsDeleteActionsCacheByKeyQuerySchema,
  t_ActionsDeleteArtifactParamSchema,
  t_ActionsDeleteEnvironmentSecretParamSchema,
  t_ActionsDeleteEnvironmentVariableParamSchema,
  t_ActionsDeleteHostedRunnerForOrgParamSchema,
  t_ActionsDeleteOrgSecretParamSchema,
  t_ActionsDeleteOrgVariableParamSchema,
  t_ActionsDeleteRepoSecretParamSchema,
  t_ActionsDeleteRepoVariableParamSchema,
  t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema,
  t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema,
  t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
  t_ActionsDeleteWorkflowRunLogsParamSchema,
  t_ActionsDeleteWorkflowRunParamSchema,
  t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
  t_ActionsDisableWorkflowParamSchema,
  t_ActionsDownloadArtifactParamSchema,
  t_ActionsDownloadJobLogsForWorkflowRunParamSchema,
  t_ActionsDownloadWorkflowRunAttemptLogsParamSchema,
  t_ActionsDownloadWorkflowRunLogsParamSchema,
  t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
  t_ActionsEnableWorkflowParamSchema,
  t_ActionsForceCancelWorkflowRunParamSchema,
  t_ActionsGenerateRunnerJitconfigForOrgBodySchema,
  t_ActionsGenerateRunnerJitconfigForOrgParamSchema,
  t_ActionsGenerateRunnerJitconfigForRepoBodySchema,
  t_ActionsGenerateRunnerJitconfigForRepoParamSchema,
  t_ActionsGetActionsCacheListParamSchema,
  t_ActionsGetActionsCacheListQuerySchema,
  t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema,
  t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema,
  t_ActionsGetActionsCacheUsageForOrgParamSchema,
  t_ActionsGetActionsCacheUsageParamSchema,
  t_ActionsGetAllowedActionsOrganizationParamSchema,
  t_ActionsGetAllowedActionsRepositoryParamSchema,
  t_ActionsGetArtifactParamSchema,
  t_ActionsGetCustomOidcSubClaimForRepoParamSchema,
  t_ActionsGetEnvironmentPublicKeyParamSchema,
  t_ActionsGetEnvironmentSecretParamSchema,
  t_ActionsGetEnvironmentVariableParamSchema,
  t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
  t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
  t_ActionsGetGithubActionsPermissionsOrganizationParamSchema,
  t_ActionsGetGithubActionsPermissionsRepositoryParamSchema,
  t_ActionsGetHostedRunnerForOrgParamSchema,
  t_ActionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema,
  t_ActionsGetHostedRunnersLimitsForOrgParamSchema,
  t_ActionsGetHostedRunnersMachineSpecsForOrgParamSchema,
  t_ActionsGetHostedRunnersPartnerImagesForOrgParamSchema,
  t_ActionsGetHostedRunnersPlatformsForOrgParamSchema,
  t_ActionsGetJobForWorkflowRunParamSchema,
  t_ActionsGetOrgPublicKeyParamSchema,
  t_ActionsGetOrgSecretParamSchema,
  t_ActionsGetOrgVariableParamSchema,
  t_ActionsGetPendingDeploymentsForRunParamSchema,
  t_ActionsGetRepoPublicKeyParamSchema,
  t_ActionsGetRepoSecretParamSchema,
  t_ActionsGetRepoVariableParamSchema,
  t_ActionsGetReviewsForRunParamSchema,
  t_ActionsGetSelfHostedRunnerForOrgParamSchema,
  t_ActionsGetSelfHostedRunnerForRepoParamSchema,
  t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema,
  t_ActionsGetWorkflowAccessToRepositoryParamSchema,
  t_ActionsGetWorkflowParamSchema,
  t_ActionsGetWorkflowRunAttemptParamSchema,
  t_ActionsGetWorkflowRunAttemptQuerySchema,
  t_ActionsGetWorkflowRunParamSchema,
  t_ActionsGetWorkflowRunQuerySchema,
  t_ActionsGetWorkflowRunUsageParamSchema,
  t_ActionsGetWorkflowUsageParamSchema,
  t_ActionsListArtifactsForRepoParamSchema,
  t_ActionsListArtifactsForRepoQuerySchema,
  t_ActionsListEnvironmentSecretsParamSchema,
  t_ActionsListEnvironmentSecretsQuerySchema,
  t_ActionsListEnvironmentVariablesParamSchema,
  t_ActionsListEnvironmentVariablesQuerySchema,
  t_ActionsListGithubHostedRunnersInGroupForOrgParamSchema,
  t_ActionsListGithubHostedRunnersInGroupForOrgQuerySchema,
  t_ActionsListHostedRunnersForOrgParamSchema,
  t_ActionsListHostedRunnersForOrgQuerySchema,
  t_ActionsListJobsForWorkflowRunAttemptParamSchema,
  t_ActionsListJobsForWorkflowRunAttemptQuerySchema,
  t_ActionsListJobsForWorkflowRunParamSchema,
  t_ActionsListJobsForWorkflowRunQuerySchema,
  t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema,
  t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema,
  t_ActionsListOrgSecretsParamSchema,
  t_ActionsListOrgSecretsQuerySchema,
  t_ActionsListOrgVariablesParamSchema,
  t_ActionsListOrgVariablesQuerySchema,
  t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
  t_ActionsListRepoOrganizationSecretsParamSchema,
  t_ActionsListRepoOrganizationSecretsQuerySchema,
  t_ActionsListRepoOrganizationVariablesParamSchema,
  t_ActionsListRepoOrganizationVariablesQuerySchema,
  t_ActionsListRepoSecretsParamSchema,
  t_ActionsListRepoSecretsQuerySchema,
  t_ActionsListRepoVariablesParamSchema,
  t_ActionsListRepoVariablesQuerySchema,
  t_ActionsListRepoWorkflowsParamSchema,
  t_ActionsListRepoWorkflowsQuerySchema,
  t_ActionsListRunnerApplicationsForOrgParamSchema,
  t_ActionsListRunnerApplicationsForRepoParamSchema,
  t_ActionsListSelectedReposForOrgSecretParamSchema,
  t_ActionsListSelectedReposForOrgSecretQuerySchema,
  t_ActionsListSelectedReposForOrgVariableParamSchema,
  t_ActionsListSelectedReposForOrgVariableQuerySchema,
  t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
  t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
  t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema,
  t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema,
  t_ActionsListSelfHostedRunnersForOrgParamSchema,
  t_ActionsListSelfHostedRunnersForOrgQuerySchema,
  t_ActionsListSelfHostedRunnersForRepoParamSchema,
  t_ActionsListSelfHostedRunnersForRepoQuerySchema,
  t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema,
  t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema,
  t_ActionsListWorkflowRunArtifactsParamSchema,
  t_ActionsListWorkflowRunArtifactsQuerySchema,
  t_ActionsListWorkflowRunsForRepoParamSchema,
  t_ActionsListWorkflowRunsForRepoQuerySchema,
  t_ActionsListWorkflowRunsParamSchema,
  t_ActionsListWorkflowRunsQuerySchema,
  t_ActionsReRunJobForWorkflowRunBodySchema,
  t_ActionsReRunJobForWorkflowRunParamSchema,
  t_ActionsReRunWorkflowBodySchema,
  t_ActionsReRunWorkflowFailedJobsBodySchema,
  t_ActionsReRunWorkflowFailedJobsParamSchema,
  t_ActionsReRunWorkflowParamSchema,
  t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
  t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
  t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
  t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
  t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema,
  t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema,
  t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
  t_ActionsReviewCustomGatesForRunBodySchema,
  t_ActionsReviewCustomGatesForRunParamSchema,
  t_ActionsReviewPendingDeploymentsForRunBodySchema,
  t_ActionsReviewPendingDeploymentsForRunParamSchema,
  t_ActionsSetAllowedActionsOrganizationBodySchema,
  t_ActionsSetAllowedActionsOrganizationParamSchema,
  t_ActionsSetAllowedActionsRepositoryBodySchema,
  t_ActionsSetAllowedActionsRepositoryParamSchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
  t_ActionsSetCustomOidcSubClaimForRepoBodySchema,
  t_ActionsSetCustomOidcSubClaimForRepoParamSchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
  t_ActionsSetGithubActionsPermissionsOrganizationBodySchema,
  t_ActionsSetGithubActionsPermissionsOrganizationParamSchema,
  t_ActionsSetGithubActionsPermissionsRepositoryBodySchema,
  t_ActionsSetGithubActionsPermissionsRepositoryParamSchema,
  t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema,
  t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsSetSelectedReposForOrgSecretBodySchema,
  t_ActionsSetSelectedReposForOrgSecretParamSchema,
  t_ActionsSetSelectedReposForOrgVariableBodySchema,
  t_ActionsSetSelectedReposForOrgVariableParamSchema,
  t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema,
  t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
  t_ActionsSetSelfHostedRunnersInGroupForOrgBodySchema,
  t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema,
  t_ActionsSetWorkflowAccessToRepositoryBodySchema,
  t_ActionsSetWorkflowAccessToRepositoryParamSchema,
  t_ActionsUpdateEnvironmentVariableBodySchema,
  t_ActionsUpdateEnvironmentVariableParamSchema,
  t_ActionsUpdateHostedRunnerForOrgBodySchema,
  t_ActionsUpdateHostedRunnerForOrgParamSchema,
  t_ActionsUpdateOrgVariableBodySchema,
  t_ActionsUpdateOrgVariableParamSchema,
  t_ActionsUpdateRepoVariableBodySchema,
  t_ActionsUpdateRepoVariableParamSchema,
  t_ActionsUpdateSelfHostedRunnerGroupForOrgBodySchema,
  t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
  t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema,
  t_ActivityDeleteRepoSubscriptionParamSchema,
  t_ActivityDeleteThreadSubscriptionParamSchema,
  t_ActivityGetRepoSubscriptionParamSchema,
  t_ActivityGetThreadParamSchema,
  t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema,
  t_ActivityListEventsForAuthenticatedUserParamSchema,
  t_ActivityListEventsForAuthenticatedUserQuerySchema,
  t_ActivityListNotificationsForAuthenticatedUserQuerySchema,
  t_ActivityListOrgEventsForAuthenticatedUserParamSchema,
  t_ActivityListOrgEventsForAuthenticatedUserQuerySchema,
  t_ActivityListPublicEventsForRepoNetworkParamSchema,
  t_ActivityListPublicEventsForRepoNetworkQuerySchema,
  t_ActivityListPublicEventsForUserParamSchema,
  t_ActivityListPublicEventsForUserQuerySchema,
  t_ActivityListPublicEventsQuerySchema,
  t_ActivityListPublicOrgEventsParamSchema,
  t_ActivityListPublicOrgEventsQuerySchema,
  t_ActivityListReceivedEventsForUserParamSchema,
  t_ActivityListReceivedEventsForUserQuerySchema,
  t_ActivityListReceivedPublicEventsForUserParamSchema,
  t_ActivityListReceivedPublicEventsForUserQuerySchema,
  t_ActivityListRepoEventsParamSchema,
  t_ActivityListRepoEventsQuerySchema,
  t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema,
  t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema,
  t_ActivityListReposStarredByAuthenticatedUserQuerySchema,
  t_ActivityListReposStarredByUserParamSchema,
  t_ActivityListReposStarredByUserQuerySchema,
  t_ActivityListReposWatchedByUserParamSchema,
  t_ActivityListReposWatchedByUserQuerySchema,
  t_ActivityListStargazersForRepoParamSchema,
  t_ActivityListStargazersForRepoQuerySchema,
  t_ActivityListWatchedReposForAuthenticatedUserQuerySchema,
  t_ActivityListWatchersForRepoParamSchema,
  t_ActivityListWatchersForRepoQuerySchema,
  t_ActivityMarkNotificationsAsReadBodySchema,
  t_ActivityMarkRepoNotificationsAsReadBodySchema,
  t_ActivityMarkRepoNotificationsAsReadParamSchema,
  t_ActivityMarkThreadAsDoneParamSchema,
  t_ActivityMarkThreadAsReadParamSchema,
  t_ActivitySetRepoSubscriptionBodySchema,
  t_ActivitySetRepoSubscriptionParamSchema,
  t_ActivitySetThreadSubscriptionBodySchema,
  t_ActivitySetThreadSubscriptionParamSchema,
  t_ActivityStarRepoForAuthenticatedUserParamSchema,
  t_ActivityUnstarRepoForAuthenticatedUserParamSchema,
  t_ApiInsightsGetRouteStatsByActorParamSchema,
  t_ApiInsightsGetRouteStatsByActorQuerySchema,
  t_ApiInsightsGetSubjectStatsParamSchema,
  t_ApiInsightsGetSubjectStatsQuerySchema,
  t_ApiInsightsGetSummaryStatsByActorParamSchema,
  t_ApiInsightsGetSummaryStatsByActorQuerySchema,
  t_ApiInsightsGetSummaryStatsByUserParamSchema,
  t_ApiInsightsGetSummaryStatsByUserQuerySchema,
  t_ApiInsightsGetSummaryStatsParamSchema,
  t_ApiInsightsGetSummaryStatsQuerySchema,
  t_ApiInsightsGetTimeStatsByActorParamSchema,
  t_ApiInsightsGetTimeStatsByActorQuerySchema,
  t_ApiInsightsGetTimeStatsByUserParamSchema,
  t_ApiInsightsGetTimeStatsByUserQuerySchema,
  t_ApiInsightsGetTimeStatsParamSchema,
  t_ApiInsightsGetTimeStatsQuerySchema,
  t_ApiInsightsGetUserStatsParamSchema,
  t_ApiInsightsGetUserStatsQuerySchema,
  t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema,
  t_AppsCheckTokenBodySchema,
  t_AppsCheckTokenParamSchema,
  t_AppsCreateFromManifestParamSchema,
  t_AppsCreateInstallationAccessTokenBodySchema,
  t_AppsCreateInstallationAccessTokenParamSchema,
  t_AppsDeleteAuthorizationBodySchema,
  t_AppsDeleteAuthorizationParamSchema,
  t_AppsDeleteInstallationParamSchema,
  t_AppsDeleteTokenBodySchema,
  t_AppsDeleteTokenParamSchema,
  t_AppsGetBySlugParamSchema,
  t_AppsGetInstallationParamSchema,
  t_AppsGetOrgInstallationParamSchema,
  t_AppsGetRepoInstallationParamSchema,
  t_AppsGetSubscriptionPlanForAccountParamSchema,
  t_AppsGetSubscriptionPlanForAccountStubbedParamSchema,
  t_AppsGetUserInstallationParamSchema,
  t_AppsGetWebhookDeliveryParamSchema,
  t_AppsListAccountsForPlanParamSchema,
  t_AppsListAccountsForPlanQuerySchema,
  t_AppsListAccountsForPlanStubbedParamSchema,
  t_AppsListAccountsForPlanStubbedQuerySchema,
  t_AppsListInstallationReposForAuthenticatedUserParamSchema,
  t_AppsListInstallationReposForAuthenticatedUserQuerySchema,
  t_AppsListInstallationRequestsForAuthenticatedAppQuerySchema,
  t_AppsListInstallationsForAuthenticatedUserQuerySchema,
  t_AppsListInstallationsQuerySchema,
  t_AppsListPlansQuerySchema,
  t_AppsListPlansStubbedQuerySchema,
  t_AppsListReposAccessibleToInstallationQuerySchema,
  t_AppsListSubscriptionsForAuthenticatedUserQuerySchema,
  t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
  t_AppsListWebhookDeliveriesQuerySchema,
  t_AppsRedeliverWebhookDeliveryParamSchema,
  t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
  t_AppsResetTokenBodySchema,
  t_AppsResetTokenParamSchema,
  t_AppsScopeTokenBodySchema,
  t_AppsScopeTokenParamSchema,
  t_AppsSuspendInstallationParamSchema,
  t_AppsUnsuspendInstallationParamSchema,
  t_AppsUpdateWebhookConfigForAppBodySchema,
  t_BillingGetGithubActionsBillingOrgParamSchema,
  t_BillingGetGithubActionsBillingUserParamSchema,
  t_BillingGetGithubBillingUsageReportOrgParamSchema,
  t_BillingGetGithubBillingUsageReportOrgQuerySchema,
  t_BillingGetGithubPackagesBillingOrgParamSchema,
  t_BillingGetGithubPackagesBillingUserParamSchema,
  t_BillingGetSharedStorageBillingOrgParamSchema,
  t_BillingGetSharedStorageBillingUserParamSchema,
  t_CampaignsCreateCampaignBodySchema,
  t_CampaignsCreateCampaignParamSchema,
  t_CampaignsDeleteCampaignParamSchema,
  t_CampaignsGetCampaignSummaryParamSchema,
  t_CampaignsListOrgCampaignsParamSchema,
  t_CampaignsListOrgCampaignsQuerySchema,
  t_CampaignsUpdateCampaignBodySchema,
  t_CampaignsUpdateCampaignParamSchema,
  t_ChecksCreateBodySchema,
  t_ChecksCreateParamSchema,
  t_ChecksCreateSuiteBodySchema,
  t_ChecksCreateSuiteParamSchema,
  t_ChecksGetParamSchema,
  t_ChecksGetSuiteParamSchema,
  t_ChecksListAnnotationsParamSchema,
  t_ChecksListAnnotationsQuerySchema,
  t_ChecksListForRefParamSchema,
  t_ChecksListForRefQuerySchema,
  t_ChecksListForSuiteParamSchema,
  t_ChecksListForSuiteQuerySchema,
  t_ChecksListSuitesForRefParamSchema,
  t_ChecksListSuitesForRefQuerySchema,
  t_ChecksRerequestRunParamSchema,
  t_ChecksRerequestSuiteParamSchema,
  t_ChecksSetSuitesPreferencesBodySchema,
  t_ChecksSetSuitesPreferencesParamSchema,
  t_ChecksUpdateBodySchema,
  t_ChecksUpdateParamSchema,
  t_ClassroomGetAClassroomParamSchema,
  t_ClassroomGetAnAssignmentParamSchema,
  t_ClassroomGetAssignmentGradesParamSchema,
  t_ClassroomListAcceptedAssignmentsForAnAssignmentParamSchema,
  t_ClassroomListAcceptedAssignmentsForAnAssignmentQuerySchema,
  t_ClassroomListAssignmentsForAClassroomParamSchema,
  t_ClassroomListAssignmentsForAClassroomQuerySchema,
  t_ClassroomListClassroomsQuerySchema,
  t_CodeScanningCommitAutofixBodySchema,
  t_CodeScanningCommitAutofixParamSchema,
  t_CodeScanningCreateAutofixParamSchema,
  t_CodeScanningCreateVariantAnalysisBodySchema,
  t_CodeScanningCreateVariantAnalysisParamSchema,
  t_CodeScanningDeleteAnalysisParamSchema,
  t_CodeScanningDeleteAnalysisQuerySchema,
  t_CodeScanningDeleteCodeqlDatabaseParamSchema,
  t_CodeScanningGetAlertParamSchema,
  t_CodeScanningGetAnalysisParamSchema,
  t_CodeScanningGetAutofixParamSchema,
  t_CodeScanningGetCodeqlDatabaseParamSchema,
  t_CodeScanningGetDefaultSetupParamSchema,
  t_CodeScanningGetSarifParamSchema,
  t_CodeScanningGetVariantAnalysisParamSchema,
  t_CodeScanningGetVariantAnalysisRepoTaskParamSchema,
  t_CodeScanningListAlertInstancesParamSchema,
  t_CodeScanningListAlertInstancesQuerySchema,
  t_CodeScanningListAlertsForOrgParamSchema,
  t_CodeScanningListAlertsForOrgQuerySchema,
  t_CodeScanningListAlertsForRepoParamSchema,
  t_CodeScanningListAlertsForRepoQuerySchema,
  t_CodeScanningListCodeqlDatabasesParamSchema,
  t_CodeScanningListRecentAnalysesParamSchema,
  t_CodeScanningListRecentAnalysesQuerySchema,
  t_CodeScanningUpdateAlertBodySchema,
  t_CodeScanningUpdateAlertParamSchema,
  t_CodeScanningUpdateDefaultSetupBodySchema,
  t_CodeScanningUpdateDefaultSetupParamSchema,
  t_CodeScanningUploadSarifBodySchema,
  t_CodeScanningUploadSarifParamSchema,
  t_CodeSecurityAttachConfigurationBodySchema,
  t_CodeSecurityAttachConfigurationParamSchema,
  t_CodeSecurityAttachEnterpriseConfigurationBodySchema,
  t_CodeSecurityAttachEnterpriseConfigurationParamSchema,
  t_CodeSecurityCreateConfigurationBodySchema,
  t_CodeSecurityCreateConfigurationForEnterpriseBodySchema,
  t_CodeSecurityCreateConfigurationForEnterpriseParamSchema,
  t_CodeSecurityCreateConfigurationParamSchema,
  t_CodeSecurityDeleteConfigurationForEnterpriseParamSchema,
  t_CodeSecurityDeleteConfigurationParamSchema,
  t_CodeSecurityDetachConfigurationBodySchema,
  t_CodeSecurityDetachConfigurationParamSchema,
  t_CodeSecurityGetConfigurationForRepositoryParamSchema,
  t_CodeSecurityGetConfigurationParamSchema,
  t_CodeSecurityGetConfigurationsForEnterpriseParamSchema,
  t_CodeSecurityGetConfigurationsForEnterpriseQuerySchema,
  t_CodeSecurityGetConfigurationsForOrgParamSchema,
  t_CodeSecurityGetConfigurationsForOrgQuerySchema,
  t_CodeSecurityGetDefaultConfigurationsForEnterpriseParamSchema,
  t_CodeSecurityGetDefaultConfigurationsParamSchema,
  t_CodeSecurityGetRepositoriesForConfigurationParamSchema,
  t_CodeSecurityGetRepositoriesForConfigurationQuerySchema,
  t_CodeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema,
  t_CodeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema,
  t_CodeSecurityGetSingleConfigurationForEnterpriseParamSchema,
  t_CodeSecuritySetConfigurationAsDefaultBodySchema,
  t_CodeSecuritySetConfigurationAsDefaultForEnterpriseBodySchema,
  t_CodeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema,
  t_CodeSecuritySetConfigurationAsDefaultParamSchema,
  t_CodeSecurityUpdateConfigurationBodySchema,
  t_CodeSecurityUpdateConfigurationParamSchema,
  t_CodeSecurityUpdateEnterpriseConfigurationBodySchema,
  t_CodeSecurityUpdateEnterpriseConfigurationParamSchema,
  t_CodesOfConductGetConductCodeParamSchema,
  t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
  t_CodespacesAddSelectedRepoToOrgSecretParamSchema,
  t_CodespacesCheckPermissionsForDevcontainerParamSchema,
  t_CodespacesCheckPermissionsForDevcontainerQuerySchema,
  t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema,
  t_CodespacesCreateForAuthenticatedUserBodySchema,
  t_CodespacesCreateOrUpdateOrgSecretBodySchema,
  t_CodespacesCreateOrUpdateOrgSecretParamSchema,
  t_CodespacesCreateOrUpdateRepoSecretBodySchema,
  t_CodespacesCreateOrUpdateRepoSecretParamSchema,
  t_CodespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema,
  t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
  t_CodespacesCreateWithPrForAuthenticatedUserBodySchema,
  t_CodespacesCreateWithPrForAuthenticatedUserParamSchema,
  t_CodespacesCreateWithRepoForAuthenticatedUserBodySchema,
  t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema,
  t_CodespacesDeleteCodespacesAccessUsersBodySchema,
  t_CodespacesDeleteCodespacesAccessUsersParamSchema,
  t_CodespacesDeleteForAuthenticatedUserParamSchema,
  t_CodespacesDeleteFromOrganizationParamSchema,
  t_CodespacesDeleteOrgSecretParamSchema,
  t_CodespacesDeleteRepoSecretParamSchema,
  t_CodespacesDeleteSecretForAuthenticatedUserParamSchema,
  t_CodespacesExportForAuthenticatedUserParamSchema,
  t_CodespacesGetCodespacesForUserInOrgParamSchema,
  t_CodespacesGetCodespacesForUserInOrgQuerySchema,
  t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema,
  t_CodespacesGetForAuthenticatedUserParamSchema,
  t_CodespacesGetOrgPublicKeyParamSchema,
  t_CodespacesGetOrgSecretParamSchema,
  t_CodespacesGetRepoPublicKeyParamSchema,
  t_CodespacesGetRepoSecretParamSchema,
  t_CodespacesGetSecretForAuthenticatedUserParamSchema,
  t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
  t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
  t_CodespacesListForAuthenticatedUserQuerySchema,
  t_CodespacesListInOrganizationParamSchema,
  t_CodespacesListInOrganizationQuerySchema,
  t_CodespacesListInRepositoryForAuthenticatedUserParamSchema,
  t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema,
  t_CodespacesListOrgSecretsParamSchema,
  t_CodespacesListOrgSecretsQuerySchema,
  t_CodespacesListRepoSecretsParamSchema,
  t_CodespacesListRepoSecretsQuerySchema,
  t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
  t_CodespacesListSecretsForAuthenticatedUserQuerySchema,
  t_CodespacesListSelectedReposForOrgSecretParamSchema,
  t_CodespacesListSelectedReposForOrgSecretQuerySchema,
  t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
  t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
  t_CodespacesPublishForAuthenticatedUserBodySchema,
  t_CodespacesPublishForAuthenticatedUserParamSchema,
  t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
  t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema,
  t_CodespacesRepoMachinesForAuthenticatedUserParamSchema,
  t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema,
  t_CodespacesSetCodespacesAccessBodySchema,
  t_CodespacesSetCodespacesAccessParamSchema,
  t_CodespacesSetCodespacesAccessUsersBodySchema,
  t_CodespacesSetCodespacesAccessUsersParamSchema,
  t_CodespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema,
  t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
  t_CodespacesSetSelectedReposForOrgSecretBodySchema,
  t_CodespacesSetSelectedReposForOrgSecretParamSchema,
  t_CodespacesStartForAuthenticatedUserParamSchema,
  t_CodespacesStopForAuthenticatedUserParamSchema,
  t_CodespacesStopInOrganizationParamSchema,
  t_CodespacesUpdateForAuthenticatedUserBodySchema,
  t_CodespacesUpdateForAuthenticatedUserParamSchema,
  t_CopilotAddCopilotSeatsForTeamsBodySchema,
  t_CopilotAddCopilotSeatsForTeamsParamSchema,
  t_CopilotAddCopilotSeatsForUsersBodySchema,
  t_CopilotAddCopilotSeatsForUsersParamSchema,
  t_CopilotCancelCopilotSeatAssignmentForTeamsBodySchema,
  t_CopilotCancelCopilotSeatAssignmentForTeamsParamSchema,
  t_CopilotCancelCopilotSeatAssignmentForUsersBodySchema,
  t_CopilotCancelCopilotSeatAssignmentForUsersParamSchema,
  t_CopilotCopilotMetricsForOrganizationParamSchema,
  t_CopilotCopilotMetricsForOrganizationQuerySchema,
  t_CopilotCopilotMetricsForTeamParamSchema,
  t_CopilotCopilotMetricsForTeamQuerySchema,
  t_CopilotGetCopilotOrganizationDetailsParamSchema,
  t_CopilotGetCopilotSeatDetailsForUserParamSchema,
  t_CopilotListCopilotSeatsParamSchema,
  t_CopilotListCopilotSeatsQuerySchema,
  t_DependabotAddSelectedRepoToOrgSecretParamSchema,
  t_DependabotCreateOrUpdateOrgSecretBodySchema,
  t_DependabotCreateOrUpdateOrgSecretParamSchema,
  t_DependabotCreateOrUpdateRepoSecretBodySchema,
  t_DependabotCreateOrUpdateRepoSecretParamSchema,
  t_DependabotDeleteOrgSecretParamSchema,
  t_DependabotDeleteRepoSecretParamSchema,
  t_DependabotGetAlertParamSchema,
  t_DependabotGetOrgPublicKeyParamSchema,
  t_DependabotGetOrgSecretParamSchema,
  t_DependabotGetRepoPublicKeyParamSchema,
  t_DependabotGetRepoSecretParamSchema,
  t_DependabotListAlertsForEnterpriseParamSchema,
  t_DependabotListAlertsForEnterpriseQuerySchema,
  t_DependabotListAlertsForOrgParamSchema,
  t_DependabotListAlertsForOrgQuerySchema,
  t_DependabotListAlertsForRepoParamSchema,
  t_DependabotListAlertsForRepoQuerySchema,
  t_DependabotListOrgSecretsParamSchema,
  t_DependabotListOrgSecretsQuerySchema,
  t_DependabotListRepoSecretsParamSchema,
  t_DependabotListRepoSecretsQuerySchema,
  t_DependabotListSelectedReposForOrgSecretParamSchema,
  t_DependabotListSelectedReposForOrgSecretQuerySchema,
  t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema,
  t_DependabotSetSelectedReposForOrgSecretBodySchema,
  t_DependabotSetSelectedReposForOrgSecretParamSchema,
  t_DependabotUpdateAlertBodySchema,
  t_DependabotUpdateAlertParamSchema,
  t_DependencyGraphCreateRepositorySnapshotBodySchema,
  t_DependencyGraphCreateRepositorySnapshotParamSchema,
  t_DependencyGraphDiffRangeParamSchema,
  t_DependencyGraphDiffRangeQuerySchema,
  t_DependencyGraphExportSbomParamSchema,
  t_GistsCheckIsStarredParamSchema,
  t_GistsCreateBodySchema,
  t_GistsCreateCommentBodySchema,
  t_GistsCreateCommentParamSchema,
  t_GistsDeleteCommentParamSchema,
  t_GistsDeleteParamSchema,
  t_GistsForkParamSchema,
  t_GistsGetCommentParamSchema,
  t_GistsGetParamSchema,
  t_GistsGetRevisionParamSchema,
  t_GistsListCommentsParamSchema,
  t_GistsListCommentsQuerySchema,
  t_GistsListCommitsParamSchema,
  t_GistsListCommitsQuerySchema,
  t_GistsListForUserParamSchema,
  t_GistsListForUserQuerySchema,
  t_GistsListForksParamSchema,
  t_GistsListForksQuerySchema,
  t_GistsListPublicQuerySchema,
  t_GistsListQuerySchema,
  t_GistsListStarredQuerySchema,
  t_GistsStarParamSchema,
  t_GistsUnstarParamSchema,
  t_GistsUpdateBodySchema,
  t_GistsUpdateCommentBodySchema,
  t_GistsUpdateCommentParamSchema,
  t_GistsUpdateParamSchema,
  t_GitCreateBlobBodySchema,
  t_GitCreateBlobParamSchema,
  t_GitCreateCommitBodySchema,
  t_GitCreateCommitParamSchema,
  t_GitCreateRefBodySchema,
  t_GitCreateRefParamSchema,
  t_GitCreateTagBodySchema,
  t_GitCreateTagParamSchema,
  t_GitCreateTreeBodySchema,
  t_GitCreateTreeParamSchema,
  t_GitDeleteRefParamSchema,
  t_GitGetBlobParamSchema,
  t_GitGetCommitParamSchema,
  t_GitGetRefParamSchema,
  t_GitGetTagParamSchema,
  t_GitGetTreeParamSchema,
  t_GitGetTreeQuerySchema,
  t_GitListMatchingRefsParamSchema,
  t_GitUpdateRefBodySchema,
  t_GitUpdateRefParamSchema,
  t_GitignoreGetTemplateParamSchema,
  t_HostedComputeCreateNetworkConfigurationForOrgBodySchema,
  t_HostedComputeCreateNetworkConfigurationForOrgParamSchema,
  t_HostedComputeDeleteNetworkConfigurationFromOrgParamSchema,
  t_HostedComputeGetNetworkConfigurationForOrgParamSchema,
  t_HostedComputeGetNetworkSettingsForOrgParamSchema,
  t_HostedComputeListNetworkConfigurationsForOrgParamSchema,
  t_HostedComputeListNetworkConfigurationsForOrgQuerySchema,
  t_HostedComputeUpdateNetworkConfigurationForOrgBodySchema,
  t_HostedComputeUpdateNetworkConfigurationForOrgParamSchema,
  t_InteractionsGetRestrictionsForOrgParamSchema,
  t_InteractionsGetRestrictionsForRepoParamSchema,
  t_InteractionsRemoveRestrictionsForOrgParamSchema,
  t_InteractionsRemoveRestrictionsForRepoParamSchema,
  t_InteractionsSetRestrictionsForAuthenticatedUserBodySchema,
  t_InteractionsSetRestrictionsForOrgBodySchema,
  t_InteractionsSetRestrictionsForOrgParamSchema,
  t_InteractionsSetRestrictionsForRepoBodySchema,
  t_InteractionsSetRestrictionsForRepoParamSchema,
  t_IssuesAddAssigneesBodySchema,
  t_IssuesAddAssigneesParamSchema,
  t_IssuesAddLabelsBodySchema,
  t_IssuesAddLabelsParamSchema,
  t_IssuesAddSubIssueBodySchema,
  t_IssuesAddSubIssueParamSchema,
  t_IssuesCheckUserCanBeAssignedParamSchema,
  t_IssuesCheckUserCanBeAssignedToIssueParamSchema,
  t_IssuesCreateBodySchema,
  t_IssuesCreateCommentBodySchema,
  t_IssuesCreateCommentParamSchema,
  t_IssuesCreateLabelBodySchema,
  t_IssuesCreateLabelParamSchema,
  t_IssuesCreateMilestoneBodySchema,
  t_IssuesCreateMilestoneParamSchema,
  t_IssuesCreateParamSchema,
  t_IssuesDeleteCommentParamSchema,
  t_IssuesDeleteLabelParamSchema,
  t_IssuesDeleteMilestoneParamSchema,
  t_IssuesGetCommentParamSchema,
  t_IssuesGetEventParamSchema,
  t_IssuesGetLabelParamSchema,
  t_IssuesGetMilestoneParamSchema,
  t_IssuesGetParamSchema,
  t_IssuesListAssigneesParamSchema,
  t_IssuesListAssigneesQuerySchema,
  t_IssuesListCommentsForRepoParamSchema,
  t_IssuesListCommentsForRepoQuerySchema,
  t_IssuesListCommentsParamSchema,
  t_IssuesListCommentsQuerySchema,
  t_IssuesListEventsForRepoParamSchema,
  t_IssuesListEventsForRepoQuerySchema,
  t_IssuesListEventsForTimelineParamSchema,
  t_IssuesListEventsForTimelineQuerySchema,
  t_IssuesListEventsParamSchema,
  t_IssuesListEventsQuerySchema,
  t_IssuesListForAuthenticatedUserQuerySchema,
  t_IssuesListForOrgParamSchema,
  t_IssuesListForOrgQuerySchema,
  t_IssuesListForRepoParamSchema,
  t_IssuesListForRepoQuerySchema,
  t_IssuesListLabelsForMilestoneParamSchema,
  t_IssuesListLabelsForMilestoneQuerySchema,
  t_IssuesListLabelsForRepoParamSchema,
  t_IssuesListLabelsForRepoQuerySchema,
  t_IssuesListLabelsOnIssueParamSchema,
  t_IssuesListLabelsOnIssueQuerySchema,
  t_IssuesListMilestonesParamSchema,
  t_IssuesListMilestonesQuerySchema,
  t_IssuesListQuerySchema,
  t_IssuesListSubIssuesParamSchema,
  t_IssuesListSubIssuesQuerySchema,
  t_IssuesLockBodySchema,
  t_IssuesLockParamSchema,
  t_IssuesRemoveAllLabelsParamSchema,
  t_IssuesRemoveAssigneesBodySchema,
  t_IssuesRemoveAssigneesParamSchema,
  t_IssuesRemoveLabelParamSchema,
  t_IssuesRemoveSubIssueBodySchema,
  t_IssuesRemoveSubIssueParamSchema,
  t_IssuesReprioritizeSubIssueBodySchema,
  t_IssuesReprioritizeSubIssueParamSchema,
  t_IssuesSetLabelsBodySchema,
  t_IssuesSetLabelsParamSchema,
  t_IssuesUnlockParamSchema,
  t_IssuesUpdateBodySchema,
  t_IssuesUpdateCommentBodySchema,
  t_IssuesUpdateCommentParamSchema,
  t_IssuesUpdateLabelBodySchema,
  t_IssuesUpdateLabelParamSchema,
  t_IssuesUpdateMilestoneBodySchema,
  t_IssuesUpdateMilestoneParamSchema,
  t_IssuesUpdateParamSchema,
  t_LicensesGetAllCommonlyUsedQuerySchema,
  t_LicensesGetForRepoParamSchema,
  t_LicensesGetForRepoQuerySchema,
  t_LicensesGetParamSchema,
  t_MarkdownRenderBodySchema,
  t_MarkdownRenderRawBodySchema,
  t_MetaGetOctocatQuerySchema,
  t_MigrationsCancelImportParamSchema,
  t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema,
  t_MigrationsDeleteArchiveForOrgParamSchema,
  t_MigrationsDownloadArchiveForOrgParamSchema,
  t_MigrationsGetArchiveForAuthenticatedUserParamSchema,
  t_MigrationsGetCommitAuthorsParamSchema,
  t_MigrationsGetCommitAuthorsQuerySchema,
  t_MigrationsGetImportStatusParamSchema,
  t_MigrationsGetLargeFilesParamSchema,
  t_MigrationsGetStatusForAuthenticatedUserParamSchema,
  t_MigrationsGetStatusForAuthenticatedUserQuerySchema,
  t_MigrationsGetStatusForOrgParamSchema,
  t_MigrationsGetStatusForOrgQuerySchema,
  t_MigrationsListForAuthenticatedUserQuerySchema,
  t_MigrationsListForOrgParamSchema,
  t_MigrationsListForOrgQuerySchema,
  t_MigrationsListReposForAuthenticatedUserParamSchema,
  t_MigrationsListReposForAuthenticatedUserQuerySchema,
  t_MigrationsListReposForOrgParamSchema,
  t_MigrationsListReposForOrgQuerySchema,
  t_MigrationsMapCommitAuthorBodySchema,
  t_MigrationsMapCommitAuthorParamSchema,
  t_MigrationsSetLfsPreferenceBodySchema,
  t_MigrationsSetLfsPreferenceParamSchema,
  t_MigrationsStartForAuthenticatedUserBodySchema,
  t_MigrationsStartForOrgBodySchema,
  t_MigrationsStartForOrgParamSchema,
  t_MigrationsStartImportBodySchema,
  t_MigrationsStartImportParamSchema,
  t_MigrationsUnlockRepoForAuthenticatedUserParamSchema,
  t_MigrationsUnlockRepoForOrgParamSchema,
  t_MigrationsUpdateImportBodySchema,
  t_MigrationsUpdateImportParamSchema,
  t_OidcGetOidcCustomSubTemplateForOrgParamSchema,
  t_OidcUpdateOidcCustomSubTemplateForOrgBodySchema,
  t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema,
  t_OrgsAddSecurityManagerTeamParamSchema,
  t_OrgsAssignTeamToOrgRoleParamSchema,
  t_OrgsAssignUserToOrgRoleParamSchema,
  t_OrgsBlockUserParamSchema,
  t_OrgsCancelInvitationParamSchema,
  t_OrgsCheckBlockedUserParamSchema,
  t_OrgsCheckMembershipForUserParamSchema,
  t_OrgsCheckPublicMembershipForUserParamSchema,
  t_OrgsConvertMemberToOutsideCollaboratorBodySchema,
  t_OrgsConvertMemberToOutsideCollaboratorParamSchema,
  t_OrgsCreateInvitationBodySchema,
  t_OrgsCreateInvitationParamSchema,
  t_OrgsCreateIssueTypeBodySchema,
  t_OrgsCreateIssueTypeParamSchema,
  t_OrgsCreateOrUpdateCustomPropertiesBodySchema,
  t_OrgsCreateOrUpdateCustomPropertiesParamSchema,
  t_OrgsCreateOrUpdateCustomPropertiesValuesForReposBodySchema,
  t_OrgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema,
  t_OrgsCreateOrUpdateCustomPropertyBodySchema,
  t_OrgsCreateOrUpdateCustomPropertyParamSchema,
  t_OrgsCreateWebhookBodySchema,
  t_OrgsCreateWebhookParamSchema,
  t_OrgsDeleteIssueTypeParamSchema,
  t_OrgsDeleteParamSchema,
  t_OrgsDeleteWebhookParamSchema,
  t_OrgsEnableOrDisableSecurityProductOnAllOrgReposBodySchema,
  t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
  t_OrgsGetAllCustomPropertiesParamSchema,
  t_OrgsGetCustomPropertyParamSchema,
  t_OrgsGetMembershipForAuthenticatedUserParamSchema,
  t_OrgsGetMembershipForUserParamSchema,
  t_OrgsGetOrgRoleParamSchema,
  t_OrgsGetOrgRulesetHistoryParamSchema,
  t_OrgsGetOrgRulesetHistoryQuerySchema,
  t_OrgsGetOrgRulesetVersionParamSchema,
  t_OrgsGetParamSchema,
  t_OrgsGetWebhookConfigForOrgParamSchema,
  t_OrgsGetWebhookDeliveryParamSchema,
  t_OrgsGetWebhookParamSchema,
  t_OrgsListAppInstallationsParamSchema,
  t_OrgsListAppInstallationsQuerySchema,
  t_OrgsListAttestationsParamSchema,
  t_OrgsListAttestationsQuerySchema,
  t_OrgsListBlockedUsersParamSchema,
  t_OrgsListBlockedUsersQuerySchema,
  t_OrgsListCustomPropertiesValuesForReposParamSchema,
  t_OrgsListCustomPropertiesValuesForReposQuerySchema,
  t_OrgsListFailedInvitationsParamSchema,
  t_OrgsListFailedInvitationsQuerySchema,
  t_OrgsListForAuthenticatedUserQuerySchema,
  t_OrgsListForUserParamSchema,
  t_OrgsListForUserQuerySchema,
  t_OrgsListInvitationTeamsParamSchema,
  t_OrgsListInvitationTeamsQuerySchema,
  t_OrgsListIssueTypesParamSchema,
  t_OrgsListMembersParamSchema,
  t_OrgsListMembersQuerySchema,
  t_OrgsListMembershipsForAuthenticatedUserQuerySchema,
  t_OrgsListOrgRoleTeamsParamSchema,
  t_OrgsListOrgRoleTeamsQuerySchema,
  t_OrgsListOrgRoleUsersParamSchema,
  t_OrgsListOrgRoleUsersQuerySchema,
  t_OrgsListOrgRolesParamSchema,
  t_OrgsListOutsideCollaboratorsParamSchema,
  t_OrgsListOutsideCollaboratorsQuerySchema,
  t_OrgsListPatGrantRepositoriesParamSchema,
  t_OrgsListPatGrantRepositoriesQuerySchema,
  t_OrgsListPatGrantRequestRepositoriesParamSchema,
  t_OrgsListPatGrantRequestRepositoriesQuerySchema,
  t_OrgsListPatGrantRequestsParamSchema,
  t_OrgsListPatGrantRequestsQuerySchema,
  t_OrgsListPatGrantsParamSchema,
  t_OrgsListPatGrantsQuerySchema,
  t_OrgsListPendingInvitationsParamSchema,
  t_OrgsListPendingInvitationsQuerySchema,
  t_OrgsListPublicMembersParamSchema,
  t_OrgsListPublicMembersQuerySchema,
  t_OrgsListQuerySchema,
  t_OrgsListSecurityManagerTeamsParamSchema,
  t_OrgsListWebhookDeliveriesParamSchema,
  t_OrgsListWebhookDeliveriesQuerySchema,
  t_OrgsListWebhooksParamSchema,
  t_OrgsListWebhooksQuerySchema,
  t_OrgsPingWebhookParamSchema,
  t_OrgsRedeliverWebhookDeliveryParamSchema,
  t_OrgsRemoveCustomPropertyParamSchema,
  t_OrgsRemoveMemberParamSchema,
  t_OrgsRemoveMembershipForUserParamSchema,
  t_OrgsRemoveOutsideCollaboratorParamSchema,
  t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema,
  t_OrgsRemoveSecurityManagerTeamParamSchema,
  t_OrgsReviewPatGrantRequestBodySchema,
  t_OrgsReviewPatGrantRequestParamSchema,
  t_OrgsReviewPatGrantRequestsInBulkBodySchema,
  t_OrgsReviewPatGrantRequestsInBulkParamSchema,
  t_OrgsRevokeAllOrgRolesTeamParamSchema,
  t_OrgsRevokeAllOrgRolesUserParamSchema,
  t_OrgsRevokeOrgRoleTeamParamSchema,
  t_OrgsRevokeOrgRoleUserParamSchema,
  t_OrgsSetMembershipForUserBodySchema,
  t_OrgsSetMembershipForUserParamSchema,
  t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema,
  t_OrgsUnblockUserParamSchema,
  t_OrgsUpdateBodySchema,
  t_OrgsUpdateIssueTypeBodySchema,
  t_OrgsUpdateIssueTypeParamSchema,
  t_OrgsUpdateMembershipForAuthenticatedUserBodySchema,
  t_OrgsUpdateMembershipForAuthenticatedUserParamSchema,
  t_OrgsUpdateParamSchema,
  t_OrgsUpdatePatAccessBodySchema,
  t_OrgsUpdatePatAccessParamSchema,
  t_OrgsUpdatePatAccessesBodySchema,
  t_OrgsUpdatePatAccessesParamSchema,
  t_OrgsUpdateWebhookBodySchema,
  t_OrgsUpdateWebhookConfigForOrgBodySchema,
  t_OrgsUpdateWebhookConfigForOrgParamSchema,
  t_OrgsUpdateWebhookParamSchema,
  t_PackagesDeletePackageForAuthenticatedUserParamSchema,
  t_PackagesDeletePackageForOrgParamSchema,
  t_PackagesDeletePackageForUserParamSchema,
  t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema,
  t_PackagesDeletePackageVersionForOrgParamSchema,
  t_PackagesDeletePackageVersionForUserParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
  t_PackagesGetPackageForAuthenticatedUserParamSchema,
  t_PackagesGetPackageForOrganizationParamSchema,
  t_PackagesGetPackageForUserParamSchema,
  t_PackagesGetPackageVersionForAuthenticatedUserParamSchema,
  t_PackagesGetPackageVersionForOrganizationParamSchema,
  t_PackagesGetPackageVersionForUserParamSchema,
  t_PackagesListDockerMigrationConflictingPackagesForOrganizationParamSchema,
  t_PackagesListDockerMigrationConflictingPackagesForUserParamSchema,
  t_PackagesListPackagesForAuthenticatedUserQuerySchema,
  t_PackagesListPackagesForOrganizationParamSchema,
  t_PackagesListPackagesForOrganizationQuerySchema,
  t_PackagesListPackagesForUserParamSchema,
  t_PackagesListPackagesForUserQuerySchema,
  t_PackagesRestorePackageForAuthenticatedUserParamSchema,
  t_PackagesRestorePackageForAuthenticatedUserQuerySchema,
  t_PackagesRestorePackageForOrgParamSchema,
  t_PackagesRestorePackageForOrgQuerySchema,
  t_PackagesRestorePackageForUserParamSchema,
  t_PackagesRestorePackageForUserQuerySchema,
  t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema,
  t_PackagesRestorePackageVersionForOrgParamSchema,
  t_PackagesRestorePackageVersionForUserParamSchema,
  t_PrivateRegistriesCreateOrgPrivateRegistryBodySchema,
  t_PrivateRegistriesCreateOrgPrivateRegistryParamSchema,
  t_PrivateRegistriesDeleteOrgPrivateRegistryParamSchema,
  t_PrivateRegistriesGetOrgPrivateRegistryParamSchema,
  t_PrivateRegistriesGetOrgPublicKeyParamSchema,
  t_PrivateRegistriesListOrgPrivateRegistriesParamSchema,
  t_PrivateRegistriesListOrgPrivateRegistriesQuerySchema,
  t_PrivateRegistriesUpdateOrgPrivateRegistryBodySchema,
  t_PrivateRegistriesUpdateOrgPrivateRegistryParamSchema,
  t_ProjectsAddCollaboratorBodySchema,
  t_ProjectsAddCollaboratorParamSchema,
  t_ProjectsCreateCardBodySchema,
  t_ProjectsCreateCardParamSchema,
  t_ProjectsCreateColumnBodySchema,
  t_ProjectsCreateColumnParamSchema,
  t_ProjectsCreateForAuthenticatedUserBodySchema,
  t_ProjectsCreateForOrgBodySchema,
  t_ProjectsCreateForOrgParamSchema,
  t_ProjectsCreateForRepoBodySchema,
  t_ProjectsCreateForRepoParamSchema,
  t_ProjectsDeleteCardParamSchema,
  t_ProjectsDeleteColumnParamSchema,
  t_ProjectsDeleteParamSchema,
  t_ProjectsGetCardParamSchema,
  t_ProjectsGetColumnParamSchema,
  t_ProjectsGetParamSchema,
  t_ProjectsGetPermissionForUserParamSchema,
  t_ProjectsListCardsParamSchema,
  t_ProjectsListCardsQuerySchema,
  t_ProjectsListCollaboratorsParamSchema,
  t_ProjectsListCollaboratorsQuerySchema,
  t_ProjectsListColumnsParamSchema,
  t_ProjectsListColumnsQuerySchema,
  t_ProjectsListForOrgParamSchema,
  t_ProjectsListForOrgQuerySchema,
  t_ProjectsListForRepoParamSchema,
  t_ProjectsListForRepoQuerySchema,
  t_ProjectsListForUserParamSchema,
  t_ProjectsListForUserQuerySchema,
  t_ProjectsMoveCardBodySchema,
  t_ProjectsMoveCardParamSchema,
  t_ProjectsMoveColumnBodySchema,
  t_ProjectsMoveColumnParamSchema,
  t_ProjectsRemoveCollaboratorParamSchema,
  t_ProjectsUpdateBodySchema,
  t_ProjectsUpdateCardBodySchema,
  t_ProjectsUpdateCardParamSchema,
  t_ProjectsUpdateColumnBodySchema,
  t_ProjectsUpdateColumnParamSchema,
  t_ProjectsUpdateParamSchema,
  t_PullsCheckIfMergedParamSchema,
  t_PullsCreateBodySchema,
  t_PullsCreateParamSchema,
  t_PullsCreateReplyForReviewCommentBodySchema,
  t_PullsCreateReplyForReviewCommentParamSchema,
  t_PullsCreateReviewBodySchema,
  t_PullsCreateReviewCommentBodySchema,
  t_PullsCreateReviewCommentParamSchema,
  t_PullsCreateReviewParamSchema,
  t_PullsDeletePendingReviewParamSchema,
  t_PullsDeleteReviewCommentParamSchema,
  t_PullsDismissReviewBodySchema,
  t_PullsDismissReviewParamSchema,
  t_PullsGetParamSchema,
  t_PullsGetReviewCommentParamSchema,
  t_PullsGetReviewParamSchema,
  t_PullsListCommentsForReviewParamSchema,
  t_PullsListCommentsForReviewQuerySchema,
  t_PullsListCommitsParamSchema,
  t_PullsListCommitsQuerySchema,
  t_PullsListFilesParamSchema,
  t_PullsListFilesQuerySchema,
  t_PullsListParamSchema,
  t_PullsListQuerySchema,
  t_PullsListRequestedReviewersParamSchema,
  t_PullsListReviewCommentsForRepoParamSchema,
  t_PullsListReviewCommentsForRepoQuerySchema,
  t_PullsListReviewCommentsParamSchema,
  t_PullsListReviewCommentsQuerySchema,
  t_PullsListReviewsParamSchema,
  t_PullsListReviewsQuerySchema,
  t_PullsMergeBodySchema,
  t_PullsMergeParamSchema,
  t_PullsRemoveRequestedReviewersBodySchema,
  t_PullsRemoveRequestedReviewersParamSchema,
  t_PullsRequestReviewersBodySchema,
  t_PullsRequestReviewersParamSchema,
  t_PullsSubmitReviewBodySchema,
  t_PullsSubmitReviewParamSchema,
  t_PullsUpdateBodySchema,
  t_PullsUpdateBranchBodySchema,
  t_PullsUpdateBranchParamSchema,
  t_PullsUpdateParamSchema,
  t_PullsUpdateReviewBodySchema,
  t_PullsUpdateReviewCommentBodySchema,
  t_PullsUpdateReviewCommentParamSchema,
  t_PullsUpdateReviewParamSchema,
  t_ReactionsCreateForCommitCommentBodySchema,
  t_ReactionsCreateForCommitCommentParamSchema,
  t_ReactionsCreateForIssueBodySchema,
  t_ReactionsCreateForIssueCommentBodySchema,
  t_ReactionsCreateForIssueCommentParamSchema,
  t_ReactionsCreateForIssueParamSchema,
  t_ReactionsCreateForPullRequestReviewCommentBodySchema,
  t_ReactionsCreateForPullRequestReviewCommentParamSchema,
  t_ReactionsCreateForReleaseBodySchema,
  t_ReactionsCreateForReleaseParamSchema,
  t_ReactionsCreateForTeamDiscussionCommentInOrgBodySchema,
  t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema,
  t_ReactionsCreateForTeamDiscussionCommentLegacyBodySchema,
  t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema,
  t_ReactionsCreateForTeamDiscussionInOrgBodySchema,
  t_ReactionsCreateForTeamDiscussionInOrgParamSchema,
  t_ReactionsCreateForTeamDiscussionLegacyBodySchema,
  t_ReactionsCreateForTeamDiscussionLegacyParamSchema,
  t_ReactionsDeleteForCommitCommentParamSchema,
  t_ReactionsDeleteForIssueCommentParamSchema,
  t_ReactionsDeleteForIssueParamSchema,
  t_ReactionsDeleteForPullRequestCommentParamSchema,
  t_ReactionsDeleteForReleaseParamSchema,
  t_ReactionsDeleteForTeamDiscussionCommentParamSchema,
  t_ReactionsDeleteForTeamDiscussionParamSchema,
  t_ReactionsListForCommitCommentParamSchema,
  t_ReactionsListForCommitCommentQuerySchema,
  t_ReactionsListForIssueCommentParamSchema,
  t_ReactionsListForIssueCommentQuerySchema,
  t_ReactionsListForIssueParamSchema,
  t_ReactionsListForIssueQuerySchema,
  t_ReactionsListForPullRequestReviewCommentParamSchema,
  t_ReactionsListForPullRequestReviewCommentQuerySchema,
  t_ReactionsListForReleaseParamSchema,
  t_ReactionsListForReleaseQuerySchema,
  t_ReactionsListForTeamDiscussionCommentInOrgParamSchema,
  t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema,
  t_ReactionsListForTeamDiscussionCommentLegacyParamSchema,
  t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema,
  t_ReactionsListForTeamDiscussionInOrgParamSchema,
  t_ReactionsListForTeamDiscussionInOrgQuerySchema,
  t_ReactionsListForTeamDiscussionLegacyParamSchema,
  t_ReactionsListForTeamDiscussionLegacyQuerySchema,
  t_ReposAcceptInvitationForAuthenticatedUserParamSchema,
  t_ReposAddAppAccessRestrictionsBodySchema,
  t_ReposAddAppAccessRestrictionsParamSchema,
  t_ReposAddCollaboratorBodySchema,
  t_ReposAddCollaboratorParamSchema,
  t_ReposAddStatusCheckContextsBodySchema,
  t_ReposAddStatusCheckContextsParamSchema,
  t_ReposAddTeamAccessRestrictionsBodySchema,
  t_ReposAddTeamAccessRestrictionsParamSchema,
  t_ReposAddUserAccessRestrictionsBodySchema,
  t_ReposAddUserAccessRestrictionsParamSchema,
  t_ReposCancelPagesDeploymentParamSchema,
  t_ReposCheckAutomatedSecurityFixesParamSchema,
  t_ReposCheckCollaboratorParamSchema,
  t_ReposCheckPrivateVulnerabilityReportingParamSchema,
  t_ReposCheckVulnerabilityAlertsParamSchema,
  t_ReposCodeownersErrorsParamSchema,
  t_ReposCodeownersErrorsQuerySchema,
  t_ReposCompareCommitsParamSchema,
  t_ReposCompareCommitsQuerySchema,
  t_ReposCreateAttestationBodySchema,
  t_ReposCreateAttestationParamSchema,
  t_ReposCreateAutolinkBodySchema,
  t_ReposCreateAutolinkParamSchema,
  t_ReposCreateCommitCommentBodySchema,
  t_ReposCreateCommitCommentParamSchema,
  t_ReposCreateCommitSignatureProtectionParamSchema,
  t_ReposCreateCommitStatusBodySchema,
  t_ReposCreateCommitStatusParamSchema,
  t_ReposCreateDeployKeyBodySchema,
  t_ReposCreateDeployKeyParamSchema,
  t_ReposCreateDeploymentBodySchema,
  t_ReposCreateDeploymentBranchPolicyBodySchema,
  t_ReposCreateDeploymentBranchPolicyParamSchema,
  t_ReposCreateDeploymentParamSchema,
  t_ReposCreateDeploymentProtectionRuleBodySchema,
  t_ReposCreateDeploymentProtectionRuleParamSchema,
  t_ReposCreateDeploymentStatusBodySchema,
  t_ReposCreateDeploymentStatusParamSchema,
  t_ReposCreateDispatchEventBodySchema,
  t_ReposCreateDispatchEventParamSchema,
  t_ReposCreateForAuthenticatedUserBodySchema,
  t_ReposCreateForkBodySchema,
  t_ReposCreateForkParamSchema,
  t_ReposCreateInOrgBodySchema,
  t_ReposCreateInOrgParamSchema,
  t_ReposCreateOrUpdateCustomPropertiesValuesBodySchema,
  t_ReposCreateOrUpdateCustomPropertiesValuesParamSchema,
  t_ReposCreateOrUpdateEnvironmentBodySchema,
  t_ReposCreateOrUpdateEnvironmentParamSchema,
  t_ReposCreateOrUpdateFileContentsBodySchema,
  t_ReposCreateOrUpdateFileContentsParamSchema,
  t_ReposCreateOrgRulesetBodySchema,
  t_ReposCreateOrgRulesetParamSchema,
  t_ReposCreatePagesDeploymentBodySchema,
  t_ReposCreatePagesDeploymentParamSchema,
  t_ReposCreatePagesSiteBodySchema,
  t_ReposCreatePagesSiteParamSchema,
  t_ReposCreateReleaseBodySchema,
  t_ReposCreateReleaseParamSchema,
  t_ReposCreateRepoRulesetBodySchema,
  t_ReposCreateRepoRulesetParamSchema,
  t_ReposCreateTagProtectionBodySchema,
  t_ReposCreateTagProtectionParamSchema,
  t_ReposCreateUsingTemplateBodySchema,
  t_ReposCreateUsingTemplateParamSchema,
  t_ReposCreateWebhookBodySchema,
  t_ReposCreateWebhookParamSchema,
  t_ReposDeclineInvitationForAuthenticatedUserParamSchema,
  t_ReposDeleteAccessRestrictionsParamSchema,
  t_ReposDeleteAdminBranchProtectionParamSchema,
  t_ReposDeleteAnEnvironmentParamSchema,
  t_ReposDeleteAutolinkParamSchema,
  t_ReposDeleteBranchProtectionParamSchema,
  t_ReposDeleteCommitCommentParamSchema,
  t_ReposDeleteCommitSignatureProtectionParamSchema,
  t_ReposDeleteDeployKeyParamSchema,
  t_ReposDeleteDeploymentBranchPolicyParamSchema,
  t_ReposDeleteDeploymentParamSchema,
  t_ReposDeleteFileBodySchema,
  t_ReposDeleteFileParamSchema,
  t_ReposDeleteInvitationParamSchema,
  t_ReposDeleteOrgRulesetParamSchema,
  t_ReposDeletePagesSiteParamSchema,
  t_ReposDeleteParamSchema,
  t_ReposDeletePullRequestReviewProtectionParamSchema,
  t_ReposDeleteReleaseAssetParamSchema,
  t_ReposDeleteReleaseParamSchema,
  t_ReposDeleteRepoRulesetParamSchema,
  t_ReposDeleteTagProtectionParamSchema,
  t_ReposDeleteWebhookParamSchema,
  t_ReposDisableAutomatedSecurityFixesParamSchema,
  t_ReposDisableDeploymentProtectionRuleParamSchema,
  t_ReposDisablePrivateVulnerabilityReportingParamSchema,
  t_ReposDisableVulnerabilityAlertsParamSchema,
  t_ReposDownloadTarballArchiveParamSchema,
  t_ReposDownloadZipballArchiveParamSchema,
  t_ReposEnableAutomatedSecurityFixesParamSchema,
  t_ReposEnablePrivateVulnerabilityReportingParamSchema,
  t_ReposEnableVulnerabilityAlertsParamSchema,
  t_ReposGenerateReleaseNotesBodySchema,
  t_ReposGenerateReleaseNotesParamSchema,
  t_ReposGetAccessRestrictionsParamSchema,
  t_ReposGetAdminBranchProtectionParamSchema,
  t_ReposGetAllDeploymentProtectionRulesParamSchema,
  t_ReposGetAllEnvironmentsParamSchema,
  t_ReposGetAllEnvironmentsQuerySchema,
  t_ReposGetAllStatusCheckContextsParamSchema,
  t_ReposGetAllTopicsParamSchema,
  t_ReposGetAllTopicsQuerySchema,
  t_ReposGetAppsWithAccessToProtectedBranchParamSchema,
  t_ReposGetAutolinkParamSchema,
  t_ReposGetBranchParamSchema,
  t_ReposGetBranchProtectionParamSchema,
  t_ReposGetBranchRulesParamSchema,
  t_ReposGetBranchRulesQuerySchema,
  t_ReposGetClonesParamSchema,
  t_ReposGetClonesQuerySchema,
  t_ReposGetCodeFrequencyStatsParamSchema,
  t_ReposGetCollaboratorPermissionLevelParamSchema,
  t_ReposGetCombinedStatusForRefParamSchema,
  t_ReposGetCombinedStatusForRefQuerySchema,
  t_ReposGetCommitActivityStatsParamSchema,
  t_ReposGetCommitCommentParamSchema,
  t_ReposGetCommitParamSchema,
  t_ReposGetCommitQuerySchema,
  t_ReposGetCommitSignatureProtectionParamSchema,
  t_ReposGetCommunityProfileMetricsParamSchema,
  t_ReposGetContentParamSchema,
  t_ReposGetContentQuerySchema,
  t_ReposGetContributorsStatsParamSchema,
  t_ReposGetCustomDeploymentProtectionRuleParamSchema,
  t_ReposGetCustomPropertiesValuesParamSchema,
  t_ReposGetDeployKeyParamSchema,
  t_ReposGetDeploymentBranchPolicyParamSchema,
  t_ReposGetDeploymentParamSchema,
  t_ReposGetDeploymentStatusParamSchema,
  t_ReposGetEnvironmentParamSchema,
  t_ReposGetLatestPagesBuildParamSchema,
  t_ReposGetLatestReleaseParamSchema,
  t_ReposGetOrgRuleSuiteParamSchema,
  t_ReposGetOrgRuleSuitesParamSchema,
  t_ReposGetOrgRuleSuitesQuerySchema,
  t_ReposGetOrgRulesetParamSchema,
  t_ReposGetOrgRulesetsParamSchema,
  t_ReposGetOrgRulesetsQuerySchema,
  t_ReposGetPagesBuildParamSchema,
  t_ReposGetPagesDeploymentParamSchema,
  t_ReposGetPagesHealthCheckParamSchema,
  t_ReposGetPagesParamSchema,
  t_ReposGetParamSchema,
  t_ReposGetParticipationStatsParamSchema,
  t_ReposGetPullRequestReviewProtectionParamSchema,
  t_ReposGetPunchCardStatsParamSchema,
  t_ReposGetReadmeInDirectoryParamSchema,
  t_ReposGetReadmeInDirectoryQuerySchema,
  t_ReposGetReadmeParamSchema,
  t_ReposGetReadmeQuerySchema,
  t_ReposGetReleaseAssetParamSchema,
  t_ReposGetReleaseByTagParamSchema,
  t_ReposGetReleaseParamSchema,
  t_ReposGetRepoRuleSuiteParamSchema,
  t_ReposGetRepoRuleSuitesParamSchema,
  t_ReposGetRepoRuleSuitesQuerySchema,
  t_ReposGetRepoRulesetHistoryParamSchema,
  t_ReposGetRepoRulesetHistoryQuerySchema,
  t_ReposGetRepoRulesetParamSchema,
  t_ReposGetRepoRulesetQuerySchema,
  t_ReposGetRepoRulesetVersionParamSchema,
  t_ReposGetRepoRulesetsParamSchema,
  t_ReposGetRepoRulesetsQuerySchema,
  t_ReposGetStatusChecksProtectionParamSchema,
  t_ReposGetTeamsWithAccessToProtectedBranchParamSchema,
  t_ReposGetTopPathsParamSchema,
  t_ReposGetTopReferrersParamSchema,
  t_ReposGetUsersWithAccessToProtectedBranchParamSchema,
  t_ReposGetViewsParamSchema,
  t_ReposGetViewsQuerySchema,
  t_ReposGetWebhookConfigForRepoParamSchema,
  t_ReposGetWebhookDeliveryParamSchema,
  t_ReposGetWebhookParamSchema,
  t_ReposListActivitiesParamSchema,
  t_ReposListActivitiesQuerySchema,
  t_ReposListAttestationsParamSchema,
  t_ReposListAttestationsQuerySchema,
  t_ReposListAutolinksParamSchema,
  t_ReposListBranchesForHeadCommitParamSchema,
  t_ReposListBranchesParamSchema,
  t_ReposListBranchesQuerySchema,
  t_ReposListCollaboratorsParamSchema,
  t_ReposListCollaboratorsQuerySchema,
  t_ReposListCommentsForCommitParamSchema,
  t_ReposListCommentsForCommitQuerySchema,
  t_ReposListCommitCommentsForRepoParamSchema,
  t_ReposListCommitCommentsForRepoQuerySchema,
  t_ReposListCommitStatusesForRefParamSchema,
  t_ReposListCommitStatusesForRefQuerySchema,
  t_ReposListCommitsParamSchema,
  t_ReposListCommitsQuerySchema,
  t_ReposListContributorsParamSchema,
  t_ReposListContributorsQuerySchema,
  t_ReposListCustomDeploymentRuleIntegrationsParamSchema,
  t_ReposListCustomDeploymentRuleIntegrationsQuerySchema,
  t_ReposListDeployKeysParamSchema,
  t_ReposListDeployKeysQuerySchema,
  t_ReposListDeploymentBranchPoliciesParamSchema,
  t_ReposListDeploymentBranchPoliciesQuerySchema,
  t_ReposListDeploymentStatusesParamSchema,
  t_ReposListDeploymentStatusesQuerySchema,
  t_ReposListDeploymentsParamSchema,
  t_ReposListDeploymentsQuerySchema,
  t_ReposListForAuthenticatedUserQuerySchema,
  t_ReposListForOrgParamSchema,
  t_ReposListForOrgQuerySchema,
  t_ReposListForUserParamSchema,
  t_ReposListForUserQuerySchema,
  t_ReposListForksParamSchema,
  t_ReposListForksQuerySchema,
  t_ReposListInvitationsForAuthenticatedUserQuerySchema,
  t_ReposListInvitationsParamSchema,
  t_ReposListInvitationsQuerySchema,
  t_ReposListLanguagesParamSchema,
  t_ReposListPagesBuildsParamSchema,
  t_ReposListPagesBuildsQuerySchema,
  t_ReposListPublicQuerySchema,
  t_ReposListPullRequestsAssociatedWithCommitParamSchema,
  t_ReposListPullRequestsAssociatedWithCommitQuerySchema,
  t_ReposListReleaseAssetsParamSchema,
  t_ReposListReleaseAssetsQuerySchema,
  t_ReposListReleasesParamSchema,
  t_ReposListReleasesQuerySchema,
  t_ReposListTagProtectionParamSchema,
  t_ReposListTagsParamSchema,
  t_ReposListTagsQuerySchema,
  t_ReposListTeamsParamSchema,
  t_ReposListTeamsQuerySchema,
  t_ReposListWebhookDeliveriesParamSchema,
  t_ReposListWebhookDeliveriesQuerySchema,
  t_ReposListWebhooksParamSchema,
  t_ReposListWebhooksQuerySchema,
  t_ReposMergeBodySchema,
  t_ReposMergeParamSchema,
  t_ReposMergeUpstreamBodySchema,
  t_ReposMergeUpstreamParamSchema,
  t_ReposPingWebhookParamSchema,
  t_ReposRedeliverWebhookDeliveryParamSchema,
  t_ReposRemoveAppAccessRestrictionsBodySchema,
  t_ReposRemoveAppAccessRestrictionsParamSchema,
  t_ReposRemoveCollaboratorParamSchema,
  t_ReposRemoveStatusCheckContextsBodySchema,
  t_ReposRemoveStatusCheckContextsParamSchema,
  t_ReposRemoveStatusCheckProtectionParamSchema,
  t_ReposRemoveTeamAccessRestrictionsBodySchema,
  t_ReposRemoveTeamAccessRestrictionsParamSchema,
  t_ReposRemoveUserAccessRestrictionsBodySchema,
  t_ReposRemoveUserAccessRestrictionsParamSchema,
  t_ReposRenameBranchBodySchema,
  t_ReposRenameBranchParamSchema,
  t_ReposReplaceAllTopicsBodySchema,
  t_ReposReplaceAllTopicsParamSchema,
  t_ReposRequestPagesBuildParamSchema,
  t_ReposSetAdminBranchProtectionParamSchema,
  t_ReposSetAppAccessRestrictionsBodySchema,
  t_ReposSetAppAccessRestrictionsParamSchema,
  t_ReposSetStatusCheckContextsBodySchema,
  t_ReposSetStatusCheckContextsParamSchema,
  t_ReposSetTeamAccessRestrictionsBodySchema,
  t_ReposSetTeamAccessRestrictionsParamSchema,
  t_ReposSetUserAccessRestrictionsBodySchema,
  t_ReposSetUserAccessRestrictionsParamSchema,
  t_ReposTestPushWebhookParamSchema,
  t_ReposTransferBodySchema,
  t_ReposTransferParamSchema,
  t_ReposUpdateBodySchema,
  t_ReposUpdateBranchProtectionBodySchema,
  t_ReposUpdateBranchProtectionParamSchema,
  t_ReposUpdateCommitCommentBodySchema,
  t_ReposUpdateCommitCommentParamSchema,
  t_ReposUpdateDeploymentBranchPolicyBodySchema,
  t_ReposUpdateDeploymentBranchPolicyParamSchema,
  t_ReposUpdateInformationAboutPagesSiteBodySchema,
  t_ReposUpdateInformationAboutPagesSiteParamSchema,
  t_ReposUpdateInvitationBodySchema,
  t_ReposUpdateInvitationParamSchema,
  t_ReposUpdateOrgRulesetBodySchema,
  t_ReposUpdateOrgRulesetParamSchema,
  t_ReposUpdateParamSchema,
  t_ReposUpdatePullRequestReviewProtectionBodySchema,
  t_ReposUpdatePullRequestReviewProtectionParamSchema,
  t_ReposUpdateReleaseAssetBodySchema,
  t_ReposUpdateReleaseAssetParamSchema,
  t_ReposUpdateReleaseBodySchema,
  t_ReposUpdateReleaseParamSchema,
  t_ReposUpdateRepoRulesetBodySchema,
  t_ReposUpdateRepoRulesetParamSchema,
  t_ReposUpdateStatusCheckProtectionBodySchema,
  t_ReposUpdateStatusCheckProtectionParamSchema,
  t_ReposUpdateWebhookBodySchema,
  t_ReposUpdateWebhookConfigForRepoBodySchema,
  t_ReposUpdateWebhookConfigForRepoParamSchema,
  t_ReposUpdateWebhookParamSchema,
  t_ReposUploadReleaseAssetBodySchema,
  t_ReposUploadReleaseAssetParamSchema,
  t_ReposUploadReleaseAssetQuerySchema,
  t_SearchCodeQuerySchema,
  t_SearchCommitsQuerySchema,
  t_SearchIssuesAndPullRequestsQuerySchema,
  t_SearchLabelsQuerySchema,
  t_SearchReposQuerySchema,
  t_SearchTopicsQuerySchema,
  t_SearchUsersQuerySchema,
  t_SecretScanningCreatePushProtectionBypassBodySchema,
  t_SecretScanningCreatePushProtectionBypassParamSchema,
  t_SecretScanningGetAlertParamSchema,
  t_SecretScanningGetScanHistoryParamSchema,
  t_SecretScanningListAlertsForEnterpriseParamSchema,
  t_SecretScanningListAlertsForEnterpriseQuerySchema,
  t_SecretScanningListAlertsForOrgParamSchema,
  t_SecretScanningListAlertsForOrgQuerySchema,
  t_SecretScanningListAlertsForRepoParamSchema,
  t_SecretScanningListAlertsForRepoQuerySchema,
  t_SecretScanningListLocationsForAlertParamSchema,
  t_SecretScanningListLocationsForAlertQuerySchema,
  t_SecretScanningUpdateAlertBodySchema,
  t_SecretScanningUpdateAlertParamSchema,
  t_SecurityAdvisoriesCreateForkParamSchema,
  t_SecurityAdvisoriesCreatePrivateVulnerabilityReportBodySchema,
  t_SecurityAdvisoriesCreatePrivateVulnerabilityReportParamSchema,
  t_SecurityAdvisoriesCreateRepositoryAdvisoryBodySchema,
  t_SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema,
  t_SecurityAdvisoriesCreateRepositoryAdvisoryParamSchema,
  t_SecurityAdvisoriesGetGlobalAdvisoryParamSchema,
  t_SecurityAdvisoriesGetRepositoryAdvisoryParamSchema,
  t_SecurityAdvisoriesListGlobalAdvisoriesQuerySchema,
  t_SecurityAdvisoriesListOrgRepositoryAdvisoriesParamSchema,
  t_SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema,
  t_SecurityAdvisoriesListRepositoryAdvisoriesParamSchema,
  t_SecurityAdvisoriesListRepositoryAdvisoriesQuerySchema,
  t_SecurityAdvisoriesUpdateRepositoryAdvisoryBodySchema,
  t_SecurityAdvisoriesUpdateRepositoryAdvisoryParamSchema,
  t_TeamsAddMemberLegacyParamSchema,
  t_TeamsAddOrUpdateMembershipForUserInOrgBodySchema,
  t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema,
  t_TeamsAddOrUpdateMembershipForUserLegacyBodySchema,
  t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema,
  t_TeamsAddOrUpdateProjectPermissionsInOrgBodySchema,
  t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema,
  t_TeamsAddOrUpdateProjectPermissionsLegacyBodySchema,
  t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema,
  t_TeamsAddOrUpdateRepoPermissionsInOrgBodySchema,
  t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema,
  t_TeamsAddOrUpdateRepoPermissionsLegacyBodySchema,
  t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema,
  t_TeamsCheckPermissionsForProjectInOrgParamSchema,
  t_TeamsCheckPermissionsForProjectLegacyParamSchema,
  t_TeamsCheckPermissionsForRepoInOrgParamSchema,
  t_TeamsCheckPermissionsForRepoLegacyParamSchema,
  t_TeamsCreateBodySchema,
  t_TeamsCreateDiscussionCommentInOrgBodySchema,
  t_TeamsCreateDiscussionCommentInOrgParamSchema,
  t_TeamsCreateDiscussionCommentLegacyBodySchema,
  t_TeamsCreateDiscussionCommentLegacyParamSchema,
  t_TeamsCreateDiscussionInOrgBodySchema,
  t_TeamsCreateDiscussionInOrgParamSchema,
  t_TeamsCreateDiscussionLegacyBodySchema,
  t_TeamsCreateDiscussionLegacyParamSchema,
  t_TeamsCreateParamSchema,
  t_TeamsDeleteDiscussionCommentInOrgParamSchema,
  t_TeamsDeleteDiscussionCommentLegacyParamSchema,
  t_TeamsDeleteDiscussionInOrgParamSchema,
  t_TeamsDeleteDiscussionLegacyParamSchema,
  t_TeamsDeleteInOrgParamSchema,
  t_TeamsDeleteLegacyParamSchema,
  t_TeamsGetByNameParamSchema,
  t_TeamsGetDiscussionCommentInOrgParamSchema,
  t_TeamsGetDiscussionCommentLegacyParamSchema,
  t_TeamsGetDiscussionInOrgParamSchema,
  t_TeamsGetDiscussionLegacyParamSchema,
  t_TeamsGetLegacyParamSchema,
  t_TeamsGetMemberLegacyParamSchema,
  t_TeamsGetMembershipForUserInOrgParamSchema,
  t_TeamsGetMembershipForUserLegacyParamSchema,
  t_TeamsListChildInOrgParamSchema,
  t_TeamsListChildInOrgQuerySchema,
  t_TeamsListChildLegacyParamSchema,
  t_TeamsListChildLegacyQuerySchema,
  t_TeamsListDiscussionCommentsInOrgParamSchema,
  t_TeamsListDiscussionCommentsInOrgQuerySchema,
  t_TeamsListDiscussionCommentsLegacyParamSchema,
  t_TeamsListDiscussionCommentsLegacyQuerySchema,
  t_TeamsListDiscussionsInOrgParamSchema,
  t_TeamsListDiscussionsInOrgQuerySchema,
  t_TeamsListDiscussionsLegacyParamSchema,
  t_TeamsListDiscussionsLegacyQuerySchema,
  t_TeamsListForAuthenticatedUserQuerySchema,
  t_TeamsListMembersInOrgParamSchema,
  t_TeamsListMembersInOrgQuerySchema,
  t_TeamsListMembersLegacyParamSchema,
  t_TeamsListMembersLegacyQuerySchema,
  t_TeamsListParamSchema,
  t_TeamsListPendingInvitationsInOrgParamSchema,
  t_TeamsListPendingInvitationsInOrgQuerySchema,
  t_TeamsListPendingInvitationsLegacyParamSchema,
  t_TeamsListPendingInvitationsLegacyQuerySchema,
  t_TeamsListProjectsInOrgParamSchema,
  t_TeamsListProjectsInOrgQuerySchema,
  t_TeamsListProjectsLegacyParamSchema,
  t_TeamsListProjectsLegacyQuerySchema,
  t_TeamsListQuerySchema,
  t_TeamsListReposInOrgParamSchema,
  t_TeamsListReposInOrgQuerySchema,
  t_TeamsListReposLegacyParamSchema,
  t_TeamsListReposLegacyQuerySchema,
  t_TeamsRemoveMemberLegacyParamSchema,
  t_TeamsRemoveMembershipForUserInOrgParamSchema,
  t_TeamsRemoveMembershipForUserLegacyParamSchema,
  t_TeamsRemoveProjectInOrgParamSchema,
  t_TeamsRemoveProjectLegacyParamSchema,
  t_TeamsRemoveRepoInOrgParamSchema,
  t_TeamsRemoveRepoLegacyParamSchema,
  t_TeamsUpdateDiscussionCommentInOrgBodySchema,
  t_TeamsUpdateDiscussionCommentInOrgParamSchema,
  t_TeamsUpdateDiscussionCommentLegacyBodySchema,
  t_TeamsUpdateDiscussionCommentLegacyParamSchema,
  t_TeamsUpdateDiscussionInOrgBodySchema,
  t_TeamsUpdateDiscussionInOrgParamSchema,
  t_TeamsUpdateDiscussionLegacyBodySchema,
  t_TeamsUpdateDiscussionLegacyParamSchema,
  t_TeamsUpdateInOrgBodySchema,
  t_TeamsUpdateInOrgParamSchema,
  t_TeamsUpdateLegacyBodySchema,
  t_TeamsUpdateLegacyParamSchema,
  t_UsersAddEmailForAuthenticatedUserBodySchema,
  t_UsersAddSocialAccountForAuthenticatedUserBodySchema,
  t_UsersBlockParamSchema,
  t_UsersCheckBlockedParamSchema,
  t_UsersCheckFollowingForUserParamSchema,
  t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema,
  t_UsersCreateGpgKeyForAuthenticatedUserBodySchema,
  t_UsersCreatePublicSshKeyForAuthenticatedUserBodySchema,
  t_UsersCreateSshSigningKeyForAuthenticatedUserBodySchema,
  t_UsersDeleteEmailForAuthenticatedUserBodySchema,
  t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema,
  t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema,
  t_UsersDeleteSocialAccountForAuthenticatedUserBodySchema,
  t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
  t_UsersFollowParamSchema,
  t_UsersGetByIdParamSchema,
  t_UsersGetByUsernameParamSchema,
  t_UsersGetContextForUserParamSchema,
  t_UsersGetContextForUserQuerySchema,
  t_UsersGetGpgKeyForAuthenticatedUserParamSchema,
  t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema,
  t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema,
  t_UsersListAttestationsParamSchema,
  t_UsersListAttestationsQuerySchema,
  t_UsersListBlockedByAuthenticatedUserQuerySchema,
  t_UsersListEmailsForAuthenticatedUserQuerySchema,
  t_UsersListFollowedByAuthenticatedUserQuerySchema,
  t_UsersListFollowersForAuthenticatedUserQuerySchema,
  t_UsersListFollowersForUserParamSchema,
  t_UsersListFollowersForUserQuerySchema,
  t_UsersListFollowingForUserParamSchema,
  t_UsersListFollowingForUserQuerySchema,
  t_UsersListGpgKeysForAuthenticatedUserQuerySchema,
  t_UsersListGpgKeysForUserParamSchema,
  t_UsersListGpgKeysForUserQuerySchema,
  t_UsersListPublicEmailsForAuthenticatedUserQuerySchema,
  t_UsersListPublicKeysForUserParamSchema,
  t_UsersListPublicKeysForUserQuerySchema,
  t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema,
  t_UsersListQuerySchema,
  t_UsersListSocialAccountsForAuthenticatedUserQuerySchema,
  t_UsersListSocialAccountsForUserParamSchema,
  t_UsersListSocialAccountsForUserQuerySchema,
  t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema,
  t_UsersListSshSigningKeysForUserParamSchema,
  t_UsersListSshSigningKeysForUserQuerySchema,
  t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema,
  t_UsersUnblockParamSchema,
  t_UsersUnfollowParamSchema,
  t_UsersUpdateAuthenticatedBodySchema,
  t_actions_billing_usage,
  t_actions_cache_list,
  t_actions_cache_usage_by_repository,
  t_actions_cache_usage_org_enterprise,
  t_actions_get_default_workflow_permissions,
  t_actions_hosted_runner,
  t_actions_hosted_runner_image,
  t_actions_hosted_runner_limits,
  t_actions_hosted_runner_machine_spec,
  t_actions_organization_permissions,
  t_actions_public_key,
  t_actions_repository_permissions,
  t_actions_secret,
  t_actions_variable,
  t_actions_workflow_access_to_repository,
  t_activity,
  t_api_insights_route_stats,
  t_api_insights_subject_stats,
  t_api_insights_summary_stats,
  t_api_insights_time_stats,
  t_api_insights_user_stats,
  t_api_overview,
  t_artifact,
  t_authentication_token,
  t_authorization,
  t_autolink,
  t_base_gist,
  t_basic_error,
  t_billing_usage_report,
  t_blob,
  t_branch_protection,
  t_branch_restriction_policy,
  t_branch_short,
  t_branch_with_protection,
  t_campaign_summary,
  t_check_annotation,
  t_check_automated_security_fixes,
  t_check_run,
  t_check_suite,
  t_check_suite_preference,
  t_classroom,
  t_classroom_accepted_assignment,
  t_classroom_assignment,
  t_classroom_assignment_grade,
  t_clone_traffic,
  t_code_frequency_stat,
  t_code_of_conduct,
  t_code_scanning_alert,
  t_code_scanning_alert_instance,
  t_code_scanning_alert_items,
  t_code_scanning_analysis,
  t_code_scanning_analysis_deletion,
  t_code_scanning_autofix,
  t_code_scanning_autofix_commits_response,
  t_code_scanning_codeql_database,
  t_code_scanning_default_setup,
  t_code_scanning_default_setup_update_response,
  t_code_scanning_organization_alert_items,
  t_code_scanning_sarifs_receipt,
  t_code_scanning_sarifs_status,
  t_code_scanning_variant_analysis,
  t_code_scanning_variant_analysis_repo_task,
  t_code_search_result_item,
  t_code_security_configuration,
  t_code_security_configuration_for_repository,
  t_code_security_configuration_repositories,
  t_code_security_default_configurations,
  t_codeowners_errors,
  t_codespace,
  t_codespace_export_details,
  t_codespace_machine,
  t_codespace_with_full_repository,
  t_codespaces_org_secret,
  t_codespaces_permissions_check_for_devcontainer,
  t_codespaces_public_key,
  t_codespaces_secret,
  t_codespaces_user_public_key,
  t_collaborator,
  t_combined_billing_usage,
  t_combined_commit_status,
  t_commit,
  t_commit_activity,
  t_commit_comment,
  t_commit_comparison,
  t_commit_search_result_item,
  t_community_profile,
  t_content_directory,
  t_content_file,
  t_content_submodule,
  t_content_symlink,
  t_content_traffic,
  t_contributor,
  t_contributor_activity,
  t_copilot_organization_details,
  t_copilot_seat_details,
  t_copilot_usage_metrics_day,
  t_custom_deployment_rule_app,
  t_custom_property,
  t_custom_property_value,
  t_dependabot_alert,
  t_dependabot_alert_with_repository,
  t_dependabot_public_key,
  t_dependabot_secret,
  t_dependency_graph_diff,
  t_dependency_graph_spdx_sbom,
  t_deploy_key,
  t_deployment,
  t_deployment_branch_policy,
  t_deployment_protection_rule,
  t_deployment_status,
  t_diff_entry,
  t_email,
  t_empty_object,
  t_environment,
  t_environment_approvals,
  t_event,
  t_feed,
  t_file_commit,
  t_full_repository,
  t_gist_comment,
  t_gist_commit,
  t_gist_simple,
  t_git_commit,
  t_git_ref,
  t_git_tag,
  t_git_tree,
  t_gitignore_template,
  t_global_advisory,
  t_gpg_key,
  t_hook,
  t_hook_delivery,
  t_hook_delivery_item,
  t_hovercard,
  t_import,
  t_installation,
  t_installation_token,
  t_integration,
  t_integration_installation_request,
  t_interaction_limit_response,
  t_issue,
  t_issue_comment,
  t_issue_event,
  t_issue_event_for_issue,
  t_issue_search_result_item,
  t_issue_type,
  t_job,
  t_key,
  t_key_simple,
  t_label,
  t_label_search_result_item,
  t_language,
  t_license,
  t_license_content,
  t_license_simple,
  t_marketplace_listing_plan,
  t_marketplace_purchase,
  t_merged_upstream,
  t_migration,
  t_milestone,
  t_minimal_repository,
  t_network_configuration,
  t_network_settings,
  t_oidc_custom_sub,
  t_oidc_custom_sub_repo,
  t_org_hook,
  t_org_membership,
  t_org_private_registry_configuration,
  t_org_private_registry_configuration_with_selected_repositories,
  t_org_repo_custom_property_values,
  t_organization_actions_secret,
  t_organization_actions_variable,
  t_organization_dependabot_secret,
  t_organization_full,
  t_organization_invitation,
  t_organization_programmatic_access_grant,
  t_organization_programmatic_access_grant_request,
  t_organization_role,
  t_organization_secret_scanning_alert,
  t_organization_simple,
  t_package,
  t_package_version,
  t_packages_billing_usage,
  t_page,
  t_page_build,
  t_page_build_status,
  t_page_deployment,
  t_pages_deployment_status,
  t_pages_health_check,
  t_participation_stats,
  t_pending_deployment,
  t_porter_author,
  t_porter_large_file,
  t_private_user,
  t_project,
  t_project_card,
  t_project_collaborator_permission,
  t_project_column,
  t_protected_branch,
  t_protected_branch_admin_enforced,
  t_protected_branch_pull_request_review,
  t_public_user,
  t_pull_request,
  t_pull_request_merge_result,
  t_pull_request_review,
  t_pull_request_review_comment,
  t_pull_request_review_request,
  t_pull_request_simple,
  t_rate_limit_overview,
  t_reaction,
  t_referrer_traffic,
  t_release,
  t_release_asset,
  t_release_notes_content,
  t_repo_codespaces_secret,
  t_repo_search_result_item,
  t_repository,
  t_repository_advisory,
  t_repository_collaborator_permission,
  t_repository_invitation,
  t_repository_rule_detailed,
  t_repository_rule_violation_error,
  t_repository_ruleset,
  t_repository_subscription,
  t_review_comment,
  t_root,
  t_rule_suite,
  t_rule_suites,
  t_ruleset_version,
  t_ruleset_version_with_state,
  t_runner,
  t_runner_application,
  t_runner_groups_org,
  t_runner_label,
  t_scim_error,
  t_secret_scanning_alert,
  t_secret_scanning_location,
  t_secret_scanning_push_protection_bypass,
  t_secret_scanning_scan_history,
  t_selected_actions,
  t_short_blob,
  t_short_branch,
  t_simple_classroom,
  t_simple_classroom_assignment,
  t_simple_user,
  t_social_account,
  t_ssh_signing_key,
  t_stargazer,
  t_starred_repository,
  t_status,
  t_status_check_policy,
  t_tag,
  t_tag_protection,
  t_team,
  t_team_discussion,
  t_team_discussion_comment,
  t_team_full,
  t_team_membership,
  t_team_project,
  t_team_repository,
  t_team_role_assignment,
  t_team_simple,
  t_thread,
  t_thread_subscription,
  t_timeline_issue_events,
  t_topic,
  t_topic_search_result_item,
  t_user_marketplace_purchase,
  t_user_role_assignment,
  t_user_search_result_item,
  t_validation_error,
  t_validation_error_simple,
  t_view_traffic,
  t_webhook_config,
  t_workflow,
  t_workflow_run,
  t_workflow_run_usage,
  t_workflow_usage,
} from "./models"
import {
  PermissiveBoolean,
  s_actions_billing_usage,
  s_actions_cache_list,
  s_actions_cache_usage_by_repository,
  s_actions_cache_usage_org_enterprise,
  s_actions_enabled,
  s_actions_get_default_workflow_permissions,
  s_actions_hosted_runner,
  s_actions_hosted_runner_image,
  s_actions_hosted_runner_limits,
  s_actions_hosted_runner_machine_spec,
  s_actions_organization_permissions,
  s_actions_public_key,
  s_actions_repository_permissions,
  s_actions_secret,
  s_actions_set_default_workflow_permissions,
  s_actions_variable,
  s_actions_workflow_access_to_repository,
  s_activity,
  s_alert_number,
  s_allowed_actions,
  s_api_insights_route_stats,
  s_api_insights_subject_stats,
  s_api_insights_summary_stats,
  s_api_insights_time_stats,
  s_api_insights_user_stats,
  s_api_overview,
  s_app_permissions,
  s_artifact,
  s_authentication_token,
  s_authorization,
  s_autolink,
  s_base_gist,
  s_basic_error,
  s_billing_usage_report,
  s_blob,
  s_branch_protection,
  s_branch_restriction_policy,
  s_branch_short,
  s_branch_with_protection,
  s_campaign_state,
  s_campaign_summary,
  s_check_annotation,
  s_check_automated_security_fixes,
  s_check_run,
  s_check_suite,
  s_check_suite_preference,
  s_classroom,
  s_classroom_accepted_assignment,
  s_classroom_assignment,
  s_classroom_assignment_grade,
  s_clone_traffic,
  s_code_frequency_stat,
  s_code_of_conduct,
  s_code_scanning_alert,
  s_code_scanning_alert_create_request,
  s_code_scanning_alert_dismissed_comment,
  s_code_scanning_alert_dismissed_reason,
  s_code_scanning_alert_instance,
  s_code_scanning_alert_items,
  s_code_scanning_alert_set_state,
  s_code_scanning_alert_severity,
  s_code_scanning_alert_state_query,
  s_code_scanning_analysis,
  s_code_scanning_analysis_commit_sha,
  s_code_scanning_analysis_deletion,
  s_code_scanning_analysis_sarif_file,
  s_code_scanning_analysis_sarif_id,
  s_code_scanning_analysis_tool_guid,
  s_code_scanning_analysis_tool_name,
  s_code_scanning_autofix,
  s_code_scanning_autofix_commits,
  s_code_scanning_autofix_commits_response,
  s_code_scanning_codeql_database,
  s_code_scanning_default_setup,
  s_code_scanning_default_setup_options,
  s_code_scanning_default_setup_update,
  s_code_scanning_default_setup_update_response,
  s_code_scanning_organization_alert_items,
  s_code_scanning_ref,
  s_code_scanning_ref_full,
  s_code_scanning_sarifs_receipt,
  s_code_scanning_sarifs_status,
  s_code_scanning_variant_analysis,
  s_code_scanning_variant_analysis_repo_task,
  s_code_search_result_item,
  s_code_security_configuration,
  s_code_security_configuration_for_repository,
  s_code_security_configuration_repositories,
  s_code_security_default_configurations,
  s_codeowners_errors,
  s_codespace,
  s_codespace_export_details,
  s_codespace_machine,
  s_codespace_with_full_repository,
  s_codespaces_org_secret,
  s_codespaces_permissions_check_for_devcontainer,
  s_codespaces_public_key,
  s_codespaces_secret,
  s_codespaces_user_public_key,
  s_collaborator,
  s_combined_billing_usage,
  s_combined_commit_status,
  s_commit,
  s_commit_activity,
  s_commit_comment,
  s_commit_comparison,
  s_commit_search_result_item,
  s_community_profile,
  s_content_directory,
  s_content_file,
  s_content_submodule,
  s_content_symlink,
  s_content_traffic,
  s_contributor,
  s_contributor_activity,
  s_copilot_organization_details,
  s_copilot_seat_details,
  s_copilot_usage_metrics_day,
  s_custom_deployment_rule_app,
  s_custom_property,
  s_custom_property_set_payload,
  s_custom_property_value,
  s_dependabot_alert,
  s_dependabot_alert_with_repository,
  s_dependabot_public_key,
  s_dependabot_secret,
  s_dependency_graph_diff,
  s_dependency_graph_spdx_sbom,
  s_deploy_key,
  s_deployment,
  s_deployment_branch_policy,
  s_deployment_branch_policy_name_pattern,
  s_deployment_branch_policy_name_pattern_with_type,
  s_deployment_branch_policy_settings,
  s_deployment_protection_rule,
  s_deployment_reviewer_type,
  s_deployment_status,
  s_diff_entry,
  s_email,
  s_empty_object,
  s_enabled_repositories,
  s_environment,
  s_environment_approvals,
  s_event,
  s_feed,
  s_file_commit,
  s_full_repository,
  s_gist_comment,
  s_gist_commit,
  s_gist_simple,
  s_git_commit,
  s_git_ref,
  s_git_tag,
  s_git_tree,
  s_gitignore_template,
  s_global_advisory,
  s_gpg_key,
  s_hook,
  s_hook_delivery,
  s_hook_delivery_item,
  s_hovercard,
  s_import,
  s_installation,
  s_installation_token,
  s_integration,
  s_integration_installation_request,
  s_interaction_limit,
  s_interaction_limit_response,
  s_issue,
  s_issue_comment,
  s_issue_event,
  s_issue_event_for_issue,
  s_issue_search_result_item,
  s_issue_type,
  s_job,
  s_key,
  s_key_simple,
  s_label,
  s_label_search_result_item,
  s_language,
  s_license,
  s_license_content,
  s_license_simple,
  s_marketplace_listing_plan,
  s_marketplace_purchase,
  s_merged_upstream,
  s_migration,
  s_milestone,
  s_minimal_repository,
  s_network_configuration,
  s_network_settings,
  s_oidc_custom_sub,
  s_oidc_custom_sub_repo,
  s_org_hook,
  s_org_membership,
  s_org_private_registry_configuration,
  s_org_private_registry_configuration_with_selected_repositories,
  s_org_repo_custom_property_values,
  s_org_ruleset_conditions,
  s_organization_actions_secret,
  s_organization_actions_variable,
  s_organization_create_issue_type,
  s_organization_dependabot_secret,
  s_organization_full,
  s_organization_invitation,
  s_organization_programmatic_access_grant,
  s_organization_programmatic_access_grant_request,
  s_organization_role,
  s_organization_secret_scanning_alert,
  s_organization_simple,
  s_organization_update_issue_type,
  s_package,
  s_package_version,
  s_packages_billing_usage,
  s_page,
  s_page_build,
  s_page_build_status,
  s_page_deployment,
  s_pages_deployment_status,
  s_pages_health_check,
  s_participation_stats,
  s_pending_deployment,
  s_porter_author,
  s_porter_large_file,
  s_prevent_self_review,
  s_private_user,
  s_private_vulnerability_report_create,
  s_project,
  s_project_card,
  s_project_collaborator_permission,
  s_project_column,
  s_protected_branch,
  s_protected_branch_admin_enforced,
  s_protected_branch_pull_request_review,
  s_public_user,
  s_pull_request,
  s_pull_request_merge_result,
  s_pull_request_review,
  s_pull_request_review_comment,
  s_pull_request_review_request,
  s_pull_request_simple,
  s_rate_limit_overview,
  s_reaction,
  s_referrer_traffic,
  s_release,
  s_release_asset,
  s_release_notes_content,
  s_repo_codespaces_secret,
  s_repo_search_result_item,
  s_repository,
  s_repository_advisory,
  s_repository_advisory_create,
  s_repository_advisory_update,
  s_repository_collaborator_permission,
  s_repository_invitation,
  s_repository_rule,
  s_repository_rule_detailed,
  s_repository_rule_enforcement,
  s_repository_rule_violation_error,
  s_repository_ruleset,
  s_repository_ruleset_bypass_actor,
  s_repository_ruleset_conditions,
  s_repository_subscription,
  s_review_comment,
  s_review_custom_gates_comment_required,
  s_review_custom_gates_state_required,
  s_root,
  s_rule_suite,
  s_rule_suites,
  s_ruleset_version,
  s_ruleset_version_with_state,
  s_runner,
  s_runner_application,
  s_runner_groups_org,
  s_runner_label,
  s_scim_error,
  s_secret_scanning_alert,
  s_secret_scanning_alert_resolution,
  s_secret_scanning_alert_resolution_comment,
  s_secret_scanning_alert_state,
  s_secret_scanning_location,
  s_secret_scanning_push_protection_bypass,
  s_secret_scanning_push_protection_bypass_placeholder_id,
  s_secret_scanning_push_protection_bypass_reason,
  s_secret_scanning_scan_history,
  s_security_advisory_ecosystems,
  s_selected_actions,
  s_short_blob,
  s_short_branch,
  s_simple_classroom,
  s_simple_classroom_assignment,
  s_simple_user,
  s_snapshot,
  s_social_account,
  s_ssh_signing_key,
  s_stargazer,
  s_starred_repository,
  s_status,
  s_status_check_policy,
  s_tag,
  s_tag_protection,
  s_team,
  s_team_discussion,
  s_team_discussion_comment,
  s_team_full,
  s_team_membership,
  s_team_project,
  s_team_repository,
  s_team_role_assignment,
  s_team_simple,
  s_thread,
  s_thread_subscription,
  s_timeline_issue_events,
  s_topic,
  s_topic_search_result_item,
  s_user_marketplace_purchase,
  s_user_role_assignment,
  s_user_search_result_item,
  s_validation_error,
  s_validation_error_simple,
  s_view_traffic,
  s_wait_timer,
  s_webhook_config,
  s_webhook_config_content_type,
  s_webhook_config_insecure_ssl,
  s_webhook_config_secret,
  s_webhook_config_url,
  s_workflow,
  s_workflow_run,
  s_workflow_run_usage,
  s_workflow_usage,
} from "./schemas"
import KoaRouter, { RouterContext } from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  KoaRuntimeResponse,
  Params,
  Response,
  ServerConfig,
  b,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import { parseRequestInput } from "@nahkies/typescript-koa-runtime/zod"
import { z } from "zod"

const metaRoot = b((r) => ({
  with200: r.with200<t_root>(s_root),
  withStatus: r.withStatus,
}))

export type MetaRoot = (
  params: Params<void, void, void, void>,
  respond: (typeof metaRoot)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_root>>

const securityAdvisoriesListGlobalAdvisories = b((r) => ({
  with200: r.with200<t_global_advisory[]>(z.array(s_global_advisory)),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  with429: r.with429<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesListGlobalAdvisories = (
  params: Params<
    void,
    t_SecurityAdvisoriesListGlobalAdvisoriesQuerySchema,
    void,
    void
  >,
  respond: (typeof securityAdvisoriesListGlobalAdvisories)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_global_advisory[]>
  | Response<422, t_validation_error_simple>
  | Response<429, t_basic_error>
>

const securityAdvisoriesGetGlobalAdvisory = b((r) => ({
  with200: r.with200<t_global_advisory>(s_global_advisory),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesGetGlobalAdvisory = (
  params: Params<
    t_SecurityAdvisoriesGetGlobalAdvisoryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof securityAdvisoriesGetGlobalAdvisory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_global_advisory>
  | Response<404, t_basic_error>
>

const appsGetAuthenticated = b((r) => ({
  with200: r.with200<t_integration>(s_integration),
  withStatus: r.withStatus,
}))

export type AppsGetAuthenticated = (
  params: Params<void, void, void, void>,
  respond: (typeof appsGetAuthenticated)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_integration>>

const appsCreateFromManifest = b((r) => ({
  with201: r.with201<
    t_integration & {
      client_id: string
      client_secret: string
      pem: string
      webhook_secret: string | null
      [key: string]: unknown | undefined
    }
  >(
    z.intersection(
      s_integration,
      z.intersection(
        z.object({
          client_id: z.string(),
          client_secret: z.string(),
          webhook_secret: z.string().nullable(),
          pem: z.string(),
        }),
        z.record(z.unknown()),
      ),
    ),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type AppsCreateFromManifest = (
  params: Params<t_AppsCreateFromManifestParamSchema, void, void, void>,
  respond: (typeof appsCreateFromManifest)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      t_integration & {
        client_id: string
        client_secret: string
        pem: string
        webhook_secret: string | null
        [key: string]: unknown | undefined
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const appsGetWebhookConfigForApp = b((r) => ({
  with200: r.with200<t_webhook_config>(s_webhook_config),
  withStatus: r.withStatus,
}))

export type AppsGetWebhookConfigForApp = (
  params: Params<void, void, void, void>,
  respond: (typeof appsGetWebhookConfigForApp)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_webhook_config>>

const appsUpdateWebhookConfigForApp = b((r) => ({
  with200: r.with200<t_webhook_config>(s_webhook_config),
  withStatus: r.withStatus,
}))

export type AppsUpdateWebhookConfigForApp = (
  params: Params<void, void, t_AppsUpdateWebhookConfigForAppBodySchema, void>,
  respond: (typeof appsUpdateWebhookConfigForApp)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_webhook_config>>

const appsListWebhookDeliveries = b((r) => ({
  with200: r.with200<t_hook_delivery_item[]>(z.array(s_hook_delivery_item)),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsListWebhookDeliveries = (
  params: Params<void, t_AppsListWebhookDeliveriesQuerySchema, void, void>,
  respond: (typeof appsListWebhookDeliveries)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook_delivery_item[]>
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const appsGetWebhookDelivery = b((r) => ({
  with200: r.with200<t_hook_delivery>(s_hook_delivery),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsGetWebhookDelivery = (
  params: Params<t_AppsGetWebhookDeliveryParamSchema, void, void, void>,
  respond: (typeof appsGetWebhookDelivery)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook_delivery>
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const appsRedeliverWebhookDelivery = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsRedeliverWebhookDelivery = (
  params: Params<t_AppsRedeliverWebhookDeliveryParamSchema, void, void, void>,
  respond: (typeof appsRedeliverWebhookDelivery)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const appsListInstallationRequestsForAuthenticatedApp = b((r) => ({
  with200: r.with200<t_integration_installation_request[]>(
    z.array(s_integration_installation_request),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListInstallationRequestsForAuthenticatedApp = (
  params: Params<
    void,
    t_AppsListInstallationRequestsForAuthenticatedAppQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListInstallationRequestsForAuthenticatedApp)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_integration_installation_request[]>
  | Response<304, void>
  | Response<401, t_basic_error>
>

const appsListInstallations = b((r) => ({
  with200: r.with200<t_installation[]>(z.array(s_installation)),
  withStatus: r.withStatus,
}))

export type AppsListInstallations = (
  params: Params<void, t_AppsListInstallationsQuerySchema, void, void>,
  respond: (typeof appsListInstallations)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_installation[]>>

const appsGetInstallation = b((r) => ({
  with200: r.with200<t_installation>(s_installation),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsGetInstallation = (
  params: Params<t_AppsGetInstallationParamSchema, void, void, void>,
  respond: (typeof appsGetInstallation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_installation>
  | Response<404, t_basic_error>
>

const appsDeleteInstallation = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsDeleteInstallation = (
  params: Params<t_AppsDeleteInstallationParamSchema, void, void, void>,
  respond: (typeof appsDeleteInstallation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const appsCreateInstallationAccessToken = b((r) => ({
  with201: r.with201<t_installation_token>(s_installation_token),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsCreateInstallationAccessToken = (
  params: Params<
    t_AppsCreateInstallationAccessTokenParamSchema,
    void,
    t_AppsCreateInstallationAccessTokenBodySchema | undefined,
    void
  >,
  respond: (typeof appsCreateInstallationAccessToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_installation_token>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const appsSuspendInstallation = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsSuspendInstallation = (
  params: Params<t_AppsSuspendInstallationParamSchema, void, void, void>,
  respond: (typeof appsSuspendInstallation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const appsUnsuspendInstallation = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsUnsuspendInstallation = (
  params: Params<t_AppsUnsuspendInstallationParamSchema, void, void, void>,
  respond: (typeof appsUnsuspendInstallation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const appsDeleteAuthorization = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsDeleteAuthorization = (
  params: Params<
    t_AppsDeleteAuthorizationParamSchema,
    void,
    t_AppsDeleteAuthorizationBodySchema,
    void
  >,
  respond: (typeof appsDeleteAuthorization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<422, t_validation_error>
>

const appsCheckToken = b((r) => ({
  with200: r.with200<t_authorization>(s_authorization),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsCheckToken = (
  params: Params<
    t_AppsCheckTokenParamSchema,
    void,
    t_AppsCheckTokenBodySchema,
    void
  >,
  respond: (typeof appsCheckToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_authorization>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const appsResetToken = b((r) => ({
  with200: r.with200<t_authorization>(s_authorization),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsResetToken = (
  params: Params<
    t_AppsResetTokenParamSchema,
    void,
    t_AppsResetTokenBodySchema,
    void
  >,
  respond: (typeof appsResetToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_authorization>
  | Response<422, t_validation_error>
>

const appsDeleteToken = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsDeleteToken = (
  params: Params<
    t_AppsDeleteTokenParamSchema,
    void,
    t_AppsDeleteTokenBodySchema,
    void
  >,
  respond: (typeof appsDeleteToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<422, t_validation_error>
>

const appsScopeToken = b((r) => ({
  with200: r.with200<t_authorization>(s_authorization),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsScopeToken = (
  params: Params<
    t_AppsScopeTokenParamSchema,
    void,
    t_AppsScopeTokenBodySchema,
    void
  >,
  respond: (typeof appsScopeToken)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_authorization>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const appsGetBySlug = b((r) => ({
  with200: r.with200<t_integration>(s_integration),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsGetBySlug = (
  params: Params<t_AppsGetBySlugParamSchema, void, void, void>,
  respond: (typeof appsGetBySlug)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_integration>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const classroomGetAnAssignment = b((r) => ({
  with200: r.with200<t_classroom_assignment>(s_classroom_assignment),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ClassroomGetAnAssignment = (
  params: Params<t_ClassroomGetAnAssignmentParamSchema, void, void, void>,
  respond: (typeof classroomGetAnAssignment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_classroom_assignment>
  | Response<404, t_basic_error>
>

const classroomListAcceptedAssignmentsForAnAssignment = b((r) => ({
  with200: r.with200<t_classroom_accepted_assignment[]>(
    z.array(s_classroom_accepted_assignment),
  ),
  withStatus: r.withStatus,
}))

export type ClassroomListAcceptedAssignmentsForAnAssignment = (
  params: Params<
    t_ClassroomListAcceptedAssignmentsForAnAssignmentParamSchema,
    t_ClassroomListAcceptedAssignmentsForAnAssignmentQuerySchema,
    void,
    void
  >,
  respond: (typeof classroomListAcceptedAssignmentsForAnAssignment)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_classroom_accepted_assignment[]>
>

const classroomGetAssignmentGrades = b((r) => ({
  with200: r.with200<t_classroom_assignment_grade[]>(
    z.array(s_classroom_assignment_grade),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ClassroomGetAssignmentGrades = (
  params: Params<t_ClassroomGetAssignmentGradesParamSchema, void, void, void>,
  respond: (typeof classroomGetAssignmentGrades)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_classroom_assignment_grade[]>
  | Response<404, t_basic_error>
>

const classroomListClassrooms = b((r) => ({
  with200: r.with200<t_simple_classroom[]>(z.array(s_simple_classroom)),
  withStatus: r.withStatus,
}))

export type ClassroomListClassrooms = (
  params: Params<void, t_ClassroomListClassroomsQuerySchema, void, void>,
  respond: (typeof classroomListClassrooms)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_classroom[]>>

const classroomGetAClassroom = b((r) => ({
  with200: r.with200<t_classroom>(s_classroom),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ClassroomGetAClassroom = (
  params: Params<t_ClassroomGetAClassroomParamSchema, void, void, void>,
  respond: (typeof classroomGetAClassroom)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_classroom>
  | Response<404, t_basic_error>
>

const classroomListAssignmentsForAClassroom = b((r) => ({
  with200: r.with200<t_simple_classroom_assignment[]>(
    z.array(s_simple_classroom_assignment),
  ),
  withStatus: r.withStatus,
}))

export type ClassroomListAssignmentsForAClassroom = (
  params: Params<
    t_ClassroomListAssignmentsForAClassroomParamSchema,
    t_ClassroomListAssignmentsForAClassroomQuerySchema,
    void,
    void
  >,
  respond: (typeof classroomListAssignmentsForAClassroom)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_simple_classroom_assignment[]>
>

const codesOfConductGetAllCodesOfConduct = b((r) => ({
  with200: r.with200<t_code_of_conduct[]>(z.array(s_code_of_conduct)),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type CodesOfConductGetAllCodesOfConduct = (
  params: Params<void, void, void, void>,
  respond: (typeof codesOfConductGetAllCodesOfConduct)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_of_conduct[]>
  | Response<304, void>
>

const codesOfConductGetConductCode = b((r) => ({
  with200: r.with200<t_code_of_conduct>(s_code_of_conduct),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodesOfConductGetConductCode = (
  params: Params<t_CodesOfConductGetConductCodeParamSchema, void, void, void>,
  respond: (typeof codesOfConductGetConductCode)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_of_conduct>
  | Response<304, void>
  | Response<404, t_basic_error>
>

const emojisGet = b((r) => ({
  with200: r.with200<{
    [key: string]: string | undefined
  }>(z.record(z.string())),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type EmojisGet = (
  params: Params<void, void, void, void>,
  respond: (typeof emojisGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        [key: string]: string | undefined
      }
    >
  | Response<304, void>
>

const codeSecurityGetConfigurationsForEnterprise = b((r) => ({
  with200: r.with200<t_code_security_configuration[]>(
    z.array(s_code_security_configuration),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetConfigurationsForEnterprise = (
  params: Params<
    t_CodeSecurityGetConfigurationsForEnterpriseParamSchema,
    t_CodeSecurityGetConfigurationsForEnterpriseQuerySchema,
    void,
    void
  >,
  respond: (typeof codeSecurityGetConfigurationsForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityCreateConfigurationForEnterprise = b((r) => ({
  with201: r.with201<t_code_security_configuration>(
    s_code_security_configuration,
  ),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityCreateConfigurationForEnterprise = (
  params: Params<
    t_CodeSecurityCreateConfigurationForEnterpriseParamSchema,
    void,
    t_CodeSecurityCreateConfigurationForEnterpriseBodySchema,
    void
  >,
  respond: (typeof codeSecurityCreateConfigurationForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_code_security_configuration>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityGetDefaultConfigurationsForEnterprise = b((r) => ({
  with200: r.with200<t_code_security_default_configurations>(
    s_code_security_default_configurations,
  ),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetDefaultConfigurationsForEnterprise = (
  params: Params<
    t_CodeSecurityGetDefaultConfigurationsForEnterpriseParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeSecurityGetDefaultConfigurationsForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_default_configurations>
>

const codeSecurityGetSingleConfigurationForEnterprise = b((r) => ({
  with200: r.with200<t_code_security_configuration>(
    s_code_security_configuration,
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetSingleConfigurationForEnterprise = (
  params: Params<
    t_CodeSecurityGetSingleConfigurationForEnterpriseParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeSecurityGetSingleConfigurationForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityUpdateEnterpriseConfiguration = b((r) => ({
  with200: r.with200<t_code_security_configuration>(
    s_code_security_configuration,
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityUpdateEnterpriseConfiguration = (
  params: Params<
    t_CodeSecurityUpdateEnterpriseConfigurationParamSchema,
    void,
    t_CodeSecurityUpdateEnterpriseConfigurationBodySchema,
    void
  >,
  respond: (typeof codeSecurityUpdateEnterpriseConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const codeSecurityDeleteConfigurationForEnterprise = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityDeleteConfigurationForEnterprise = (
  params: Params<
    t_CodeSecurityDeleteConfigurationForEnterpriseParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeSecurityDeleteConfigurationForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const codeSecurityAttachEnterpriseConfiguration = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityAttachEnterpriseConfiguration = (
  params: Params<
    t_CodeSecurityAttachEnterpriseConfigurationParamSchema,
    void,
    t_CodeSecurityAttachEnterpriseConfigurationBodySchema,
    void
  >,
  respond: (typeof codeSecurityAttachEnterpriseConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const codeSecuritySetConfigurationAsDefaultForEnterprise = b((r) => ({
  with200: r.with200<{
    configuration?: t_code_security_configuration
    default_for_new_repos?: "all" | "none" | "private_and_internal" | "public"
  }>(
    z.object({
      default_for_new_repos: z
        .enum(["all", "none", "private_and_internal", "public"])
        .optional(),
      configuration: s_code_security_configuration.optional(),
    }),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecuritySetConfigurationAsDefaultForEnterprise = (
  params: Params<
    t_CodeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema,
    void,
    t_CodeSecuritySetConfigurationAsDefaultForEnterpriseBodySchema,
    void
  >,
  respond: (typeof codeSecuritySetConfigurationAsDefaultForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        configuration?: t_code_security_configuration
        default_for_new_repos?:
          | "all"
          | "none"
          | "private_and_internal"
          | "public"
      }
    >
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityGetRepositoriesForEnterpriseConfiguration = b((r) => ({
  with200: r.with200<t_code_security_configuration_repositories[]>(
    z.array(s_code_security_configuration_repositories),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetRepositoriesForEnterpriseConfiguration = (
  params: Params<
    t_CodeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema,
    t_CodeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema,
    void,
    void
  >,
  respond: (typeof codeSecurityGetRepositoriesForEnterpriseConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration_repositories[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const dependabotListAlertsForEnterprise = b((r) => ({
  with200: r.with200<t_dependabot_alert_with_repository[]>(
    z.array(s_dependabot_alert_with_repository),
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type DependabotListAlertsForEnterprise = (
  params: Params<
    t_DependabotListAlertsForEnterpriseParamSchema,
    t_DependabotListAlertsForEnterpriseQuerySchema,
    void,
    void
  >,
  respond: (typeof dependabotListAlertsForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dependabot_alert_with_repository[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const secretScanningListAlertsForEnterprise = b((r) => ({
  with200: r.with200<t_organization_secret_scanning_alert[]>(
    z.array(s_organization_secret_scanning_alert),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningListAlertsForEnterprise = (
  params: Params<
    t_SecretScanningListAlertsForEnterpriseParamSchema,
    t_SecretScanningListAlertsForEnterpriseQuerySchema,
    void,
    void
  >,
  respond: (typeof secretScanningListAlertsForEnterprise)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_secret_scanning_alert[]>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const activityListPublicEvents = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActivityListPublicEvents = (
  params: Params<void, t_ActivityListPublicEventsQuerySchema, void, void>,
  respond: (typeof activityListPublicEvents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_event[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const activityGetFeeds = b((r) => ({
  with200: r.with200<t_feed>(s_feed),
  withStatus: r.withStatus,
}))

export type ActivityGetFeeds = (
  params: Params<void, void, void, void>,
  respond: (typeof activityGetFeeds)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_feed>>

const gistsList = b((r) => ({
  with200: r.with200<t_base_gist[]>(z.array(s_base_gist)),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsList = (
  params: Params<void, t_GistsListQuerySchema, void, void>,
  respond: (typeof gistsList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_base_gist[]>
  | Response<304, void>
  | Response<403, t_basic_error>
>

const gistsCreate = b((r) => ({
  with201: r.with201<t_gist_simple>(s_gist_simple),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GistsCreate = (
  params: Params<void, void, t_GistsCreateBodySchema, void>,
  respond: (typeof gistsCreate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_gist_simple>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const gistsListPublic = b((r) => ({
  with200: r.with200<t_base_gist[]>(z.array(s_base_gist)),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GistsListPublic = (
  params: Params<void, t_GistsListPublicQuerySchema, void, void>,
  respond: (typeof gistsListPublic)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_base_gist[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const gistsListStarred = b((r) => ({
  with200: r.with200<t_base_gist[]>(z.array(s_base_gist)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsListStarred = (
  params: Params<void, t_GistsListStarredQuerySchema, void, void>,
  respond: (typeof gistsListStarred)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_base_gist[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const gistsGet = b((r) => ({
  with200: r.with200<t_gist_simple>(s_gist_simple),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<{
    block?: {
      created_at?: string
      html_url?: string | null
      reason?: string
    }
    documentation_url?: string
    message?: string
  }>(
    z.object({
      block: z
        .object({
          reason: z.string().optional(),
          created_at: z.string().optional(),
          html_url: z.string().nullable().optional(),
        })
        .optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsGet = (
  params: Params<t_GistsGetParamSchema, void, void, void>,
  respond: (typeof gistsGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_simple>
  | Response<304, void>
  | Response<
      403,
      {
        block?: {
          created_at?: string
          html_url?: string | null
          reason?: string
        }
        documentation_url?: string
        message?: string
      }
    >
  | Response<404, t_basic_error>
>

const gistsUpdate = b((r) => ({
  with200: r.with200<t_gist_simple>(s_gist_simple),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GistsUpdate = (
  params: Params<t_GistsUpdateParamSchema, void, t_GistsUpdateBodySchema, void>,
  respond: (typeof gistsUpdate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_simple>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const gistsDelete = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsDelete = (
  params: Params<t_GistsDeleteParamSchema, void, void, void>,
  respond: (typeof gistsDelete)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsListComments = b((r) => ({
  with200: r.with200<t_gist_comment[]>(z.array(s_gist_comment)),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsListComments = (
  params: Params<
    t_GistsListCommentsParamSchema,
    t_GistsListCommentsQuerySchema,
    void,
    void
  >,
  respond: (typeof gistsListComments)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_comment[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsCreateComment = b((r) => ({
  with201: r.with201<t_gist_comment>(s_gist_comment),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsCreateComment = (
  params: Params<
    t_GistsCreateCommentParamSchema,
    void,
    t_GistsCreateCommentBodySchema,
    void
  >,
  respond: (typeof gistsCreateComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_gist_comment>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsGetComment = b((r) => ({
  with200: r.with200<t_gist_comment>(s_gist_comment),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<{
    block?: {
      created_at?: string
      html_url?: string | null
      reason?: string
    }
    documentation_url?: string
    message?: string
  }>(
    z.object({
      block: z
        .object({
          reason: z.string().optional(),
          created_at: z.string().optional(),
          html_url: z.string().nullable().optional(),
        })
        .optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsGetComment = (
  params: Params<t_GistsGetCommentParamSchema, void, void, void>,
  respond: (typeof gistsGetComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_comment>
  | Response<304, void>
  | Response<
      403,
      {
        block?: {
          created_at?: string
          html_url?: string | null
          reason?: string
        }
        documentation_url?: string
        message?: string
      }
    >
  | Response<404, t_basic_error>
>

const gistsUpdateComment = b((r) => ({
  with200: r.with200<t_gist_comment>(s_gist_comment),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsUpdateComment = (
  params: Params<
    t_GistsUpdateCommentParamSchema,
    void,
    t_GistsUpdateCommentBodySchema,
    void
  >,
  respond: (typeof gistsUpdateComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_comment>
  | Response<404, t_basic_error>
>

const gistsDeleteComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsDeleteComment = (
  params: Params<t_GistsDeleteCommentParamSchema, void, void, void>,
  respond: (typeof gistsDeleteComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsListCommits = b((r) => ({
  with200: r.with200<t_gist_commit[]>(z.array(s_gist_commit)),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsListCommits = (
  params: Params<
    t_GistsListCommitsParamSchema,
    t_GistsListCommitsQuerySchema,
    void,
    void
  >,
  respond: (typeof gistsListCommits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_commit[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsListForks = b((r) => ({
  with200: r.with200<t_gist_simple[]>(z.array(s_gist_simple)),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsListForks = (
  params: Params<
    t_GistsListForksParamSchema,
    t_GistsListForksQuerySchema,
    void,
    void
  >,
  respond: (typeof gistsListForks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_simple[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsFork = b((r) => ({
  with201: r.with201<t_base_gist>(s_base_gist),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GistsFork = (
  params: Params<t_GistsForkParamSchema, void, void, void>,
  respond: (typeof gistsFork)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_base_gist>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const gistsCheckIsStarred = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<EmptyObject>(z.object({})),
  withStatus: r.withStatus,
}))

export type GistsCheckIsStarred = (
  params: Params<t_GistsCheckIsStarredParamSchema, void, void, void>,
  respond: (typeof gistsCheckIsStarred)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, EmptyObject>
>

const gistsStar = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsStar = (
  params: Params<t_GistsStarParamSchema, void, void, void>,
  respond: (typeof gistsStar)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsUnstar = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GistsUnstar = (
  params: Params<t_GistsUnstarParamSchema, void, void, void>,
  respond: (typeof gistsUnstar)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const gistsGetRevision = b((r) => ({
  with200: r.with200<t_gist_simple>(s_gist_simple),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GistsGetRevision = (
  params: Params<t_GistsGetRevisionParamSchema, void, void, void>,
  respond: (typeof gistsGetRevision)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gist_simple>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const gitignoreGetAllTemplates = b((r) => ({
  with200: r.with200<string[]>(z.array(z.string())),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type GitignoreGetAllTemplates = (
  params: Params<void, void, void, void>,
  respond: (typeof gitignoreGetAllTemplates)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, string[]> | Response<304, void>
>

const gitignoreGetTemplate = b((r) => ({
  with200: r.with200<t_gitignore_template>(s_gitignore_template),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type GitignoreGetTemplate = (
  params: Params<t_GitignoreGetTemplateParamSchema, void, void, void>,
  respond: (typeof gitignoreGetTemplate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gitignore_template>
  | Response<304, void>
>

const appsListReposAccessibleToInstallation = b((r) => ({
  with200: r.with200<{
    repositories: t_repository[]
    repository_selection?: string
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repositories: z.array(s_repository),
      repository_selection: z.string().optional(),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListReposAccessibleToInstallation = (
  params: Params<
    void,
    t_AppsListReposAccessibleToInstallationQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListReposAccessibleToInstallation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_repository[]
        repository_selection?: string
        total_count: number
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const appsRevokeInstallationAccessToken = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type AppsRevokeInstallationAccessToken = (
  params: Params<void, void, void, void>,
  respond: (typeof appsRevokeInstallationAccessToken)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const issuesList = b((r) => ({
  with200: r.with200<t_issue[]>(z.array(s_issue)),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesList = (
  params: Params<void, t_IssuesListQuerySchema, void, void>,
  respond: (typeof issuesList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue[]>
  | Response<304, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const licensesGetAllCommonlyUsed = b((r) => ({
  with200: r.with200<t_license_simple[]>(z.array(s_license_simple)),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type LicensesGetAllCommonlyUsed = (
  params: Params<void, t_LicensesGetAllCommonlyUsedQuerySchema, void, void>,
  respond: (typeof licensesGetAllCommonlyUsed)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_license_simple[]>
  | Response<304, void>
>

const licensesGet = b((r) => ({
  with200: r.with200<t_license>(s_license),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type LicensesGet = (
  params: Params<t_LicensesGetParamSchema, void, void, void>,
  respond: (typeof licensesGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_license>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const markdownRender = b((r) => ({
  with200: r.with200<string>(z.string()),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type MarkdownRender = (
  params: Params<void, void, t_MarkdownRenderBodySchema, void>,
  respond: (typeof markdownRender)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, string> | Response<304, void>
>

const markdownRenderRaw = b((r) => ({
  with200: r.with200<string>(z.string()),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type MarkdownRenderRaw = (
  params: Params<void, void, t_MarkdownRenderRawBodySchema | undefined, void>,
  respond: (typeof markdownRenderRaw)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, string> | Response<304, void>
>

const appsGetSubscriptionPlanForAccount = b((r) => ({
  with200: r.with200<t_marketplace_purchase>(s_marketplace_purchase),
  with401: r.with401<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsGetSubscriptionPlanForAccount = (
  params: Params<
    t_AppsGetSubscriptionPlanForAccountParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof appsGetSubscriptionPlanForAccount)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_marketplace_purchase>
  | Response<401, t_basic_error>
  | Response<404, t_basic_error>
>

const appsListPlans = b((r) => ({
  with200: r.with200<t_marketplace_listing_plan[]>(
    z.array(s_marketplace_listing_plan),
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListPlans = (
  params: Params<void, t_AppsListPlansQuerySchema, void, void>,
  respond: (typeof appsListPlans)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_marketplace_listing_plan[]>
  | Response<401, t_basic_error>
  | Response<404, t_basic_error>
>

const appsListAccountsForPlan = b((r) => ({
  with200: r.with200<t_marketplace_purchase[]>(z.array(s_marketplace_purchase)),
  with401: r.with401<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type AppsListAccountsForPlan = (
  params: Params<
    t_AppsListAccountsForPlanParamSchema,
    t_AppsListAccountsForPlanQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListAccountsForPlan)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_marketplace_purchase[]>
  | Response<401, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const appsGetSubscriptionPlanForAccountStubbed = b((r) => ({
  with200: r.with200<t_marketplace_purchase>(s_marketplace_purchase),
  with401: r.with401<t_basic_error>(s_basic_error),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type AppsGetSubscriptionPlanForAccountStubbed = (
  params: Params<
    t_AppsGetSubscriptionPlanForAccountStubbedParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof appsGetSubscriptionPlanForAccountStubbed)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_marketplace_purchase>
  | Response<401, t_basic_error>
  | Response<404, void>
>

const appsListPlansStubbed = b((r) => ({
  with200: r.with200<t_marketplace_listing_plan[]>(
    z.array(s_marketplace_listing_plan),
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListPlansStubbed = (
  params: Params<void, t_AppsListPlansStubbedQuerySchema, void, void>,
  respond: (typeof appsListPlansStubbed)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_marketplace_listing_plan[]>
  | Response<401, t_basic_error>
>

const appsListAccountsForPlanStubbed = b((r) => ({
  with200: r.with200<t_marketplace_purchase[]>(z.array(s_marketplace_purchase)),
  with401: r.with401<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListAccountsForPlanStubbed = (
  params: Params<
    t_AppsListAccountsForPlanStubbedParamSchema,
    t_AppsListAccountsForPlanStubbedQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListAccountsForPlanStubbed)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_marketplace_purchase[]>
  | Response<401, t_basic_error>
>

const metaGet = b((r) => ({
  with200: r.with200<t_api_overview>(s_api_overview),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type MetaGet = (
  params: Params<void, void, void, void>,
  respond: (typeof metaGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_api_overview>
  | Response<304, void>
>

const activityListPublicEventsForRepoNetwork = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  with301: r.with301<t_basic_error>(s_basic_error),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityListPublicEventsForRepoNetwork = (
  params: Params<
    t_ActivityListPublicEventsForRepoNetworkParamSchema,
    t_ActivityListPublicEventsForRepoNetworkQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListPublicEventsForRepoNetwork)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_event[]>
  | Response<301, t_basic_error>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const activityListNotificationsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_thread[]>(z.array(s_thread)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ActivityListNotificationsForAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListNotificationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListNotificationsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_thread[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const activityMarkNotificationsAsRead = b((r) => ({
  with202: r.with202<{
    message?: string
  }>(z.object({ message: z.string().optional() })),
  with205: r.with205<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityMarkNotificationsAsRead = (
  params: Params<
    void,
    void,
    t_ActivityMarkNotificationsAsReadBodySchema | undefined,
    void
  >,
  respond: (typeof activityMarkNotificationsAsRead)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        message?: string
      }
    >
  | Response<205, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const activityGetThread = b((r) => ({
  with200: r.with200<t_thread>(s_thread),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityGetThread = (
  params: Params<t_ActivityGetThreadParamSchema, void, void, void>,
  respond: (typeof activityGetThread)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_thread>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const activityMarkThreadAsRead = b((r) => ({
  with205: r.with205<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityMarkThreadAsRead = (
  params: Params<t_ActivityMarkThreadAsReadParamSchema, void, void, void>,
  respond: (typeof activityMarkThreadAsRead)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<205, void>
  | Response<304, void>
  | Response<403, t_basic_error>
>

const activityMarkThreadAsDone = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActivityMarkThreadAsDone = (
  params: Params<t_ActivityMarkThreadAsDoneParamSchema, void, void, void>,
  respond: (typeof activityMarkThreadAsDone)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const activityGetThreadSubscriptionForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_thread_subscription>(s_thread_subscription),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityGetThreadSubscriptionForAuthenticatedUser = (
  params: Params<
    t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof activityGetThreadSubscriptionForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_thread_subscription>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const activitySetThreadSubscription = b((r) => ({
  with200: r.with200<t_thread_subscription>(s_thread_subscription),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivitySetThreadSubscription = (
  params: Params<
    t_ActivitySetThreadSubscriptionParamSchema,
    void,
    t_ActivitySetThreadSubscriptionBodySchema | undefined,
    void
  >,
  respond: (typeof activitySetThreadSubscription)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_thread_subscription>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const activityDeleteThreadSubscription = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityDeleteThreadSubscription = (
  params: Params<
    t_ActivityDeleteThreadSubscriptionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof activityDeleteThreadSubscription)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const metaGetOctocat = b((r) => ({
  with200: r.with200<string>(z.string()),
  withStatus: r.withStatus,
}))

export type MetaGetOctocat = (
  params: Params<void, t_MetaGetOctocatQuerySchema, void, void>,
  respond: (typeof metaGetOctocat)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, string>>

const orgsList = b((r) => ({
  with200: r.with200<t_organization_simple[]>(z.array(s_organization_simple)),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsList = (
  params: Params<void, t_OrgsListQuerySchema, void, void>,
  respond: (typeof orgsList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_simple[]>
  | Response<304, void>
>

const billingGetGithubBillingUsageReportOrg = b((r) => ({
  with200: r.with200<t_billing_usage_report>(s_billing_usage_report),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type BillingGetGithubBillingUsageReportOrg = (
  params: Params<
    t_BillingGetGithubBillingUsageReportOrgParamSchema,
    t_BillingGetGithubBillingUsageReportOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof billingGetGithubBillingUsageReportOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_billing_usage_report>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<500, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const orgsGet = b((r) => ({
  with200: r.with200<t_organization_full>(s_organization_full),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGet = (
  params: Params<t_OrgsGetParamSchema, void, void, void>,
  respond: (typeof orgsGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_full>
  | Response<404, t_basic_error>
>

const orgsUpdate = b((r) => ({
  with200: r.with200<t_organization_full>(s_organization_full),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error | t_validation_error_simple>(
    z.union([s_validation_error, s_validation_error_simple]),
  ),
  withStatus: r.withStatus,
}))

export type OrgsUpdate = (
  params: Params<
    t_OrgsUpdateParamSchema,
    void,
    t_OrgsUpdateBodySchema | undefined,
    void
  >,
  respond: (typeof orgsUpdate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_full>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error | t_validation_error_simple>
>

const orgsDelete = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsDelete = (
  params: Params<t_OrgsDeleteParamSchema, void, void, void>,
  respond: (typeof orgsDelete)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const actionsGetActionsCacheUsageForOrg = b((r) => ({
  with200: r.with200<t_actions_cache_usage_org_enterprise>(
    s_actions_cache_usage_org_enterprise,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetActionsCacheUsageForOrg = (
  params: Params<
    t_ActionsGetActionsCacheUsageForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetActionsCacheUsageForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_actions_cache_usage_org_enterprise>
>

const actionsGetActionsCacheUsageByRepoForOrg = b((r) => ({
  with200: r.with200<{
    repository_cache_usages: t_actions_cache_usage_by_repository[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repository_cache_usages: z.array(s_actions_cache_usage_by_repository),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetActionsCacheUsageByRepoForOrg = (
  params: Params<
    t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema,
    t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsGetActionsCacheUsageByRepoForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repository_cache_usages: t_actions_cache_usage_by_repository[]
        total_count: number
      }
    >
>

const actionsListHostedRunnersForOrg = b((r) => ({
  with200: r.with200<{
    runners: t_actions_hosted_runner[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      runners: z.array(s_actions_hosted_runner),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListHostedRunnersForOrg = (
  params: Params<
    t_ActionsListHostedRunnersForOrgParamSchema,
    t_ActionsListHostedRunnersForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListHostedRunnersForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        runners: t_actions_hosted_runner[]
        total_count: number
      }
    >
>

const actionsCreateHostedRunnerForOrg = b((r) => ({
  with201: r.with201<t_actions_hosted_runner>(s_actions_hosted_runner),
  withStatus: r.withStatus,
}))

export type ActionsCreateHostedRunnerForOrg = (
  params: Params<
    t_ActionsCreateHostedRunnerForOrgParamSchema,
    void,
    t_ActionsCreateHostedRunnerForOrgBodySchema,
    void
  >,
  respond: (typeof actionsCreateHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_actions_hosted_runner>
>

const actionsGetHostedRunnersGithubOwnedImagesForOrg = b((r) => ({
  with200: r.with200<{
    images: t_actions_hosted_runner_image[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      images: z.array(s_actions_hosted_runner_image),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetHostedRunnersGithubOwnedImagesForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetHostedRunnersGithubOwnedImagesForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        images: t_actions_hosted_runner_image[]
        total_count: number
      }
    >
>

const actionsGetHostedRunnersPartnerImagesForOrg = b((r) => ({
  with200: r.with200<{
    images: t_actions_hosted_runner_image[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      images: z.array(s_actions_hosted_runner_image),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetHostedRunnersPartnerImagesForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersPartnerImagesForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetHostedRunnersPartnerImagesForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        images: t_actions_hosted_runner_image[]
        total_count: number
      }
    >
>

const actionsGetHostedRunnersLimitsForOrg = b((r) => ({
  with200: r.with200<t_actions_hosted_runner_limits>(
    s_actions_hosted_runner_limits,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetHostedRunnersLimitsForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersLimitsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetHostedRunnersLimitsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_actions_hosted_runner_limits>
>

const actionsGetHostedRunnersMachineSpecsForOrg = b((r) => ({
  with200: r.with200<{
    machine_specs: t_actions_hosted_runner_machine_spec[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      machine_specs: z.array(s_actions_hosted_runner_machine_spec),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetHostedRunnersMachineSpecsForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersMachineSpecsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetHostedRunnersMachineSpecsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        machine_specs: t_actions_hosted_runner_machine_spec[]
        total_count: number
      }
    >
>

const actionsGetHostedRunnersPlatformsForOrg = b((r) => ({
  with200: r.with200<{
    platforms: string[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      platforms: z.array(z.string()),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetHostedRunnersPlatformsForOrg = (
  params: Params<
    t_ActionsGetHostedRunnersPlatformsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetHostedRunnersPlatformsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        platforms: string[]
        total_count: number
      }
    >
>

const actionsGetHostedRunnerForOrg = b((r) => ({
  with200: r.with200<t_actions_hosted_runner>(s_actions_hosted_runner),
  withStatus: r.withStatus,
}))

export type ActionsGetHostedRunnerForOrg = (
  params: Params<t_ActionsGetHostedRunnerForOrgParamSchema, void, void, void>,
  respond: (typeof actionsGetHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_actions_hosted_runner>
>

const actionsUpdateHostedRunnerForOrg = b((r) => ({
  with200: r.with200<t_actions_hosted_runner>(s_actions_hosted_runner),
  withStatus: r.withStatus,
}))

export type ActionsUpdateHostedRunnerForOrg = (
  params: Params<
    t_ActionsUpdateHostedRunnerForOrgParamSchema,
    void,
    t_ActionsUpdateHostedRunnerForOrgBodySchema,
    void
  >,
  respond: (typeof actionsUpdateHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_actions_hosted_runner>
>

const actionsDeleteHostedRunnerForOrg = b((r) => ({
  with202: r.with202<t_actions_hosted_runner>(s_actions_hosted_runner),
  withStatus: r.withStatus,
}))

export type ActionsDeleteHostedRunnerForOrg = (
  params: Params<
    t_ActionsDeleteHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDeleteHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<202, t_actions_hosted_runner>
>

const oidcGetOidcCustomSubTemplateForOrg = b((r) => ({
  with200: r.with200<t_oidc_custom_sub>(s_oidc_custom_sub),
  withStatus: r.withStatus,
}))

export type OidcGetOidcCustomSubTemplateForOrg = (
  params: Params<
    t_OidcGetOidcCustomSubTemplateForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof oidcGetOidcCustomSubTemplateForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_oidc_custom_sub>>

const oidcUpdateOidcCustomSubTemplateForOrg = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OidcUpdateOidcCustomSubTemplateForOrg = (
  params: Params<
    t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema,
    void,
    t_OidcUpdateOidcCustomSubTemplateForOrgBodySchema,
    void
  >,
  respond: (typeof oidcUpdateOidcCustomSubTemplateForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const actionsGetGithubActionsPermissionsOrganization = b((r) => ({
  with200: r.with200<t_actions_organization_permissions>(
    s_actions_organization_permissions,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetGithubActionsPermissionsOrganization = (
  params: Params<
    t_ActionsGetGithubActionsPermissionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetGithubActionsPermissionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_actions_organization_permissions>
>

const actionsSetGithubActionsPermissionsOrganization = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetGithubActionsPermissionsOrganization = (
  params: Params<
    t_ActionsSetGithubActionsPermissionsOrganizationParamSchema,
    void,
    t_ActionsSetGithubActionsPermissionsOrganizationBodySchema,
    void
  >,
  respond: (typeof actionsSetGithubActionsPermissionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListSelectedRepositoriesEnabledGithubActionsOrganization = b(
  (r) => ({
    with200: r.with200<{
      repositories: t_repository[]
      total_count: number
    }>(
      z.object({
        total_count: z.coerce.number(),
        repositories: z.array(s_repository),
      }),
    ),
    withStatus: r.withStatus,
  }),
)

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganization = (
  params: Params<
    t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
    t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListSelectedRepositoriesEnabledGithubActionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_repository[]
        total_count: number
      }
    >
>

const actionsSetSelectedRepositoriesEnabledGithubActionsOrganization = b(
  (r) => ({
    with204: r.with204<void>(z.undefined()),
    withStatus: r.withStatus,
  }),
)

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization = (
  params: Params<
    t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
    void,
    t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema,
    void
  >,
  respond: (typeof actionsSetSelectedRepositoriesEnabledGithubActionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsEnableSelectedRepositoryGithubActionsOrganization = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsEnableSelectedRepositoryGithubActionsOrganization = (
  params: Params<
    t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsEnableSelectedRepositoryGithubActionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsDisableSelectedRepositoryGithubActionsOrganization = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDisableSelectedRepositoryGithubActionsOrganization = (
  params: Params<
    t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDisableSelectedRepositoryGithubActionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsGetAllowedActionsOrganization = b((r) => ({
  with200: r.with200<t_selected_actions>(s_selected_actions),
  withStatus: r.withStatus,
}))

export type ActionsGetAllowedActionsOrganization = (
  params: Params<
    t_ActionsGetAllowedActionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetAllowedActionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_selected_actions>>

const actionsSetAllowedActionsOrganization = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetAllowedActionsOrganization = (
  params: Params<
    t_ActionsSetAllowedActionsOrganizationParamSchema,
    void,
    t_ActionsSetAllowedActionsOrganizationBodySchema | undefined,
    void
  >,
  respond: (typeof actionsSetAllowedActionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsGetGithubActionsDefaultWorkflowPermissionsOrganization = b(
  (r) => ({
    with200: r.with200<t_actions_get_default_workflow_permissions>(
      s_actions_get_default_workflow_permissions,
    ),
    withStatus: r.withStatus,
  }),
)

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization = (
  params: Params<
    t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetGithubActionsDefaultWorkflowPermissionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_actions_get_default_workflow_permissions>
>

const actionsSetGithubActionsDefaultWorkflowPermissionsOrganization = b(
  (r) => ({
    with204: r.with204<void>(z.undefined()),
    withStatus: r.withStatus,
  }),
)

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization = (
  params: Params<
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
    void,
    | t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema
    | undefined,
    void
  >,
  respond: (typeof actionsSetGithubActionsDefaultWorkflowPermissionsOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListSelfHostedRunnerGroupsForOrg = b((r) => ({
  with200: r.with200<{
    runner_groups: t_runner_groups_org[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      runner_groups: z.array(s_runner_groups_org),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListSelfHostedRunnerGroupsForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema,
    t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListSelfHostedRunnerGroupsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        runner_groups: t_runner_groups_org[]
        total_count: number
      }
    >
>

const actionsCreateSelfHostedRunnerGroupForOrg = b((r) => ({
  with201: r.with201<t_runner_groups_org>(s_runner_groups_org),
  withStatus: r.withStatus,
}))

export type ActionsCreateSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema,
    void,
    t_ActionsCreateSelfHostedRunnerGroupForOrgBodySchema,
    void
  >,
  respond: (typeof actionsCreateSelfHostedRunnerGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_runner_groups_org>>

const actionsGetSelfHostedRunnerGroupForOrg = b((r) => ({
  with200: r.with200<t_runner_groups_org>(s_runner_groups_org),
  withStatus: r.withStatus,
}))

export type ActionsGetSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetSelfHostedRunnerGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_runner_groups_org>>

const actionsUpdateSelfHostedRunnerGroupForOrg = b((r) => ({
  with200: r.with200<t_runner_groups_org>(s_runner_groups_org),
  withStatus: r.withStatus,
}))

export type ActionsUpdateSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
    void,
    t_ActionsUpdateSelfHostedRunnerGroupForOrgBodySchema,
    void
  >,
  respond: (typeof actionsUpdateSelfHostedRunnerGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_runner_groups_org>>

const actionsDeleteSelfHostedRunnerGroupFromOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteSelfHostedRunnerGroupFromOrg = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDeleteSelfHostedRunnerGroupFromOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListGithubHostedRunnersInGroupForOrg = b((r) => ({
  with200: r.with200<{
    runners: t_actions_hosted_runner[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      runners: z.array(s_actions_hosted_runner),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListGithubHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsListGithubHostedRunnersInGroupForOrgParamSchema,
    t_ActionsListGithubHostedRunnersInGroupForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListGithubHostedRunnersInGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        runners: t_actions_hosted_runner[]
        total_count: number
      }
    >
>

const actionsListRepoAccessToSelfHostedRunnerGroupInOrg = b((r) => ({
  with200: r.with200<{
    repositories: t_minimal_repository[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repositories: z.array(s_minimal_repository),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListRepoAccessToSelfHostedRunnerGroupInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
>

const actionsSetRepoAccessToSelfHostedRunnerGroupInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema,
    void
  >,
  respond: (typeof actionsSetRepoAccessToSelfHostedRunnerGroupInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsAddRepoAccessToSelfHostedRunnerGroupInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsAddRepoAccessToSelfHostedRunnerGroupInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListSelfHostedRunnersInGroupForOrg = b((r) => ({
  with200: r.with200<{
    runners: t_runner[]
    total_count: number
  }>(z.object({ total_count: z.coerce.number(), runners: z.array(s_runner) })),
  withStatus: r.withStatus,
}))

export type ActionsListSelfHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema,
    t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListSelfHostedRunnersInGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        runners: t_runner[]
        total_count: number
      }
    >
>

const actionsSetSelfHostedRunnersInGroupForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetSelfHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema,
    void,
    t_ActionsSetSelfHostedRunnersInGroupForOrgBodySchema,
    void
  >,
  respond: (typeof actionsSetSelfHostedRunnersInGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsAddSelfHostedRunnerToGroupForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsAddSelfHostedRunnerToGroupForOrg = (
  params: Params<
    t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsAddSelfHostedRunnerToGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsRemoveSelfHostedRunnerFromGroupForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsRemoveSelfHostedRunnerFromGroupForOrg = (
  params: Params<
    t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveSelfHostedRunnerFromGroupForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListSelfHostedRunnersForOrg = b((r) => ({
  with200: r.with200<{
    runners: t_runner[]
    total_count: number
  }>(z.object({ total_count: z.coerce.number(), runners: z.array(s_runner) })),
  withStatus: r.withStatus,
}))

export type ActionsListSelfHostedRunnersForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnersForOrgParamSchema,
    t_ActionsListSelfHostedRunnersForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListSelfHostedRunnersForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        runners: t_runner[]
        total_count: number
      }
    >
>

const actionsListRunnerApplicationsForOrg = b((r) => ({
  with200: r.with200<t_runner_application[]>(z.array(s_runner_application)),
  withStatus: r.withStatus,
}))

export type ActionsListRunnerApplicationsForOrg = (
  params: Params<
    t_ActionsListRunnerApplicationsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsListRunnerApplicationsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_runner_application[]>
>

const actionsGenerateRunnerJitconfigForOrg = b((r) => ({
  with201: r.with201<{
    encoded_jit_config: string
    runner: t_runner
  }>(z.object({ runner: s_runner, encoded_jit_config: z.string() })),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsGenerateRunnerJitconfigForOrg = (
  params: Params<
    t_ActionsGenerateRunnerJitconfigForOrgParamSchema,
    void,
    t_ActionsGenerateRunnerJitconfigForOrgBodySchema,
    void
  >,
  respond: (typeof actionsGenerateRunnerJitconfigForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      {
        encoded_jit_config: string
        runner: t_runner
      }
    >
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsCreateRegistrationTokenForOrg = b((r) => ({
  with201: r.with201<t_authentication_token>(s_authentication_token),
  withStatus: r.withStatus,
}))

export type ActionsCreateRegistrationTokenForOrg = (
  params: Params<
    t_ActionsCreateRegistrationTokenForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsCreateRegistrationTokenForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_authentication_token>
>

const actionsCreateRemoveTokenForOrg = b((r) => ({
  with201: r.with201<t_authentication_token>(s_authentication_token),
  withStatus: r.withStatus,
}))

export type ActionsCreateRemoveTokenForOrg = (
  params: Params<t_ActionsCreateRemoveTokenForOrgParamSchema, void, void, void>,
  respond: (typeof actionsCreateRemoveTokenForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_authentication_token>
>

const actionsGetSelfHostedRunnerForOrg = b((r) => ({
  with200: r.with200<t_runner>(s_runner),
  withStatus: r.withStatus,
}))

export type ActionsGetSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsGetSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetSelfHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_runner>>

const actionsDeleteSelfHostedRunnerFromOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteSelfHostedRunnerFromOrg = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDeleteSelfHostedRunnerFromOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListLabelsForSelfHostedRunnerForOrg = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsListLabelsForSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsListLabelsForSelfHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
>

const actionsAddCustomLabelsToSelfHostedRunnerForOrg = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
    void,
    t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema,
    void
  >,
  respond: (typeof actionsAddCustomLabelsToSelfHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsSetCustomLabelsForSelfHostedRunnerForOrg = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
    void,
    t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema,
    void
  >,
  respond: (typeof actionsSetCustomLabelsForSelfHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
>

const actionsRemoveCustomLabelFromSelfHostedRunnerForOrg = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveCustomLabelFromSelfHostedRunnerForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsListOrgSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_organization_actions_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_organization_actions_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListOrgSecrets = (
  params: Params<
    t_ActionsListOrgSecretsParamSchema,
    t_ActionsListOrgSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListOrgSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_organization_actions_secret[]
        total_count: number
      }
    >
>

const actionsGetOrgPublicKey = b((r) => ({
  with200: r.with200<t_actions_public_key>(s_actions_public_key),
  withStatus: r.withStatus,
}))

export type ActionsGetOrgPublicKey = (
  params: Params<t_ActionsGetOrgPublicKeyParamSchema, void, void, void>,
  respond: (typeof actionsGetOrgPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_public_key>>

const actionsGetOrgSecret = b((r) => ({
  with200: r.with200<t_organization_actions_secret>(
    s_organization_actions_secret,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetOrgSecret = (
  params: Params<t_ActionsGetOrgSecretParamSchema, void, void, void>,
  respond: (typeof actionsGetOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_organization_actions_secret>
>

const actionsCreateOrUpdateOrgSecret = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsCreateOrUpdateOrgSecret = (
  params: Params<
    t_ActionsCreateOrUpdateOrgSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateOrgSecretBodySchema,
    void
  >,
  respond: (typeof actionsCreateOrUpdateOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
>

const actionsDeleteOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteOrgSecret = (
  params: Params<t_ActionsDeleteOrgSecretParamSchema, void, void, void>,
  respond: (typeof actionsDeleteOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListSelectedReposForOrgSecret = b((r) => ({
  with200: r.with200<{
    repositories: t_minimal_repository[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repositories: z.array(s_minimal_repository),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListSelectedReposForOrgSecret = (
  params: Params<
    t_ActionsListSelectedReposForOrgSecretParamSchema,
    t_ActionsListSelectedReposForOrgSecretQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListSelectedReposForOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
>

const actionsSetSelectedReposForOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetSelectedReposForOrgSecret = (
  params: Params<
    t_ActionsSetSelectedReposForOrgSecretParamSchema,
    void,
    t_ActionsSetSelectedReposForOrgSecretBodySchema,
    void
  >,
  respond: (typeof actionsSetSelectedReposForOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsAddSelectedRepoToOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsAddSelectedRepoToOrgSecret = (
  params: Params<
    t_ActionsAddSelectedRepoToOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsAddSelectedRepoToOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const actionsRemoveSelectedRepoFromOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveSelectedRepoFromOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const actionsListOrgVariables = b((r) => ({
  with200: r.with200<{
    total_count: number
    variables: t_organization_actions_variable[]
  }>(
    z.object({
      total_count: z.coerce.number(),
      variables: z.array(s_organization_actions_variable),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListOrgVariables = (
  params: Params<
    t_ActionsListOrgVariablesParamSchema,
    t_ActionsListOrgVariablesQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListOrgVariables)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        total_count: number
        variables: t_organization_actions_variable[]
      }
    >
>

const actionsCreateOrgVariable = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  withStatus: r.withStatus,
}))

export type ActionsCreateOrgVariable = (
  params: Params<
    t_ActionsCreateOrgVariableParamSchema,
    void,
    t_ActionsCreateOrgVariableBodySchema,
    void
  >,
  respond: (typeof actionsCreateOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_empty_object>>

const actionsGetOrgVariable = b((r) => ({
  with200: r.with200<t_organization_actions_variable>(
    s_organization_actions_variable,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetOrgVariable = (
  params: Params<t_ActionsGetOrgVariableParamSchema, void, void, void>,
  respond: (typeof actionsGetOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_organization_actions_variable>
>

const actionsUpdateOrgVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsUpdateOrgVariable = (
  params: Params<
    t_ActionsUpdateOrgVariableParamSchema,
    void,
    t_ActionsUpdateOrgVariableBodySchema,
    void
  >,
  respond: (typeof actionsUpdateOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsDeleteOrgVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteOrgVariable = (
  params: Params<t_ActionsDeleteOrgVariableParamSchema, void, void, void>,
  respond: (typeof actionsDeleteOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListSelectedReposForOrgVariable = b((r) => ({
  with200: r.with200<{
    repositories: t_minimal_repository[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repositories: z.array(s_minimal_repository),
    }),
  ),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsListSelectedReposForOrgVariable = (
  params: Params<
    t_ActionsListSelectedReposForOrgVariableParamSchema,
    t_ActionsListSelectedReposForOrgVariableQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListSelectedReposForOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
  | Response<409, void>
>

const actionsSetSelectedReposForOrgVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetSelectedReposForOrgVariable = (
  params: Params<
    t_ActionsSetSelectedReposForOrgVariableParamSchema,
    void,
    t_ActionsSetSelectedReposForOrgVariableBodySchema,
    void
  >,
  respond: (typeof actionsSetSelectedReposForOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const actionsAddSelectedRepoToOrgVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsAddSelectedRepoToOrgVariable = (
  params: Params<
    t_ActionsAddSelectedRepoToOrgVariableParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsAddSelectedRepoToOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const actionsRemoveSelectedRepoFromOrgVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsRemoveSelectedRepoFromOrgVariable = (
  params: Params<
    t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveSelectedRepoFromOrgVariable)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const orgsListAttestations = b((r) => ({
  with200: r.with200<{
    attestations?: {
      bundle?: {
        dsseEnvelope?: {
          [key: string]: unknown | undefined
        }
        mediaType?: string
        verificationMaterial?: {
          [key: string]: unknown | undefined
        }
      }
      bundle_url?: string
      repository_id?: number
    }[]
  }>(
    z.object({
      attestations: z
        .array(
          z.object({
            bundle: z
              .object({
                mediaType: z.string().optional(),
                verificationMaterial: z.record(z.unknown()).optional(),
                dsseEnvelope: z.record(z.unknown()).optional(),
              })
              .optional(),
            repository_id: z.coerce.number().optional(),
            bundle_url: z.string().optional(),
          }),
        )
        .optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type OrgsListAttestations = (
  params: Params<
    t_OrgsListAttestationsParamSchema,
    t_OrgsListAttestationsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListAttestations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        attestations?: {
          bundle?: {
            dsseEnvelope?: {
              [key: string]: unknown | undefined
            }
            mediaType?: string
            verificationMaterial?: {
              [key: string]: unknown | undefined
            }
          }
          bundle_url?: string
          repository_id?: number
        }[]
      }
    >
>

const orgsListBlockedUsers = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  withStatus: r.withStatus,
}))

export type OrgsListBlockedUsers = (
  params: Params<
    t_OrgsListBlockedUsersParamSchema,
    t_OrgsListBlockedUsersQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListBlockedUsers)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_user[]>>

const orgsCheckBlockedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsCheckBlockedUser = (
  params: Params<t_OrgsCheckBlockedUserParamSchema, void, void, void>,
  respond: (typeof orgsCheckBlockedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const orgsBlockUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsBlockUser = (
  params: Params<t_OrgsBlockUserParamSchema, void, void, void>,
  respond: (typeof orgsBlockUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<422, t_validation_error>
>

const orgsUnblockUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsUnblockUser = (
  params: Params<t_OrgsUnblockUserParamSchema, void, void, void>,
  respond: (typeof orgsUnblockUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const campaignsListOrgCampaigns = b((r) => ({
  with200: r.with200<t_campaign_summary[]>(z.array(s_campaign_summary)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CampaignsListOrgCampaigns = (
  params: Params<
    t_CampaignsListOrgCampaignsParamSchema,
    t_CampaignsListOrgCampaignsQuerySchema,
    void,
    void
  >,
  respond: (typeof campaignsListOrgCampaigns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_campaign_summary[]>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const campaignsCreateCampaign = b((r) => ({
  with200: r.with200<t_campaign_summary>(s_campaign_summary),
  with400: r.with400<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_basic_error>(s_basic_error),
  with429: r.with429<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CampaignsCreateCampaign = (
  params: Params<
    t_CampaignsCreateCampaignParamSchema,
    void,
    t_CampaignsCreateCampaignBodySchema,
    void
  >,
  respond: (typeof campaignsCreateCampaign)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_campaign_summary>
  | Response<400, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_basic_error>
  | Response<429, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const campaignsGetCampaignSummary = b((r) => ({
  with200: r.with200<t_campaign_summary>(s_campaign_summary),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CampaignsGetCampaignSummary = (
  params: Params<t_CampaignsGetCampaignSummaryParamSchema, void, void, void>,
  respond: (typeof campaignsGetCampaignSummary)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_campaign_summary>
  | Response<404, t_basic_error>
  | Response<422, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const campaignsUpdateCampaign = b((r) => ({
  with200: r.with200<t_campaign_summary>(s_campaign_summary),
  with400: r.with400<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CampaignsUpdateCampaign = (
  params: Params<
    t_CampaignsUpdateCampaignParamSchema,
    void,
    t_CampaignsUpdateCampaignBodySchema,
    void
  >,
  respond: (typeof campaignsUpdateCampaign)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_campaign_summary>
  | Response<400, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const campaignsDeleteCampaign = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CampaignsDeleteCampaign = (
  params: Params<t_CampaignsDeleteCampaignParamSchema, void, void, void>,
  respond: (typeof campaignsDeleteCampaign)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningListAlertsForOrg = b((r) => ({
  with200: r.with200<t_code_scanning_organization_alert_items[]>(
    z.array(s_code_scanning_organization_alert_items),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningListAlertsForOrg = (
  params: Params<
    t_CodeScanningListAlertsForOrgParamSchema,
    t_CodeScanningListAlertsForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof codeScanningListAlertsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_organization_alert_items[]>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeSecurityGetConfigurationsForOrg = b((r) => ({
  with200: r.with200<t_code_security_configuration[]>(
    z.array(s_code_security_configuration),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetConfigurationsForOrg = (
  params: Params<
    t_CodeSecurityGetConfigurationsForOrgParamSchema,
    t_CodeSecurityGetConfigurationsForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof codeSecurityGetConfigurationsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityCreateConfiguration = b((r) => ({
  with201: r.with201<t_code_security_configuration>(
    s_code_security_configuration,
  ),
  withStatus: r.withStatus,
}))

export type CodeSecurityCreateConfiguration = (
  params: Params<
    t_CodeSecurityCreateConfigurationParamSchema,
    void,
    t_CodeSecurityCreateConfigurationBodySchema,
    void
  >,
  respond: (typeof codeSecurityCreateConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_code_security_configuration>
>

const codeSecurityGetDefaultConfigurations = b((r) => ({
  with200: r.with200<t_code_security_default_configurations>(
    s_code_security_default_configurations,
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetDefaultConfigurations = (
  params: Params<
    t_CodeSecurityGetDefaultConfigurationsParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeSecurityGetDefaultConfigurations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_default_configurations>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityDetachConfiguration = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityDetachConfiguration = (
  params: Params<
    t_CodeSecurityDetachConfigurationParamSchema,
    void,
    t_CodeSecurityDetachConfigurationBodySchema,
    void
  >,
  respond: (typeof codeSecurityDetachConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const codeSecurityGetConfiguration = b((r) => ({
  with200: r.with200<t_code_security_configuration>(
    s_code_security_configuration,
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetConfiguration = (
  params: Params<t_CodeSecurityGetConfigurationParamSchema, void, void, void>,
  respond: (typeof codeSecurityGetConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityUpdateConfiguration = b((r) => ({
  with200: r.with200<t_code_security_configuration>(
    s_code_security_configuration,
  ),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type CodeSecurityUpdateConfiguration = (
  params: Params<
    t_CodeSecurityUpdateConfigurationParamSchema,
    void,
    t_CodeSecurityUpdateConfigurationBodySchema,
    void
  >,
  respond: (typeof codeSecurityUpdateConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration>
  | Response<204, void>
>

const codeSecurityDeleteConfiguration = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityDeleteConfiguration = (
  params: Params<
    t_CodeSecurityDeleteConfigurationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeSecurityDeleteConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const codeSecurityAttachConfiguration = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  withStatus: r.withStatus,
}))

export type CodeSecurityAttachConfiguration = (
  params: Params<
    t_CodeSecurityAttachConfigurationParamSchema,
    void,
    t_CodeSecurityAttachConfigurationBodySchema,
    void
  >,
  respond: (typeof codeSecurityAttachConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
>

const codeSecuritySetConfigurationAsDefault = b((r) => ({
  with200: r.with200<{
    configuration?: t_code_security_configuration
    default_for_new_repos?: "all" | "none" | "private_and_internal" | "public"
  }>(
    z.object({
      default_for_new_repos: z
        .enum(["all", "none", "private_and_internal", "public"])
        .optional(),
      configuration: s_code_security_configuration.optional(),
    }),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecuritySetConfigurationAsDefault = (
  params: Params<
    t_CodeSecuritySetConfigurationAsDefaultParamSchema,
    void,
    t_CodeSecuritySetConfigurationAsDefaultBodySchema,
    void
  >,
  respond: (typeof codeSecuritySetConfigurationAsDefault)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        configuration?: t_code_security_configuration
        default_for_new_repos?:
          | "all"
          | "none"
          | "private_and_internal"
          | "public"
      }
    >
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codeSecurityGetRepositoriesForConfiguration = b((r) => ({
  with200: r.with200<t_code_security_configuration_repositories[]>(
    z.array(s_code_security_configuration_repositories),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetRepositoriesForConfiguration = (
  params: Params<
    t_CodeSecurityGetRepositoriesForConfigurationParamSchema,
    t_CodeSecurityGetRepositoriesForConfigurationQuerySchema,
    void,
    void
  >,
  respond: (typeof codeSecurityGetRepositoriesForConfiguration)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration_repositories[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codespacesListInOrganization = b((r) => ({
  with200: r.with200<{
    codespaces: t_codespace[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      codespaces: z.array(s_codespace),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesListInOrganization = (
  params: Params<
    t_CodespacesListInOrganizationParamSchema,
    t_CodespacesListInOrganizationQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListInOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        codespaces: t_codespace[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesSetCodespacesAccess = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with400: r.with400<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesSetCodespacesAccess = (
  params: Params<
    t_CodespacesSetCodespacesAccessParamSchema,
    void,
    t_CodespacesSetCodespacesAccessBodySchema,
    void
  >,
  respond: (typeof codespacesSetCodespacesAccess)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<400, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const codespacesSetCodespacesAccessUsers = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with400: r.with400<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesSetCodespacesAccessUsers = (
  params: Params<
    t_CodespacesSetCodespacesAccessUsersParamSchema,
    void,
    t_CodespacesSetCodespacesAccessUsersBodySchema,
    void
  >,
  respond: (typeof codespacesSetCodespacesAccessUsers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<400, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const codespacesDeleteCodespacesAccessUsers = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with400: r.with400<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesDeleteCodespacesAccessUsers = (
  params: Params<
    t_CodespacesDeleteCodespacesAccessUsersParamSchema,
    void,
    t_CodespacesDeleteCodespacesAccessUsersBodySchema,
    void
  >,
  respond: (typeof codespacesDeleteCodespacesAccessUsers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<400, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const codespacesListOrgSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_codespaces_org_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_codespaces_org_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodespacesListOrgSecrets = (
  params: Params<
    t_CodespacesListOrgSecretsParamSchema,
    t_CodespacesListOrgSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListOrgSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_codespaces_org_secret[]
        total_count: number
      }
    >
>

const codespacesGetOrgPublicKey = b((r) => ({
  with200: r.with200<t_codespaces_public_key>(s_codespaces_public_key),
  withStatus: r.withStatus,
}))

export type CodespacesGetOrgPublicKey = (
  params: Params<t_CodespacesGetOrgPublicKeyParamSchema, void, void, void>,
  respond: (typeof codespacesGetOrgPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_codespaces_public_key>
>

const codespacesGetOrgSecret = b((r) => ({
  with200: r.with200<t_codespaces_org_secret>(s_codespaces_org_secret),
  withStatus: r.withStatus,
}))

export type CodespacesGetOrgSecret = (
  params: Params<t_CodespacesGetOrgSecretParamSchema, void, void, void>,
  respond: (typeof codespacesGetOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_codespaces_org_secret>
>

const codespacesCreateOrUpdateOrgSecret = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type CodespacesCreateOrUpdateOrgSecret = (
  params: Params<
    t_CodespacesCreateOrUpdateOrgSecretParamSchema,
    void,
    t_CodespacesCreateOrUpdateOrgSecretBodySchema,
    void
  >,
  respond: (typeof codespacesCreateOrUpdateOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const codespacesDeleteOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesDeleteOrgSecret = (
  params: Params<t_CodespacesDeleteOrgSecretParamSchema, void, void, void>,
  respond: (typeof codespacesDeleteOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const codespacesListSelectedReposForOrgSecret = b((r) => ({
  with200: r.with200<{
    repositories: t_minimal_repository[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repositories: z.array(s_minimal_repository),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesListSelectedReposForOrgSecret = (
  params: Params<
    t_CodespacesListSelectedReposForOrgSecretParamSchema,
    t_CodespacesListSelectedReposForOrgSecretQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListSelectedReposForOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
>

const codespacesSetSelectedReposForOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type CodespacesSetSelectedReposForOrgSecret = (
  params: Params<
    t_CodespacesSetSelectedReposForOrgSecretParamSchema,
    void,
    t_CodespacesSetSelectedReposForOrgSecretBodySchema,
    void
  >,
  respond: (typeof codespacesSetSelectedReposForOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<409, void>
>

const codespacesAddSelectedRepoToOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type CodespacesAddSelectedRepoToOrgSecret = (
  params: Params<
    t_CodespacesAddSelectedRepoToOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesAddSelectedRepoToOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<409, void>
  | Response<422, t_validation_error>
>

const codespacesRemoveSelectedRepoFromOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type CodespacesRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesRemoveSelectedRepoFromOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<409, void>
  | Response<422, t_validation_error>
>

const copilotGetCopilotOrganizationDetails = b((r) => ({
  with200: r.with200<t_copilot_organization_details>(
    s_copilot_organization_details,
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotGetCopilotOrganizationDetails = (
  params: Params<
    t_CopilotGetCopilotOrganizationDetailsParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof copilotGetCopilotOrganizationDetails)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_copilot_organization_details>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<500, t_basic_error>
>

const copilotListCopilotSeats = b((r) => ({
  with200: r.with200<{
    seats?: t_copilot_seat_details[]
    total_seats?: number
  }>(
    z.object({
      total_seats: z.coerce.number().optional(),
      seats: z.array(s_copilot_seat_details).optional(),
    }),
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotListCopilotSeats = (
  params: Params<
    t_CopilotListCopilotSeatsParamSchema,
    t_CopilotListCopilotSeatsQuerySchema,
    void,
    void
  >,
  respond: (typeof copilotListCopilotSeats)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        seats?: t_copilot_seat_details[]
        total_seats?: number
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const copilotAddCopilotSeatsForTeams = b((r) => ({
  with201: r.with201<{
    seats_created: number
  }>(z.object({ seats_created: z.coerce.number() })),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotAddCopilotSeatsForTeams = (
  params: Params<
    t_CopilotAddCopilotSeatsForTeamsParamSchema,
    void,
    t_CopilotAddCopilotSeatsForTeamsBodySchema,
    void
  >,
  respond: (typeof copilotAddCopilotSeatsForTeams)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      {
        seats_created: number
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<500, t_basic_error>
>

const copilotCancelCopilotSeatAssignmentForTeams = b((r) => ({
  with200: r.with200<{
    seats_cancelled: number
  }>(z.object({ seats_cancelled: z.coerce.number() })),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotCancelCopilotSeatAssignmentForTeams = (
  params: Params<
    t_CopilotCancelCopilotSeatAssignmentForTeamsParamSchema,
    void,
    t_CopilotCancelCopilotSeatAssignmentForTeamsBodySchema,
    void
  >,
  respond: (typeof copilotCancelCopilotSeatAssignmentForTeams)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        seats_cancelled: number
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<500, t_basic_error>
>

const copilotAddCopilotSeatsForUsers = b((r) => ({
  with201: r.with201<{
    seats_created: number
  }>(z.object({ seats_created: z.coerce.number() })),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotAddCopilotSeatsForUsers = (
  params: Params<
    t_CopilotAddCopilotSeatsForUsersParamSchema,
    void,
    t_CopilotAddCopilotSeatsForUsersBodySchema,
    void
  >,
  respond: (typeof copilotAddCopilotSeatsForUsers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      {
        seats_created: number
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<500, t_basic_error>
>

const copilotCancelCopilotSeatAssignmentForUsers = b((r) => ({
  with200: r.with200<{
    seats_cancelled: number
  }>(z.object({ seats_cancelled: z.coerce.number() })),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotCancelCopilotSeatAssignmentForUsers = (
  params: Params<
    t_CopilotCancelCopilotSeatAssignmentForUsersParamSchema,
    void,
    t_CopilotCancelCopilotSeatAssignmentForUsersBodySchema,
    void
  >,
  respond: (typeof copilotCancelCopilotSeatAssignmentForUsers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        seats_cancelled: number
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<500, t_basic_error>
>

const copilotCopilotMetricsForOrganization = b((r) => ({
  with200: r.with200<t_copilot_usage_metrics_day[]>(
    z.array(s_copilot_usage_metrics_day),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotCopilotMetricsForOrganization = (
  params: Params<
    t_CopilotCopilotMetricsForOrganizationParamSchema,
    t_CopilotCopilotMetricsForOrganizationQuerySchema,
    void,
    void
  >,
  respond: (typeof copilotCopilotMetricsForOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_copilot_usage_metrics_day[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_basic_error>
  | Response<500, t_basic_error>
>

const dependabotListAlertsForOrg = b((r) => ({
  with200: r.with200<t_dependabot_alert_with_repository[]>(
    z.array(s_dependabot_alert_with_repository),
  ),
  with304: r.with304<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type DependabotListAlertsForOrg = (
  params: Params<
    t_DependabotListAlertsForOrgParamSchema,
    t_DependabotListAlertsForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof dependabotListAlertsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dependabot_alert_with_repository[]>
  | Response<304, void>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const dependabotListOrgSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_organization_dependabot_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_organization_dependabot_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type DependabotListOrgSecrets = (
  params: Params<
    t_DependabotListOrgSecretsParamSchema,
    t_DependabotListOrgSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof dependabotListOrgSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_organization_dependabot_secret[]
        total_count: number
      }
    >
>

const dependabotGetOrgPublicKey = b((r) => ({
  with200: r.with200<t_dependabot_public_key>(s_dependabot_public_key),
  withStatus: r.withStatus,
}))

export type DependabotGetOrgPublicKey = (
  params: Params<t_DependabotGetOrgPublicKeyParamSchema, void, void, void>,
  respond: (typeof dependabotGetOrgPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_dependabot_public_key>
>

const dependabotGetOrgSecret = b((r) => ({
  with200: r.with200<t_organization_dependabot_secret>(
    s_organization_dependabot_secret,
  ),
  withStatus: r.withStatus,
}))

export type DependabotGetOrgSecret = (
  params: Params<t_DependabotGetOrgSecretParamSchema, void, void, void>,
  respond: (typeof dependabotGetOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_organization_dependabot_secret>
>

const dependabotCreateOrUpdateOrgSecret = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type DependabotCreateOrUpdateOrgSecret = (
  params: Params<
    t_DependabotCreateOrUpdateOrgSecretParamSchema,
    void,
    t_DependabotCreateOrUpdateOrgSecretBodySchema,
    void
  >,
  respond: (typeof dependabotCreateOrUpdateOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
>

const dependabotDeleteOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type DependabotDeleteOrgSecret = (
  params: Params<t_DependabotDeleteOrgSecretParamSchema, void, void, void>,
  respond: (typeof dependabotDeleteOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const dependabotListSelectedReposForOrgSecret = b((r) => ({
  with200: r.with200<{
    repositories: t_minimal_repository[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repositories: z.array(s_minimal_repository),
    }),
  ),
  withStatus: r.withStatus,
}))

export type DependabotListSelectedReposForOrgSecret = (
  params: Params<
    t_DependabotListSelectedReposForOrgSecretParamSchema,
    t_DependabotListSelectedReposForOrgSecretQuerySchema,
    void,
    void
  >,
  respond: (typeof dependabotListSelectedReposForOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
>

const dependabotSetSelectedReposForOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type DependabotSetSelectedReposForOrgSecret = (
  params: Params<
    t_DependabotSetSelectedReposForOrgSecretParamSchema,
    void,
    t_DependabotSetSelectedReposForOrgSecretBodySchema,
    void
  >,
  respond: (typeof dependabotSetSelectedReposForOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const dependabotAddSelectedRepoToOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type DependabotAddSelectedRepoToOrgSecret = (
  params: Params<
    t_DependabotAddSelectedRepoToOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof dependabotAddSelectedRepoToOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const dependabotRemoveSelectedRepoFromOrgSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type DependabotRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof dependabotRemoveSelectedRepoFromOrgSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const packagesListDockerMigrationConflictingPackagesForOrganization = b(
  (r) => ({
    with200: r.with200<t_package[]>(z.array(s_package)),
    with401: r.with401<t_basic_error>(s_basic_error),
    with403: r.with403<t_basic_error>(s_basic_error),
    withStatus: r.withStatus,
  }),
)

export type PackagesListDockerMigrationConflictingPackagesForOrganization = (
  params: Params<
    t_PackagesListDockerMigrationConflictingPackagesForOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesListDockerMigrationConflictingPackagesForOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_package[]>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const activityListPublicOrgEvents = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  withStatus: r.withStatus,
}))

export type ActivityListPublicOrgEvents = (
  params: Params<
    t_ActivityListPublicOrgEventsParamSchema,
    t_ActivityListPublicOrgEventsQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListPublicOrgEvents)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_event[]>>

const orgsListFailedInvitations = b((r) => ({
  with200: r.with200<t_organization_invitation[]>(
    z.array(s_organization_invitation),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListFailedInvitations = (
  params: Params<
    t_OrgsListFailedInvitationsParamSchema,
    t_OrgsListFailedInvitationsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListFailedInvitations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_invitation[]>
  | Response<404, t_basic_error>
>

const orgsListWebhooks = b((r) => ({
  with200: r.with200<t_org_hook[]>(z.array(s_org_hook)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListWebhooks = (
  params: Params<
    t_OrgsListWebhooksParamSchema,
    t_OrgsListWebhooksQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListWebhooks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_hook[]>
  | Response<404, t_basic_error>
>

const orgsCreateWebhook = b((r) => ({
  with201: r.with201<t_org_hook>(s_org_hook),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsCreateWebhook = (
  params: Params<
    t_OrgsCreateWebhookParamSchema,
    void,
    t_OrgsCreateWebhookBodySchema,
    void
  >,
  respond: (typeof orgsCreateWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_org_hook>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsGetWebhook = b((r) => ({
  with200: r.with200<t_org_hook>(s_org_hook),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGetWebhook = (
  params: Params<t_OrgsGetWebhookParamSchema, void, void, void>,
  respond: (typeof orgsGetWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_hook>
  | Response<404, t_basic_error>
>

const orgsUpdateWebhook = b((r) => ({
  with200: r.with200<t_org_hook>(s_org_hook),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsUpdateWebhook = (
  params: Params<
    t_OrgsUpdateWebhookParamSchema,
    void,
    t_OrgsUpdateWebhookBodySchema | undefined,
    void
  >,
  respond: (typeof orgsUpdateWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_hook>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsDeleteWebhook = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsDeleteWebhook = (
  params: Params<t_OrgsDeleteWebhookParamSchema, void, void, void>,
  respond: (typeof orgsDeleteWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const orgsGetWebhookConfigForOrg = b((r) => ({
  with200: r.with200<t_webhook_config>(s_webhook_config),
  withStatus: r.withStatus,
}))

export type OrgsGetWebhookConfigForOrg = (
  params: Params<t_OrgsGetWebhookConfigForOrgParamSchema, void, void, void>,
  respond: (typeof orgsGetWebhookConfigForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_webhook_config>>

const orgsUpdateWebhookConfigForOrg = b((r) => ({
  with200: r.with200<t_webhook_config>(s_webhook_config),
  withStatus: r.withStatus,
}))

export type OrgsUpdateWebhookConfigForOrg = (
  params: Params<
    t_OrgsUpdateWebhookConfigForOrgParamSchema,
    void,
    t_OrgsUpdateWebhookConfigForOrgBodySchema | undefined,
    void
  >,
  respond: (typeof orgsUpdateWebhookConfigForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_webhook_config>>

const orgsListWebhookDeliveries = b((r) => ({
  with200: r.with200<t_hook_delivery_item[]>(z.array(s_hook_delivery_item)),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsListWebhookDeliveries = (
  params: Params<
    t_OrgsListWebhookDeliveriesParamSchema,
    t_OrgsListWebhookDeliveriesQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListWebhookDeliveries)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook_delivery_item[]>
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const orgsGetWebhookDelivery = b((r) => ({
  with200: r.with200<t_hook_delivery>(s_hook_delivery),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsGetWebhookDelivery = (
  params: Params<t_OrgsGetWebhookDeliveryParamSchema, void, void, void>,
  respond: (typeof orgsGetWebhookDelivery)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook_delivery>
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const orgsRedeliverWebhookDelivery = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsRedeliverWebhookDelivery = (
  params: Params<t_OrgsRedeliverWebhookDeliveryParamSchema, void, void, void>,
  respond: (typeof orgsRedeliverWebhookDelivery)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const orgsPingWebhook = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsPingWebhook = (
  params: Params<t_OrgsPingWebhookParamSchema, void, void, void>,
  respond: (typeof orgsPingWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const apiInsightsGetRouteStatsByActor = b((r) => ({
  with200: r.with200<t_api_insights_route_stats>(s_api_insights_route_stats),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetRouteStatsByActor = (
  params: Params<
    t_ApiInsightsGetRouteStatsByActorParamSchema,
    t_ApiInsightsGetRouteStatsByActorQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetRouteStatsByActor)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_route_stats>
>

const apiInsightsGetSubjectStats = b((r) => ({
  with200: r.with200<t_api_insights_subject_stats>(
    s_api_insights_subject_stats,
  ),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetSubjectStats = (
  params: Params<
    t_ApiInsightsGetSubjectStatsParamSchema,
    t_ApiInsightsGetSubjectStatsQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetSubjectStats)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_subject_stats>
>

const apiInsightsGetSummaryStats = b((r) => ({
  with200: r.with200<t_api_insights_summary_stats>(
    s_api_insights_summary_stats,
  ),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetSummaryStats = (
  params: Params<
    t_ApiInsightsGetSummaryStatsParamSchema,
    t_ApiInsightsGetSummaryStatsQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetSummaryStats)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_summary_stats>
>

const apiInsightsGetSummaryStatsByUser = b((r) => ({
  with200: r.with200<t_api_insights_summary_stats>(
    s_api_insights_summary_stats,
  ),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetSummaryStatsByUser = (
  params: Params<
    t_ApiInsightsGetSummaryStatsByUserParamSchema,
    t_ApiInsightsGetSummaryStatsByUserQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetSummaryStatsByUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_summary_stats>
>

const apiInsightsGetSummaryStatsByActor = b((r) => ({
  with200: r.with200<t_api_insights_summary_stats>(
    s_api_insights_summary_stats,
  ),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetSummaryStatsByActor = (
  params: Params<
    t_ApiInsightsGetSummaryStatsByActorParamSchema,
    t_ApiInsightsGetSummaryStatsByActorQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetSummaryStatsByActor)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_summary_stats>
>

const apiInsightsGetTimeStats = b((r) => ({
  with200: r.with200<t_api_insights_time_stats>(s_api_insights_time_stats),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetTimeStats = (
  params: Params<
    t_ApiInsightsGetTimeStatsParamSchema,
    t_ApiInsightsGetTimeStatsQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetTimeStats)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_time_stats>
>

const apiInsightsGetTimeStatsByUser = b((r) => ({
  with200: r.with200<t_api_insights_time_stats>(s_api_insights_time_stats),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetTimeStatsByUser = (
  params: Params<
    t_ApiInsightsGetTimeStatsByUserParamSchema,
    t_ApiInsightsGetTimeStatsByUserQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetTimeStatsByUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_time_stats>
>

const apiInsightsGetTimeStatsByActor = b((r) => ({
  with200: r.with200<t_api_insights_time_stats>(s_api_insights_time_stats),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetTimeStatsByActor = (
  params: Params<
    t_ApiInsightsGetTimeStatsByActorParamSchema,
    t_ApiInsightsGetTimeStatsByActorQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetTimeStatsByActor)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_time_stats>
>

const apiInsightsGetUserStats = b((r) => ({
  with200: r.with200<t_api_insights_user_stats>(s_api_insights_user_stats),
  withStatus: r.withStatus,
}))

export type ApiInsightsGetUserStats = (
  params: Params<
    t_ApiInsightsGetUserStatsParamSchema,
    t_ApiInsightsGetUserStatsQuerySchema,
    void,
    void
  >,
  respond: (typeof apiInsightsGetUserStats)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_api_insights_user_stats>
>

const appsGetOrgInstallation = b((r) => ({
  with200: r.with200<t_installation>(s_installation),
  withStatus: r.withStatus,
}))

export type AppsGetOrgInstallation = (
  params: Params<t_AppsGetOrgInstallationParamSchema, void, void, void>,
  respond: (typeof appsGetOrgInstallation)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_installation>>

const orgsListAppInstallations = b((r) => ({
  with200: r.with200<{
    installations: t_installation[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      installations: z.array(s_installation),
    }),
  ),
  withStatus: r.withStatus,
}))

export type OrgsListAppInstallations = (
  params: Params<
    t_OrgsListAppInstallationsParamSchema,
    t_OrgsListAppInstallationsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListAppInstallations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        installations: t_installation[]
        total_count: number
      }
    >
>

const interactionsGetRestrictionsForOrg = b((r) => ({
  with200: r.with200<t_interaction_limit_response | EmptyObject>(
    z.union([s_interaction_limit_response, z.object({})]),
  ),
  withStatus: r.withStatus,
}))

export type InteractionsGetRestrictionsForOrg = (
  params: Params<
    t_InteractionsGetRestrictionsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof interactionsGetRestrictionsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_interaction_limit_response | EmptyObject>
>

const interactionsSetRestrictionsForOrg = b((r) => ({
  with200: r.with200<t_interaction_limit_response>(
    s_interaction_limit_response,
  ),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type InteractionsSetRestrictionsForOrg = (
  params: Params<
    t_InteractionsSetRestrictionsForOrgParamSchema,
    void,
    t_InteractionsSetRestrictionsForOrgBodySchema,
    void
  >,
  respond: (typeof interactionsSetRestrictionsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_interaction_limit_response>
  | Response<422, t_validation_error>
>

const interactionsRemoveRestrictionsForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type InteractionsRemoveRestrictionsForOrg = (
  params: Params<
    t_InteractionsRemoveRestrictionsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof interactionsRemoveRestrictionsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const orgsListPendingInvitations = b((r) => ({
  with200: r.with200<t_organization_invitation[]>(
    z.array(s_organization_invitation),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListPendingInvitations = (
  params: Params<
    t_OrgsListPendingInvitationsParamSchema,
    t_OrgsListPendingInvitationsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListPendingInvitations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_invitation[]>
  | Response<404, t_basic_error>
>

const orgsCreateInvitation = b((r) => ({
  with201: r.with201<t_organization_invitation>(s_organization_invitation),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsCreateInvitation = (
  params: Params<
    t_OrgsCreateInvitationParamSchema,
    void,
    t_OrgsCreateInvitationBodySchema | undefined,
    void
  >,
  respond: (typeof orgsCreateInvitation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_organization_invitation>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsCancelInvitation = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsCancelInvitation = (
  params: Params<t_OrgsCancelInvitationParamSchema, void, void, void>,
  respond: (typeof orgsCancelInvitation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsListInvitationTeams = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListInvitationTeams = (
  params: Params<
    t_OrgsListInvitationTeamsParamSchema,
    t_OrgsListInvitationTeamsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListInvitationTeams)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<404, t_basic_error>
>

const orgsListIssueTypes = b((r) => ({
  with200: r.with200<t_issue_type[]>(z.array(s_issue_type)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListIssueTypes = (
  params: Params<t_OrgsListIssueTypesParamSchema, void, void, void>,
  respond: (typeof orgsListIssueTypes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_type[]>
  | Response<404, t_basic_error>
>

const orgsCreateIssueType = b((r) => ({
  with200: r.with200<t_issue_type>(s_issue_type),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type OrgsCreateIssueType = (
  params: Params<
    t_OrgsCreateIssueTypeParamSchema,
    void,
    t_OrgsCreateIssueTypeBodySchema,
    void
  >,
  respond: (typeof orgsCreateIssueType)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_type>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const orgsUpdateIssueType = b((r) => ({
  with200: r.with200<t_issue_type>(s_issue_type),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type OrgsUpdateIssueType = (
  params: Params<
    t_OrgsUpdateIssueTypeParamSchema,
    void,
    t_OrgsUpdateIssueTypeBodySchema,
    void
  >,
  respond: (typeof orgsUpdateIssueType)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_type>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const orgsDeleteIssueType = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type OrgsDeleteIssueType = (
  params: Params<t_OrgsDeleteIssueTypeParamSchema, void, void, void>,
  respond: (typeof orgsDeleteIssueType)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const issuesListForOrg = b((r) => ({
  with200: r.with200<t_issue[]>(z.array(s_issue)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListForOrg = (
  params: Params<
    t_IssuesListForOrgParamSchema,
    t_IssuesListForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue[]>
  | Response<404, t_basic_error>
>

const orgsListMembers = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsListMembers = (
  params: Params<
    t_OrgsListMembersParamSchema,
    t_OrgsListMembersQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListMembers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<422, t_validation_error>
>

const orgsCheckMembershipForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with302: r.with302<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsCheckMembershipForUser = (
  params: Params<t_OrgsCheckMembershipForUserParamSchema, void, void, void>,
  respond: (typeof orgsCheckMembershipForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<302, void>
  | Response<404, void>
>

const orgsRemoveMember = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsRemoveMember = (
  params: Params<t_OrgsRemoveMemberParamSchema, void, void, void>,
  respond: (typeof orgsRemoveMember)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
>

const codespacesGetCodespacesForUserInOrg = b((r) => ({
  with200: r.with200<{
    codespaces: t_codespace[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      codespaces: z.array(s_codespace),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesGetCodespacesForUserInOrg = (
  params: Params<
    t_CodespacesGetCodespacesForUserInOrgParamSchema,
    t_CodespacesGetCodespacesForUserInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesGetCodespacesForUserInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        codespaces: t_codespace[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesDeleteFromOrganization = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesDeleteFromOrganization = (
  params: Params<
    t_CodespacesDeleteFromOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesDeleteFromOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesStopInOrganization = b((r) => ({
  with200: r.with200<t_codespace>(s_codespace),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesStopInOrganization = (
  params: Params<t_CodespacesStopInOrganizationParamSchema, void, void, void>,
  respond: (typeof codespacesStopInOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codespace>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const copilotGetCopilotSeatDetailsForUser = b((r) => ({
  with200: r.with200<t_copilot_seat_details>(s_copilot_seat_details),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotGetCopilotSeatDetailsForUser = (
  params: Params<
    t_CopilotGetCopilotSeatDetailsForUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof copilotGetCopilotSeatDetailsForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_copilot_seat_details>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<500, t_basic_error>
>

const orgsGetMembershipForUser = b((r) => ({
  with200: r.with200<t_org_membership>(s_org_membership),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGetMembershipForUser = (
  params: Params<t_OrgsGetMembershipForUserParamSchema, void, void, void>,
  respond: (typeof orgsGetMembershipForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_membership>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsSetMembershipForUser = b((r) => ({
  with200: r.with200<t_org_membership>(s_org_membership),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsSetMembershipForUser = (
  params: Params<
    t_OrgsSetMembershipForUserParamSchema,
    void,
    t_OrgsSetMembershipForUserBodySchema | undefined,
    void
  >,
  respond: (typeof orgsSetMembershipForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_membership>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsRemoveMembershipForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsRemoveMembershipForUser = (
  params: Params<t_OrgsRemoveMembershipForUserParamSchema, void, void, void>,
  respond: (typeof orgsRemoveMembershipForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const migrationsListForOrg = b((r) => ({
  with200: r.with200<t_migration[]>(z.array(s_migration)),
  withStatus: r.withStatus,
}))

export type MigrationsListForOrg = (
  params: Params<
    t_MigrationsListForOrgParamSchema,
    t_MigrationsListForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof migrationsListForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_migration[]>>

const migrationsStartForOrg = b((r) => ({
  with201: r.with201<t_migration>(s_migration),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type MigrationsStartForOrg = (
  params: Params<
    t_MigrationsStartForOrgParamSchema,
    void,
    t_MigrationsStartForOrgBodySchema,
    void
  >,
  respond: (typeof migrationsStartForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_migration>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const migrationsGetStatusForOrg = b((r) => ({
  with200: r.with200<t_migration>(s_migration),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsGetStatusForOrg = (
  params: Params<
    t_MigrationsGetStatusForOrgParamSchema,
    t_MigrationsGetStatusForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof migrationsGetStatusForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_migration>
  | Response<404, t_basic_error>
>

const migrationsDownloadArchiveForOrg = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsDownloadArchiveForOrg = (
  params: Params<
    t_MigrationsDownloadArchiveForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof migrationsDownloadArchiveForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<302, void>
  | Response<404, t_basic_error>
>

const migrationsDeleteArchiveForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsDeleteArchiveForOrg = (
  params: Params<t_MigrationsDeleteArchiveForOrgParamSchema, void, void, void>,
  respond: (typeof migrationsDeleteArchiveForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const migrationsUnlockRepoForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsUnlockRepoForOrg = (
  params: Params<t_MigrationsUnlockRepoForOrgParamSchema, void, void, void>,
  respond: (typeof migrationsUnlockRepoForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const migrationsListReposForOrg = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsListReposForOrg = (
  params: Params<
    t_MigrationsListReposForOrgParamSchema,
    t_MigrationsListReposForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof migrationsListReposForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<404, t_basic_error>
>

const orgsListOrgRoles = b((r) => ({
  with200: r.with200<{
    roles?: t_organization_role[]
    total_count?: number
  }>(
    z.object({
      total_count: z.coerce.number().optional(),
      roles: z.array(s_organization_role).optional(),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsListOrgRoles = (
  params: Params<t_OrgsListOrgRolesParamSchema, void, void, void>,
  respond: (typeof orgsListOrgRoles)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        roles?: t_organization_role[]
        total_count?: number
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsRevokeAllOrgRolesTeam = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsRevokeAllOrgRolesTeam = (
  params: Params<t_OrgsRevokeAllOrgRolesTeamParamSchema, void, void, void>,
  respond: (typeof orgsRevokeAllOrgRolesTeam)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const orgsAssignTeamToOrgRole = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsAssignTeamToOrgRole = (
  params: Params<t_OrgsAssignTeamToOrgRoleParamSchema, void, void, void>,
  respond: (typeof orgsAssignTeamToOrgRole)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, void>
  | Response<422, void>
>

const orgsRevokeOrgRoleTeam = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsRevokeOrgRoleTeam = (
  params: Params<t_OrgsRevokeOrgRoleTeamParamSchema, void, void, void>,
  respond: (typeof orgsRevokeOrgRoleTeam)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const orgsRevokeAllOrgRolesUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsRevokeAllOrgRolesUser = (
  params: Params<t_OrgsRevokeAllOrgRolesUserParamSchema, void, void, void>,
  respond: (typeof orgsRevokeAllOrgRolesUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const orgsAssignUserToOrgRole = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsAssignUserToOrgRole = (
  params: Params<t_OrgsAssignUserToOrgRoleParamSchema, void, void, void>,
  respond: (typeof orgsAssignUserToOrgRole)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, void>
  | Response<422, void>
>

const orgsRevokeOrgRoleUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsRevokeOrgRoleUser = (
  params: Params<t_OrgsRevokeOrgRoleUserParamSchema, void, void, void>,
  respond: (typeof orgsRevokeOrgRoleUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const orgsGetOrgRole = b((r) => ({
  with200: r.with200<t_organization_role>(s_organization_role),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsGetOrgRole = (
  params: Params<t_OrgsGetOrgRoleParamSchema, void, void, void>,
  respond: (typeof orgsGetOrgRole)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_role>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsListOrgRoleTeams = b((r) => ({
  with200: r.with200<t_team_role_assignment[]>(z.array(s_team_role_assignment)),
  with404: r.with404<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsListOrgRoleTeams = (
  params: Params<
    t_OrgsListOrgRoleTeamsParamSchema,
    t_OrgsListOrgRoleTeamsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListOrgRoleTeams)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_role_assignment[]>
  | Response<404, void>
  | Response<422, void>
>

const orgsListOrgRoleUsers = b((r) => ({
  with200: r.with200<t_user_role_assignment[]>(z.array(s_user_role_assignment)),
  with404: r.with404<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsListOrgRoleUsers = (
  params: Params<
    t_OrgsListOrgRoleUsersParamSchema,
    t_OrgsListOrgRoleUsersQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListOrgRoleUsers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_user_role_assignment[]>
  | Response<404, void>
  | Response<422, void>
>

const orgsListOutsideCollaborators = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  withStatus: r.withStatus,
}))

export type OrgsListOutsideCollaborators = (
  params: Params<
    t_OrgsListOutsideCollaboratorsParamSchema,
    t_OrgsListOutsideCollaboratorsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListOutsideCollaborators)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_user[]>>

const orgsConvertMemberToOutsideCollaborator = b((r) => ({
  with202: r.with202<EmptyObject>(z.object({})),
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsConvertMemberToOutsideCollaborator = (
  params: Params<
    t_OrgsConvertMemberToOutsideCollaboratorParamSchema,
    void,
    t_OrgsConvertMemberToOutsideCollaboratorBodySchema | undefined,
    void
  >,
  respond: (typeof orgsConvertMemberToOutsideCollaborator)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<202, EmptyObject>
  | Response<204, void>
  | Response<403, void>
  | Response<404, t_basic_error>
>

const orgsRemoveOutsideCollaborator = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<{
    documentation_url?: string
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type OrgsRemoveOutsideCollaborator = (
  params: Params<t_OrgsRemoveOutsideCollaboratorParamSchema, void, void, void>,
  respond: (typeof orgsRemoveOutsideCollaborator)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<
      422,
      {
        documentation_url?: string
        message?: string
      }
    >
>

const packagesListPackagesForOrganization = b((r) => ({
  with200: r.with200<t_package[]>(z.array(s_package)),
  with400: r.with400<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesListPackagesForOrganization = (
  params: Params<
    t_PackagesListPackagesForOrganizationParamSchema,
    t_PackagesListPackagesForOrganizationQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesListPackagesForOrganization)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_package[]>
  | Response<400, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const packagesGetPackageForOrganization = b((r) => ({
  with200: r.with200<t_package>(s_package),
  withStatus: r.withStatus,
}))

export type PackagesGetPackageForOrganization = (
  params: Params<
    t_PackagesGetPackageForOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesGetPackageForOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_package>>

const packagesDeletePackageForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesDeletePackageForOrg = (
  params: Params<t_PackagesDeletePackageForOrgParamSchema, void, void, void>,
  respond: (typeof packagesDeletePackageForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesRestorePackageForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesRestorePackageForOrg = (
  params: Params<
    t_PackagesRestorePackageForOrgParamSchema,
    t_PackagesRestorePackageForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesRestorePackageForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesGetAllPackageVersionsForPackageOwnedByOrg = b((r) => ({
  with200: r.with200<t_package_version[]>(z.array(s_package_version)),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
    t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesGetAllPackageVersionsForPackageOwnedByOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_package_version[]>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesGetPackageVersionForOrganization = b((r) => ({
  with200: r.with200<t_package_version>(s_package_version),
  withStatus: r.withStatus,
}))

export type PackagesGetPackageVersionForOrganization = (
  params: Params<
    t_PackagesGetPackageVersionForOrganizationParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesGetPackageVersionForOrganization)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_package_version>>

const packagesDeletePackageVersionForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesDeletePackageVersionForOrg = (
  params: Params<
    t_PackagesDeletePackageVersionForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesDeletePackageVersionForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesRestorePackageVersionForOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesRestorePackageVersionForOrg = (
  params: Params<
    t_PackagesRestorePackageVersionForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesRestorePackageVersionForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsListPatGrantRequests = b((r) => ({
  with200: r.with200<t_organization_programmatic_access_grant_request[]>(
    z.array(s_organization_programmatic_access_grant_request),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListPatGrantRequests = (
  params: Params<
    t_OrgsListPatGrantRequestsParamSchema,
    t_OrgsListPatGrantRequestsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListPatGrantRequests)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_programmatic_access_grant_request[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const orgsReviewPatGrantRequestsInBulk = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsReviewPatGrantRequestsInBulk = (
  params: Params<
    t_OrgsReviewPatGrantRequestsInBulkParamSchema,
    void,
    t_OrgsReviewPatGrantRequestsInBulkBodySchema,
    void
  >,
  respond: (typeof orgsReviewPatGrantRequestsInBulk)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const orgsReviewPatGrantRequest = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsReviewPatGrantRequest = (
  params: Params<
    t_OrgsReviewPatGrantRequestParamSchema,
    void,
    t_OrgsReviewPatGrantRequestBodySchema,
    void
  >,
  respond: (typeof orgsReviewPatGrantRequest)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const orgsListPatGrantRequestRepositories = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListPatGrantRequestRepositories = (
  params: Params<
    t_OrgsListPatGrantRequestRepositoriesParamSchema,
    t_OrgsListPatGrantRequestRepositoriesQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListPatGrantRequestRepositories)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const orgsListPatGrants = b((r) => ({
  with200: r.with200<t_organization_programmatic_access_grant[]>(
    z.array(s_organization_programmatic_access_grant),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListPatGrants = (
  params: Params<
    t_OrgsListPatGrantsParamSchema,
    t_OrgsListPatGrantsQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListPatGrants)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_programmatic_access_grant[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const orgsUpdatePatAccesses = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsUpdatePatAccesses = (
  params: Params<
    t_OrgsUpdatePatAccessesParamSchema,
    void,
    t_OrgsUpdatePatAccessesBodySchema,
    void
  >,
  respond: (typeof orgsUpdatePatAccesses)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const orgsUpdatePatAccess = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsUpdatePatAccess = (
  params: Params<
    t_OrgsUpdatePatAccessParamSchema,
    void,
    t_OrgsUpdatePatAccessBodySchema,
    void
  >,
  respond: (typeof orgsUpdatePatAccess)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const orgsListPatGrantRepositories = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListPatGrantRepositories = (
  params: Params<
    t_OrgsListPatGrantRepositoriesParamSchema,
    t_OrgsListPatGrantRepositoriesQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListPatGrantRepositories)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const privateRegistriesListOrgPrivateRegistries = b((r) => ({
  with200: r.with200<{
    configurations: t_org_private_registry_configuration[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      configurations: z.array(s_org_private_registry_configuration),
    }),
  ),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PrivateRegistriesListOrgPrivateRegistries = (
  params: Params<
    t_PrivateRegistriesListOrgPrivateRegistriesParamSchema,
    t_PrivateRegistriesListOrgPrivateRegistriesQuerySchema,
    void,
    void
  >,
  respond: (typeof privateRegistriesListOrgPrivateRegistries)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        configurations: t_org_private_registry_configuration[]
        total_count: number
      }
    >
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
>

const privateRegistriesCreateOrgPrivateRegistry = b((r) => ({
  with201:
    r.with201<t_org_private_registry_configuration_with_selected_repositories>(
      s_org_private_registry_configuration_with_selected_repositories,
    ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PrivateRegistriesCreateOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesCreateOrgPrivateRegistryParamSchema,
    void,
    t_PrivateRegistriesCreateOrgPrivateRegistryBodySchema,
    void
  >,
  respond: (typeof privateRegistriesCreateOrgPrivateRegistry)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      t_org_private_registry_configuration_with_selected_repositories
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const privateRegistriesGetOrgPublicKey = b((r) => ({
  with200: r.with200<{
    key: string
    key_id: string
  }>(z.object({ key_id: z.string(), key: z.string() })),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PrivateRegistriesGetOrgPublicKey = (
  params: Params<
    t_PrivateRegistriesGetOrgPublicKeyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof privateRegistriesGetOrgPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        key: string
        key_id: string
      }
    >
  | Response<404, t_basic_error>
>

const privateRegistriesGetOrgPrivateRegistry = b((r) => ({
  with200: r.with200<t_org_private_registry_configuration>(
    s_org_private_registry_configuration,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PrivateRegistriesGetOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesGetOrgPrivateRegistryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof privateRegistriesGetOrgPrivateRegistry)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_private_registry_configuration>
  | Response<404, t_basic_error>
>

const privateRegistriesUpdateOrgPrivateRegistry = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PrivateRegistriesUpdateOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesUpdateOrgPrivateRegistryParamSchema,
    void,
    t_PrivateRegistriesUpdateOrgPrivateRegistryBodySchema,
    void
  >,
  respond: (typeof privateRegistriesUpdateOrgPrivateRegistry)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const privateRegistriesDeleteOrgPrivateRegistry = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PrivateRegistriesDeleteOrgPrivateRegistry = (
  params: Params<
    t_PrivateRegistriesDeleteOrgPrivateRegistryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof privateRegistriesDeleteOrgPrivateRegistry)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
>

const projectsListForOrg = b((r) => ({
  with200: r.with200<t_project[]>(z.array(s_project)),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsListForOrg = (
  params: Params<
    t_ProjectsListForOrgParamSchema,
    t_ProjectsListForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof projectsListForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project[]>
  | Response<422, t_validation_error_simple>
>

const projectsCreateForOrg = b((r) => ({
  with201: r.with201<t_project>(s_project),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsCreateForOrg = (
  params: Params<
    t_ProjectsCreateForOrgParamSchema,
    void,
    t_ProjectsCreateForOrgBodySchema,
    void
  >,
  respond: (typeof projectsCreateForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_project>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const orgsGetAllCustomProperties = b((r) => ({
  with200: r.with200<t_custom_property[]>(z.array(s_custom_property)),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGetAllCustomProperties = (
  params: Params<t_OrgsGetAllCustomPropertiesParamSchema, void, void, void>,
  respond: (typeof orgsGetAllCustomProperties)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_custom_property[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsCreateOrUpdateCustomProperties = b((r) => ({
  with200: r.with200<t_custom_property[]>(z.array(s_custom_property)),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsCreateOrUpdateCustomProperties = (
  params: Params<
    t_OrgsCreateOrUpdateCustomPropertiesParamSchema,
    void,
    t_OrgsCreateOrUpdateCustomPropertiesBodySchema,
    void
  >,
  respond: (typeof orgsCreateOrUpdateCustomProperties)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_custom_property[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsGetCustomProperty = b((r) => ({
  with200: r.with200<t_custom_property>(s_custom_property),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGetCustomProperty = (
  params: Params<t_OrgsGetCustomPropertyParamSchema, void, void, void>,
  respond: (typeof orgsGetCustomProperty)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_custom_property>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsCreateOrUpdateCustomProperty = b((r) => ({
  with200: r.with200<t_custom_property>(s_custom_property),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsCreateOrUpdateCustomProperty = (
  params: Params<
    t_OrgsCreateOrUpdateCustomPropertyParamSchema,
    void,
    t_OrgsCreateOrUpdateCustomPropertyBodySchema,
    void
  >,
  respond: (typeof orgsCreateOrUpdateCustomProperty)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_custom_property>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsRemoveCustomProperty = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsRemoveCustomProperty = (
  params: Params<t_OrgsRemoveCustomPropertyParamSchema, void, void, void>,
  respond: (typeof orgsRemoveCustomProperty)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsListCustomPropertiesValuesForRepos = b((r) => ({
  with200: r.with200<t_org_repo_custom_property_values[]>(
    z.array(s_org_repo_custom_property_values),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListCustomPropertiesValuesForRepos = (
  params: Params<
    t_OrgsListCustomPropertiesValuesForReposParamSchema,
    t_OrgsListCustomPropertiesValuesForReposQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListCustomPropertiesValuesForRepos)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_repo_custom_property_values[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsCreateOrUpdateCustomPropertiesValuesForRepos = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsCreateOrUpdateCustomPropertiesValuesForRepos = (
  params: Params<
    t_OrgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema,
    void,
    t_OrgsCreateOrUpdateCustomPropertiesValuesForReposBodySchema,
    void
  >,
  respond: (typeof orgsCreateOrUpdateCustomPropertiesValuesForRepos)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsListPublicMembers = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  withStatus: r.withStatus,
}))

export type OrgsListPublicMembers = (
  params: Params<
    t_OrgsListPublicMembersParamSchema,
    t_OrgsListPublicMembersQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListPublicMembers)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_user[]>>

const orgsCheckPublicMembershipForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsCheckPublicMembershipForUser = (
  params: Params<
    t_OrgsCheckPublicMembershipForUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof orgsCheckPublicMembershipForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<404, void>
>

const orgsSetPublicMembershipForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsSetPublicMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof orgsSetPublicMembershipForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
>

const orgsRemovePublicMembershipForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsRemovePublicMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof orgsRemovePublicMembershipForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListForOrg = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  withStatus: r.withStatus,
}))

export type ReposListForOrg = (
  params: Params<
    t_ReposListForOrgParamSchema,
    t_ReposListForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_minimal_repository[]>
>

const reposCreateInOrg = b((r) => ({
  with201: r.with201<t_full_repository>(s_full_repository),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateInOrg = (
  params: Params<
    t_ReposCreateInOrgParamSchema,
    void,
    t_ReposCreateInOrgBodySchema,
    void
  >,
  respond: (typeof reposCreateInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_full_repository>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetOrgRulesets = b((r) => ({
  with200: r.with200<t_repository_ruleset[]>(z.array(s_repository_ruleset)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetOrgRulesets = (
  params: Params<
    t_ReposGetOrgRulesetsParamSchema,
    t_ReposGetOrgRulesetsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetOrgRulesets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_ruleset[]>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposCreateOrgRuleset = b((r) => ({
  with201: r.with201<t_repository_ruleset>(s_repository_ruleset),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposCreateOrgRuleset = (
  params: Params<
    t_ReposCreateOrgRulesetParamSchema,
    void,
    t_ReposCreateOrgRulesetBodySchema,
    void
  >,
  respond: (typeof reposCreateOrgRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_repository_ruleset>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetOrgRuleSuites = b((r) => ({
  with200: r.with200<t_rule_suites>(s_rule_suites),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetOrgRuleSuites = (
  params: Params<
    t_ReposGetOrgRuleSuitesParamSchema,
    t_ReposGetOrgRuleSuitesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetOrgRuleSuites)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_rule_suites>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetOrgRuleSuite = b((r) => ({
  with200: r.with200<t_rule_suite>(s_rule_suite),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetOrgRuleSuite = (
  params: Params<t_ReposGetOrgRuleSuiteParamSchema, void, void, void>,
  respond: (typeof reposGetOrgRuleSuite)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_rule_suite>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetOrgRuleset = b((r) => ({
  with200: r.with200<t_repository_ruleset>(s_repository_ruleset),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetOrgRuleset = (
  params: Params<t_ReposGetOrgRulesetParamSchema, void, void, void>,
  respond: (typeof reposGetOrgRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_ruleset>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposUpdateOrgRuleset = b((r) => ({
  with200: r.with200<t_repository_ruleset>(s_repository_ruleset),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposUpdateOrgRuleset = (
  params: Params<
    t_ReposUpdateOrgRulesetParamSchema,
    void,
    t_ReposUpdateOrgRulesetBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdateOrgRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_ruleset>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposDeleteOrgRuleset = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteOrgRuleset = (
  params: Params<t_ReposDeleteOrgRulesetParamSchema, void, void, void>,
  respond: (typeof reposDeleteOrgRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const orgsGetOrgRulesetHistory = b((r) => ({
  with200: r.with200<t_ruleset_version[]>(z.array(s_ruleset_version)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGetOrgRulesetHistory = (
  params: Params<
    t_OrgsGetOrgRulesetHistoryParamSchema,
    t_OrgsGetOrgRulesetHistoryQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsGetOrgRulesetHistory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ruleset_version[]>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const orgsGetOrgRulesetVersion = b((r) => ({
  with200: r.with200<t_ruleset_version_with_state>(
    s_ruleset_version_with_state,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGetOrgRulesetVersion = (
  params: Params<t_OrgsGetOrgRulesetVersionParamSchema, void, void, void>,
  respond: (typeof orgsGetOrgRulesetVersion)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ruleset_version_with_state>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const secretScanningListAlertsForOrg = b((r) => ({
  with200: r.with200<t_organization_secret_scanning_alert[]>(
    z.array(s_organization_secret_scanning_alert),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningListAlertsForOrg = (
  params: Params<
    t_SecretScanningListAlertsForOrgParamSchema,
    t_SecretScanningListAlertsForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof secretScanningListAlertsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_secret_scanning_alert[]>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const securityAdvisoriesListOrgRepositoryAdvisories = b((r) => ({
  with200: r.with200<t_repository_advisory[]>(z.array(s_repository_advisory)),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesListOrgRepositoryAdvisories = (
  params: Params<
    t_SecurityAdvisoriesListOrgRepositoryAdvisoriesParamSchema,
    t_SecurityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema,
    void,
    void
  >,
  respond: (typeof securityAdvisoriesListOrgRepositoryAdvisories)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_advisory[]>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
>

const orgsListSecurityManagerTeams = b((r) => ({
  with200: r.with200<t_team_simple[]>(z.array(s_team_simple)),
  withStatus: r.withStatus,
}))

export type OrgsListSecurityManagerTeams = (
  params: Params<t_OrgsListSecurityManagerTeamsParamSchema, void, void, void>,
  respond: (typeof orgsListSecurityManagerTeams)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_simple[]>>

const orgsAddSecurityManagerTeam = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsAddSecurityManagerTeam = (
  params: Params<t_OrgsAddSecurityManagerTeamParamSchema, void, void, void>,
  respond: (typeof orgsAddSecurityManagerTeam)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const orgsRemoveSecurityManagerTeam = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsRemoveSecurityManagerTeam = (
  params: Params<t_OrgsRemoveSecurityManagerTeamParamSchema, void, void, void>,
  respond: (typeof orgsRemoveSecurityManagerTeam)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const billingGetGithubActionsBillingOrg = b((r) => ({
  with200: r.with200<t_actions_billing_usage>(s_actions_billing_usage),
  withStatus: r.withStatus,
}))

export type BillingGetGithubActionsBillingOrg = (
  params: Params<
    t_BillingGetGithubActionsBillingOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof billingGetGithubActionsBillingOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_actions_billing_usage>
>

const billingGetGithubPackagesBillingOrg = b((r) => ({
  with200: r.with200<t_packages_billing_usage>(s_packages_billing_usage),
  withStatus: r.withStatus,
}))

export type BillingGetGithubPackagesBillingOrg = (
  params: Params<
    t_BillingGetGithubPackagesBillingOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof billingGetGithubPackagesBillingOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_packages_billing_usage>
>

const billingGetSharedStorageBillingOrg = b((r) => ({
  with200: r.with200<t_combined_billing_usage>(s_combined_billing_usage),
  withStatus: r.withStatus,
}))

export type BillingGetSharedStorageBillingOrg = (
  params: Params<
    t_BillingGetSharedStorageBillingOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof billingGetSharedStorageBillingOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_combined_billing_usage>
>

const hostedComputeListNetworkConfigurationsForOrg = b((r) => ({
  with200: r.with200<{
    network_configurations: t_network_configuration[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      network_configurations: z.array(s_network_configuration),
    }),
  ),
  withStatus: r.withStatus,
}))

export type HostedComputeListNetworkConfigurationsForOrg = (
  params: Params<
    t_HostedComputeListNetworkConfigurationsForOrgParamSchema,
    t_HostedComputeListNetworkConfigurationsForOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof hostedComputeListNetworkConfigurationsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        network_configurations: t_network_configuration[]
        total_count: number
      }
    >
>

const hostedComputeCreateNetworkConfigurationForOrg = b((r) => ({
  with201: r.with201<t_network_configuration>(s_network_configuration),
  withStatus: r.withStatus,
}))

export type HostedComputeCreateNetworkConfigurationForOrg = (
  params: Params<
    t_HostedComputeCreateNetworkConfigurationForOrgParamSchema,
    void,
    t_HostedComputeCreateNetworkConfigurationForOrgBodySchema,
    void
  >,
  respond: (typeof hostedComputeCreateNetworkConfigurationForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_network_configuration>
>

const hostedComputeGetNetworkConfigurationForOrg = b((r) => ({
  with200: r.with200<t_network_configuration>(s_network_configuration),
  withStatus: r.withStatus,
}))

export type HostedComputeGetNetworkConfigurationForOrg = (
  params: Params<
    t_HostedComputeGetNetworkConfigurationForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof hostedComputeGetNetworkConfigurationForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_network_configuration>
>

const hostedComputeUpdateNetworkConfigurationForOrg = b((r) => ({
  with200: r.with200<t_network_configuration>(s_network_configuration),
  withStatus: r.withStatus,
}))

export type HostedComputeUpdateNetworkConfigurationForOrg = (
  params: Params<
    t_HostedComputeUpdateNetworkConfigurationForOrgParamSchema,
    void,
    t_HostedComputeUpdateNetworkConfigurationForOrgBodySchema,
    void
  >,
  respond: (typeof hostedComputeUpdateNetworkConfigurationForOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_network_configuration>
>

const hostedComputeDeleteNetworkConfigurationFromOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type HostedComputeDeleteNetworkConfigurationFromOrg = (
  params: Params<
    t_HostedComputeDeleteNetworkConfigurationFromOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof hostedComputeDeleteNetworkConfigurationFromOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const hostedComputeGetNetworkSettingsForOrg = b((r) => ({
  with200: r.with200<t_network_settings>(s_network_settings),
  withStatus: r.withStatus,
}))

export type HostedComputeGetNetworkSettingsForOrg = (
  params: Params<
    t_HostedComputeGetNetworkSettingsForOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof hostedComputeGetNetworkSettingsForOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_network_settings>>

const copilotCopilotMetricsForTeam = b((r) => ({
  with200: r.with200<t_copilot_usage_metrics_day[]>(
    z.array(s_copilot_usage_metrics_day),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CopilotCopilotMetricsForTeam = (
  params: Params<
    t_CopilotCopilotMetricsForTeamParamSchema,
    t_CopilotCopilotMetricsForTeamQuerySchema,
    void,
    void
  >,
  respond: (typeof copilotCopilotMetricsForTeam)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_copilot_usage_metrics_day[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_basic_error>
  | Response<500, t_basic_error>
>

const teamsList = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsList = (
  params: Params<t_TeamsListParamSchema, t_TeamsListQuerySchema, void, void>,
  respond: (typeof teamsList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<403, t_basic_error>
>

const teamsCreate = b((r) => ({
  with201: r.with201<t_team_full>(s_team_full),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsCreate = (
  params: Params<t_TeamsCreateParamSchema, void, t_TeamsCreateBodySchema, void>,
  respond: (typeof teamsCreate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_team_full>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const teamsGetByName = b((r) => ({
  with200: r.with200<t_team_full>(s_team_full),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsGetByName = (
  params: Params<t_TeamsGetByNameParamSchema, void, void, void>,
  respond: (typeof teamsGetByName)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_full>
  | Response<404, t_basic_error>
>

const teamsUpdateInOrg = b((r) => ({
  with200: r.with200<t_team_full>(s_team_full),
  with201: r.with201<t_team_full>(s_team_full),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsUpdateInOrg = (
  params: Params<
    t_TeamsUpdateInOrgParamSchema,
    void,
    t_TeamsUpdateInOrgBodySchema | undefined,
    void
  >,
  respond: (typeof teamsUpdateInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_full>
  | Response<201, t_team_full>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const teamsDeleteInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsDeleteInOrg = (
  params: Params<t_TeamsDeleteInOrgParamSchema, void, void, void>,
  respond: (typeof teamsDeleteInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsListDiscussionsInOrg = b((r) => ({
  with200: r.with200<t_team_discussion[]>(z.array(s_team_discussion)),
  withStatus: r.withStatus,
}))

export type TeamsListDiscussionsInOrg = (
  params: Params<
    t_TeamsListDiscussionsInOrgParamSchema,
    t_TeamsListDiscussionsInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListDiscussionsInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_discussion[]>>

const teamsCreateDiscussionInOrg = b((r) => ({
  with201: r.with201<t_team_discussion>(s_team_discussion),
  withStatus: r.withStatus,
}))

export type TeamsCreateDiscussionInOrg = (
  params: Params<
    t_TeamsCreateDiscussionInOrgParamSchema,
    void,
    t_TeamsCreateDiscussionInOrgBodySchema,
    void
  >,
  respond: (typeof teamsCreateDiscussionInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_team_discussion>>

const teamsGetDiscussionInOrg = b((r) => ({
  with200: r.with200<t_team_discussion>(s_team_discussion),
  withStatus: r.withStatus,
}))

export type TeamsGetDiscussionInOrg = (
  params: Params<t_TeamsGetDiscussionInOrgParamSchema, void, void, void>,
  respond: (typeof teamsGetDiscussionInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_discussion>>

const teamsUpdateDiscussionInOrg = b((r) => ({
  with200: r.with200<t_team_discussion>(s_team_discussion),
  withStatus: r.withStatus,
}))

export type TeamsUpdateDiscussionInOrg = (
  params: Params<
    t_TeamsUpdateDiscussionInOrgParamSchema,
    void,
    t_TeamsUpdateDiscussionInOrgBodySchema | undefined,
    void
  >,
  respond: (typeof teamsUpdateDiscussionInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_discussion>>

const teamsDeleteDiscussionInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsDeleteDiscussionInOrg = (
  params: Params<t_TeamsDeleteDiscussionInOrgParamSchema, void, void, void>,
  respond: (typeof teamsDeleteDiscussionInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsListDiscussionCommentsInOrg = b((r) => ({
  with200: r.with200<t_team_discussion_comment[]>(
    z.array(s_team_discussion_comment),
  ),
  withStatus: r.withStatus,
}))

export type TeamsListDiscussionCommentsInOrg = (
  params: Params<
    t_TeamsListDiscussionCommentsInOrgParamSchema,
    t_TeamsListDiscussionCommentsInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListDiscussionCommentsInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_team_discussion_comment[]>
>

const teamsCreateDiscussionCommentInOrg = b((r) => ({
  with201: r.with201<t_team_discussion_comment>(s_team_discussion_comment),
  withStatus: r.withStatus,
}))

export type TeamsCreateDiscussionCommentInOrg = (
  params: Params<
    t_TeamsCreateDiscussionCommentInOrgParamSchema,
    void,
    t_TeamsCreateDiscussionCommentInOrgBodySchema,
    void
  >,
  respond: (typeof teamsCreateDiscussionCommentInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_team_discussion_comment>
>

const teamsGetDiscussionCommentInOrg = b((r) => ({
  with200: r.with200<t_team_discussion_comment>(s_team_discussion_comment),
  withStatus: r.withStatus,
}))

export type TeamsGetDiscussionCommentInOrg = (
  params: Params<t_TeamsGetDiscussionCommentInOrgParamSchema, void, void, void>,
  respond: (typeof teamsGetDiscussionCommentInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_team_discussion_comment>
>

const teamsUpdateDiscussionCommentInOrg = b((r) => ({
  with200: r.with200<t_team_discussion_comment>(s_team_discussion_comment),
  withStatus: r.withStatus,
}))

export type TeamsUpdateDiscussionCommentInOrg = (
  params: Params<
    t_TeamsUpdateDiscussionCommentInOrgParamSchema,
    void,
    t_TeamsUpdateDiscussionCommentInOrgBodySchema,
    void
  >,
  respond: (typeof teamsUpdateDiscussionCommentInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_team_discussion_comment>
>

const teamsDeleteDiscussionCommentInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsDeleteDiscussionCommentInOrg = (
  params: Params<
    t_TeamsDeleteDiscussionCommentInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsDeleteDiscussionCommentInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reactionsListForTeamDiscussionCommentInOrg = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  withStatus: r.withStatus,
}))

export type ReactionsListForTeamDiscussionCommentInOrg = (
  params: Params<
    t_ReactionsListForTeamDiscussionCommentInOrgParamSchema,
    t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForTeamDiscussionCommentInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_reaction[]>>

const reactionsCreateForTeamDiscussionCommentInOrg = b((r) => ({
  with200: r.with200<t_reaction>(s_reaction),
  with201: r.with201<t_reaction>(s_reaction),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForTeamDiscussionCommentInOrg = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionCommentInOrgBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForTeamDiscussionCommentInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction>
  | Response<201, t_reaction>
>

const reactionsDeleteForTeamDiscussionComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReactionsDeleteForTeamDiscussionComment = (
  params: Params<
    t_ReactionsDeleteForTeamDiscussionCommentParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reactionsDeleteForTeamDiscussionComment)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reactionsListForTeamDiscussionInOrg = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  withStatus: r.withStatus,
}))

export type ReactionsListForTeamDiscussionInOrg = (
  params: Params<
    t_ReactionsListForTeamDiscussionInOrgParamSchema,
    t_ReactionsListForTeamDiscussionInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForTeamDiscussionInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_reaction[]>>

const reactionsCreateForTeamDiscussionInOrg = b((r) => ({
  with200: r.with200<t_reaction>(s_reaction),
  with201: r.with201<t_reaction>(s_reaction),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForTeamDiscussionInOrg = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionInOrgParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionInOrgBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForTeamDiscussionInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction>
  | Response<201, t_reaction>
>

const reactionsDeleteForTeamDiscussion = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReactionsDeleteForTeamDiscussion = (
  params: Params<
    t_ReactionsDeleteForTeamDiscussionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reactionsDeleteForTeamDiscussion)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsListPendingInvitationsInOrg = b((r) => ({
  with200: r.with200<t_organization_invitation[]>(
    z.array(s_organization_invitation),
  ),
  withStatus: r.withStatus,
}))

export type TeamsListPendingInvitationsInOrg = (
  params: Params<
    t_TeamsListPendingInvitationsInOrgParamSchema,
    t_TeamsListPendingInvitationsInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListPendingInvitationsInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_organization_invitation[]>
>

const teamsListMembersInOrg = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  withStatus: r.withStatus,
}))

export type TeamsListMembersInOrg = (
  params: Params<
    t_TeamsListMembersInOrgParamSchema,
    t_TeamsListMembersInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListMembersInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_user[]>>

const teamsGetMembershipForUserInOrg = b((r) => ({
  with200: r.with200<t_team_membership>(s_team_membership),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsGetMembershipForUserInOrg = (
  params: Params<t_TeamsGetMembershipForUserInOrgParamSchema, void, void, void>,
  respond: (typeof teamsGetMembershipForUserInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_membership>
  | Response<404, void>
>

const teamsAddOrUpdateMembershipForUserInOrg = b((r) => ({
  with200: r.with200<t_team_membership>(s_team_membership),
  with403: r.with403<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsAddOrUpdateMembershipForUserInOrg = (
  params: Params<
    t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateMembershipForUserInOrgBodySchema | undefined,
    void
  >,
  respond: (typeof teamsAddOrUpdateMembershipForUserInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_membership>
  | Response<403, void>
  | Response<422, void>
>

const teamsRemoveMembershipForUserInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsRemoveMembershipForUserInOrg = (
  params: Params<
    t_TeamsRemoveMembershipForUserInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsRemoveMembershipForUserInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<403, void>
>

const teamsListProjectsInOrg = b((r) => ({
  with200: r.with200<t_team_project[]>(z.array(s_team_project)),
  withStatus: r.withStatus,
}))

export type TeamsListProjectsInOrg = (
  params: Params<
    t_TeamsListProjectsInOrgParamSchema,
    t_TeamsListProjectsInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListProjectsInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_project[]>>

const teamsCheckPermissionsForProjectInOrg = b((r) => ({
  with200: r.with200<t_team_project>(s_team_project),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsCheckPermissionsForProjectInOrg = (
  params: Params<
    t_TeamsCheckPermissionsForProjectInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsCheckPermissionsForProjectInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_project>
  | Response<404, void>
>

const teamsAddOrUpdateProjectPermissionsInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<{
    documentation_url?: string
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type TeamsAddOrUpdateProjectPermissionsInOrg = (
  params: Params<
    t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateProjectPermissionsInOrgBodySchema | undefined,
    void
  >,
  respond: (typeof teamsAddOrUpdateProjectPermissionsInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<
      403,
      {
        documentation_url?: string
        message?: string
      }
    >
>

const teamsRemoveProjectInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsRemoveProjectInOrg = (
  params: Params<t_TeamsRemoveProjectInOrgParamSchema, void, void, void>,
  respond: (typeof teamsRemoveProjectInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsListReposInOrg = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  withStatus: r.withStatus,
}))

export type TeamsListReposInOrg = (
  params: Params<
    t_TeamsListReposInOrgParamSchema,
    t_TeamsListReposInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListReposInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_minimal_repository[]>
>

const teamsCheckPermissionsForRepoInOrg = b((r) => ({
  with200: r.with200<t_team_repository>(s_team_repository),
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsCheckPermissionsForRepoInOrg = (
  params: Params<
    t_TeamsCheckPermissionsForRepoInOrgParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsCheckPermissionsForRepoInOrg)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_repository>
  | Response<204, void>
  | Response<404, void>
>

const teamsAddOrUpdateRepoPermissionsInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsAddOrUpdateRepoPermissionsInOrg = (
  params: Params<
    t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateRepoPermissionsInOrgBodySchema | undefined,
    void
  >,
  respond: (typeof teamsAddOrUpdateRepoPermissionsInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsRemoveRepoInOrg = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsRemoveRepoInOrg = (
  params: Params<t_TeamsRemoveRepoInOrgParamSchema, void, void, void>,
  respond: (typeof teamsRemoveRepoInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsListChildInOrg = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  withStatus: r.withStatus,
}))

export type TeamsListChildInOrg = (
  params: Params<
    t_TeamsListChildInOrgParamSchema,
    t_TeamsListChildInOrgQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListChildInOrg)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team[]>>

const orgsEnableOrDisableSecurityProductOnAllOrgRepos = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type OrgsEnableOrDisableSecurityProductOnAllOrgRepos = (
  params: Params<
    t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
    void,
    t_OrgsEnableOrDisableSecurityProductOnAllOrgReposBodySchema | undefined,
    void
  >,
  respond: (typeof orgsEnableOrDisableSecurityProductOnAllOrgRepos)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<422, void>
>

const projectsGetCard = b((r) => ({
  with200: r.with200<t_project_card>(s_project_card),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsGetCard = (
  params: Params<t_ProjectsGetCardParamSchema, void, void, void>,
  respond: (typeof projectsGetCard)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project_card>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const projectsUpdateCard = b((r) => ({
  with200: r.with200<t_project_card>(s_project_card),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsUpdateCard = (
  params: Params<
    t_ProjectsUpdateCardParamSchema,
    void,
    t_ProjectsUpdateCardBodySchema | undefined,
    void
  >,
  respond: (typeof projectsUpdateCard)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project_card>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const projectsDeleteCard = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<{
    documentation_url?: string
    errors?: string[]
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
      errors: z.array(z.string()).optional(),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsDeleteCard = (
  params: Params<t_ProjectsDeleteCardParamSchema, void, void, void>,
  respond: (typeof projectsDeleteCard)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<
      403,
      {
        documentation_url?: string
        errors?: string[]
        message?: string
      }
    >
  | Response<404, t_basic_error>
>

const projectsMoveCard = b((r) => ({
  with201: r.with201<EmptyObject>(z.object({})),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<{
    documentation_url?: string
    errors?: {
      code?: string
      field?: string
      message?: string
      resource?: string
    }[]
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
      errors: z
        .array(
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
            resource: z.string().optional(),
            field: z.string().optional(),
          }),
        )
        .optional(),
    }),
  ),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    errors?: {
      code?: string
      message?: string
    }[]
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
      errors: z
        .array(
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
          }),
        )
        .optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ProjectsMoveCard = (
  params: Params<
    t_ProjectsMoveCardParamSchema,
    void,
    t_ProjectsMoveCardBodySchema,
    void
  >,
  respond: (typeof projectsMoveCard)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, EmptyObject>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<
      403,
      {
        documentation_url?: string
        errors?: {
          code?: string
          field?: string
          message?: string
          resource?: string
        }[]
        message?: string
      }
    >
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        errors?: {
          code?: string
          message?: string
        }[]
        message?: string
      }
    >
>

const projectsGetColumn = b((r) => ({
  with200: r.with200<t_project_column>(s_project_column),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsGetColumn = (
  params: Params<t_ProjectsGetColumnParamSchema, void, void, void>,
  respond: (typeof projectsGetColumn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project_column>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const projectsUpdateColumn = b((r) => ({
  with200: r.with200<t_project_column>(s_project_column),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsUpdateColumn = (
  params: Params<
    t_ProjectsUpdateColumnParamSchema,
    void,
    t_ProjectsUpdateColumnBodySchema,
    void
  >,
  respond: (typeof projectsUpdateColumn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project_column>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const projectsDeleteColumn = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsDeleteColumn = (
  params: Params<t_ProjectsDeleteColumnParamSchema, void, void, void>,
  respond: (typeof projectsDeleteColumn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const projectsListCards = b((r) => ({
  with200: r.with200<t_project_card[]>(z.array(s_project_card)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsListCards = (
  params: Params<
    t_ProjectsListCardsParamSchema,
    t_ProjectsListCardsQuerySchema,
    void,
    void
  >,
  respond: (typeof projectsListCards)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project_card[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const projectsCreateCard = b((r) => ({
  with201: r.with201<t_project_card>(s_project_card),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error | t_validation_error_simple>(
    z.union([s_validation_error, s_validation_error_simple]),
  ),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    errors?: {
      code?: string
      message?: string
    }[]
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
      errors: z
        .array(
          z.object({
            code: z.string().optional(),
            message: z.string().optional(),
          }),
        )
        .optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ProjectsCreateCard = (
  params: Params<
    t_ProjectsCreateCardParamSchema,
    void,
    t_ProjectsCreateCardBodySchema,
    void
  >,
  respond: (typeof projectsCreateCard)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_project_card>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error | t_validation_error_simple>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        errors?: {
          code?: string
          message?: string
        }[]
        message?: string
      }
    >
>

const projectsMoveColumn = b((r) => ({
  with201: r.with201<EmptyObject>(z.object({})),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsMoveColumn = (
  params: Params<
    t_ProjectsMoveColumnParamSchema,
    void,
    t_ProjectsMoveColumnBodySchema,
    void
  >,
  respond: (typeof projectsMoveColumn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, EmptyObject>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const projectsGet = b((r) => ({
  with200: r.with200<t_project>(s_project),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsGet = (
  params: Params<t_ProjectsGetParamSchema, void, void, void>,
  respond: (typeof projectsGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const projectsUpdate = b((r) => ({
  with200: r.with200<t_project>(s_project),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<{
    documentation_url?: string
    errors?: string[]
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
      errors: z.array(z.string()).optional(),
    }),
  ),
  with404: r.with404<void>(z.undefined()),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsUpdate = (
  params: Params<
    t_ProjectsUpdateParamSchema,
    void,
    t_ProjectsUpdateBodySchema | undefined,
    void
  >,
  respond: (typeof projectsUpdate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<
      403,
      {
        documentation_url?: string
        errors?: string[]
        message?: string
      }
    >
  | Response<404, void>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const projectsDelete = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<{
    documentation_url?: string
    errors?: string[]
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
      errors: z.array(z.string()).optional(),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsDelete = (
  params: Params<t_ProjectsDeleteParamSchema, void, void, void>,
  respond: (typeof projectsDelete)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<
      403,
      {
        documentation_url?: string
        errors?: string[]
        message?: string
      }
    >
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const projectsListCollaborators = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ProjectsListCollaborators = (
  params: Params<
    t_ProjectsListCollaboratorsParamSchema,
    t_ProjectsListCollaboratorsQuerySchema,
    void,
    void
  >,
  respond: (typeof projectsListCollaborators)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const projectsAddCollaborator = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ProjectsAddCollaborator = (
  params: Params<
    t_ProjectsAddCollaboratorParamSchema,
    void,
    t_ProjectsAddCollaboratorBodySchema | undefined,
    void
  >,
  respond: (typeof projectsAddCollaborator)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const projectsRemoveCollaborator = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ProjectsRemoveCollaborator = (
  params: Params<t_ProjectsRemoveCollaboratorParamSchema, void, void, void>,
  respond: (typeof projectsRemoveCollaborator)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const projectsGetPermissionForUser = b((r) => ({
  with200: r.with200<t_project_collaborator_permission>(
    s_project_collaborator_permission,
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ProjectsGetPermissionForUser = (
  params: Params<t_ProjectsGetPermissionForUserParamSchema, void, void, void>,
  respond: (typeof projectsGetPermissionForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project_collaborator_permission>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const projectsListColumns = b((r) => ({
  with200: r.with200<t_project_column[]>(z.array(s_project_column)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ProjectsListColumns = (
  params: Params<
    t_ProjectsListColumnsParamSchema,
    t_ProjectsListColumnsQuerySchema,
    void,
    void
  >,
  respond: (typeof projectsListColumns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project_column[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const projectsCreateColumn = b((r) => ({
  with201: r.with201<t_project_column>(s_project_column),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsCreateColumn = (
  params: Params<
    t_ProjectsCreateColumnParamSchema,
    void,
    t_ProjectsCreateColumnBodySchema,
    void
  >,
  respond: (typeof projectsCreateColumn)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_project_column>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const rateLimitGet = b((r) => ({
  with200: r.with200<t_rate_limit_overview>(s_rate_limit_overview),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type RateLimitGet = (
  params: Params<void, void, void, void>,
  respond: (typeof rateLimitGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_rate_limit_overview>
  | Response<304, void>
  | Response<404, t_basic_error>
>

const reposGet = b((r) => ({
  with200: r.with200<t_full_repository>(s_full_repository),
  with301: r.with301<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGet = (
  params: Params<t_ReposGetParamSchema, void, void, void>,
  respond: (typeof reposGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_full_repository>
  | Response<301, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposUpdate = b((r) => ({
  with200: r.with200<t_full_repository>(s_full_repository),
  with307: r.with307<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposUpdate = (
  params: Params<
    t_ReposUpdateParamSchema,
    void,
    t_ReposUpdateBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_full_repository>
  | Response<307, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposDelete = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with307: r.with307<t_basic_error>(s_basic_error),
  with403: r.with403<{
    documentation_url?: string
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDelete = (
  params: Params<t_ReposDeleteParamSchema, void, void, void>,
  respond: (typeof reposDelete)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<307, t_basic_error>
  | Response<
      403,
      {
        documentation_url?: string
        message?: string
      }
    >
  | Response<404, t_basic_error>
>

const actionsListArtifactsForRepo = b((r) => ({
  with200: r.with200<{
    artifacts: t_artifact[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      artifacts: z.array(s_artifact),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListArtifactsForRepo = (
  params: Params<
    t_ActionsListArtifactsForRepoParamSchema,
    t_ActionsListArtifactsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListArtifactsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        artifacts: t_artifact[]
        total_count: number
      }
    >
>

const actionsGetArtifact = b((r) => ({
  with200: r.with200<t_artifact>(s_artifact),
  withStatus: r.withStatus,
}))

export type ActionsGetArtifact = (
  params: Params<t_ActionsGetArtifactParamSchema, void, void, void>,
  respond: (typeof actionsGetArtifact)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_artifact>>

const actionsDeleteArtifact = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteArtifact = (
  params: Params<t_ActionsDeleteArtifactParamSchema, void, void, void>,
  respond: (typeof actionsDeleteArtifact)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsDownloadArtifact = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsDownloadArtifact = (
  params: Params<t_ActionsDownloadArtifactParamSchema, void, void, void>,
  respond: (typeof actionsDownloadArtifact)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<302, void>
  | Response<410, t_basic_error>
>

const actionsGetActionsCacheUsage = b((r) => ({
  with200: r.with200<t_actions_cache_usage_by_repository>(
    s_actions_cache_usage_by_repository,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetActionsCacheUsage = (
  params: Params<t_ActionsGetActionsCacheUsageParamSchema, void, void, void>,
  respond: (typeof actionsGetActionsCacheUsage)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_actions_cache_usage_by_repository>
>

const actionsGetActionsCacheList = b((r) => ({
  with200: r.with200<t_actions_cache_list>(s_actions_cache_list),
  withStatus: r.withStatus,
}))

export type ActionsGetActionsCacheList = (
  params: Params<
    t_ActionsGetActionsCacheListParamSchema,
    t_ActionsGetActionsCacheListQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsGetActionsCacheList)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_cache_list>>

const actionsDeleteActionsCacheByKey = b((r) => ({
  with200: r.with200<t_actions_cache_list>(s_actions_cache_list),
  withStatus: r.withStatus,
}))

export type ActionsDeleteActionsCacheByKey = (
  params: Params<
    t_ActionsDeleteActionsCacheByKeyParamSchema,
    t_ActionsDeleteActionsCacheByKeyQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsDeleteActionsCacheByKey)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_cache_list>>

const actionsDeleteActionsCacheById = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteActionsCacheById = (
  params: Params<t_ActionsDeleteActionsCacheByIdParamSchema, void, void, void>,
  respond: (typeof actionsDeleteActionsCacheById)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsGetJobForWorkflowRun = b((r) => ({
  with200: r.with200<t_job>(s_job),
  withStatus: r.withStatus,
}))

export type ActionsGetJobForWorkflowRun = (
  params: Params<t_ActionsGetJobForWorkflowRunParamSchema, void, void, void>,
  respond: (typeof actionsGetJobForWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_job>>

const actionsDownloadJobLogsForWorkflowRun = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDownloadJobLogsForWorkflowRun = (
  params: Params<
    t_ActionsDownloadJobLogsForWorkflowRunParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDownloadJobLogsForWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<302, void>>

const actionsReRunJobForWorkflowRun = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsReRunJobForWorkflowRun = (
  params: Params<
    t_ActionsReRunJobForWorkflowRunParamSchema,
    void,
    t_ActionsReRunJobForWorkflowRunBodySchema | undefined,
    void
  >,
  respond: (typeof actionsReRunJobForWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<403, t_basic_error>
>

const actionsGetCustomOidcSubClaimForRepo = b((r) => ({
  with200: r.with200<t_oidc_custom_sub_repo>(s_oidc_custom_sub_repo),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsGetCustomOidcSubClaimForRepo = (
  params: Params<
    t_ActionsGetCustomOidcSubClaimForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetCustomOidcSubClaimForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_oidc_custom_sub_repo>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
>

const actionsSetCustomOidcSubClaimForRepo = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsSetCustomOidcSubClaimForRepo = (
  params: Params<
    t_ActionsSetCustomOidcSubClaimForRepoParamSchema,
    void,
    t_ActionsSetCustomOidcSubClaimForRepoBodySchema,
    void
  >,
  respond: (typeof actionsSetCustomOidcSubClaimForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsListRepoOrganizationSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_actions_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_actions_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListRepoOrganizationSecrets = (
  params: Params<
    t_ActionsListRepoOrganizationSecretsParamSchema,
    t_ActionsListRepoOrganizationSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListRepoOrganizationSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_actions_secret[]
        total_count: number
      }
    >
>

const actionsListRepoOrganizationVariables = b((r) => ({
  with200: r.with200<{
    total_count: number
    variables: t_actions_variable[]
  }>(
    z.object({
      total_count: z.coerce.number(),
      variables: z.array(s_actions_variable),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListRepoOrganizationVariables = (
  params: Params<
    t_ActionsListRepoOrganizationVariablesParamSchema,
    t_ActionsListRepoOrganizationVariablesQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListRepoOrganizationVariables)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        total_count: number
        variables: t_actions_variable[]
      }
    >
>

const actionsGetGithubActionsPermissionsRepository = b((r) => ({
  with200: r.with200<t_actions_repository_permissions>(
    s_actions_repository_permissions,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetGithubActionsPermissionsRepository = (
  params: Params<
    t_ActionsGetGithubActionsPermissionsRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetGithubActionsPermissionsRepository)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_actions_repository_permissions>
>

const actionsSetGithubActionsPermissionsRepository = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetGithubActionsPermissionsRepository = (
  params: Params<
    t_ActionsSetGithubActionsPermissionsRepositoryParamSchema,
    void,
    t_ActionsSetGithubActionsPermissionsRepositoryBodySchema,
    void
  >,
  respond: (typeof actionsSetGithubActionsPermissionsRepository)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsGetWorkflowAccessToRepository = b((r) => ({
  with200: r.with200<t_actions_workflow_access_to_repository>(
    s_actions_workflow_access_to_repository,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetWorkflowAccessToRepository = (
  params: Params<
    t_ActionsGetWorkflowAccessToRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetWorkflowAccessToRepository)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_actions_workflow_access_to_repository>
>

const actionsSetWorkflowAccessToRepository = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetWorkflowAccessToRepository = (
  params: Params<
    t_ActionsSetWorkflowAccessToRepositoryParamSchema,
    void,
    t_ActionsSetWorkflowAccessToRepositoryBodySchema,
    void
  >,
  respond: (typeof actionsSetWorkflowAccessToRepository)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsGetAllowedActionsRepository = b((r) => ({
  with200: r.with200<t_selected_actions>(s_selected_actions),
  withStatus: r.withStatus,
}))

export type ActionsGetAllowedActionsRepository = (
  params: Params<
    t_ActionsGetAllowedActionsRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetAllowedActionsRepository)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_selected_actions>>

const actionsSetAllowedActionsRepository = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetAllowedActionsRepository = (
  params: Params<
    t_ActionsSetAllowedActionsRepositoryParamSchema,
    void,
    t_ActionsSetAllowedActionsRepositoryBodySchema | undefined,
    void
  >,
  respond: (typeof actionsSetAllowedActionsRepository)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsGetGithubActionsDefaultWorkflowPermissionsRepository = b((r) => ({
  with200: r.with200<t_actions_get_default_workflow_permissions>(
    s_actions_get_default_workflow_permissions,
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepository = (
  params: Params<
    t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetGithubActionsDefaultWorkflowPermissionsRepository)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_actions_get_default_workflow_permissions>
>

const actionsSetGithubActionsDefaultWorkflowPermissionsRepository = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepository = (
  params: Params<
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
    void,
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema,
    void
  >,
  respond: (typeof actionsSetGithubActionsDefaultWorkflowPermissionsRepository)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const actionsListSelfHostedRunnersForRepo = b((r) => ({
  with200: r.with200<{
    runners: t_runner[]
    total_count: number
  }>(z.object({ total_count: z.coerce.number(), runners: z.array(s_runner) })),
  withStatus: r.withStatus,
}))

export type ActionsListSelfHostedRunnersForRepo = (
  params: Params<
    t_ActionsListSelfHostedRunnersForRepoParamSchema,
    t_ActionsListSelfHostedRunnersForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListSelfHostedRunnersForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        runners: t_runner[]
        total_count: number
      }
    >
>

const actionsListRunnerApplicationsForRepo = b((r) => ({
  with200: r.with200<t_runner_application[]>(z.array(s_runner_application)),
  withStatus: r.withStatus,
}))

export type ActionsListRunnerApplicationsForRepo = (
  params: Params<
    t_ActionsListRunnerApplicationsForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsListRunnerApplicationsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_runner_application[]>
>

const actionsGenerateRunnerJitconfigForRepo = b((r) => ({
  with201: r.with201<{
    encoded_jit_config: string
    runner: t_runner
  }>(z.object({ runner: s_runner, encoded_jit_config: z.string() })),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsGenerateRunnerJitconfigForRepo = (
  params: Params<
    t_ActionsGenerateRunnerJitconfigForRepoParamSchema,
    void,
    t_ActionsGenerateRunnerJitconfigForRepoBodySchema,
    void
  >,
  respond: (typeof actionsGenerateRunnerJitconfigForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      {
        encoded_jit_config: string
        runner: t_runner
      }
    >
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsCreateRegistrationTokenForRepo = b((r) => ({
  with201: r.with201<t_authentication_token>(s_authentication_token),
  withStatus: r.withStatus,
}))

export type ActionsCreateRegistrationTokenForRepo = (
  params: Params<
    t_ActionsCreateRegistrationTokenForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsCreateRegistrationTokenForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_authentication_token>
>

const actionsCreateRemoveTokenForRepo = b((r) => ({
  with201: r.with201<t_authentication_token>(s_authentication_token),
  withStatus: r.withStatus,
}))

export type ActionsCreateRemoveTokenForRepo = (
  params: Params<
    t_ActionsCreateRemoveTokenForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsCreateRemoveTokenForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_authentication_token>
>

const actionsGetSelfHostedRunnerForRepo = b((r) => ({
  with200: r.with200<t_runner>(s_runner),
  withStatus: r.withStatus,
}))

export type ActionsGetSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsGetSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetSelfHostedRunnerForRepo)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_runner>>

const actionsDeleteSelfHostedRunnerFromRepo = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteSelfHostedRunnerFromRepo = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDeleteSelfHostedRunnerFromRepo)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListLabelsForSelfHostedRunnerForRepo = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsListLabelsForSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsListLabelsForSelfHostedRunnerForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
>

const actionsAddCustomLabelsToSelfHostedRunnerForRepo = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
    void,
    t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema,
    void
  >,
  respond: (typeof actionsAddCustomLabelsToSelfHostedRunnerForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsSetCustomLabelsForSelfHostedRunnerForRepo = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
    void,
    t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema,
    void
  >,
  respond: (typeof actionsSetCustomLabelsForSelfHostedRunnerForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
>

const actionsRemoveCustomLabelFromSelfHostedRunnerForRepo = b((r) => ({
  with200: r.with200<{
    labels: t_runner_label[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      labels: z.array(s_runner_label),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsRemoveCustomLabelFromSelfHostedRunnerForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        labels: t_runner_label[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const actionsListWorkflowRunsForRepo = b((r) => ({
  with200: r.with200<{
    total_count: number
    workflow_runs: t_workflow_run[]
  }>(
    z.object({
      total_count: z.coerce.number(),
      workflow_runs: z.array(s_workflow_run),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListWorkflowRunsForRepo = (
  params: Params<
    t_ActionsListWorkflowRunsForRepoParamSchema,
    t_ActionsListWorkflowRunsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListWorkflowRunsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        total_count: number
        workflow_runs: t_workflow_run[]
      }
    >
>

const actionsGetWorkflowRun = b((r) => ({
  with200: r.with200<t_workflow_run>(s_workflow_run),
  withStatus: r.withStatus,
}))

export type ActionsGetWorkflowRun = (
  params: Params<
    t_ActionsGetWorkflowRunParamSchema,
    t_ActionsGetWorkflowRunQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsGetWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_workflow_run>>

const actionsDeleteWorkflowRun = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteWorkflowRun = (
  params: Params<t_ActionsDeleteWorkflowRunParamSchema, void, void, void>,
  respond: (typeof actionsDeleteWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsGetReviewsForRun = b((r) => ({
  with200: r.with200<t_environment_approvals[]>(
    z.array(s_environment_approvals),
  ),
  withStatus: r.withStatus,
}))

export type ActionsGetReviewsForRun = (
  params: Params<t_ActionsGetReviewsForRunParamSchema, void, void, void>,
  respond: (typeof actionsGetReviewsForRun)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_environment_approvals[]>
>

const actionsApproveWorkflowRun = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsApproveWorkflowRun = (
  params: Params<t_ActionsApproveWorkflowRunParamSchema, void, void, void>,
  respond: (typeof actionsApproveWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const actionsListWorkflowRunArtifacts = b((r) => ({
  with200: r.with200<{
    artifacts: t_artifact[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      artifacts: z.array(s_artifact),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListWorkflowRunArtifacts = (
  params: Params<
    t_ActionsListWorkflowRunArtifactsParamSchema,
    t_ActionsListWorkflowRunArtifactsQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListWorkflowRunArtifacts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        artifacts: t_artifact[]
        total_count: number
      }
    >
>

const actionsGetWorkflowRunAttempt = b((r) => ({
  with200: r.with200<t_workflow_run>(s_workflow_run),
  withStatus: r.withStatus,
}))

export type ActionsGetWorkflowRunAttempt = (
  params: Params<
    t_ActionsGetWorkflowRunAttemptParamSchema,
    t_ActionsGetWorkflowRunAttemptQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsGetWorkflowRunAttempt)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_workflow_run>>

const actionsListJobsForWorkflowRunAttempt = b((r) => ({
  with200: r.with200<{
    jobs: t_job[]
    total_count: number
  }>(z.object({ total_count: z.coerce.number(), jobs: z.array(s_job) })),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsListJobsForWorkflowRunAttempt = (
  params: Params<
    t_ActionsListJobsForWorkflowRunAttemptParamSchema,
    t_ActionsListJobsForWorkflowRunAttemptQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListJobsForWorkflowRunAttempt)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        jobs: t_job[]
        total_count: number
      }
    >
  | Response<404, t_basic_error>
>

const actionsDownloadWorkflowRunAttemptLogs = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDownloadWorkflowRunAttemptLogs = (
  params: Params<
    t_ActionsDownloadWorkflowRunAttemptLogsParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDownloadWorkflowRunAttemptLogs)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<302, void>>

const actionsCancelWorkflowRun = b((r) => ({
  with202: r.with202<t_empty_object>(s_empty_object),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsCancelWorkflowRun = (
  params: Params<t_ActionsCancelWorkflowRunParamSchema, void, void, void>,
  respond: (typeof actionsCancelWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<202, t_empty_object>
  | Response<409, t_basic_error>
>

const actionsReviewCustomGatesForRun = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsReviewCustomGatesForRun = (
  params: Params<
    t_ActionsReviewCustomGatesForRunParamSchema,
    void,
    t_ActionsReviewCustomGatesForRunBodySchema,
    void
  >,
  respond: (typeof actionsReviewCustomGatesForRun)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsForceCancelWorkflowRun = b((r) => ({
  with202: r.with202<t_empty_object>(s_empty_object),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsForceCancelWorkflowRun = (
  params: Params<t_ActionsForceCancelWorkflowRunParamSchema, void, void, void>,
  respond: (typeof actionsForceCancelWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<202, t_empty_object>
  | Response<409, t_basic_error>
>

const actionsListJobsForWorkflowRun = b((r) => ({
  with200: r.with200<{
    jobs: t_job[]
    total_count: number
  }>(z.object({ total_count: z.coerce.number(), jobs: z.array(s_job) })),
  withStatus: r.withStatus,
}))

export type ActionsListJobsForWorkflowRun = (
  params: Params<
    t_ActionsListJobsForWorkflowRunParamSchema,
    t_ActionsListJobsForWorkflowRunQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListJobsForWorkflowRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        jobs: t_job[]
        total_count: number
      }
    >
>

const actionsDownloadWorkflowRunLogs = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDownloadWorkflowRunLogs = (
  params: Params<t_ActionsDownloadWorkflowRunLogsParamSchema, void, void, void>,
  respond: (typeof actionsDownloadWorkflowRunLogs)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<302, void>>

const actionsDeleteWorkflowRunLogs = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActionsDeleteWorkflowRunLogs = (
  params: Params<t_ActionsDeleteWorkflowRunLogsParamSchema, void, void, void>,
  respond: (typeof actionsDeleteWorkflowRunLogs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<500, t_basic_error>
>

const actionsGetPendingDeploymentsForRun = b((r) => ({
  with200: r.with200<t_pending_deployment[]>(z.array(s_pending_deployment)),
  withStatus: r.withStatus,
}))

export type ActionsGetPendingDeploymentsForRun = (
  params: Params<
    t_ActionsGetPendingDeploymentsForRunParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsGetPendingDeploymentsForRun)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_pending_deployment[]>
>

const actionsReviewPendingDeploymentsForRun = b((r) => ({
  with200: r.with200<t_deployment[]>(z.array(s_deployment)),
  withStatus: r.withStatus,
}))

export type ActionsReviewPendingDeploymentsForRun = (
  params: Params<
    t_ActionsReviewPendingDeploymentsForRunParamSchema,
    void,
    t_ActionsReviewPendingDeploymentsForRunBodySchema,
    void
  >,
  respond: (typeof actionsReviewPendingDeploymentsForRun)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_deployment[]>>

const actionsReRunWorkflow = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  withStatus: r.withStatus,
}))

export type ActionsReRunWorkflow = (
  params: Params<
    t_ActionsReRunWorkflowParamSchema,
    void,
    t_ActionsReRunWorkflowBodySchema | undefined,
    void
  >,
  respond: (typeof actionsReRunWorkflow)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_empty_object>>

const actionsReRunWorkflowFailedJobs = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  withStatus: r.withStatus,
}))

export type ActionsReRunWorkflowFailedJobs = (
  params: Params<
    t_ActionsReRunWorkflowFailedJobsParamSchema,
    void,
    t_ActionsReRunWorkflowFailedJobsBodySchema | undefined,
    void
  >,
  respond: (typeof actionsReRunWorkflowFailedJobs)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_empty_object>>

const actionsGetWorkflowRunUsage = b((r) => ({
  with200: r.with200<t_workflow_run_usage>(s_workflow_run_usage),
  withStatus: r.withStatus,
}))

export type ActionsGetWorkflowRunUsage = (
  params: Params<t_ActionsGetWorkflowRunUsageParamSchema, void, void, void>,
  respond: (typeof actionsGetWorkflowRunUsage)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_workflow_run_usage>>

const actionsListRepoSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_actions_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_actions_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListRepoSecrets = (
  params: Params<
    t_ActionsListRepoSecretsParamSchema,
    t_ActionsListRepoSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListRepoSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_actions_secret[]
        total_count: number
      }
    >
>

const actionsGetRepoPublicKey = b((r) => ({
  with200: r.with200<t_actions_public_key>(s_actions_public_key),
  withStatus: r.withStatus,
}))

export type ActionsGetRepoPublicKey = (
  params: Params<t_ActionsGetRepoPublicKeyParamSchema, void, void, void>,
  respond: (typeof actionsGetRepoPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_public_key>>

const actionsGetRepoSecret = b((r) => ({
  with200: r.with200<t_actions_secret>(s_actions_secret),
  withStatus: r.withStatus,
}))

export type ActionsGetRepoSecret = (
  params: Params<t_ActionsGetRepoSecretParamSchema, void, void, void>,
  respond: (typeof actionsGetRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_secret>>

const actionsCreateOrUpdateRepoSecret = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsCreateOrUpdateRepoSecret = (
  params: Params<
    t_ActionsCreateOrUpdateRepoSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateRepoSecretBodySchema,
    void
  >,
  respond: (typeof actionsCreateOrUpdateRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
>

const actionsDeleteRepoSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteRepoSecret = (
  params: Params<t_ActionsDeleteRepoSecretParamSchema, void, void, void>,
  respond: (typeof actionsDeleteRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListRepoVariables = b((r) => ({
  with200: r.with200<{
    total_count: number
    variables: t_actions_variable[]
  }>(
    z.object({
      total_count: z.coerce.number(),
      variables: z.array(s_actions_variable),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListRepoVariables = (
  params: Params<
    t_ActionsListRepoVariablesParamSchema,
    t_ActionsListRepoVariablesQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListRepoVariables)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        total_count: number
        variables: t_actions_variable[]
      }
    >
>

const actionsCreateRepoVariable = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  withStatus: r.withStatus,
}))

export type ActionsCreateRepoVariable = (
  params: Params<
    t_ActionsCreateRepoVariableParamSchema,
    void,
    t_ActionsCreateRepoVariableBodySchema,
    void
  >,
  respond: (typeof actionsCreateRepoVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_empty_object>>

const actionsGetRepoVariable = b((r) => ({
  with200: r.with200<t_actions_variable>(s_actions_variable),
  withStatus: r.withStatus,
}))

export type ActionsGetRepoVariable = (
  params: Params<t_ActionsGetRepoVariableParamSchema, void, void, void>,
  respond: (typeof actionsGetRepoVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_variable>>

const actionsUpdateRepoVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsUpdateRepoVariable = (
  params: Params<
    t_ActionsUpdateRepoVariableParamSchema,
    void,
    t_ActionsUpdateRepoVariableBodySchema,
    void
  >,
  respond: (typeof actionsUpdateRepoVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsDeleteRepoVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteRepoVariable = (
  params: Params<t_ActionsDeleteRepoVariableParamSchema, void, void, void>,
  respond: (typeof actionsDeleteRepoVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListRepoWorkflows = b((r) => ({
  with200: r.with200<{
    total_count: number
    workflows: t_workflow[]
  }>(
    z.object({
      total_count: z.coerce.number(),
      workflows: z.array(s_workflow),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListRepoWorkflows = (
  params: Params<
    t_ActionsListRepoWorkflowsParamSchema,
    t_ActionsListRepoWorkflowsQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListRepoWorkflows)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        total_count: number
        workflows: t_workflow[]
      }
    >
>

const actionsGetWorkflow = b((r) => ({
  with200: r.with200<t_workflow>(s_workflow),
  withStatus: r.withStatus,
}))

export type ActionsGetWorkflow = (
  params: Params<t_ActionsGetWorkflowParamSchema, void, void, void>,
  respond: (typeof actionsGetWorkflow)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_workflow>>

const actionsDisableWorkflow = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDisableWorkflow = (
  params: Params<t_ActionsDisableWorkflowParamSchema, void, void, void>,
  respond: (typeof actionsDisableWorkflow)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsCreateWorkflowDispatch = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsCreateWorkflowDispatch = (
  params: Params<
    t_ActionsCreateWorkflowDispatchParamSchema,
    void,
    t_ActionsCreateWorkflowDispatchBodySchema,
    void
  >,
  respond: (typeof actionsCreateWorkflowDispatch)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsEnableWorkflow = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsEnableWorkflow = (
  params: Params<t_ActionsEnableWorkflowParamSchema, void, void, void>,
  respond: (typeof actionsEnableWorkflow)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListWorkflowRuns = b((r) => ({
  with200: r.with200<{
    total_count: number
    workflow_runs: t_workflow_run[]
  }>(
    z.object({
      total_count: z.coerce.number(),
      workflow_runs: z.array(s_workflow_run),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListWorkflowRuns = (
  params: Params<
    t_ActionsListWorkflowRunsParamSchema,
    t_ActionsListWorkflowRunsQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListWorkflowRuns)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        total_count: number
        workflow_runs: t_workflow_run[]
      }
    >
>

const actionsGetWorkflowUsage = b((r) => ({
  with200: r.with200<t_workflow_usage>(s_workflow_usage),
  withStatus: r.withStatus,
}))

export type ActionsGetWorkflowUsage = (
  params: Params<t_ActionsGetWorkflowUsageParamSchema, void, void, void>,
  respond: (typeof actionsGetWorkflowUsage)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_workflow_usage>>

const reposListActivities = b((r) => ({
  with200: r.with200<t_activity[]>(z.array(s_activity)),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ReposListActivities = (
  params: Params<
    t_ReposListActivitiesParamSchema,
    t_ReposListActivitiesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListActivities)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_activity[]>
  | Response<422, t_validation_error_simple>
>

const issuesListAssignees = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListAssignees = (
  params: Params<
    t_IssuesListAssigneesParamSchema,
    t_IssuesListAssigneesQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListAssignees)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<404, t_basic_error>
>

const issuesCheckUserCanBeAssigned = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesCheckUserCanBeAssigned = (
  params: Params<t_IssuesCheckUserCanBeAssignedParamSchema, void, void, void>,
  respond: (typeof issuesCheckUserCanBeAssigned)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposCreateAttestation = b((r) => ({
  with201: r.with201<{
    id?: number
  }>(z.object({ id: z.coerce.number().optional() })),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateAttestation = (
  params: Params<
    t_ReposCreateAttestationParamSchema,
    void,
    t_ReposCreateAttestationBodySchema,
    void
  >,
  respond: (typeof reposCreateAttestation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      {
        id?: number
      }
    >
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const reposListAttestations = b((r) => ({
  with200: r.with200<{
    attestations?: {
      bundle?: {
        dsseEnvelope?: {
          [key: string]: unknown | undefined
        }
        mediaType?: string
        verificationMaterial?: {
          [key: string]: unknown | undefined
        }
      }
      bundle_url?: string
      repository_id?: number
    }[]
  }>(
    z.object({
      attestations: z
        .array(
          z.object({
            bundle: z
              .object({
                mediaType: z.string().optional(),
                verificationMaterial: z.record(z.unknown()).optional(),
                dsseEnvelope: z.record(z.unknown()).optional(),
              })
              .optional(),
            repository_id: z.coerce.number().optional(),
            bundle_url: z.string().optional(),
          }),
        )
        .optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposListAttestations = (
  params: Params<
    t_ReposListAttestationsParamSchema,
    t_ReposListAttestationsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListAttestations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        attestations?: {
          bundle?: {
            dsseEnvelope?: {
              [key: string]: unknown | undefined
            }
            mediaType?: string
            verificationMaterial?: {
              [key: string]: unknown | undefined
            }
          }
          bundle_url?: string
          repository_id?: number
        }[]
      }
    >
>

const reposListAutolinks = b((r) => ({
  with200: r.with200<t_autolink[]>(z.array(s_autolink)),
  withStatus: r.withStatus,
}))

export type ReposListAutolinks = (
  params: Params<t_ReposListAutolinksParamSchema, void, void, void>,
  respond: (typeof reposListAutolinks)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_autolink[]>>

const reposCreateAutolink = b((r) => ({
  with201: r.with201<t_autolink>(s_autolink),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateAutolink = (
  params: Params<
    t_ReposCreateAutolinkParamSchema,
    void,
    t_ReposCreateAutolinkBodySchema,
    void
  >,
  respond: (typeof reposCreateAutolink)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_autolink>
  | Response<422, t_validation_error>
>

const reposGetAutolink = b((r) => ({
  with200: r.with200<t_autolink>(s_autolink),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetAutolink = (
  params: Params<t_ReposGetAutolinkParamSchema, void, void, void>,
  respond: (typeof reposGetAutolink)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_autolink>
  | Response<404, t_basic_error>
>

const reposDeleteAutolink = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteAutolink = (
  params: Params<t_ReposDeleteAutolinkParamSchema, void, void, void>,
  respond: (typeof reposDeleteAutolink)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposCheckAutomatedSecurityFixes = b((r) => ({
  with200: r.with200<t_check_automated_security_fixes>(
    s_check_automated_security_fixes,
  ),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposCheckAutomatedSecurityFixes = (
  params: Params<
    t_ReposCheckAutomatedSecurityFixesParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposCheckAutomatedSecurityFixes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_check_automated_security_fixes>
  | Response<404, void>
>

const reposEnableAutomatedSecurityFixes = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposEnableAutomatedSecurityFixes = (
  params: Params<
    t_ReposEnableAutomatedSecurityFixesParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposEnableAutomatedSecurityFixes)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposDisableAutomatedSecurityFixes = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDisableAutomatedSecurityFixes = (
  params: Params<
    t_ReposDisableAutomatedSecurityFixesParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDisableAutomatedSecurityFixes)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListBranches = b((r) => ({
  with200: r.with200<t_short_branch[]>(z.array(s_short_branch)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListBranches = (
  params: Params<
    t_ReposListBranchesParamSchema,
    t_ReposListBranchesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListBranches)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_short_branch[]>
  | Response<404, t_basic_error>
>

const reposGetBranch = b((r) => ({
  with200: r.with200<t_branch_with_protection>(s_branch_with_protection),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetBranch = (
  params: Params<t_ReposGetBranchParamSchema, void, void, void>,
  respond: (typeof reposGetBranch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_branch_with_protection>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
>

const reposGetBranchProtection = b((r) => ({
  with200: r.with200<t_branch_protection>(s_branch_protection),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetBranchProtection = (
  params: Params<t_ReposGetBranchProtectionParamSchema, void, void, void>,
  respond: (typeof reposGetBranchProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_branch_protection>
  | Response<404, t_basic_error>
>

const reposUpdateBranchProtection = b((r) => ({
  with200: r.with200<t_protected_branch>(s_protected_branch),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ReposUpdateBranchProtection = (
  params: Params<
    t_ReposUpdateBranchProtectionParamSchema,
    void,
    t_ReposUpdateBranchProtectionBodySchema,
    void
  >,
  respond: (typeof reposUpdateBranchProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_protected_branch>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const reposDeleteBranchProtection = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteBranchProtection = (
  params: Params<t_ReposDeleteBranchProtectionParamSchema, void, void, void>,
  respond: (typeof reposDeleteBranchProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
>

const reposGetAdminBranchProtection = b((r) => ({
  with200: r.with200<t_protected_branch_admin_enforced>(
    s_protected_branch_admin_enforced,
  ),
  withStatus: r.withStatus,
}))

export type ReposGetAdminBranchProtection = (
  params: Params<t_ReposGetAdminBranchProtectionParamSchema, void, void, void>,
  respond: (typeof reposGetAdminBranchProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_protected_branch_admin_enforced>
>

const reposSetAdminBranchProtection = b((r) => ({
  with200: r.with200<t_protected_branch_admin_enforced>(
    s_protected_branch_admin_enforced,
  ),
  withStatus: r.withStatus,
}))

export type ReposSetAdminBranchProtection = (
  params: Params<t_ReposSetAdminBranchProtectionParamSchema, void, void, void>,
  respond: (typeof reposSetAdminBranchProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_protected_branch_admin_enforced>
>

const reposDeleteAdminBranchProtection = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteAdminBranchProtection = (
  params: Params<
    t_ReposDeleteAdminBranchProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDeleteAdminBranchProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposGetPullRequestReviewProtection = b((r) => ({
  with200: r.with200<t_protected_branch_pull_request_review>(
    s_protected_branch_pull_request_review,
  ),
  withStatus: r.withStatus,
}))

export type ReposGetPullRequestReviewProtection = (
  params: Params<
    t_ReposGetPullRequestReviewProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetPullRequestReviewProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_protected_branch_pull_request_review>
>

const reposUpdatePullRequestReviewProtection = b((r) => ({
  with200: r.with200<t_protected_branch_pull_request_review>(
    s_protected_branch_pull_request_review,
  ),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposUpdatePullRequestReviewProtection = (
  params: Params<
    t_ReposUpdatePullRequestReviewProtectionParamSchema,
    void,
    t_ReposUpdatePullRequestReviewProtectionBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdatePullRequestReviewProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_protected_branch_pull_request_review>
  | Response<422, t_validation_error>
>

const reposDeletePullRequestReviewProtection = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeletePullRequestReviewProtection = (
  params: Params<
    t_ReposDeletePullRequestReviewProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDeletePullRequestReviewProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposGetCommitSignatureProtection = b((r) => ({
  with200: r.with200<t_protected_branch_admin_enforced>(
    s_protected_branch_admin_enforced,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetCommitSignatureProtection = (
  params: Params<
    t_ReposGetCommitSignatureProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetCommitSignatureProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_protected_branch_admin_enforced>
  | Response<404, t_basic_error>
>

const reposCreateCommitSignatureProtection = b((r) => ({
  with200: r.with200<t_protected_branch_admin_enforced>(
    s_protected_branch_admin_enforced,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposCreateCommitSignatureProtection = (
  params: Params<
    t_ReposCreateCommitSignatureProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposCreateCommitSignatureProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_protected_branch_admin_enforced>
  | Response<404, t_basic_error>
>

const reposDeleteCommitSignatureProtection = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteCommitSignatureProtection = (
  params: Params<
    t_ReposDeleteCommitSignatureProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDeleteCommitSignatureProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposGetStatusChecksProtection = b((r) => ({
  with200: r.with200<t_status_check_policy>(s_status_check_policy),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetStatusChecksProtection = (
  params: Params<t_ReposGetStatusChecksProtectionParamSchema, void, void, void>,
  respond: (typeof reposGetStatusChecksProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_status_check_policy>
  | Response<404, t_basic_error>
>

const reposUpdateStatusCheckProtection = b((r) => ({
  with200: r.with200<t_status_check_policy>(s_status_check_policy),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposUpdateStatusCheckProtection = (
  params: Params<
    t_ReposUpdateStatusCheckProtectionParamSchema,
    void,
    t_ReposUpdateStatusCheckProtectionBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdateStatusCheckProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_status_check_policy>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposRemoveStatusCheckProtection = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposRemoveStatusCheckProtection = (
  params: Params<
    t_ReposRemoveStatusCheckProtectionParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposRemoveStatusCheckProtection)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposGetAllStatusCheckContexts = b((r) => ({
  with200: r.with200<string[]>(z.array(z.string())),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetAllStatusCheckContexts = (
  params: Params<t_ReposGetAllStatusCheckContextsParamSchema, void, void, void>,
  respond: (typeof reposGetAllStatusCheckContexts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, string[]>
  | Response<404, t_basic_error>
>

const reposAddStatusCheckContexts = b((r) => ({
  with200: r.with200<string[]>(z.array(z.string())),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposAddStatusCheckContexts = (
  params: Params<
    t_ReposAddStatusCheckContextsParamSchema,
    void,
    t_ReposAddStatusCheckContextsBodySchema | undefined,
    void
  >,
  respond: (typeof reposAddStatusCheckContexts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, string[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposSetStatusCheckContexts = b((r) => ({
  with200: r.with200<string[]>(z.array(z.string())),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposSetStatusCheckContexts = (
  params: Params<
    t_ReposSetStatusCheckContextsParamSchema,
    void,
    t_ReposSetStatusCheckContextsBodySchema | undefined,
    void
  >,
  respond: (typeof reposSetStatusCheckContexts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, string[]>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposRemoveStatusCheckContexts = b((r) => ({
  with200: r.with200<string[]>(z.array(z.string())),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposRemoveStatusCheckContexts = (
  params: Params<
    t_ReposRemoveStatusCheckContextsParamSchema,
    void,
    t_ReposRemoveStatusCheckContextsBodySchema,
    void
  >,
  respond: (typeof reposRemoveStatusCheckContexts)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, string[]>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetAccessRestrictions = b((r) => ({
  with200: r.with200<t_branch_restriction_policy>(s_branch_restriction_policy),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetAccessRestrictions = (
  params: Params<t_ReposGetAccessRestrictionsParamSchema, void, void, void>,
  respond: (typeof reposGetAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_branch_restriction_policy>
  | Response<404, t_basic_error>
>

const reposDeleteAccessRestrictions = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDeleteAccessRestrictions = (
  params: Params<t_ReposDeleteAccessRestrictionsParamSchema, void, void, void>,
  respond: (typeof reposDeleteAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposGetAppsWithAccessToProtectedBranch = b((r) => ({
  with200: r.with200<t_integration[]>(z.array(s_integration)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetAppsWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetAppsWithAccessToProtectedBranchParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetAppsWithAccessToProtectedBranch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_integration[]>
  | Response<404, t_basic_error>
>

const reposAddAppAccessRestrictions = b((r) => ({
  with200: r.with200<t_integration[]>(z.array(s_integration)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposAddAppAccessRestrictions = (
  params: Params<
    t_ReposAddAppAccessRestrictionsParamSchema,
    void,
    t_ReposAddAppAccessRestrictionsBodySchema,
    void
  >,
  respond: (typeof reposAddAppAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_integration[]>
  | Response<422, t_validation_error>
>

const reposSetAppAccessRestrictions = b((r) => ({
  with200: r.with200<t_integration[]>(z.array(s_integration)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposSetAppAccessRestrictions = (
  params: Params<
    t_ReposSetAppAccessRestrictionsParamSchema,
    void,
    t_ReposSetAppAccessRestrictionsBodySchema,
    void
  >,
  respond: (typeof reposSetAppAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_integration[]>
  | Response<422, t_validation_error>
>

const reposRemoveAppAccessRestrictions = b((r) => ({
  with200: r.with200<t_integration[]>(z.array(s_integration)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposRemoveAppAccessRestrictions = (
  params: Params<
    t_ReposRemoveAppAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveAppAccessRestrictionsBodySchema,
    void
  >,
  respond: (typeof reposRemoveAppAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_integration[]>
  | Response<422, t_validation_error>
>

const reposGetTeamsWithAccessToProtectedBranch = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetTeamsWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetTeamsWithAccessToProtectedBranchParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetTeamsWithAccessToProtectedBranch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<404, t_basic_error>
>

const reposAddTeamAccessRestrictions = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposAddTeamAccessRestrictions = (
  params: Params<
    t_ReposAddTeamAccessRestrictionsParamSchema,
    void,
    t_ReposAddTeamAccessRestrictionsBodySchema | undefined,
    void
  >,
  respond: (typeof reposAddTeamAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<422, t_validation_error>
>

const reposSetTeamAccessRestrictions = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposSetTeamAccessRestrictions = (
  params: Params<
    t_ReposSetTeamAccessRestrictionsParamSchema,
    void,
    t_ReposSetTeamAccessRestrictionsBodySchema | undefined,
    void
  >,
  respond: (typeof reposSetTeamAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<422, t_validation_error>
>

const reposRemoveTeamAccessRestrictions = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposRemoveTeamAccessRestrictions = (
  params: Params<
    t_ReposRemoveTeamAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveTeamAccessRestrictionsBodySchema,
    void
  >,
  respond: (typeof reposRemoveTeamAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<422, t_validation_error>
>

const reposGetUsersWithAccessToProtectedBranch = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetUsersWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetUsersWithAccessToProtectedBranchParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetUsersWithAccessToProtectedBranch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<404, t_basic_error>
>

const reposAddUserAccessRestrictions = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposAddUserAccessRestrictions = (
  params: Params<
    t_ReposAddUserAccessRestrictionsParamSchema,
    void,
    t_ReposAddUserAccessRestrictionsBodySchema,
    void
  >,
  respond: (typeof reposAddUserAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<422, t_validation_error>
>

const reposSetUserAccessRestrictions = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposSetUserAccessRestrictions = (
  params: Params<
    t_ReposSetUserAccessRestrictionsParamSchema,
    void,
    t_ReposSetUserAccessRestrictionsBodySchema,
    void
  >,
  respond: (typeof reposSetUserAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<422, t_validation_error>
>

const reposRemoveUserAccessRestrictions = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposRemoveUserAccessRestrictions = (
  params: Params<
    t_ReposRemoveUserAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveUserAccessRestrictionsBodySchema,
    void
  >,
  respond: (typeof reposRemoveUserAccessRestrictions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<422, t_validation_error>
>

const reposRenameBranch = b((r) => ({
  with201: r.with201<t_branch_with_protection>(s_branch_with_protection),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposRenameBranch = (
  params: Params<
    t_ReposRenameBranchParamSchema,
    void,
    t_ReposRenameBranchBodySchema,
    void
  >,
  respond: (typeof reposRenameBranch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_branch_with_protection>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const checksCreate = b((r) => ({
  with201: r.with201<t_check_run>(s_check_run),
  withStatus: r.withStatus,
}))

export type ChecksCreate = (
  params: Params<
    t_ChecksCreateParamSchema,
    void,
    t_ChecksCreateBodySchema,
    void
  >,
  respond: (typeof checksCreate)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_check_run>>

const checksGet = b((r) => ({
  with200: r.with200<t_check_run>(s_check_run),
  withStatus: r.withStatus,
}))

export type ChecksGet = (
  params: Params<t_ChecksGetParamSchema, void, void, void>,
  respond: (typeof checksGet)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_check_run>>

const checksUpdate = b((r) => ({
  with200: r.with200<t_check_run>(s_check_run),
  withStatus: r.withStatus,
}))

export type ChecksUpdate = (
  params: Params<
    t_ChecksUpdateParamSchema,
    void,
    t_ChecksUpdateBodySchema,
    void
  >,
  respond: (typeof checksUpdate)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_check_run>>

const checksListAnnotations = b((r) => ({
  with200: r.with200<t_check_annotation[]>(z.array(s_check_annotation)),
  withStatus: r.withStatus,
}))

export type ChecksListAnnotations = (
  params: Params<
    t_ChecksListAnnotationsParamSchema,
    t_ChecksListAnnotationsQuerySchema,
    void,
    void
  >,
  respond: (typeof checksListAnnotations)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_check_annotation[]>>

const checksRerequestRun = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ChecksRerequestRun = (
  params: Params<t_ChecksRerequestRunParamSchema, void, void, void>,
  respond: (typeof checksRerequestRun)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_basic_error>
>

const checksCreateSuite = b((r) => ({
  with200: r.with200<t_check_suite>(s_check_suite),
  with201: r.with201<t_check_suite>(s_check_suite),
  withStatus: r.withStatus,
}))

export type ChecksCreateSuite = (
  params: Params<
    t_ChecksCreateSuiteParamSchema,
    void,
    t_ChecksCreateSuiteBodySchema,
    void
  >,
  respond: (typeof checksCreateSuite)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_check_suite>
  | Response<201, t_check_suite>
>

const checksSetSuitesPreferences = b((r) => ({
  with200: r.with200<t_check_suite_preference>(s_check_suite_preference),
  withStatus: r.withStatus,
}))

export type ChecksSetSuitesPreferences = (
  params: Params<
    t_ChecksSetSuitesPreferencesParamSchema,
    void,
    t_ChecksSetSuitesPreferencesBodySchema,
    void
  >,
  respond: (typeof checksSetSuitesPreferences)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_check_suite_preference>
>

const checksGetSuite = b((r) => ({
  with200: r.with200<t_check_suite>(s_check_suite),
  withStatus: r.withStatus,
}))

export type ChecksGetSuite = (
  params: Params<t_ChecksGetSuiteParamSchema, void, void, void>,
  respond: (typeof checksGetSuite)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_check_suite>>

const checksListForSuite = b((r) => ({
  with200: r.with200<{
    check_runs: t_check_run[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      check_runs: z.array(s_check_run),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ChecksListForSuite = (
  params: Params<
    t_ChecksListForSuiteParamSchema,
    t_ChecksListForSuiteQuerySchema,
    void,
    void
  >,
  respond: (typeof checksListForSuite)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        check_runs: t_check_run[]
        total_count: number
      }
    >
>

const checksRerequestSuite = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  withStatus: r.withStatus,
}))

export type ChecksRerequestSuite = (
  params: Params<t_ChecksRerequestSuiteParamSchema, void, void, void>,
  respond: (typeof checksRerequestSuite)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_empty_object>>

const codeScanningListAlertsForRepo = b((r) => ({
  with200: r.with200<t_code_scanning_alert_items[]>(
    z.array(s_code_scanning_alert_items),
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningListAlertsForRepo = (
  params: Params<
    t_CodeScanningListAlertsForRepoParamSchema,
    t_CodeScanningListAlertsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof codeScanningListAlertsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_alert_items[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetAlert = b((r) => ({
  with200: r.with200<t_code_scanning_alert>(s_code_scanning_alert),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetAlert = (
  params: Params<t_CodeScanningGetAlertParamSchema, void, void, void>,
  respond: (typeof codeScanningGetAlert)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_alert>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningUpdateAlert = b((r) => ({
  with200: r.with200<t_code_scanning_alert>(s_code_scanning_alert),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningUpdateAlert = (
  params: Params<
    t_CodeScanningUpdateAlertParamSchema,
    void,
    t_CodeScanningUpdateAlertBodySchema,
    void
  >,
  respond: (typeof codeScanningUpdateAlert)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_alert>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetAutofix = b((r) => ({
  with200: r.with200<t_code_scanning_autofix>(s_code_scanning_autofix),
  with400: r.with400<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetAutofix = (
  params: Params<t_CodeScanningGetAutofixParamSchema, void, void, void>,
  respond: (typeof codeScanningGetAutofix)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_autofix>
  | Response<400, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningCreateAutofix = b((r) => ({
  with200: r.with200<t_code_scanning_autofix>(s_code_scanning_autofix),
  with202: r.with202<t_code_scanning_autofix>(s_code_scanning_autofix),
  with400: r.with400<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningCreateAutofix = (
  params: Params<t_CodeScanningCreateAutofixParamSchema, void, void, void>,
  respond: (typeof codeScanningCreateAutofix)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_autofix>
  | Response<202, t_code_scanning_autofix>
  | Response<400, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningCommitAutofix = b((r) => ({
  with201: r.with201<t_code_scanning_autofix_commits_response>(
    s_code_scanning_autofix_commits_response,
  ),
  with400: r.with400<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningCommitAutofix = (
  params: Params<
    t_CodeScanningCommitAutofixParamSchema,
    void,
    t_CodeScanningCommitAutofixBodySchema | undefined,
    void
  >,
  respond: (typeof codeScanningCommitAutofix)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_code_scanning_autofix_commits_response>
  | Response<400, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningListAlertInstances = b((r) => ({
  with200: r.with200<t_code_scanning_alert_instance[]>(
    z.array(s_code_scanning_alert_instance),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningListAlertInstances = (
  params: Params<
    t_CodeScanningListAlertInstancesParamSchema,
    t_CodeScanningListAlertInstancesQuerySchema,
    void,
    void
  >,
  respond: (typeof codeScanningListAlertInstances)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_alert_instance[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningListRecentAnalyses = b((r) => ({
  with200: r.with200<t_code_scanning_analysis[]>(
    z.array(s_code_scanning_analysis),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningListRecentAnalyses = (
  params: Params<
    t_CodeScanningListRecentAnalysesParamSchema,
    t_CodeScanningListRecentAnalysesQuerySchema,
    void,
    void
  >,
  respond: (typeof codeScanningListRecentAnalyses)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_analysis[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetAnalysis = b((r) => ({
  with200: r.with200<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetAnalysis = (
  params: Params<t_CodeScanningGetAnalysisParamSchema, void, void, void>,
  respond: (typeof codeScanningGetAnalysis)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningDeleteAnalysis = b((r) => ({
  with200: r.with200<t_code_scanning_analysis_deletion>(
    s_code_scanning_analysis_deletion,
  ),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningDeleteAnalysis = (
  params: Params<
    t_CodeScanningDeleteAnalysisParamSchema,
    t_CodeScanningDeleteAnalysisQuerySchema,
    void,
    void
  >,
  respond: (typeof codeScanningDeleteAnalysis)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_analysis_deletion>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningListCodeqlDatabases = b((r) => ({
  with200: r.with200<t_code_scanning_codeql_database[]>(
    z.array(s_code_scanning_codeql_database),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningListCodeqlDatabases = (
  params: Params<
    t_CodeScanningListCodeqlDatabasesParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeScanningListCodeqlDatabases)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_codeql_database[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetCodeqlDatabase = b((r) => ({
  with200: r.with200<t_code_scanning_codeql_database>(
    s_code_scanning_codeql_database,
  ),
  with302: r.with302<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetCodeqlDatabase = (
  params: Params<t_CodeScanningGetCodeqlDatabaseParamSchema, void, void, void>,
  respond: (typeof codeScanningGetCodeqlDatabase)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_codeql_database>
  | Response<302, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningDeleteCodeqlDatabase = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningDeleteCodeqlDatabase = (
  params: Params<
    t_CodeScanningDeleteCodeqlDatabaseParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeScanningDeleteCodeqlDatabase)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningCreateVariantAnalysis = b((r) => ({
  with201: r.with201<t_code_scanning_variant_analysis>(
    s_code_scanning_variant_analysis,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningCreateVariantAnalysis = (
  params: Params<
    t_CodeScanningCreateVariantAnalysisParamSchema,
    void,
    t_CodeScanningCreateVariantAnalysisBodySchema,
    void
  >,
  respond: (typeof codeScanningCreateVariantAnalysis)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_code_scanning_variant_analysis>
  | Response<404, t_basic_error>
  | Response<422, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetVariantAnalysis = b((r) => ({
  with200: r.with200<t_code_scanning_variant_analysis>(
    s_code_scanning_variant_analysis,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetVariantAnalysis = (
  params: Params<t_CodeScanningGetVariantAnalysisParamSchema, void, void, void>,
  respond: (typeof codeScanningGetVariantAnalysis)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_variant_analysis>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetVariantAnalysisRepoTask = b((r) => ({
  with200: r.with200<t_code_scanning_variant_analysis_repo_task>(
    s_code_scanning_variant_analysis_repo_task,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetVariantAnalysisRepoTask = (
  params: Params<
    t_CodeScanningGetVariantAnalysisRepoTaskParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeScanningGetVariantAnalysisRepoTask)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_variant_analysis_repo_task>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetDefaultSetup = b((r) => ({
  with200: r.with200<t_code_scanning_default_setup>(
    s_code_scanning_default_setup,
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetDefaultSetup = (
  params: Params<t_CodeScanningGetDefaultSetupParamSchema, void, void, void>,
  respond: (typeof codeScanningGetDefaultSetup)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_default_setup>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningUpdateDefaultSetup = b((r) => ({
  with200: r.with200<t_empty_object>(s_empty_object),
  with202: r.with202<t_code_scanning_default_setup_update_response>(
    s_code_scanning_default_setup_update_response,
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningUpdateDefaultSetup = (
  params: Params<
    t_CodeScanningUpdateDefaultSetupParamSchema,
    void,
    t_CodeScanningUpdateDefaultSetupBodySchema,
    void
  >,
  respond: (typeof codeScanningUpdateDefaultSetup)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_empty_object>
  | Response<202, t_code_scanning_default_setup_update_response>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningUploadSarif = b((r) => ({
  with202: r.with202<t_code_scanning_sarifs_receipt>(
    s_code_scanning_sarifs_receipt,
  ),
  with400: r.with400<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with413: r.with413<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningUploadSarif = (
  params: Params<
    t_CodeScanningUploadSarifParamSchema,
    void,
    t_CodeScanningUploadSarifBodySchema,
    void
  >,
  respond: (typeof codeScanningUploadSarif)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<202, t_code_scanning_sarifs_receipt>
  | Response<400, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<413, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeScanningGetSarif = b((r) => ({
  with200: r.with200<t_code_scanning_sarifs_status>(
    s_code_scanning_sarifs_status,
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodeScanningGetSarif = (
  params: Params<t_CodeScanningGetSarifParamSchema, void, void, void>,
  respond: (typeof codeScanningGetSarif)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_scanning_sarifs_status>
  | Response<403, t_basic_error>
  | Response<404, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codeSecurityGetConfigurationForRepository = b((r) => ({
  with200: r.with200<t_code_security_configuration_for_repository>(
    s_code_security_configuration_for_repository,
  ),
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodeSecurityGetConfigurationForRepository = (
  params: Params<
    t_CodeSecurityGetConfigurationForRepositoryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codeSecurityGetConfigurationForRepository)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_security_configuration_for_repository>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposCodeownersErrors = b((r) => ({
  with200: r.with200<t_codeowners_errors>(s_codeowners_errors),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposCodeownersErrors = (
  params: Params<
    t_ReposCodeownersErrorsParamSchema,
    t_ReposCodeownersErrorsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposCodeownersErrors)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codeowners_errors>
  | Response<404, void>
>

const codespacesListInRepositoryForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    codespaces: t_codespace[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      codespaces: z.array(s_codespace),
    }),
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesListInRepositoryForAuthenticatedUser = (
  params: Params<
    t_CodespacesListInRepositoryForAuthenticatedUserParamSchema,
    t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListInRepositoryForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        codespaces: t_codespace[]
        total_count: number
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesCreateWithRepoForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_codespace>(s_codespace),
  with202: r.with202<t_codespace>(s_codespace),
  with400: r.with400<t_scim_error>(s_scim_error),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodespacesCreateWithRepoForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateWithRepoForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof codespacesCreateWithRepoForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_codespace>
  | Response<202, t_codespace>
  | Response<400, t_scim_error>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codespacesListDevcontainersInRepositoryForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    devcontainers: {
      display_name?: string
      name?: string
      path: string
    }[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      devcontainers: z.array(
        z.object({
          path: z.string(),
          name: z.string().optional(),
          display_name: z.string().optional(),
        }),
      ),
    }),
  ),
  with400: r.with400<t_scim_error>(s_scim_error),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser = (
  params: Params<
    t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
    t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListDevcontainersInRepositoryForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        devcontainers: {
          display_name?: string
          name?: string
          path: string
        }[]
        total_count: number
      }
    >
  | Response<400, t_scim_error>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesRepoMachinesForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    machines: t_codespace_machine[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      machines: z.array(s_codespace_machine),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesRepoMachinesForAuthenticatedUser = (
  params: Params<
    t_CodespacesRepoMachinesForAuthenticatedUserParamSchema,
    t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesRepoMachinesForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        machines: t_codespace_machine[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesPreFlightWithRepoForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    billable_owner?: t_simple_user
    defaults?: {
      devcontainer_path: string | null
      location: string
    }
  }>(
    z.object({
      billable_owner: s_simple_user.optional(),
      defaults: z
        .object({
          location: z.string(),
          devcontainer_path: z.string().nullable(),
        })
        .optional(),
    }),
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesPreFlightWithRepoForAuthenticatedUser = (
  params: Params<
    t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
    t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesPreFlightWithRepoForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        billable_owner?: t_simple_user
        defaults?: {
          devcontainer_path: string | null
          location: string
        }
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codespacesCheckPermissionsForDevcontainer = b((r) => ({
  with200: r.with200<t_codespaces_permissions_check_for_devcontainer>(
    s_codespaces_permissions_check_for_devcontainer,
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodespacesCheckPermissionsForDevcontainer = (
  params: Params<
    t_CodespacesCheckPermissionsForDevcontainerParamSchema,
    t_CodespacesCheckPermissionsForDevcontainerQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesCheckPermissionsForDevcontainer)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codespaces_permissions_check_for_devcontainer>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codespacesListRepoSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_repo_codespaces_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_repo_codespaces_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodespacesListRepoSecrets = (
  params: Params<
    t_CodespacesListRepoSecretsParamSchema,
    t_CodespacesListRepoSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListRepoSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_repo_codespaces_secret[]
        total_count: number
      }
    >
>

const codespacesGetRepoPublicKey = b((r) => ({
  with200: r.with200<t_codespaces_public_key>(s_codespaces_public_key),
  withStatus: r.withStatus,
}))

export type CodespacesGetRepoPublicKey = (
  params: Params<t_CodespacesGetRepoPublicKeyParamSchema, void, void, void>,
  respond: (typeof codespacesGetRepoPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_codespaces_public_key>
>

const codespacesGetRepoSecret = b((r) => ({
  with200: r.with200<t_repo_codespaces_secret>(s_repo_codespaces_secret),
  withStatus: r.withStatus,
}))

export type CodespacesGetRepoSecret = (
  params: Params<t_CodespacesGetRepoSecretParamSchema, void, void, void>,
  respond: (typeof codespacesGetRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_repo_codespaces_secret>
>

const codespacesCreateOrUpdateRepoSecret = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type CodespacesCreateOrUpdateRepoSecret = (
  params: Params<
    t_CodespacesCreateOrUpdateRepoSecretParamSchema,
    void,
    t_CodespacesCreateOrUpdateRepoSecretBodySchema,
    void
  >,
  respond: (typeof codespacesCreateOrUpdateRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
>

const codespacesDeleteRepoSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type CodespacesDeleteRepoSecret = (
  params: Params<t_CodespacesDeleteRepoSecretParamSchema, void, void, void>,
  respond: (typeof codespacesDeleteRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListCollaborators = b((r) => ({
  with200: r.with200<t_collaborator[]>(z.array(s_collaborator)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListCollaborators = (
  params: Params<
    t_ReposListCollaboratorsParamSchema,
    t_ReposListCollaboratorsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListCollaborators)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_collaborator[]>
  | Response<404, t_basic_error>
>

const reposCheckCollaborator = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposCheckCollaborator = (
  params: Params<t_ReposCheckCollaboratorParamSchema, void, void, void>,
  respond: (typeof reposCheckCollaborator)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<404, void>
>

const reposAddCollaborator = b((r) => ({
  with201: r.with201<t_repository_invitation>(s_repository_invitation),
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposAddCollaborator = (
  params: Params<
    t_ReposAddCollaboratorParamSchema,
    void,
    t_ReposAddCollaboratorBodySchema | undefined,
    void
  >,
  respond: (typeof reposAddCollaborator)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_repository_invitation>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const reposRemoveCollaborator = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposRemoveCollaborator = (
  params: Params<t_ReposRemoveCollaboratorParamSchema, void, void, void>,
  respond: (typeof reposRemoveCollaborator)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetCollaboratorPermissionLevel = b((r) => ({
  with200: r.with200<t_repository_collaborator_permission>(
    s_repository_collaborator_permission,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetCollaboratorPermissionLevel = (
  params: Params<
    t_ReposGetCollaboratorPermissionLevelParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetCollaboratorPermissionLevel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_collaborator_permission>
  | Response<404, t_basic_error>
>

const reposListCommitCommentsForRepo = b((r) => ({
  with200: r.with200<t_commit_comment[]>(z.array(s_commit_comment)),
  withStatus: r.withStatus,
}))

export type ReposListCommitCommentsForRepo = (
  params: Params<
    t_ReposListCommitCommentsForRepoParamSchema,
    t_ReposListCommitCommentsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListCommitCommentsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_commit_comment[]>>

const reposGetCommitComment = b((r) => ({
  with200: r.with200<t_commit_comment>(s_commit_comment),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetCommitComment = (
  params: Params<t_ReposGetCommitCommentParamSchema, void, void, void>,
  respond: (typeof reposGetCommitComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_commit_comment>
  | Response<404, t_basic_error>
>

const reposUpdateCommitComment = b((r) => ({
  with200: r.with200<t_commit_comment>(s_commit_comment),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposUpdateCommitComment = (
  params: Params<
    t_ReposUpdateCommitCommentParamSchema,
    void,
    t_ReposUpdateCommitCommentBodySchema,
    void
  >,
  respond: (typeof reposUpdateCommitComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_commit_comment>
  | Response<404, t_basic_error>
>

const reposDeleteCommitComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteCommitComment = (
  params: Params<t_ReposDeleteCommitCommentParamSchema, void, void, void>,
  respond: (typeof reposDeleteCommitComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reactionsListForCommitComment = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReactionsListForCommitComment = (
  params: Params<
    t_ReactionsListForCommitCommentParamSchema,
    t_ReactionsListForCommitCommentQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForCommitComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction[]>
  | Response<404, t_basic_error>
>

const reactionsCreateForCommitComment = b((r) => ({
  with200: r.with200<t_reaction>(s_reaction),
  with201: r.with201<t_reaction>(s_reaction),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForCommitComment = (
  params: Params<
    t_ReactionsCreateForCommitCommentParamSchema,
    void,
    t_ReactionsCreateForCommitCommentBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForCommitComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction>
  | Response<201, t_reaction>
  | Response<422, t_validation_error>
>

const reactionsDeleteForCommitComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReactionsDeleteForCommitComment = (
  params: Params<
    t_ReactionsDeleteForCommitCommentParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reactionsDeleteForCommitComment)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListCommits = b((r) => ({
  with200: r.with200<t_commit[]>(z.array(s_commit)),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListCommits = (
  params: Params<
    t_ReposListCommitsParamSchema,
    t_ReposListCommitsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListCommits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_commit[]>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<500, t_basic_error>
>

const reposListBranchesForHeadCommit = b((r) => ({
  with200: r.with200<t_branch_short[]>(z.array(s_branch_short)),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposListBranchesForHeadCommit = (
  params: Params<t_ReposListBranchesForHeadCommitParamSchema, void, void, void>,
  respond: (typeof reposListBranchesForHeadCommit)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_branch_short[]>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const reposListCommentsForCommit = b((r) => ({
  with200: r.with200<t_commit_comment[]>(z.array(s_commit_comment)),
  withStatus: r.withStatus,
}))

export type ReposListCommentsForCommit = (
  params: Params<
    t_ReposListCommentsForCommitParamSchema,
    t_ReposListCommentsForCommitQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListCommentsForCommit)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_commit_comment[]>>

const reposCreateCommitComment = b((r) => ({
  with201: r.with201<t_commit_comment>(s_commit_comment),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateCommitComment = (
  params: Params<
    t_ReposCreateCommitCommentParamSchema,
    void,
    t_ReposCreateCommitCommentBodySchema,
    void
  >,
  respond: (typeof reposCreateCommitComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_commit_comment>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const reposListPullRequestsAssociatedWithCommit = b((r) => ({
  with200: r.with200<t_pull_request_simple[]>(z.array(s_pull_request_simple)),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListPullRequestsAssociatedWithCommit = (
  params: Params<
    t_ReposListPullRequestsAssociatedWithCommitParamSchema,
    t_ReposListPullRequestsAssociatedWithCommitQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListPullRequestsAssociatedWithCommit)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_simple[]>
  | Response<409, t_basic_error>
>

const reposGetCommit = b((r) => ({
  with200: r.with200<t_commit>(s_commit),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposGetCommit = (
  params: Params<
    t_ReposGetCommitParamSchema,
    t_ReposGetCommitQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetCommit)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_commit>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const checksListForRef = b((r) => ({
  with200: r.with200<{
    check_runs: t_check_run[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      check_runs: z.array(s_check_run),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ChecksListForRef = (
  params: Params<
    t_ChecksListForRefParamSchema,
    t_ChecksListForRefQuerySchema,
    void,
    void
  >,
  respond: (typeof checksListForRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        check_runs: t_check_run[]
        total_count: number
      }
    >
>

const checksListSuitesForRef = b((r) => ({
  with200: r.with200<{
    check_suites: t_check_suite[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      check_suites: z.array(s_check_suite),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ChecksListSuitesForRef = (
  params: Params<
    t_ChecksListSuitesForRefParamSchema,
    t_ChecksListSuitesForRefQuerySchema,
    void,
    void
  >,
  respond: (typeof checksListSuitesForRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        check_suites: t_check_suite[]
        total_count: number
      }
    >
>

const reposGetCombinedStatusForRef = b((r) => ({
  with200: r.with200<t_combined_commit_status>(s_combined_commit_status),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetCombinedStatusForRef = (
  params: Params<
    t_ReposGetCombinedStatusForRefParamSchema,
    t_ReposGetCombinedStatusForRefQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetCombinedStatusForRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_combined_commit_status>
  | Response<404, t_basic_error>
>

const reposListCommitStatusesForRef = b((r) => ({
  with200: r.with200<t_status[]>(z.array(s_status)),
  with301: r.with301<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListCommitStatusesForRef = (
  params: Params<
    t_ReposListCommitStatusesForRefParamSchema,
    t_ReposListCommitStatusesForRefQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListCommitStatusesForRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_status[]>
  | Response<301, t_basic_error>
>

const reposGetCommunityProfileMetrics = b((r) => ({
  with200: r.with200<t_community_profile>(s_community_profile),
  withStatus: r.withStatus,
}))

export type ReposGetCommunityProfileMetrics = (
  params: Params<
    t_ReposGetCommunityProfileMetricsParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetCommunityProfileMetrics)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_community_profile>>

const reposCompareCommits = b((r) => ({
  with200: r.with200<t_commit_comparison>(s_commit_comparison),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposCompareCommits = (
  params: Params<
    t_ReposCompareCommitsParamSchema,
    t_ReposCompareCommitsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposCompareCommits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_commit_comparison>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const reposGetContent = b((r) => ({
  with200: r.with200<
    | t_content_directory
    | t_content_file
    | t_content_symlink
    | t_content_submodule
  >(
    z.union([
      s_content_directory,
      s_content_file,
      s_content_symlink,
      s_content_submodule,
    ]),
  ),
  with302: r.with302<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetContent = (
  params: Params<
    t_ReposGetContentParamSchema,
    t_ReposGetContentQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetContent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      | t_content_directory
      | t_content_file
      | t_content_symlink
      | t_content_submodule
    >
  | Response<302, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposCreateOrUpdateFileContents = b((r) => ({
  with200: r.with200<t_file_commit>(s_file_commit),
  with201: r.with201<t_file_commit>(s_file_commit),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error | t_repository_rule_violation_error>(
    z.union([s_basic_error, s_repository_rule_violation_error]),
  ),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateOrUpdateFileContents = (
  params: Params<
    t_ReposCreateOrUpdateFileContentsParamSchema,
    void,
    t_ReposCreateOrUpdateFileContentsBodySchema,
    void
  >,
  respond: (typeof reposCreateOrUpdateFileContents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_commit>
  | Response<201, t_file_commit>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error | t_repository_rule_violation_error>
  | Response<422, t_validation_error>
>

const reposDeleteFile = b((r) => ({
  with200: r.with200<t_file_commit>(s_file_commit),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposDeleteFile = (
  params: Params<
    t_ReposDeleteFileParamSchema,
    void,
    t_ReposDeleteFileBodySchema,
    void
  >,
  respond: (typeof reposDeleteFile)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_file_commit>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const reposListContributors = b((r) => ({
  with200: r.with200<t_contributor[]>(z.array(s_contributor)),
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListContributors = (
  params: Params<
    t_ReposListContributorsParamSchema,
    t_ReposListContributorsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListContributors)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_contributor[]>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const dependabotListAlertsForRepo = b((r) => ({
  with200: r.with200<t_dependabot_alert[]>(z.array(s_dependabot_alert)),
  with304: r.with304<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type DependabotListAlertsForRepo = (
  params: Params<
    t_DependabotListAlertsForRepoParamSchema,
    t_DependabotListAlertsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof dependabotListAlertsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dependabot_alert[]>
  | Response<304, void>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const dependabotGetAlert = b((r) => ({
  with200: r.with200<t_dependabot_alert>(s_dependabot_alert),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type DependabotGetAlert = (
  params: Params<t_DependabotGetAlertParamSchema, void, void, void>,
  respond: (typeof dependabotGetAlert)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dependabot_alert>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const dependabotUpdateAlert = b((r) => ({
  with200: r.with200<t_dependabot_alert>(s_dependabot_alert),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type DependabotUpdateAlert = (
  params: Params<
    t_DependabotUpdateAlertParamSchema,
    void,
    t_DependabotUpdateAlertBodySchema,
    void
  >,
  respond: (typeof dependabotUpdateAlert)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dependabot_alert>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const dependabotListRepoSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_dependabot_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_dependabot_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type DependabotListRepoSecrets = (
  params: Params<
    t_DependabotListRepoSecretsParamSchema,
    t_DependabotListRepoSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof dependabotListRepoSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_dependabot_secret[]
        total_count: number
      }
    >
>

const dependabotGetRepoPublicKey = b((r) => ({
  with200: r.with200<t_dependabot_public_key>(s_dependabot_public_key),
  withStatus: r.withStatus,
}))

export type DependabotGetRepoPublicKey = (
  params: Params<t_DependabotGetRepoPublicKeyParamSchema, void, void, void>,
  respond: (typeof dependabotGetRepoPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_dependabot_public_key>
>

const dependabotGetRepoSecret = b((r) => ({
  with200: r.with200<t_dependabot_secret>(s_dependabot_secret),
  withStatus: r.withStatus,
}))

export type DependabotGetRepoSecret = (
  params: Params<t_DependabotGetRepoSecretParamSchema, void, void, void>,
  respond: (typeof dependabotGetRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_dependabot_secret>>

const dependabotCreateOrUpdateRepoSecret = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type DependabotCreateOrUpdateRepoSecret = (
  params: Params<
    t_DependabotCreateOrUpdateRepoSecretParamSchema,
    void,
    t_DependabotCreateOrUpdateRepoSecretBodySchema,
    void
  >,
  respond: (typeof dependabotCreateOrUpdateRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
>

const dependabotDeleteRepoSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type DependabotDeleteRepoSecret = (
  params: Params<t_DependabotDeleteRepoSecretParamSchema, void, void, void>,
  respond: (typeof dependabotDeleteRepoSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const dependencyGraphDiffRange = b((r) => ({
  with200: r.with200<t_dependency_graph_diff>(s_dependency_graph_diff),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type DependencyGraphDiffRange = (
  params: Params<
    t_DependencyGraphDiffRangeParamSchema,
    t_DependencyGraphDiffRangeQuerySchema,
    void,
    void
  >,
  respond: (typeof dependencyGraphDiffRange)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dependency_graph_diff>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const dependencyGraphExportSbom = b((r) => ({
  with200: r.with200<t_dependency_graph_spdx_sbom>(
    s_dependency_graph_spdx_sbom,
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type DependencyGraphExportSbom = (
  params: Params<t_DependencyGraphExportSbomParamSchema, void, void, void>,
  respond: (typeof dependencyGraphExportSbom)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_dependency_graph_spdx_sbom>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const dependencyGraphCreateRepositorySnapshot = b((r) => ({
  with201: r.with201<{
    created_at: string
    id: number
    message: string
    result: string
  }>(
    z.object({
      id: z.coerce.number(),
      created_at: z.string(),
      result: z.string(),
      message: z.string(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type DependencyGraphCreateRepositorySnapshot = (
  params: Params<
    t_DependencyGraphCreateRepositorySnapshotParamSchema,
    void,
    t_DependencyGraphCreateRepositorySnapshotBodySchema,
    void
  >,
  respond: (typeof dependencyGraphCreateRepositorySnapshot)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      201,
      {
        created_at: string
        id: number
        message: string
        result: string
      }
    >
>

const reposListDeployments = b((r) => ({
  with200: r.with200<t_deployment[]>(z.array(s_deployment)),
  withStatus: r.withStatus,
}))

export type ReposListDeployments = (
  params: Params<
    t_ReposListDeploymentsParamSchema,
    t_ReposListDeploymentsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListDeployments)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_deployment[]>>

const reposCreateDeployment = b((r) => ({
  with201: r.with201<t_deployment>(s_deployment),
  with202: r.with202<{
    message?: string
  }>(z.object({ message: z.string().optional() })),
  with409: r.with409<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateDeployment = (
  params: Params<
    t_ReposCreateDeploymentParamSchema,
    void,
    t_ReposCreateDeploymentBodySchema,
    void
  >,
  respond: (typeof reposCreateDeployment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_deployment>
  | Response<
      202,
      {
        message?: string
      }
    >
  | Response<409, void>
  | Response<422, t_validation_error>
>

const reposGetDeployment = b((r) => ({
  with200: r.with200<t_deployment>(s_deployment),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetDeployment = (
  params: Params<t_ReposGetDeploymentParamSchema, void, void, void>,
  respond: (typeof reposGetDeployment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deployment>
  | Response<404, t_basic_error>
>

const reposDeleteDeployment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ReposDeleteDeployment = (
  params: Params<t_ReposDeleteDeploymentParamSchema, void, void, void>,
  respond: (typeof reposDeleteDeployment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const reposListDeploymentStatuses = b((r) => ({
  with200: r.with200<t_deployment_status[]>(z.array(s_deployment_status)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListDeploymentStatuses = (
  params: Params<
    t_ReposListDeploymentStatusesParamSchema,
    t_ReposListDeploymentStatusesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListDeploymentStatuses)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deployment_status[]>
  | Response<404, t_basic_error>
>

const reposCreateDeploymentStatus = b((r) => ({
  with201: r.with201<t_deployment_status>(s_deployment_status),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateDeploymentStatus = (
  params: Params<
    t_ReposCreateDeploymentStatusParamSchema,
    void,
    t_ReposCreateDeploymentStatusBodySchema,
    void
  >,
  respond: (typeof reposCreateDeploymentStatus)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_deployment_status>
  | Response<422, t_validation_error>
>

const reposGetDeploymentStatus = b((r) => ({
  with200: r.with200<t_deployment_status>(s_deployment_status),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetDeploymentStatus = (
  params: Params<t_ReposGetDeploymentStatusParamSchema, void, void, void>,
  respond: (typeof reposGetDeploymentStatus)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deployment_status>
  | Response<404, t_basic_error>
>

const reposCreateDispatchEvent = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateDispatchEvent = (
  params: Params<
    t_ReposCreateDispatchEventParamSchema,
    void,
    t_ReposCreateDispatchEventBodySchema,
    void
  >,
  respond: (typeof reposCreateDispatchEvent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetAllEnvironments = b((r) => ({
  with200: r.with200<{
    environments?: t_environment[]
    total_count?: number
  }>(
    z.object({
      total_count: z.coerce.number().optional(),
      environments: z.array(s_environment).optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposGetAllEnvironments = (
  params: Params<
    t_ReposGetAllEnvironmentsParamSchema,
    t_ReposGetAllEnvironmentsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetAllEnvironments)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        environments?: t_environment[]
        total_count?: number
      }
    >
>

const reposGetEnvironment = b((r) => ({
  with200: r.with200<t_environment>(s_environment),
  withStatus: r.withStatus,
}))

export type ReposGetEnvironment = (
  params: Params<t_ReposGetEnvironmentParamSchema, void, void, void>,
  respond: (typeof reposGetEnvironment)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_environment>>

const reposCreateOrUpdateEnvironment = b((r) => ({
  with200: r.with200<t_environment>(s_environment),
  with422: r.with422<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposCreateOrUpdateEnvironment = (
  params: Params<
    t_ReposCreateOrUpdateEnvironmentParamSchema,
    void,
    t_ReposCreateOrUpdateEnvironmentBodySchema | undefined,
    void
  >,
  respond: (typeof reposCreateOrUpdateEnvironment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_environment>
  | Response<422, t_basic_error>
>

const reposDeleteAnEnvironment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDeleteAnEnvironment = (
  params: Params<t_ReposDeleteAnEnvironmentParamSchema, void, void, void>,
  respond: (typeof reposDeleteAnEnvironment)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListDeploymentBranchPolicies = b((r) => ({
  with200: r.with200<{
    branch_policies: t_deployment_branch_policy[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      branch_policies: z.array(s_deployment_branch_policy),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposListDeploymentBranchPolicies = (
  params: Params<
    t_ReposListDeploymentBranchPoliciesParamSchema,
    t_ReposListDeploymentBranchPoliciesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListDeploymentBranchPolicies)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        branch_policies: t_deployment_branch_policy[]
        total_count: number
      }
    >
>

const reposCreateDeploymentBranchPolicy = b((r) => ({
  with200: r.with200<t_deployment_branch_policy>(s_deployment_branch_policy),
  with303: r.with303<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposCreateDeploymentBranchPolicy = (
  params: Params<
    t_ReposCreateDeploymentBranchPolicyParamSchema,
    void,
    t_ReposCreateDeploymentBranchPolicyBodySchema,
    void
  >,
  respond: (typeof reposCreateDeploymentBranchPolicy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deployment_branch_policy>
  | Response<303, void>
  | Response<404, void>
>

const reposGetDeploymentBranchPolicy = b((r) => ({
  with200: r.with200<t_deployment_branch_policy>(s_deployment_branch_policy),
  withStatus: r.withStatus,
}))

export type ReposGetDeploymentBranchPolicy = (
  params: Params<t_ReposGetDeploymentBranchPolicyParamSchema, void, void, void>,
  respond: (typeof reposGetDeploymentBranchPolicy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_deployment_branch_policy>
>

const reposUpdateDeploymentBranchPolicy = b((r) => ({
  with200: r.with200<t_deployment_branch_policy>(s_deployment_branch_policy),
  withStatus: r.withStatus,
}))

export type ReposUpdateDeploymentBranchPolicy = (
  params: Params<
    t_ReposUpdateDeploymentBranchPolicyParamSchema,
    void,
    t_ReposUpdateDeploymentBranchPolicyBodySchema,
    void
  >,
  respond: (typeof reposUpdateDeploymentBranchPolicy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_deployment_branch_policy>
>

const reposDeleteDeploymentBranchPolicy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDeleteDeploymentBranchPolicy = (
  params: Params<
    t_ReposDeleteDeploymentBranchPolicyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDeleteDeploymentBranchPolicy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposGetAllDeploymentProtectionRules = b((r) => ({
  with200: r.with200<{
    custom_deployment_protection_rules?: t_deployment_protection_rule[]
    total_count?: number
  }>(
    z.object({
      total_count: z.coerce.number().optional(),
      custom_deployment_protection_rules: z
        .array(s_deployment_protection_rule)
        .optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposGetAllDeploymentProtectionRules = (
  params: Params<
    t_ReposGetAllDeploymentProtectionRulesParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetAllDeploymentProtectionRules)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        custom_deployment_protection_rules?: t_deployment_protection_rule[]
        total_count?: number
      }
    >
>

const reposCreateDeploymentProtectionRule = b((r) => ({
  with201: r.with201<t_deployment_protection_rule>(
    s_deployment_protection_rule,
  ),
  withStatus: r.withStatus,
}))

export type ReposCreateDeploymentProtectionRule = (
  params: Params<
    t_ReposCreateDeploymentProtectionRuleParamSchema,
    void,
    t_ReposCreateDeploymentProtectionRuleBodySchema,
    void
  >,
  respond: (typeof reposCreateDeploymentProtectionRule)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_deployment_protection_rule>
>

const reposListCustomDeploymentRuleIntegrations = b((r) => ({
  with200: r.with200<{
    available_custom_deployment_protection_rule_integrations?: t_custom_deployment_rule_app[]
    total_count?: number
  }>(
    z.object({
      total_count: z.coerce.number().optional(),
      available_custom_deployment_protection_rule_integrations: z
        .array(s_custom_deployment_rule_app)
        .optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ReposListCustomDeploymentRuleIntegrations = (
  params: Params<
    t_ReposListCustomDeploymentRuleIntegrationsParamSchema,
    t_ReposListCustomDeploymentRuleIntegrationsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListCustomDeploymentRuleIntegrations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        available_custom_deployment_protection_rule_integrations?: t_custom_deployment_rule_app[]
        total_count?: number
      }
    >
>

const reposGetCustomDeploymentProtectionRule = b((r) => ({
  with200: r.with200<t_deployment_protection_rule>(
    s_deployment_protection_rule,
  ),
  withStatus: r.withStatus,
}))

export type ReposGetCustomDeploymentProtectionRule = (
  params: Params<
    t_ReposGetCustomDeploymentProtectionRuleParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposGetCustomDeploymentProtectionRule)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_deployment_protection_rule>
>

const reposDisableDeploymentProtectionRule = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDisableDeploymentProtectionRule = (
  params: Params<
    t_ReposDisableDeploymentProtectionRuleParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDisableDeploymentProtectionRule)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListEnvironmentSecrets = b((r) => ({
  with200: r.with200<{
    secrets: t_actions_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_actions_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListEnvironmentSecrets = (
  params: Params<
    t_ActionsListEnvironmentSecretsParamSchema,
    t_ActionsListEnvironmentSecretsQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListEnvironmentSecrets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_actions_secret[]
        total_count: number
      }
    >
>

const actionsGetEnvironmentPublicKey = b((r) => ({
  with200: r.with200<t_actions_public_key>(s_actions_public_key),
  withStatus: r.withStatus,
}))

export type ActionsGetEnvironmentPublicKey = (
  params: Params<t_ActionsGetEnvironmentPublicKeyParamSchema, void, void, void>,
  respond: (typeof actionsGetEnvironmentPublicKey)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_public_key>>

const actionsGetEnvironmentSecret = b((r) => ({
  with200: r.with200<t_actions_secret>(s_actions_secret),
  withStatus: r.withStatus,
}))

export type ActionsGetEnvironmentSecret = (
  params: Params<t_ActionsGetEnvironmentSecretParamSchema, void, void, void>,
  respond: (typeof actionsGetEnvironmentSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_secret>>

const actionsCreateOrUpdateEnvironmentSecret = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsCreateOrUpdateEnvironmentSecret = (
  params: Params<
    t_ActionsCreateOrUpdateEnvironmentSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateEnvironmentSecretBodySchema,
    void
  >,
  respond: (typeof actionsCreateOrUpdateEnvironmentSecret)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
>

const actionsDeleteEnvironmentSecret = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteEnvironmentSecret = (
  params: Params<t_ActionsDeleteEnvironmentSecretParamSchema, void, void, void>,
  respond: (typeof actionsDeleteEnvironmentSecret)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsListEnvironmentVariables = b((r) => ({
  with200: r.with200<{
    total_count: number
    variables: t_actions_variable[]
  }>(
    z.object({
      total_count: z.coerce.number(),
      variables: z.array(s_actions_variable),
    }),
  ),
  withStatus: r.withStatus,
}))

export type ActionsListEnvironmentVariables = (
  params: Params<
    t_ActionsListEnvironmentVariablesParamSchema,
    t_ActionsListEnvironmentVariablesQuerySchema,
    void,
    void
  >,
  respond: (typeof actionsListEnvironmentVariables)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        total_count: number
        variables: t_actions_variable[]
      }
    >
>

const actionsCreateEnvironmentVariable = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  withStatus: r.withStatus,
}))

export type ActionsCreateEnvironmentVariable = (
  params: Params<
    t_ActionsCreateEnvironmentVariableParamSchema,
    void,
    t_ActionsCreateEnvironmentVariableBodySchema,
    void
  >,
  respond: (typeof actionsCreateEnvironmentVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_empty_object>>

const actionsGetEnvironmentVariable = b((r) => ({
  with200: r.with200<t_actions_variable>(s_actions_variable),
  withStatus: r.withStatus,
}))

export type ActionsGetEnvironmentVariable = (
  params: Params<t_ActionsGetEnvironmentVariableParamSchema, void, void, void>,
  respond: (typeof actionsGetEnvironmentVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_actions_variable>>

const actionsUpdateEnvironmentVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsUpdateEnvironmentVariable = (
  params: Params<
    t_ActionsUpdateEnvironmentVariableParamSchema,
    void,
    t_ActionsUpdateEnvironmentVariableBodySchema,
    void
  >,
  respond: (typeof actionsUpdateEnvironmentVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const actionsDeleteEnvironmentVariable = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActionsDeleteEnvironmentVariable = (
  params: Params<
    t_ActionsDeleteEnvironmentVariableParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof actionsDeleteEnvironmentVariable)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const activityListRepoEvents = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  withStatus: r.withStatus,
}))

export type ActivityListRepoEvents = (
  params: Params<
    t_ActivityListRepoEventsParamSchema,
    t_ActivityListRepoEventsQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListRepoEvents)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_event[]>>

const reposListForks = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with400: r.with400<t_scim_error>(s_scim_error),
  withStatus: r.withStatus,
}))

export type ReposListForks = (
  params: Params<
    t_ReposListForksParamSchema,
    t_ReposListForksQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListForks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<400, t_scim_error>
>

const reposCreateFork = b((r) => ({
  with202: r.with202<t_full_repository>(s_full_repository),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateFork = (
  params: Params<
    t_ReposCreateForkParamSchema,
    void,
    t_ReposCreateForkBodySchema | undefined,
    void
  >,
  respond: (typeof reposCreateFork)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<202, t_full_repository>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const gitCreateBlob = b((r) => ({
  with201: r.with201<t_short_blob>(s_short_blob),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error | t_repository_rule_violation_error>(
    z.union([s_validation_error, s_repository_rule_violation_error]),
  ),
  withStatus: r.withStatus,
}))

export type GitCreateBlob = (
  params: Params<
    t_GitCreateBlobParamSchema,
    void,
    t_GitCreateBlobBodySchema,
    void
  >,
  respond: (typeof gitCreateBlob)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_short_blob>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error | t_repository_rule_violation_error>
>

const gitGetBlob = b((r) => ({
  with200: r.with200<t_blob>(s_blob),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GitGetBlob = (
  params: Params<t_GitGetBlobParamSchema, void, void, void>,
  respond: (typeof gitGetBlob)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_blob>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const gitCreateCommit = b((r) => ({
  with201: r.with201<t_git_commit>(s_git_commit),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GitCreateCommit = (
  params: Params<
    t_GitCreateCommitParamSchema,
    void,
    t_GitCreateCommitBodySchema,
    void
  >,
  respond: (typeof gitCreateCommit)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_git_commit>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const gitGetCommit = b((r) => ({
  with200: r.with200<t_git_commit>(s_git_commit),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GitGetCommit = (
  params: Params<t_GitGetCommitParamSchema, void, void, void>,
  respond: (typeof gitGetCommit)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_git_commit>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const gitListMatchingRefs = b((r) => ({
  with200: r.with200<t_git_ref[]>(z.array(s_git_ref)),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GitListMatchingRefs = (
  params: Params<t_GitListMatchingRefsParamSchema, void, void, void>,
  respond: (typeof gitListMatchingRefs)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_git_ref[]>
  | Response<409, t_basic_error>
>

const gitGetRef = b((r) => ({
  with200: r.with200<t_git_ref>(s_git_ref),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GitGetRef = (
  params: Params<t_GitGetRefParamSchema, void, void, void>,
  respond: (typeof gitGetRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_git_ref>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const gitCreateRef = b((r) => ({
  with201: r.with201<t_git_ref>(s_git_ref),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GitCreateRef = (
  params: Params<
    t_GitCreateRefParamSchema,
    void,
    t_GitCreateRefBodySchema,
    void
  >,
  respond: (typeof gitCreateRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_git_ref>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const gitUpdateRef = b((r) => ({
  with200: r.with200<t_git_ref>(s_git_ref),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GitUpdateRef = (
  params: Params<
    t_GitUpdateRefParamSchema,
    void,
    t_GitUpdateRefBodySchema,
    void
  >,
  respond: (typeof gitUpdateRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_git_ref>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const gitDeleteRef = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type GitDeleteRef = (
  params: Params<t_GitDeleteRefParamSchema, void, void, void>,
  respond: (typeof gitDeleteRef)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<409, t_basic_error>
  | Response<422, void>
>

const gitCreateTag = b((r) => ({
  with201: r.with201<t_git_tag>(s_git_tag),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GitCreateTag = (
  params: Params<
    t_GitCreateTagParamSchema,
    void,
    t_GitCreateTagBodySchema,
    void
  >,
  respond: (typeof gitCreateTag)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_git_tag>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const gitGetTag = b((r) => ({
  with200: r.with200<t_git_tag>(s_git_tag),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type GitGetTag = (
  params: Params<t_GitGetTagParamSchema, void, void, void>,
  respond: (typeof gitGetTag)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_git_tag>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const gitCreateTree = b((r) => ({
  with201: r.with201<t_git_tree>(s_git_tree),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GitCreateTree = (
  params: Params<
    t_GitCreateTreeParamSchema,
    void,
    t_GitCreateTreeBodySchema,
    void
  >,
  respond: (typeof gitCreateTree)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_git_tree>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const gitGetTree = b((r) => ({
  with200: r.with200<t_git_tree>(s_git_tree),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GitGetTree = (
  params: Params<t_GitGetTreeParamSchema, t_GitGetTreeQuerySchema, void, void>,
  respond: (typeof gitGetTree)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_git_tree>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const reposListWebhooks = b((r) => ({
  with200: r.with200<t_hook[]>(z.array(s_hook)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListWebhooks = (
  params: Params<
    t_ReposListWebhooksParamSchema,
    t_ReposListWebhooksQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListWebhooks)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook[]>
  | Response<404, t_basic_error>
>

const reposCreateWebhook = b((r) => ({
  with201: r.with201<t_hook>(s_hook),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateWebhook = (
  params: Params<
    t_ReposCreateWebhookParamSchema,
    void,
    t_ReposCreateWebhookBodySchema | undefined,
    void
  >,
  respond: (typeof reposCreateWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_hook>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetWebhook = b((r) => ({
  with200: r.with200<t_hook>(s_hook),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetWebhook = (
  params: Params<t_ReposGetWebhookParamSchema, void, void, void>,
  respond: (typeof reposGetWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook>
  | Response<404, t_basic_error>
>

const reposUpdateWebhook = b((r) => ({
  with200: r.with200<t_hook>(s_hook),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposUpdateWebhook = (
  params: Params<
    t_ReposUpdateWebhookParamSchema,
    void,
    t_ReposUpdateWebhookBodySchema,
    void
  >,
  respond: (typeof reposUpdateWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposDeleteWebhook = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteWebhook = (
  params: Params<t_ReposDeleteWebhookParamSchema, void, void, void>,
  respond: (typeof reposDeleteWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposGetWebhookConfigForRepo = b((r) => ({
  with200: r.with200<t_webhook_config>(s_webhook_config),
  withStatus: r.withStatus,
}))

export type ReposGetWebhookConfigForRepo = (
  params: Params<t_ReposGetWebhookConfigForRepoParamSchema, void, void, void>,
  respond: (typeof reposGetWebhookConfigForRepo)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_webhook_config>>

const reposUpdateWebhookConfigForRepo = b((r) => ({
  with200: r.with200<t_webhook_config>(s_webhook_config),
  withStatus: r.withStatus,
}))

export type ReposUpdateWebhookConfigForRepo = (
  params: Params<
    t_ReposUpdateWebhookConfigForRepoParamSchema,
    void,
    t_ReposUpdateWebhookConfigForRepoBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdateWebhookConfigForRepo)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_webhook_config>>

const reposListWebhookDeliveries = b((r) => ({
  with200: r.with200<t_hook_delivery_item[]>(z.array(s_hook_delivery_item)),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposListWebhookDeliveries = (
  params: Params<
    t_ReposListWebhookDeliveriesParamSchema,
    t_ReposListWebhookDeliveriesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListWebhookDeliveries)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook_delivery_item[]>
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const reposGetWebhookDelivery = b((r) => ({
  with200: r.with200<t_hook_delivery>(s_hook_delivery),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposGetWebhookDelivery = (
  params: Params<t_ReposGetWebhookDeliveryParamSchema, void, void, void>,
  respond: (typeof reposGetWebhookDelivery)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hook_delivery>
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const reposRedeliverWebhookDelivery = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with400: r.with400<t_scim_error>(s_scim_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposRedeliverWebhookDelivery = (
  params: Params<t_ReposRedeliverWebhookDeliveryParamSchema, void, void, void>,
  respond: (typeof reposRedeliverWebhookDelivery)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<400, t_scim_error>
  | Response<422, t_validation_error>
>

const reposPingWebhook = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposPingWebhook = (
  params: Params<t_ReposPingWebhookParamSchema, void, void, void>,
  respond: (typeof reposPingWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposTestPushWebhook = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposTestPushWebhook = (
  params: Params<t_ReposTestPushWebhookParamSchema, void, void, void>,
  respond: (typeof reposTestPushWebhook)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const migrationsGetImportStatus = b((r) => ({
  with200: r.with200<t_import>(s_import),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsGetImportStatus = (
  params: Params<t_MigrationsGetImportStatusParamSchema, void, void, void>,
  respond: (typeof migrationsGetImportStatus)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_import>
  | Response<404, t_basic_error>
  | Response<503, t_basic_error>
>

const migrationsStartImport = b((r) => ({
  with201: r.with201<t_import>(s_import),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsStartImport = (
  params: Params<
    t_MigrationsStartImportParamSchema,
    void,
    t_MigrationsStartImportBodySchema,
    void
  >,
  respond: (typeof migrationsStartImport)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_import>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<503, t_basic_error>
>

const migrationsUpdateImport = b((r) => ({
  with200: r.with200<t_import>(s_import),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsUpdateImport = (
  params: Params<
    t_MigrationsUpdateImportParamSchema,
    void,
    t_MigrationsUpdateImportBodySchema | undefined,
    void
  >,
  respond: (typeof migrationsUpdateImport)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_import>
  | Response<503, t_basic_error>
>

const migrationsCancelImport = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsCancelImport = (
  params: Params<t_MigrationsCancelImportParamSchema, void, void, void>,
  respond: (typeof migrationsCancelImport)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<503, t_basic_error>
>

const migrationsGetCommitAuthors = b((r) => ({
  with200: r.with200<t_porter_author[]>(z.array(s_porter_author)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsGetCommitAuthors = (
  params: Params<
    t_MigrationsGetCommitAuthorsParamSchema,
    t_MigrationsGetCommitAuthorsQuerySchema,
    void,
    void
  >,
  respond: (typeof migrationsGetCommitAuthors)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_porter_author[]>
  | Response<404, t_basic_error>
  | Response<503, t_basic_error>
>

const migrationsMapCommitAuthor = b((r) => ({
  with200: r.with200<t_porter_author>(s_porter_author),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsMapCommitAuthor = (
  params: Params<
    t_MigrationsMapCommitAuthorParamSchema,
    void,
    t_MigrationsMapCommitAuthorBodySchema | undefined,
    void
  >,
  respond: (typeof migrationsMapCommitAuthor)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_porter_author>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<503, t_basic_error>
>

const migrationsGetLargeFiles = b((r) => ({
  with200: r.with200<t_porter_large_file[]>(z.array(s_porter_large_file)),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsGetLargeFiles = (
  params: Params<t_MigrationsGetLargeFilesParamSchema, void, void, void>,
  respond: (typeof migrationsGetLargeFiles)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_porter_large_file[]>
  | Response<503, t_basic_error>
>

const migrationsSetLfsPreference = b((r) => ({
  with200: r.with200<t_import>(s_import),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsSetLfsPreference = (
  params: Params<
    t_MigrationsSetLfsPreferenceParamSchema,
    void,
    t_MigrationsSetLfsPreferenceBodySchema,
    void
  >,
  respond: (typeof migrationsSetLfsPreference)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_import>
  | Response<422, t_validation_error>
  | Response<503, t_basic_error>
>

const appsGetRepoInstallation = b((r) => ({
  with200: r.with200<t_installation>(s_installation),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsGetRepoInstallation = (
  params: Params<t_AppsGetRepoInstallationParamSchema, void, void, void>,
  respond: (typeof appsGetRepoInstallation)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_installation>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
>

const interactionsGetRestrictionsForRepo = b((r) => ({
  with200: r.with200<t_interaction_limit_response | EmptyObject>(
    z.union([s_interaction_limit_response, z.object({})]),
  ),
  withStatus: r.withStatus,
}))

export type InteractionsGetRestrictionsForRepo = (
  params: Params<
    t_InteractionsGetRestrictionsForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof interactionsGetRestrictionsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_interaction_limit_response | EmptyObject>
>

const interactionsSetRestrictionsForRepo = b((r) => ({
  with200: r.with200<t_interaction_limit_response>(
    s_interaction_limit_response,
  ),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type InteractionsSetRestrictionsForRepo = (
  params: Params<
    t_InteractionsSetRestrictionsForRepoParamSchema,
    void,
    t_InteractionsSetRestrictionsForRepoBodySchema,
    void
  >,
  respond: (typeof interactionsSetRestrictionsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_interaction_limit_response>
  | Response<409, void>
>

const interactionsRemoveRestrictionsForRepo = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type InteractionsRemoveRestrictionsForRepo = (
  params: Params<
    t_InteractionsRemoveRestrictionsForRepoParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof interactionsRemoveRestrictionsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<409, void>
>

const reposListInvitations = b((r) => ({
  with200: r.with200<t_repository_invitation[]>(
    z.array(s_repository_invitation),
  ),
  withStatus: r.withStatus,
}))

export type ReposListInvitations = (
  params: Params<
    t_ReposListInvitationsParamSchema,
    t_ReposListInvitationsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListInvitations)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_repository_invitation[]>
>

const reposUpdateInvitation = b((r) => ({
  with200: r.with200<t_repository_invitation>(s_repository_invitation),
  withStatus: r.withStatus,
}))

export type ReposUpdateInvitation = (
  params: Params<
    t_ReposUpdateInvitationParamSchema,
    void,
    t_ReposUpdateInvitationBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdateInvitation)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_repository_invitation>
>

const reposDeleteInvitation = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDeleteInvitation = (
  params: Params<t_ReposDeleteInvitationParamSchema, void, void, void>,
  respond: (typeof reposDeleteInvitation)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const issuesListForRepo = b((r) => ({
  with200: r.with200<t_issue[]>(z.array(s_issue)),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesListForRepo = (
  params: Params<
    t_IssuesListForRepoParamSchema,
    t_IssuesListForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue[]>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesCreate = b((r) => ({
  with201: r.with201<t_issue>(s_issue),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type IssuesCreate = (
  params: Params<
    t_IssuesCreateParamSchema,
    void,
    t_IssuesCreateBodySchema,
    void
  >,
  respond: (typeof issuesCreate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_issue>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const issuesListCommentsForRepo = b((r) => ({
  with200: r.with200<t_issue_comment[]>(z.array(s_issue_comment)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesListCommentsForRepo = (
  params: Params<
    t_IssuesListCommentsForRepoParamSchema,
    t_IssuesListCommentsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListCommentsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_comment[]>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesGetComment = b((r) => ({
  with200: r.with200<t_issue_comment>(s_issue_comment),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesGetComment = (
  params: Params<t_IssuesGetCommentParamSchema, void, void, void>,
  respond: (typeof issuesGetComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_comment>
  | Response<404, t_basic_error>
>

const issuesUpdateComment = b((r) => ({
  with200: r.with200<t_issue_comment>(s_issue_comment),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesUpdateComment = (
  params: Params<
    t_IssuesUpdateCommentParamSchema,
    void,
    t_IssuesUpdateCommentBodySchema,
    void
  >,
  respond: (typeof issuesUpdateComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_comment>
  | Response<422, t_validation_error>
>

const issuesDeleteComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type IssuesDeleteComment = (
  params: Params<t_IssuesDeleteCommentParamSchema, void, void, void>,
  respond: (typeof issuesDeleteComment)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reactionsListForIssueComment = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReactionsListForIssueComment = (
  params: Params<
    t_ReactionsListForIssueCommentParamSchema,
    t_ReactionsListForIssueCommentQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForIssueComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction[]>
  | Response<404, t_basic_error>
>

const reactionsCreateForIssueComment = b((r) => ({
  with200: r.with200<t_reaction>(s_reaction),
  with201: r.with201<t_reaction>(s_reaction),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForIssueComment = (
  params: Params<
    t_ReactionsCreateForIssueCommentParamSchema,
    void,
    t_ReactionsCreateForIssueCommentBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForIssueComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction>
  | Response<201, t_reaction>
  | Response<422, t_validation_error>
>

const reactionsDeleteForIssueComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReactionsDeleteForIssueComment = (
  params: Params<t_ReactionsDeleteForIssueCommentParamSchema, void, void, void>,
  respond: (typeof reactionsDeleteForIssueComment)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const issuesListEventsForRepo = b((r) => ({
  with200: r.with200<t_issue_event[]>(z.array(s_issue_event)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesListEventsForRepo = (
  params: Params<
    t_IssuesListEventsForRepoParamSchema,
    t_IssuesListEventsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListEventsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_event[]>
  | Response<422, t_validation_error>
>

const issuesGetEvent = b((r) => ({
  with200: r.with200<t_issue_event>(s_issue_event),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesGetEvent = (
  params: Params<t_IssuesGetEventParamSchema, void, void, void>,
  respond: (typeof issuesGetEvent)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_event>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const issuesGet = b((r) => ({
  with200: r.with200<t_issue>(s_issue),
  with301: r.with301<t_basic_error>(s_basic_error),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesGet = (
  params: Params<t_IssuesGetParamSchema, void, void, void>,
  respond: (typeof issuesGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue>
  | Response<301, t_basic_error>
  | Response<304, void>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const issuesUpdate = b((r) => ({
  with200: r.with200<t_issue>(s_issue),
  with301: r.with301<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type IssuesUpdate = (
  params: Params<
    t_IssuesUpdateParamSchema,
    void,
    t_IssuesUpdateBodySchema | undefined,
    void
  >,
  respond: (typeof issuesUpdate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue>
  | Response<301, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const issuesAddAssignees = b((r) => ({
  with201: r.with201<t_issue>(s_issue),
  withStatus: r.withStatus,
}))

export type IssuesAddAssignees = (
  params: Params<
    t_IssuesAddAssigneesParamSchema,
    void,
    t_IssuesAddAssigneesBodySchema | undefined,
    void
  >,
  respond: (typeof issuesAddAssignees)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_issue>>

const issuesRemoveAssignees = b((r) => ({
  with200: r.with200<t_issue>(s_issue),
  withStatus: r.withStatus,
}))

export type IssuesRemoveAssignees = (
  params: Params<
    t_IssuesRemoveAssigneesParamSchema,
    void,
    t_IssuesRemoveAssigneesBodySchema,
    void
  >,
  respond: (typeof issuesRemoveAssignees)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_issue>>

const issuesCheckUserCanBeAssignedToIssue = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesCheckUserCanBeAssignedToIssue = (
  params: Params<
    t_IssuesCheckUserCanBeAssignedToIssueParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof issuesCheckUserCanBeAssignedToIssue)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const issuesListComments = b((r) => ({
  with200: r.with200<t_issue_comment[]>(z.array(s_issue_comment)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListComments = (
  params: Params<
    t_IssuesListCommentsParamSchema,
    t_IssuesListCommentsQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListComments)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_comment[]>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const issuesCreateComment = b((r) => ({
  with201: r.with201<t_issue_comment>(s_issue_comment),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesCreateComment = (
  params: Params<
    t_IssuesCreateCommentParamSchema,
    void,
    t_IssuesCreateCommentBodySchema,
    void
  >,
  respond: (typeof issuesCreateComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_issue_comment>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesListEvents = b((r) => ({
  with200: r.with200<t_issue_event_for_issue[]>(
    z.array(s_issue_event_for_issue),
  ),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListEvents = (
  params: Params<
    t_IssuesListEventsParamSchema,
    t_IssuesListEventsQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListEvents)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue_event_for_issue[]>
  | Response<410, t_basic_error>
>

const issuesListLabelsOnIssue = b((r) => ({
  with200: r.with200<t_label[]>(z.array(s_label)),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListLabelsOnIssue = (
  params: Params<
    t_IssuesListLabelsOnIssueParamSchema,
    t_IssuesListLabelsOnIssueQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListLabelsOnIssue)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_label[]>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const issuesAddLabels = b((r) => ({
  with200: r.with200<t_label[]>(z.array(s_label)),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesAddLabels = (
  params: Params<
    t_IssuesAddLabelsParamSchema,
    void,
    t_IssuesAddLabelsBodySchema | undefined,
    void
  >,
  respond: (typeof issuesAddLabels)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_label[]>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesSetLabels = b((r) => ({
  with200: r.with200<t_label[]>(z.array(s_label)),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesSetLabels = (
  params: Params<
    t_IssuesSetLabelsParamSchema,
    void,
    t_IssuesSetLabelsBodySchema | undefined,
    void
  >,
  respond: (typeof issuesSetLabels)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_label[]>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesRemoveAllLabels = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesRemoveAllLabels = (
  params: Params<t_IssuesRemoveAllLabelsParamSchema, void, void, void>,
  respond: (typeof issuesRemoveAllLabels)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const issuesRemoveLabel = b((r) => ({
  with200: r.with200<t_label[]>(z.array(s_label)),
  with301: r.with301<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesRemoveLabel = (
  params: Params<t_IssuesRemoveLabelParamSchema, void, void, void>,
  respond: (typeof issuesRemoveLabel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_label[]>
  | Response<301, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const issuesLock = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesLock = (
  params: Params<
    t_IssuesLockParamSchema,
    void,
    t_IssuesLockBodySchema | undefined,
    void
  >,
  respond: (typeof issuesLock)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesUnlock = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesUnlock = (
  params: Params<t_IssuesUnlockParamSchema, void, void, void>,
  respond: (typeof issuesUnlock)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reactionsListForIssue = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReactionsListForIssue = (
  params: Params<
    t_ReactionsListForIssueParamSchema,
    t_ReactionsListForIssueQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForIssue)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction[]>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const reactionsCreateForIssue = b((r) => ({
  with200: r.with200<t_reaction>(s_reaction),
  with201: r.with201<t_reaction>(s_reaction),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForIssue = (
  params: Params<
    t_ReactionsCreateForIssueParamSchema,
    void,
    t_ReactionsCreateForIssueBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForIssue)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction>
  | Response<201, t_reaction>
  | Response<422, t_validation_error>
>

const reactionsDeleteForIssue = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReactionsDeleteForIssue = (
  params: Params<t_ReactionsDeleteForIssueParamSchema, void, void, void>,
  respond: (typeof reactionsDeleteForIssue)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const issuesRemoveSubIssue = b((r) => ({
  with200: r.with200<t_issue>(s_issue),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesRemoveSubIssue = (
  params: Params<
    t_IssuesRemoveSubIssueParamSchema,
    void,
    t_IssuesRemoveSubIssueBodySchema,
    void
  >,
  respond: (typeof issuesRemoveSubIssue)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
>

const issuesListSubIssues = b((r) => ({
  with200: r.with200<t_issue[]>(z.array(s_issue)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListSubIssues = (
  params: Params<
    t_IssuesListSubIssuesParamSchema,
    t_IssuesListSubIssuesQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListSubIssues)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue[]>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const issuesAddSubIssue = b((r) => ({
  with201: r.with201<t_issue>(s_issue),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesAddSubIssue = (
  params: Params<
    t_IssuesAddSubIssueParamSchema,
    void,
    t_IssuesAddSubIssueBodySchema,
    void
  >,
  respond: (typeof issuesAddSubIssue)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_issue>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesReprioritizeSubIssue = b((r) => ({
  with200: r.with200<t_issue>(s_issue),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type IssuesReprioritizeSubIssue = (
  params: Params<
    t_IssuesReprioritizeSubIssueParamSchema,
    void,
    t_IssuesReprioritizeSubIssueBodySchema,
    void
  >,
  respond: (typeof issuesReprioritizeSubIssue)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const issuesListEventsForTimeline = b((r) => ({
  with200: r.with200<t_timeline_issue_events[]>(
    z.array(s_timeline_issue_events),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListEventsForTimeline = (
  params: Params<
    t_IssuesListEventsForTimelineParamSchema,
    t_IssuesListEventsForTimelineQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListEventsForTimeline)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_timeline_issue_events[]>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
>

const reposListDeployKeys = b((r) => ({
  with200: r.with200<t_deploy_key[]>(z.array(s_deploy_key)),
  withStatus: r.withStatus,
}))

export type ReposListDeployKeys = (
  params: Params<
    t_ReposListDeployKeysParamSchema,
    t_ReposListDeployKeysQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListDeployKeys)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_deploy_key[]>>

const reposCreateDeployKey = b((r) => ({
  with201: r.with201<t_deploy_key>(s_deploy_key),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateDeployKey = (
  params: Params<
    t_ReposCreateDeployKeyParamSchema,
    void,
    t_ReposCreateDeployKeyBodySchema,
    void
  >,
  respond: (typeof reposCreateDeployKey)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_deploy_key>
  | Response<422, t_validation_error>
>

const reposGetDeployKey = b((r) => ({
  with200: r.with200<t_deploy_key>(s_deploy_key),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetDeployKey = (
  params: Params<t_ReposGetDeployKeyParamSchema, void, void, void>,
  respond: (typeof reposGetDeployKey)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_deploy_key>
  | Response<404, t_basic_error>
>

const reposDeleteDeployKey = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDeleteDeployKey = (
  params: Params<t_ReposDeleteDeployKeyParamSchema, void, void, void>,
  respond: (typeof reposDeleteDeployKey)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const issuesListLabelsForRepo = b((r) => ({
  with200: r.with200<t_label[]>(z.array(s_label)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListLabelsForRepo = (
  params: Params<
    t_IssuesListLabelsForRepoParamSchema,
    t_IssuesListLabelsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListLabelsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_label[]>
  | Response<404, t_basic_error>
>

const issuesCreateLabel = b((r) => ({
  with201: r.with201<t_label>(s_label),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesCreateLabel = (
  params: Params<
    t_IssuesCreateLabelParamSchema,
    void,
    t_IssuesCreateLabelBodySchema,
    void
  >,
  respond: (typeof issuesCreateLabel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_label>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesGetLabel = b((r) => ({
  with200: r.with200<t_label>(s_label),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesGetLabel = (
  params: Params<t_IssuesGetLabelParamSchema, void, void, void>,
  respond: (typeof issuesGetLabel)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_label>
  | Response<404, t_basic_error>
>

const issuesUpdateLabel = b((r) => ({
  with200: r.with200<t_label>(s_label),
  withStatus: r.withStatus,
}))

export type IssuesUpdateLabel = (
  params: Params<
    t_IssuesUpdateLabelParamSchema,
    void,
    t_IssuesUpdateLabelBodySchema | undefined,
    void
  >,
  respond: (typeof issuesUpdateLabel)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_label>>

const issuesDeleteLabel = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type IssuesDeleteLabel = (
  params: Params<t_IssuesDeleteLabelParamSchema, void, void, void>,
  respond: (typeof issuesDeleteLabel)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListLanguages = b((r) => ({
  with200: r.with200<t_language>(s_language),
  withStatus: r.withStatus,
}))

export type ReposListLanguages = (
  params: Params<t_ReposListLanguagesParamSchema, void, void, void>,
  respond: (typeof reposListLanguages)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_language>>

const licensesGetForRepo = b((r) => ({
  with200: r.with200<t_license_content>(s_license_content),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type LicensesGetForRepo = (
  params: Params<
    t_LicensesGetForRepoParamSchema,
    t_LicensesGetForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof licensesGetForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_license_content>
  | Response<404, t_basic_error>
>

const reposMergeUpstream = b((r) => ({
  with200: r.with200<t_merged_upstream>(s_merged_upstream),
  with409: r.with409<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposMergeUpstream = (
  params: Params<
    t_ReposMergeUpstreamParamSchema,
    void,
    t_ReposMergeUpstreamBodySchema,
    void
  >,
  respond: (typeof reposMergeUpstream)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_merged_upstream>
  | Response<409, void>
  | Response<422, void>
>

const reposMerge = b((r) => ({
  with201: r.with201<t_commit>(s_commit),
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<void>(z.undefined()),
  with409: r.with409<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposMerge = (
  params: Params<t_ReposMergeParamSchema, void, t_ReposMergeBodySchema, void>,
  respond: (typeof reposMerge)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_commit>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, void>
  | Response<409, void>
  | Response<422, t_validation_error>
>

const issuesListMilestones = b((r) => ({
  with200: r.with200<t_milestone[]>(z.array(s_milestone)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListMilestones = (
  params: Params<
    t_IssuesListMilestonesParamSchema,
    t_IssuesListMilestonesQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListMilestones)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_milestone[]>
  | Response<404, t_basic_error>
>

const issuesCreateMilestone = b((r) => ({
  with201: r.with201<t_milestone>(s_milestone),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type IssuesCreateMilestone = (
  params: Params<
    t_IssuesCreateMilestoneParamSchema,
    void,
    t_IssuesCreateMilestoneBodySchema,
    void
  >,
  respond: (typeof issuesCreateMilestone)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_milestone>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const issuesGetMilestone = b((r) => ({
  with200: r.with200<t_milestone>(s_milestone),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesGetMilestone = (
  params: Params<t_IssuesGetMilestoneParamSchema, void, void, void>,
  respond: (typeof issuesGetMilestone)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_milestone>
  | Response<404, t_basic_error>
>

const issuesUpdateMilestone = b((r) => ({
  with200: r.with200<t_milestone>(s_milestone),
  withStatus: r.withStatus,
}))

export type IssuesUpdateMilestone = (
  params: Params<
    t_IssuesUpdateMilestoneParamSchema,
    void,
    t_IssuesUpdateMilestoneBodySchema | undefined,
    void
  >,
  respond: (typeof issuesUpdateMilestone)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_milestone>>

const issuesDeleteMilestone = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesDeleteMilestone = (
  params: Params<t_IssuesDeleteMilestoneParamSchema, void, void, void>,
  respond: (typeof issuesDeleteMilestone)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const issuesListLabelsForMilestone = b((r) => ({
  with200: r.with200<t_label[]>(z.array(s_label)),
  withStatus: r.withStatus,
}))

export type IssuesListLabelsForMilestone = (
  params: Params<
    t_IssuesListLabelsForMilestoneParamSchema,
    t_IssuesListLabelsForMilestoneQuerySchema,
    void,
    void
  >,
  respond: (typeof issuesListLabelsForMilestone)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_label[]>>

const activityListRepoNotificationsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_thread[]>(z.array(s_thread)),
  withStatus: r.withStatus,
}))

export type ActivityListRepoNotificationsForAuthenticatedUser = (
  params: Params<
    t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema,
    t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListRepoNotificationsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_thread[]>>

const activityMarkRepoNotificationsAsRead = b((r) => ({
  with202: r.with202<{
    message?: string
    url?: string
  }>(z.object({ message: z.string().optional(), url: z.string().optional() })),
  with205: r.with205<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActivityMarkRepoNotificationsAsRead = (
  params: Params<
    t_ActivityMarkRepoNotificationsAsReadParamSchema,
    void,
    t_ActivityMarkRepoNotificationsAsReadBodySchema | undefined,
    void
  >,
  respond: (typeof activityMarkRepoNotificationsAsRead)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        message?: string
        url?: string
      }
    >
  | Response<205, void>
>

const reposGetPages = b((r) => ({
  with200: r.with200<t_page>(s_page),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetPages = (
  params: Params<t_ReposGetPagesParamSchema, void, void, void>,
  respond: (typeof reposGetPages)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_page>
  | Response<404, t_basic_error>
>

const reposCreatePagesSite = b((r) => ({
  with201: r.with201<t_page>(s_page),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreatePagesSite = (
  params: Params<
    t_ReposCreatePagesSiteParamSchema,
    void,
    t_ReposCreatePagesSiteBodySchema,
    void
  >,
  respond: (typeof reposCreatePagesSite)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_page>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const reposUpdateInformationAboutPagesSite = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposUpdateInformationAboutPagesSite = (
  params: Params<
    t_ReposUpdateInformationAboutPagesSiteParamSchema,
    void,
    t_ReposUpdateInformationAboutPagesSiteBodySchema,
    void
  >,
  respond: (typeof reposUpdateInformationAboutPagesSite)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<400, t_scim_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const reposDeletePagesSite = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposDeletePagesSite = (
  params: Params<t_ReposDeletePagesSiteParamSchema, void, void, void>,
  respond: (typeof reposDeletePagesSite)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<422, t_validation_error>
>

const reposListPagesBuilds = b((r) => ({
  with200: r.with200<t_page_build[]>(z.array(s_page_build)),
  withStatus: r.withStatus,
}))

export type ReposListPagesBuilds = (
  params: Params<
    t_ReposListPagesBuildsParamSchema,
    t_ReposListPagesBuildsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListPagesBuilds)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_page_build[]>>

const reposRequestPagesBuild = b((r) => ({
  with201: r.with201<t_page_build_status>(s_page_build_status),
  withStatus: r.withStatus,
}))

export type ReposRequestPagesBuild = (
  params: Params<t_ReposRequestPagesBuildParamSchema, void, void, void>,
  respond: (typeof reposRequestPagesBuild)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_page_build_status>>

const reposGetLatestPagesBuild = b((r) => ({
  with200: r.with200<t_page_build>(s_page_build),
  withStatus: r.withStatus,
}))

export type ReposGetLatestPagesBuild = (
  params: Params<t_ReposGetLatestPagesBuildParamSchema, void, void, void>,
  respond: (typeof reposGetLatestPagesBuild)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_page_build>>

const reposGetPagesBuild = b((r) => ({
  with200: r.with200<t_page_build>(s_page_build),
  withStatus: r.withStatus,
}))

export type ReposGetPagesBuild = (
  params: Params<t_ReposGetPagesBuildParamSchema, void, void, void>,
  respond: (typeof reposGetPagesBuild)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_page_build>>

const reposCreatePagesDeployment = b((r) => ({
  with200: r.with200<t_page_deployment>(s_page_deployment),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreatePagesDeployment = (
  params: Params<
    t_ReposCreatePagesDeploymentParamSchema,
    void,
    t_ReposCreatePagesDeploymentBodySchema,
    void
  >,
  respond: (typeof reposCreatePagesDeployment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_page_deployment>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetPagesDeployment = b((r) => ({
  with200: r.with200<t_pages_deployment_status>(s_pages_deployment_status),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetPagesDeployment = (
  params: Params<t_ReposGetPagesDeploymentParamSchema, void, void, void>,
  respond: (typeof reposGetPagesDeployment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pages_deployment_status>
  | Response<404, t_basic_error>
>

const reposCancelPagesDeployment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposCancelPagesDeployment = (
  params: Params<t_ReposCancelPagesDeploymentParamSchema, void, void, void>,
  respond: (typeof reposCancelPagesDeployment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reposGetPagesHealthCheck = b((r) => ({
  with200: r.with200<t_pages_health_check>(s_pages_health_check),
  with202: r.with202<t_empty_object>(s_empty_object),
  with400: r.with400<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposGetPagesHealthCheck = (
  params: Params<t_ReposGetPagesHealthCheckParamSchema, void, void, void>,
  respond: (typeof reposGetPagesHealthCheck)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pages_health_check>
  | Response<202, t_empty_object>
  | Response<400, void>
  | Response<404, t_basic_error>
  | Response<422, void>
>

const reposCheckPrivateVulnerabilityReporting = b((r) => ({
  with200: r.with200<{
    enabled: boolean
  }>(z.object({ enabled: PermissiveBoolean })),
  with422: r.with422<t_scim_error>(s_scim_error),
  withStatus: r.withStatus,
}))

export type ReposCheckPrivateVulnerabilityReporting = (
  params: Params<
    t_ReposCheckPrivateVulnerabilityReportingParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposCheckPrivateVulnerabilityReporting)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        enabled: boolean
      }
    >
  | Response<422, t_scim_error>
>

const reposEnablePrivateVulnerabilityReporting = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<t_scim_error>(s_scim_error),
  withStatus: r.withStatus,
}))

export type ReposEnablePrivateVulnerabilityReporting = (
  params: Params<
    t_ReposEnablePrivateVulnerabilityReportingParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposEnablePrivateVulnerabilityReporting)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<422, t_scim_error>
>

const reposDisablePrivateVulnerabilityReporting = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<t_scim_error>(s_scim_error),
  withStatus: r.withStatus,
}))

export type ReposDisablePrivateVulnerabilityReporting = (
  params: Params<
    t_ReposDisablePrivateVulnerabilityReportingParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDisablePrivateVulnerabilityReporting)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<422, t_scim_error>
>

const projectsListForRepo = b((r) => ({
  with200: r.with200<t_project[]>(z.array(s_project)),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsListForRepo = (
  params: Params<
    t_ProjectsListForRepoParamSchema,
    t_ProjectsListForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof projectsListForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project[]>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const projectsCreateForRepo = b((r) => ({
  with201: r.with201<t_project>(s_project),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with410: r.with410<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsCreateForRepo = (
  params: Params<
    t_ProjectsCreateForRepoParamSchema,
    void,
    t_ProjectsCreateForRepoBodySchema,
    void
  >,
  respond: (typeof projectsCreateForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_project>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<410, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const reposGetCustomPropertiesValues = b((r) => ({
  with200: r.with200<t_custom_property_value[]>(
    z.array(s_custom_property_value),
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetCustomPropertiesValues = (
  params: Params<t_ReposGetCustomPropertiesValuesParamSchema, void, void, void>,
  respond: (typeof reposGetCustomPropertiesValues)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_custom_property_value[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposCreateOrUpdateCustomPropertiesValues = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateOrUpdateCustomPropertiesValues = (
  params: Params<
    t_ReposCreateOrUpdateCustomPropertiesValuesParamSchema,
    void,
    t_ReposCreateOrUpdateCustomPropertiesValuesBodySchema,
    void
  >,
  respond: (typeof reposCreateOrUpdateCustomPropertiesValues)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const pullsList = b((r) => ({
  with200: r.with200<t_pull_request_simple[]>(z.array(s_pull_request_simple)),
  with304: r.with304<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PullsList = (
  params: Params<t_PullsListParamSchema, t_PullsListQuerySchema, void, void>,
  respond: (typeof pullsList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_simple[]>
  | Response<304, void>
  | Response<422, t_validation_error>
>

const pullsCreate = b((r) => ({
  with201: r.with201<t_pull_request>(s_pull_request),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PullsCreate = (
  params: Params<t_PullsCreateParamSchema, void, t_PullsCreateBodySchema, void>,
  respond: (typeof pullsCreate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_pull_request>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const pullsListReviewCommentsForRepo = b((r) => ({
  with200: r.with200<t_pull_request_review_comment[]>(
    z.array(s_pull_request_review_comment),
  ),
  withStatus: r.withStatus,
}))

export type PullsListReviewCommentsForRepo = (
  params: Params<
    t_PullsListReviewCommentsForRepoParamSchema,
    t_PullsListReviewCommentsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof pullsListReviewCommentsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_pull_request_review_comment[]>
>

const pullsGetReviewComment = b((r) => ({
  with200: r.with200<t_pull_request_review_comment>(
    s_pull_request_review_comment,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PullsGetReviewComment = (
  params: Params<t_PullsGetReviewCommentParamSchema, void, void, void>,
  respond: (typeof pullsGetReviewComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_review_comment>
  | Response<404, t_basic_error>
>

const pullsUpdateReviewComment = b((r) => ({
  with200: r.with200<t_pull_request_review_comment>(
    s_pull_request_review_comment,
  ),
  withStatus: r.withStatus,
}))

export type PullsUpdateReviewComment = (
  params: Params<
    t_PullsUpdateReviewCommentParamSchema,
    void,
    t_PullsUpdateReviewCommentBodySchema,
    void
  >,
  respond: (typeof pullsUpdateReviewComment)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_pull_request_review_comment>
>

const pullsDeleteReviewComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PullsDeleteReviewComment = (
  params: Params<t_PullsDeleteReviewCommentParamSchema, void, void, void>,
  respond: (typeof pullsDeleteReviewComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const reactionsListForPullRequestReviewComment = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReactionsListForPullRequestReviewComment = (
  params: Params<
    t_ReactionsListForPullRequestReviewCommentParamSchema,
    t_ReactionsListForPullRequestReviewCommentQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForPullRequestReviewComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction[]>
  | Response<404, t_basic_error>
>

const reactionsCreateForPullRequestReviewComment = b((r) => ({
  with200: r.with200<t_reaction>(s_reaction),
  with201: r.with201<t_reaction>(s_reaction),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForPullRequestReviewComment = (
  params: Params<
    t_ReactionsCreateForPullRequestReviewCommentParamSchema,
    void,
    t_ReactionsCreateForPullRequestReviewCommentBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForPullRequestReviewComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction>
  | Response<201, t_reaction>
  | Response<422, t_validation_error>
>

const reactionsDeleteForPullRequestComment = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReactionsDeleteForPullRequestComment = (
  params: Params<
    t_ReactionsDeleteForPullRequestCommentParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reactionsDeleteForPullRequestComment)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const pullsGet = b((r) => ({
  with200: r.with200<t_pull_request>(s_pull_request),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with406: r.with406<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type PullsGet = (
  params: Params<t_PullsGetParamSchema, void, void, void>,
  respond: (typeof pullsGet)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request>
  | Response<304, void>
  | Response<404, t_basic_error>
  | Response<406, t_basic_error>
  | Response<500, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const pullsUpdate = b((r) => ({
  with200: r.with200<t_pull_request>(s_pull_request),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PullsUpdate = (
  params: Params<
    t_PullsUpdateParamSchema,
    void,
    t_PullsUpdateBodySchema | undefined,
    void
  >,
  respond: (typeof pullsUpdate)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const codespacesCreateWithPrForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_codespace>(s_codespace),
  with202: r.with202<t_codespace>(s_codespace),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodespacesCreateWithPrForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateWithPrForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateWithPrForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof codespacesCreateWithPrForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_codespace>
  | Response<202, t_codespace>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const pullsListReviewComments = b((r) => ({
  with200: r.with200<t_pull_request_review_comment[]>(
    z.array(s_pull_request_review_comment),
  ),
  withStatus: r.withStatus,
}))

export type PullsListReviewComments = (
  params: Params<
    t_PullsListReviewCommentsParamSchema,
    t_PullsListReviewCommentsQuerySchema,
    void,
    void
  >,
  respond: (typeof pullsListReviewComments)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_pull_request_review_comment[]>
>

const pullsCreateReviewComment = b((r) => ({
  with201: r.with201<t_pull_request_review_comment>(
    s_pull_request_review_comment,
  ),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PullsCreateReviewComment = (
  params: Params<
    t_PullsCreateReviewCommentParamSchema,
    void,
    t_PullsCreateReviewCommentBodySchema,
    void
  >,
  respond: (typeof pullsCreateReviewComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_pull_request_review_comment>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const pullsCreateReplyForReviewComment = b((r) => ({
  with201: r.with201<t_pull_request_review_comment>(
    s_pull_request_review_comment,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PullsCreateReplyForReviewComment = (
  params: Params<
    t_PullsCreateReplyForReviewCommentParamSchema,
    void,
    t_PullsCreateReplyForReviewCommentBodySchema,
    void
  >,
  respond: (typeof pullsCreateReplyForReviewComment)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_pull_request_review_comment>
  | Response<404, t_basic_error>
>

const pullsListCommits = b((r) => ({
  with200: r.with200<t_commit[]>(z.array(s_commit)),
  withStatus: r.withStatus,
}))

export type PullsListCommits = (
  params: Params<
    t_PullsListCommitsParamSchema,
    t_PullsListCommitsQuerySchema,
    void,
    void
  >,
  respond: (typeof pullsListCommits)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_commit[]>>

const pullsListFiles = b((r) => ({
  with200: r.with200<t_diff_entry[]>(z.array(s_diff_entry)),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type PullsListFiles = (
  params: Params<
    t_PullsListFilesParamSchema,
    t_PullsListFilesQuerySchema,
    void,
    void
  >,
  respond: (typeof pullsListFiles)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_diff_entry[]>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const pullsCheckIfMerged = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type PullsCheckIfMerged = (
  params: Params<t_PullsCheckIfMergedParamSchema, void, void, void>,
  respond: (typeof pullsCheckIfMerged)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<404, void>
>

const pullsMerge = b((r) => ({
  with200: r.with200<t_pull_request_merge_result>(s_pull_request_merge_result),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with405: r.with405<{
    documentation_url?: string
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  with409: r.with409<{
    documentation_url?: string
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PullsMerge = (
  params: Params<
    t_PullsMergeParamSchema,
    void,
    t_PullsMergeBodySchema | undefined,
    void
  >,
  respond: (typeof pullsMerge)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_merge_result>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      405,
      {
        documentation_url?: string
        message?: string
      }
    >
  | Response<
      409,
      {
        documentation_url?: string
        message?: string
      }
    >
  | Response<422, t_validation_error>
>

const pullsListRequestedReviewers = b((r) => ({
  with200: r.with200<t_pull_request_review_request>(
    s_pull_request_review_request,
  ),
  withStatus: r.withStatus,
}))

export type PullsListRequestedReviewers = (
  params: Params<t_PullsListRequestedReviewersParamSchema, void, void, void>,
  respond: (typeof pullsListRequestedReviewers)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_pull_request_review_request>
>

const pullsRequestReviewers = b((r) => ({
  with201: r.with201<t_pull_request_simple>(s_pull_request_simple),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type PullsRequestReviewers = (
  params: Params<
    t_PullsRequestReviewersParamSchema,
    void,
    t_PullsRequestReviewersBodySchema | undefined,
    void
  >,
  respond: (typeof pullsRequestReviewers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_pull_request_simple>
  | Response<403, t_basic_error>
  | Response<422, void>
>

const pullsRemoveRequestedReviewers = b((r) => ({
  with200: r.with200<t_pull_request_simple>(s_pull_request_simple),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PullsRemoveRequestedReviewers = (
  params: Params<
    t_PullsRemoveRequestedReviewersParamSchema,
    void,
    t_PullsRemoveRequestedReviewersBodySchema,
    void
  >,
  respond: (typeof pullsRemoveRequestedReviewers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_simple>
  | Response<422, t_validation_error>
>

const pullsListReviews = b((r) => ({
  with200: r.with200<t_pull_request_review[]>(z.array(s_pull_request_review)),
  withStatus: r.withStatus,
}))

export type PullsListReviews = (
  params: Params<
    t_PullsListReviewsParamSchema,
    t_PullsListReviewsQuerySchema,
    void,
    void
  >,
  respond: (typeof pullsListReviews)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_pull_request_review[]>
>

const pullsCreateReview = b((r) => ({
  with200: r.with200<t_pull_request_review>(s_pull_request_review),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type PullsCreateReview = (
  params: Params<
    t_PullsCreateReviewParamSchema,
    void,
    t_PullsCreateReviewBodySchema | undefined,
    void
  >,
  respond: (typeof pullsCreateReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_review>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const pullsGetReview = b((r) => ({
  with200: r.with200<t_pull_request_review>(s_pull_request_review),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PullsGetReview = (
  params: Params<t_PullsGetReviewParamSchema, void, void, void>,
  respond: (typeof pullsGetReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_review>
  | Response<404, t_basic_error>
>

const pullsUpdateReview = b((r) => ({
  with200: r.with200<t_pull_request_review>(s_pull_request_review),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type PullsUpdateReview = (
  params: Params<
    t_PullsUpdateReviewParamSchema,
    void,
    t_PullsUpdateReviewBodySchema,
    void
  >,
  respond: (typeof pullsUpdateReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_review>
  | Response<422, t_validation_error_simple>
>

const pullsDeletePendingReview = b((r) => ({
  with200: r.with200<t_pull_request_review>(s_pull_request_review),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type PullsDeletePendingReview = (
  params: Params<t_PullsDeletePendingReviewParamSchema, void, void, void>,
  respond: (typeof pullsDeletePendingReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_review>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const pullsListCommentsForReview = b((r) => ({
  with200: r.with200<t_review_comment[]>(z.array(s_review_comment)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PullsListCommentsForReview = (
  params: Params<
    t_PullsListCommentsForReviewParamSchema,
    t_PullsListCommentsForReviewQuerySchema,
    void,
    void
  >,
  respond: (typeof pullsListCommentsForReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_review_comment[]>
  | Response<404, t_basic_error>
>

const pullsDismissReview = b((r) => ({
  with200: r.with200<t_pull_request_review>(s_pull_request_review),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type PullsDismissReview = (
  params: Params<
    t_PullsDismissReviewParamSchema,
    void,
    t_PullsDismissReviewBodySchema,
    void
  >,
  respond: (typeof pullsDismissReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_review>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const pullsSubmitReview = b((r) => ({
  with200: r.with200<t_pull_request_review>(s_pull_request_review),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type PullsSubmitReview = (
  params: Params<
    t_PullsSubmitReviewParamSchema,
    void,
    t_PullsSubmitReviewBodySchema,
    void
  >,
  respond: (typeof pullsSubmitReview)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_pull_request_review>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const pullsUpdateBranch = b((r) => ({
  with202: r.with202<{
    message?: string
    url?: string
  }>(z.object({ message: z.string().optional(), url: z.string().optional() })),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type PullsUpdateBranch = (
  params: Params<
    t_PullsUpdateBranchParamSchema,
    void,
    t_PullsUpdateBranchBodySchema | undefined,
    void
  >,
  respond: (typeof pullsUpdateBranch)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        message?: string
        url?: string
      }
    >
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetReadme = b((r) => ({
  with200: r.with200<t_content_file>(s_content_file),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposGetReadme = (
  params: Params<
    t_ReposGetReadmeParamSchema,
    t_ReposGetReadmeQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetReadme)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_content_file>
  | Response<304, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetReadmeInDirectory = b((r) => ({
  with200: r.with200<t_content_file>(s_content_file),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposGetReadmeInDirectory = (
  params: Params<
    t_ReposGetReadmeInDirectoryParamSchema,
    t_ReposGetReadmeInDirectoryQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetReadmeInDirectory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_content_file>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposListReleases = b((r) => ({
  with200: r.with200<t_release[]>(z.array(s_release)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListReleases = (
  params: Params<
    t_ReposListReleasesParamSchema,
    t_ReposListReleasesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListReleases)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_release[]>
  | Response<404, t_basic_error>
>

const reposCreateRelease = b((r) => ({
  with201: r.with201<t_release>(s_release),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateRelease = (
  params: Params<
    t_ReposCreateReleaseParamSchema,
    void,
    t_ReposCreateReleaseBodySchema,
    void
  >,
  respond: (typeof reposCreateRelease)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_release>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposGetReleaseAsset = b((r) => ({
  with200: r.with200<t_release_asset>(s_release_asset),
  with302: r.with302<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetReleaseAsset = (
  params: Params<t_ReposGetReleaseAssetParamSchema, void, void, void>,
  respond: (typeof reposGetReleaseAsset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_release_asset>
  | Response<302, void>
  | Response<404, t_basic_error>
>

const reposUpdateReleaseAsset = b((r) => ({
  with200: r.with200<t_release_asset>(s_release_asset),
  withStatus: r.withStatus,
}))

export type ReposUpdateReleaseAsset = (
  params: Params<
    t_ReposUpdateReleaseAssetParamSchema,
    void,
    t_ReposUpdateReleaseAssetBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdateReleaseAsset)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_release_asset>>

const reposDeleteReleaseAsset = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDeleteReleaseAsset = (
  params: Params<t_ReposDeleteReleaseAssetParamSchema, void, void, void>,
  respond: (typeof reposDeleteReleaseAsset)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposGenerateReleaseNotes = b((r) => ({
  with200: r.with200<t_release_notes_content>(s_release_notes_content),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGenerateReleaseNotes = (
  params: Params<
    t_ReposGenerateReleaseNotesParamSchema,
    void,
    t_ReposGenerateReleaseNotesBodySchema,
    void
  >,
  respond: (typeof reposGenerateReleaseNotes)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_release_notes_content>
  | Response<404, t_basic_error>
>

const reposGetLatestRelease = b((r) => ({
  with200: r.with200<t_release>(s_release),
  withStatus: r.withStatus,
}))

export type ReposGetLatestRelease = (
  params: Params<t_ReposGetLatestReleaseParamSchema, void, void, void>,
  respond: (typeof reposGetLatestRelease)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_release>>

const reposGetReleaseByTag = b((r) => ({
  with200: r.with200<t_release>(s_release),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetReleaseByTag = (
  params: Params<t_ReposGetReleaseByTagParamSchema, void, void, void>,
  respond: (typeof reposGetReleaseByTag)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_release>
  | Response<404, t_basic_error>
>

const reposGetRelease = b((r) => ({
  with200: r.with200<t_release>(s_release),
  with401: r.with401<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposGetRelease = (
  params: Params<t_ReposGetReleaseParamSchema, void, void, void>,
  respond: (typeof reposGetRelease)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_release> | Response<401, void>
>

const reposUpdateRelease = b((r) => ({
  with200: r.with200<t_release>(s_release),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposUpdateRelease = (
  params: Params<
    t_ReposUpdateReleaseParamSchema,
    void,
    t_ReposUpdateReleaseBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdateRelease)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_release>
  | Response<404, t_basic_error>
>

const reposDeleteRelease = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDeleteRelease = (
  params: Params<t_ReposDeleteReleaseParamSchema, void, void, void>,
  respond: (typeof reposDeleteRelease)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListReleaseAssets = b((r) => ({
  with200: r.with200<t_release_asset[]>(z.array(s_release_asset)),
  withStatus: r.withStatus,
}))

export type ReposListReleaseAssets = (
  params: Params<
    t_ReposListReleaseAssetsParamSchema,
    t_ReposListReleaseAssetsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListReleaseAssets)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_release_asset[]>>

const reposUploadReleaseAsset = b((r) => ({
  with201: r.with201<t_release_asset>(s_release_asset),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposUploadReleaseAsset = (
  params: Params<
    t_ReposUploadReleaseAssetParamSchema,
    t_ReposUploadReleaseAssetQuerySchema,
    t_ReposUploadReleaseAssetBodySchema | undefined,
    void
  >,
  respond: (typeof reposUploadReleaseAsset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_release_asset>
  | Response<422, void>
>

const reactionsListForRelease = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReactionsListForRelease = (
  params: Params<
    t_ReactionsListForReleaseParamSchema,
    t_ReactionsListForReleaseQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForRelease)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction[]>
  | Response<404, t_basic_error>
>

const reactionsCreateForRelease = b((r) => ({
  with200: r.with200<t_reaction>(s_reaction),
  with201: r.with201<t_reaction>(s_reaction),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForRelease = (
  params: Params<
    t_ReactionsCreateForReleaseParamSchema,
    void,
    t_ReactionsCreateForReleaseBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForRelease)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_reaction>
  | Response<201, t_reaction>
  | Response<422, t_validation_error>
>

const reactionsDeleteForRelease = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReactionsDeleteForRelease = (
  params: Params<t_ReactionsDeleteForReleaseParamSchema, void, void, void>,
  respond: (typeof reactionsDeleteForRelease)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposGetBranchRules = b((r) => ({
  with200: r.with200<t_repository_rule_detailed[]>(
    z.array(s_repository_rule_detailed),
  ),
  withStatus: r.withStatus,
}))

export type ReposGetBranchRules = (
  params: Params<
    t_ReposGetBranchRulesParamSchema,
    t_ReposGetBranchRulesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetBranchRules)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_repository_rule_detailed[]>
>

const reposGetRepoRulesets = b((r) => ({
  with200: r.with200<t_repository_ruleset[]>(z.array(s_repository_ruleset)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetRepoRulesets = (
  params: Params<
    t_ReposGetRepoRulesetsParamSchema,
    t_ReposGetRepoRulesetsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetRepoRulesets)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_ruleset[]>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposCreateRepoRuleset = b((r) => ({
  with201: r.with201<t_repository_ruleset>(s_repository_ruleset),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposCreateRepoRuleset = (
  params: Params<
    t_ReposCreateRepoRulesetParamSchema,
    void,
    t_ReposCreateRepoRulesetBodySchema,
    void
  >,
  respond: (typeof reposCreateRepoRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_repository_ruleset>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetRepoRuleSuites = b((r) => ({
  with200: r.with200<t_rule_suites>(s_rule_suites),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetRepoRuleSuites = (
  params: Params<
    t_ReposGetRepoRuleSuitesParamSchema,
    t_ReposGetRepoRuleSuitesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetRepoRuleSuites)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_rule_suites>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetRepoRuleSuite = b((r) => ({
  with200: r.with200<t_rule_suite>(s_rule_suite),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetRepoRuleSuite = (
  params: Params<t_ReposGetRepoRuleSuiteParamSchema, void, void, void>,
  respond: (typeof reposGetRepoRuleSuite)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_rule_suite>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetRepoRuleset = b((r) => ({
  with200: r.with200<t_repository_ruleset>(s_repository_ruleset),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetRepoRuleset = (
  params: Params<
    t_ReposGetRepoRulesetParamSchema,
    t_ReposGetRepoRulesetQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetRepoRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_ruleset>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposUpdateRepoRuleset = b((r) => ({
  with200: r.with200<t_repository_ruleset>(s_repository_ruleset),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposUpdateRepoRuleset = (
  params: Params<
    t_ReposUpdateRepoRulesetParamSchema,
    void,
    t_ReposUpdateRepoRulesetBodySchema | undefined,
    void
  >,
  respond: (typeof reposUpdateRepoRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_ruleset>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposDeleteRepoRuleset = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteRepoRuleset = (
  params: Params<t_ReposDeleteRepoRulesetParamSchema, void, void, void>,
  respond: (typeof reposDeleteRepoRuleset)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetRepoRulesetHistory = b((r) => ({
  with200: r.with200<t_ruleset_version[]>(z.array(s_ruleset_version)),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetRepoRulesetHistory = (
  params: Params<
    t_ReposGetRepoRulesetHistoryParamSchema,
    t_ReposGetRepoRulesetHistoryQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetRepoRulesetHistory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ruleset_version[]>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const reposGetRepoRulesetVersion = b((r) => ({
  with200: r.with200<t_ruleset_version_with_state>(
    s_ruleset_version_with_state,
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetRepoRulesetVersion = (
  params: Params<t_ReposGetRepoRulesetVersionParamSchema, void, void, void>,
  respond: (typeof reposGetRepoRulesetVersion)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ruleset_version_with_state>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const secretScanningListAlertsForRepo = b((r) => ({
  with200: r.with200<t_secret_scanning_alert[]>(
    z.array(s_secret_scanning_alert),
  ),
  with404: r.with404<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningListAlertsForRepo = (
  params: Params<
    t_SecretScanningListAlertsForRepoParamSchema,
    t_SecretScanningListAlertsForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof secretScanningListAlertsForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_secret_scanning_alert[]>
  | Response<404, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const secretScanningGetAlert = b((r) => ({
  with200: r.with200<t_secret_scanning_alert>(s_secret_scanning_alert),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningGetAlert = (
  params: Params<t_SecretScanningGetAlertParamSchema, void, void, void>,
  respond: (typeof secretScanningGetAlert)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_secret_scanning_alert>
  | Response<304, void>
  | Response<404, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const secretScanningUpdateAlert = b((r) => ({
  with200: r.with200<t_secret_scanning_alert>(s_secret_scanning_alert),
  with400: r.with400<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningUpdateAlert = (
  params: Params<
    t_SecretScanningUpdateAlertParamSchema,
    void,
    t_SecretScanningUpdateAlertBodySchema,
    void
  >,
  respond: (typeof secretScanningUpdateAlert)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_secret_scanning_alert>
  | Response<400, void>
  | Response<404, void>
  | Response<422, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const secretScanningListLocationsForAlert = b((r) => ({
  with200: r.with200<t_secret_scanning_location[]>(
    z.array(s_secret_scanning_location),
  ),
  with404: r.with404<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningListLocationsForAlert = (
  params: Params<
    t_SecretScanningListLocationsForAlertParamSchema,
    t_SecretScanningListLocationsForAlertQuerySchema,
    void,
    void
  >,
  respond: (typeof secretScanningListLocationsForAlert)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_secret_scanning_location[]>
  | Response<404, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const secretScanningCreatePushProtectionBypass = b((r) => ({
  with200: r.with200<t_secret_scanning_push_protection_bypass>(
    s_secret_scanning_push_protection_bypass,
  ),
  with403: r.with403<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningCreatePushProtectionBypass = (
  params: Params<
    t_SecretScanningCreatePushProtectionBypassParamSchema,
    void,
    t_SecretScanningCreatePushProtectionBypassBodySchema,
    void
  >,
  respond: (typeof secretScanningCreatePushProtectionBypass)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_secret_scanning_push_protection_bypass>
  | Response<403, void>
  | Response<404, void>
  | Response<422, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const secretScanningGetScanHistory = b((r) => ({
  with200: r.with200<t_secret_scanning_scan_history>(
    s_secret_scanning_scan_history,
  ),
  with404: r.with404<void>(z.undefined()),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SecretScanningGetScanHistory = (
  params: Params<t_SecretScanningGetScanHistoryParamSchema, void, void, void>,
  respond: (typeof secretScanningGetScanHistory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_secret_scanning_scan_history>
  | Response<404, void>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const securityAdvisoriesListRepositoryAdvisories = b((r) => ({
  with200: r.with200<t_repository_advisory[]>(z.array(s_repository_advisory)),
  with400: r.with400<t_scim_error>(s_scim_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesListRepositoryAdvisories = (
  params: Params<
    t_SecurityAdvisoriesListRepositoryAdvisoriesParamSchema,
    t_SecurityAdvisoriesListRepositoryAdvisoriesQuerySchema,
    void,
    void
  >,
  respond: (typeof securityAdvisoriesListRepositoryAdvisories)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_advisory[]>
  | Response<400, t_scim_error>
  | Response<404, t_basic_error>
>

const securityAdvisoriesCreateRepositoryAdvisory = b((r) => ({
  with201: r.with201<t_repository_advisory>(s_repository_advisory),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesCreateRepositoryAdvisory = (
  params: Params<
    t_SecurityAdvisoriesCreateRepositoryAdvisoryParamSchema,
    void,
    t_SecurityAdvisoriesCreateRepositoryAdvisoryBodySchema,
    void
  >,
  respond: (typeof securityAdvisoriesCreateRepositoryAdvisory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_repository_advisory>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const securityAdvisoriesCreatePrivateVulnerabilityReport = b((r) => ({
  with201: r.with201<t_repository_advisory>(s_repository_advisory),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesCreatePrivateVulnerabilityReport = (
  params: Params<
    t_SecurityAdvisoriesCreatePrivateVulnerabilityReportParamSchema,
    void,
    t_SecurityAdvisoriesCreatePrivateVulnerabilityReportBodySchema,
    void
  >,
  respond: (typeof securityAdvisoriesCreatePrivateVulnerabilityReport)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_repository_advisory>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const securityAdvisoriesGetRepositoryAdvisory = b((r) => ({
  with200: r.with200<t_repository_advisory>(s_repository_advisory),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesGetRepositoryAdvisory = (
  params: Params<
    t_SecurityAdvisoriesGetRepositoryAdvisoryParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof securityAdvisoriesGetRepositoryAdvisory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_advisory>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const securityAdvisoriesUpdateRepositoryAdvisory = b((r) => ({
  with200: r.with200<t_repository_advisory>(s_repository_advisory),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesUpdateRepositoryAdvisory = (
  params: Params<
    t_SecurityAdvisoriesUpdateRepositoryAdvisoryParamSchema,
    void,
    t_SecurityAdvisoriesUpdateRepositoryAdvisoryBodySchema,
    void
  >,
  respond: (typeof securityAdvisoriesUpdateRepositoryAdvisory)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_advisory>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const securityAdvisoriesCreateRepositoryAdvisoryCveRequest = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesCreateRepositoryAdvisoryCveRequest = (
  params: Params<
    t_SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof securityAdvisoriesCreateRepositoryAdvisoryCveRequest)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const securityAdvisoriesCreateFork = b((r) => ({
  with202: r.with202<t_full_repository>(s_full_repository),
  with400: r.with400<t_scim_error>(s_scim_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type SecurityAdvisoriesCreateFork = (
  params: Params<t_SecurityAdvisoriesCreateForkParamSchema, void, void, void>,
  respond: (typeof securityAdvisoriesCreateFork)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<202, t_full_repository>
  | Response<400, t_scim_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const activityListStargazersForRepo = b((r) => ({
  with200: r.with200<t_simple_user[] | t_stargazer[]>(
    z.union([z.array(s_simple_user), z.array(s_stargazer)]),
  ),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ActivityListStargazersForRepo = (
  params: Params<
    t_ActivityListStargazersForRepoParamSchema,
    t_ActivityListStargazersForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListStargazersForRepo)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[] | t_stargazer[]>
  | Response<422, t_validation_error>
>

const reposGetCodeFrequencyStats = b((r) => ({
  with200: r.with200<t_code_frequency_stat[]>(z.array(s_code_frequency_stat)),
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with204: r.with204<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposGetCodeFrequencyStats = (
  params: Params<t_ReposGetCodeFrequencyStatsParamSchema, void, void, void>,
  respond: (typeof reposGetCodeFrequencyStats)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_frequency_stat[]>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<204, void>
  | Response<422, void>
>

const reposGetCommitActivityStats = b((r) => ({
  with200: r.with200<t_commit_activity[]>(z.array(s_commit_activity)),
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposGetCommitActivityStats = (
  params: Params<t_ReposGetCommitActivityStatsParamSchema, void, void, void>,
  respond: (typeof reposGetCommitActivityStats)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_commit_activity[]>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<204, void>
>

const reposGetContributorsStats = b((r) => ({
  with200: r.with200<t_contributor_activity[]>(z.array(s_contributor_activity)),
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposGetContributorsStats = (
  params: Params<t_ReposGetContributorsStatsParamSchema, void, void, void>,
  respond: (typeof reposGetContributorsStats)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_contributor_activity[]>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<204, void>
>

const reposGetParticipationStats = b((r) => ({
  with200: r.with200<t_participation_stats>(s_participation_stats),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetParticipationStats = (
  params: Params<t_ReposGetParticipationStatsParamSchema, void, void, void>,
  respond: (typeof reposGetParticipationStats)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_participation_stats>
  | Response<404, t_basic_error>
>

const reposGetPunchCardStats = b((r) => ({
  with200: r.with200<t_code_frequency_stat[]>(z.array(s_code_frequency_stat)),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposGetPunchCardStats = (
  params: Params<t_ReposGetPunchCardStatsParamSchema, void, void, void>,
  respond: (typeof reposGetPunchCardStats)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_code_frequency_stat[]>
  | Response<204, void>
>

const reposCreateCommitStatus = b((r) => ({
  with201: r.with201<t_status>(s_status),
  withStatus: r.withStatus,
}))

export type ReposCreateCommitStatus = (
  params: Params<
    t_ReposCreateCommitStatusParamSchema,
    void,
    t_ReposCreateCommitStatusBodySchema,
    void
  >,
  respond: (typeof reposCreateCommitStatus)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_status>>

const activityListWatchersForRepo = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  withStatus: r.withStatus,
}))

export type ActivityListWatchersForRepo = (
  params: Params<
    t_ActivityListWatchersForRepoParamSchema,
    t_ActivityListWatchersForRepoQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListWatchersForRepo)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_user[]>>

const activityGetRepoSubscription = b((r) => ({
  with200: r.with200<t_repository_subscription>(s_repository_subscription),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActivityGetRepoSubscription = (
  params: Params<t_ActivityGetRepoSubscriptionParamSchema, void, void, void>,
  respond: (typeof activityGetRepoSubscription)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_subscription>
  | Response<403, t_basic_error>
  | Response<404, void>
>

const activitySetRepoSubscription = b((r) => ({
  with200: r.with200<t_repository_subscription>(s_repository_subscription),
  withStatus: r.withStatus,
}))

export type ActivitySetRepoSubscription = (
  params: Params<
    t_ActivitySetRepoSubscriptionParamSchema,
    void,
    t_ActivitySetRepoSubscriptionBodySchema | undefined,
    void
  >,
  respond: (typeof activitySetRepoSubscription)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_repository_subscription>
>

const activityDeleteRepoSubscription = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ActivityDeleteRepoSubscription = (
  params: Params<t_ActivityDeleteRepoSubscriptionParamSchema, void, void, void>,
  respond: (typeof activityDeleteRepoSubscription)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposListTags = b((r) => ({
  with200: r.with200<t_tag[]>(z.array(s_tag)),
  withStatus: r.withStatus,
}))

export type ReposListTags = (
  params: Params<
    t_ReposListTagsParamSchema,
    t_ReposListTagsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListTags)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_tag[]>>

const reposListTagProtection = b((r) => ({
  with200: r.with200<t_tag_protection[]>(z.array(s_tag_protection)),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListTagProtection = (
  params: Params<t_ReposListTagProtectionParamSchema, void, void, void>,
  respond: (typeof reposListTagProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_tag_protection[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposCreateTagProtection = b((r) => ({
  with201: r.with201<t_tag_protection>(s_tag_protection),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposCreateTagProtection = (
  params: Params<
    t_ReposCreateTagProtectionParamSchema,
    void,
    t_ReposCreateTagProtectionBodySchema,
    void
  >,
  respond: (typeof reposCreateTagProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_tag_protection>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposDeleteTagProtection = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeleteTagProtection = (
  params: Params<t_ReposDeleteTagProtectionParamSchema, void, void, void>,
  respond: (typeof reposDeleteTagProtection)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposDownloadTarballArchive = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDownloadTarballArchive = (
  params: Params<t_ReposDownloadTarballArchiveParamSchema, void, void, void>,
  respond: (typeof reposDownloadTarballArchive)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<302, void>>

const reposListTeams = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListTeams = (
  params: Params<
    t_ReposListTeamsParamSchema,
    t_ReposListTeamsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListTeams)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<404, t_basic_error>
>

const reposGetAllTopics = b((r) => ({
  with200: r.with200<t_topic>(s_topic),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetAllTopics = (
  params: Params<
    t_ReposGetAllTopicsParamSchema,
    t_ReposGetAllTopicsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetAllTopics)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topic>
  | Response<404, t_basic_error>
>

const reposReplaceAllTopics = b((r) => ({
  with200: r.with200<t_topic>(s_topic),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ReposReplaceAllTopics = (
  params: Params<
    t_ReposReplaceAllTopicsParamSchema,
    void,
    t_ReposReplaceAllTopicsBodySchema,
    void
  >,
  respond: (typeof reposReplaceAllTopics)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_topic>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const reposGetClones = b((r) => ({
  with200: r.with200<t_clone_traffic>(s_clone_traffic),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetClones = (
  params: Params<
    t_ReposGetClonesParamSchema,
    t_ReposGetClonesQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetClones)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_clone_traffic>
  | Response<403, t_basic_error>
>

const reposGetTopPaths = b((r) => ({
  with200: r.with200<t_content_traffic[]>(z.array(s_content_traffic)),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetTopPaths = (
  params: Params<t_ReposGetTopPathsParamSchema, void, void, void>,
  respond: (typeof reposGetTopPaths)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_content_traffic[]>
  | Response<403, t_basic_error>
>

const reposGetTopReferrers = b((r) => ({
  with200: r.with200<t_referrer_traffic[]>(z.array(s_referrer_traffic)),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetTopReferrers = (
  params: Params<t_ReposGetTopReferrersParamSchema, void, void, void>,
  respond: (typeof reposGetTopReferrers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_referrer_traffic[]>
  | Response<403, t_basic_error>
>

const reposGetViews = b((r) => ({
  with200: r.with200<t_view_traffic>(s_view_traffic),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposGetViews = (
  params: Params<
    t_ReposGetViewsParamSchema,
    t_ReposGetViewsQuerySchema,
    void,
    void
  >,
  respond: (typeof reposGetViews)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_view_traffic>
  | Response<403, t_basic_error>
>

const reposTransfer = b((r) => ({
  with202: r.with202<t_minimal_repository>(s_minimal_repository),
  withStatus: r.withStatus,
}))

export type ReposTransfer = (
  params: Params<
    t_ReposTransferParamSchema,
    void,
    t_ReposTransferBodySchema,
    void
  >,
  respond: (typeof reposTransfer)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<202, t_minimal_repository>>

const reposCheckVulnerabilityAlerts = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposCheckVulnerabilityAlerts = (
  params: Params<t_ReposCheckVulnerabilityAlertsParamSchema, void, void, void>,
  respond: (typeof reposCheckVulnerabilityAlerts)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<404, void>
>

const reposEnableVulnerabilityAlerts = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposEnableVulnerabilityAlerts = (
  params: Params<t_ReposEnableVulnerabilityAlertsParamSchema, void, void, void>,
  respond: (typeof reposEnableVulnerabilityAlerts)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposDisableVulnerabilityAlerts = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDisableVulnerabilityAlerts = (
  params: Params<
    t_ReposDisableVulnerabilityAlertsParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDisableVulnerabilityAlerts)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reposDownloadZipballArchive = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type ReposDownloadZipballArchive = (
  params: Params<t_ReposDownloadZipballArchiveParamSchema, void, void, void>,
  respond: (typeof reposDownloadZipballArchive)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<302, void>>

const reposCreateUsingTemplate = b((r) => ({
  with201: r.with201<t_full_repository>(s_full_repository),
  withStatus: r.withStatus,
}))

export type ReposCreateUsingTemplate = (
  params: Params<
    t_ReposCreateUsingTemplateParamSchema,
    void,
    t_ReposCreateUsingTemplateBodySchema,
    void
  >,
  respond: (typeof reposCreateUsingTemplate)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_full_repository>>

const reposListPublic = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with304: r.with304<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposListPublic = (
  params: Params<void, t_ReposListPublicQuerySchema, void, void>,
  respond: (typeof reposListPublic)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<304, void>
  | Response<422, t_validation_error>
>

const searchCode = b((r) => ({
  with200: r.with200<{
    incomplete_results: boolean
    items: t_code_search_result_item[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      incomplete_results: PermissiveBoolean,
      items: z.array(s_code_search_result_item),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SearchCode = (
  params: Params<void, t_SearchCodeQuerySchema, void, void>,
  respond: (typeof searchCode)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        incomplete_results: boolean
        items: t_code_search_result_item[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const searchCommits = b((r) => ({
  with200: r.with200<{
    incomplete_results: boolean
    items: t_commit_search_result_item[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      incomplete_results: PermissiveBoolean,
      items: z.array(s_commit_search_result_item),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type SearchCommits = (
  params: Params<void, t_SearchCommitsQuerySchema, void, void>,
  respond: (typeof searchCommits)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        incomplete_results: boolean
        items: t_commit_search_result_item[]
        total_count: number
      }
    >
  | Response<304, void>
>

const searchIssuesAndPullRequests = b((r) => ({
  with200: r.with200<{
    incomplete_results: boolean
    items: t_issue_search_result_item[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      incomplete_results: PermissiveBoolean,
      items: z.array(s_issue_search_result_item),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SearchIssuesAndPullRequests = (
  params: Params<void, t_SearchIssuesAndPullRequestsQuerySchema, void, void>,
  respond: (typeof searchIssuesAndPullRequests)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        incomplete_results: boolean
        items: t_issue_search_result_item[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const searchLabels = b((r) => ({
  with200: r.with200<{
    incomplete_results: boolean
    items: t_label_search_result_item[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      incomplete_results: PermissiveBoolean,
      items: z.array(s_label_search_result_item),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type SearchLabels = (
  params: Params<void, t_SearchLabelsQuerySchema, void, void>,
  respond: (typeof searchLabels)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        incomplete_results: boolean
        items: t_label_search_result_item[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const searchRepos = b((r) => ({
  with200: r.with200<{
    incomplete_results: boolean
    items: t_repo_search_result_item[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      incomplete_results: PermissiveBoolean,
      items: z.array(s_repo_search_result_item),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SearchRepos = (
  params: Params<void, t_SearchReposQuerySchema, void, void>,
  respond: (typeof searchRepos)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        incomplete_results: boolean
        items: t_repo_search_result_item[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const searchTopics = b((r) => ({
  with200: r.with200<{
    incomplete_results: boolean
    items: t_topic_search_result_item[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      incomplete_results: PermissiveBoolean,
      items: z.array(s_topic_search_result_item),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type SearchTopics = (
  params: Params<void, t_SearchTopicsQuerySchema, void, void>,
  respond: (typeof searchTopics)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        incomplete_results: boolean
        items: t_topic_search_result_item[]
        total_count: number
      }
    >
  | Response<304, void>
>

const searchUsers = b((r) => ({
  with200: r.with200<{
    incomplete_results: boolean
    items: t_user_search_result_item[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      incomplete_results: PermissiveBoolean,
      items: z.array(s_user_search_result_item),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with422: r.with422<t_validation_error>(s_validation_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type SearchUsers = (
  params: Params<void, t_SearchUsersQuerySchema, void, void>,
  respond: (typeof searchUsers)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        incomplete_results: boolean
        items: t_user_search_result_item[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<422, t_validation_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const teamsGetLegacy = b((r) => ({
  with200: r.with200<t_team_full>(s_team_full),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsGetLegacy = (
  params: Params<t_TeamsGetLegacyParamSchema, void, void, void>,
  respond: (typeof teamsGetLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_full>
  | Response<404, t_basic_error>
>

const teamsUpdateLegacy = b((r) => ({
  with200: r.with200<t_team_full>(s_team_full),
  with201: r.with201<t_team_full>(s_team_full),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsUpdateLegacy = (
  params: Params<
    t_TeamsUpdateLegacyParamSchema,
    void,
    t_TeamsUpdateLegacyBodySchema,
    void
  >,
  respond: (typeof teamsUpdateLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_full>
  | Response<201, t_team_full>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const teamsDeleteLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsDeleteLegacy = (
  params: Params<t_TeamsDeleteLegacyParamSchema, void, void, void>,
  respond: (typeof teamsDeleteLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const teamsListDiscussionsLegacy = b((r) => ({
  with200: r.with200<t_team_discussion[]>(z.array(s_team_discussion)),
  withStatus: r.withStatus,
}))

export type TeamsListDiscussionsLegacy = (
  params: Params<
    t_TeamsListDiscussionsLegacyParamSchema,
    t_TeamsListDiscussionsLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListDiscussionsLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_discussion[]>>

const teamsCreateDiscussionLegacy = b((r) => ({
  with201: r.with201<t_team_discussion>(s_team_discussion),
  withStatus: r.withStatus,
}))

export type TeamsCreateDiscussionLegacy = (
  params: Params<
    t_TeamsCreateDiscussionLegacyParamSchema,
    void,
    t_TeamsCreateDiscussionLegacyBodySchema,
    void
  >,
  respond: (typeof teamsCreateDiscussionLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_team_discussion>>

const teamsGetDiscussionLegacy = b((r) => ({
  with200: r.with200<t_team_discussion>(s_team_discussion),
  withStatus: r.withStatus,
}))

export type TeamsGetDiscussionLegacy = (
  params: Params<t_TeamsGetDiscussionLegacyParamSchema, void, void, void>,
  respond: (typeof teamsGetDiscussionLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_discussion>>

const teamsUpdateDiscussionLegacy = b((r) => ({
  with200: r.with200<t_team_discussion>(s_team_discussion),
  withStatus: r.withStatus,
}))

export type TeamsUpdateDiscussionLegacy = (
  params: Params<
    t_TeamsUpdateDiscussionLegacyParamSchema,
    void,
    t_TeamsUpdateDiscussionLegacyBodySchema | undefined,
    void
  >,
  respond: (typeof teamsUpdateDiscussionLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_team_discussion>>

const teamsDeleteDiscussionLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsDeleteDiscussionLegacy = (
  params: Params<t_TeamsDeleteDiscussionLegacyParamSchema, void, void, void>,
  respond: (typeof teamsDeleteDiscussionLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsListDiscussionCommentsLegacy = b((r) => ({
  with200: r.with200<t_team_discussion_comment[]>(
    z.array(s_team_discussion_comment),
  ),
  withStatus: r.withStatus,
}))

export type TeamsListDiscussionCommentsLegacy = (
  params: Params<
    t_TeamsListDiscussionCommentsLegacyParamSchema,
    t_TeamsListDiscussionCommentsLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListDiscussionCommentsLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_team_discussion_comment[]>
>

const teamsCreateDiscussionCommentLegacy = b((r) => ({
  with201: r.with201<t_team_discussion_comment>(s_team_discussion_comment),
  withStatus: r.withStatus,
}))

export type TeamsCreateDiscussionCommentLegacy = (
  params: Params<
    t_TeamsCreateDiscussionCommentLegacyParamSchema,
    void,
    t_TeamsCreateDiscussionCommentLegacyBodySchema,
    void
  >,
  respond: (typeof teamsCreateDiscussionCommentLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<201, t_team_discussion_comment>
>

const teamsGetDiscussionCommentLegacy = b((r) => ({
  with200: r.with200<t_team_discussion_comment>(s_team_discussion_comment),
  withStatus: r.withStatus,
}))

export type TeamsGetDiscussionCommentLegacy = (
  params: Params<
    t_TeamsGetDiscussionCommentLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsGetDiscussionCommentLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_team_discussion_comment>
>

const teamsUpdateDiscussionCommentLegacy = b((r) => ({
  with200: r.with200<t_team_discussion_comment>(s_team_discussion_comment),
  withStatus: r.withStatus,
}))

export type TeamsUpdateDiscussionCommentLegacy = (
  params: Params<
    t_TeamsUpdateDiscussionCommentLegacyParamSchema,
    void,
    t_TeamsUpdateDiscussionCommentLegacyBodySchema,
    void
  >,
  respond: (typeof teamsUpdateDiscussionCommentLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_team_discussion_comment>
>

const teamsDeleteDiscussionCommentLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsDeleteDiscussionCommentLegacy = (
  params: Params<
    t_TeamsDeleteDiscussionCommentLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsDeleteDiscussionCommentLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const reactionsListForTeamDiscussionCommentLegacy = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  withStatus: r.withStatus,
}))

export type ReactionsListForTeamDiscussionCommentLegacy = (
  params: Params<
    t_ReactionsListForTeamDiscussionCommentLegacyParamSchema,
    t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForTeamDiscussionCommentLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_reaction[]>>

const reactionsCreateForTeamDiscussionCommentLegacy = b((r) => ({
  with201: r.with201<t_reaction>(s_reaction),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForTeamDiscussionCommentLegacy = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionCommentLegacyBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForTeamDiscussionCommentLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_reaction>>

const reactionsListForTeamDiscussionLegacy = b((r) => ({
  with200: r.with200<t_reaction[]>(z.array(s_reaction)),
  withStatus: r.withStatus,
}))

export type ReactionsListForTeamDiscussionLegacy = (
  params: Params<
    t_ReactionsListForTeamDiscussionLegacyParamSchema,
    t_ReactionsListForTeamDiscussionLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof reactionsListForTeamDiscussionLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_reaction[]>>

const reactionsCreateForTeamDiscussionLegacy = b((r) => ({
  with201: r.with201<t_reaction>(s_reaction),
  withStatus: r.withStatus,
}))

export type ReactionsCreateForTeamDiscussionLegacy = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionLegacyParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionLegacyBodySchema,
    void
  >,
  respond: (typeof reactionsCreateForTeamDiscussionLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<201, t_reaction>>

const teamsListPendingInvitationsLegacy = b((r) => ({
  with200: r.with200<t_organization_invitation[]>(
    z.array(s_organization_invitation),
  ),
  withStatus: r.withStatus,
}))

export type TeamsListPendingInvitationsLegacy = (
  params: Params<
    t_TeamsListPendingInvitationsLegacyParamSchema,
    t_TeamsListPendingInvitationsLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListPendingInvitationsLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_organization_invitation[]>
>

const teamsListMembersLegacy = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsListMembersLegacy = (
  params: Params<
    t_TeamsListMembersLegacyParamSchema,
    t_TeamsListMembersLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListMembersLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<404, t_basic_error>
>

const teamsGetMemberLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsGetMemberLegacy = (
  params: Params<t_TeamsGetMemberLegacyParamSchema, void, void, void>,
  respond: (typeof teamsGetMemberLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<404, void>
>

const teamsAddMemberLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<void>(z.undefined()),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsAddMemberLegacy = (
  params: Params<t_TeamsAddMemberLegacyParamSchema, void, void, void>,
  respond: (typeof teamsAddMemberLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<404, void>
  | Response<422, void>
>

const teamsRemoveMemberLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsRemoveMemberLegacy = (
  params: Params<t_TeamsRemoveMemberLegacyParamSchema, void, void, void>,
  respond: (typeof teamsRemoveMemberLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<404, void>
>

const teamsGetMembershipForUserLegacy = b((r) => ({
  with200: r.with200<t_team_membership>(s_team_membership),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsGetMembershipForUserLegacy = (
  params: Params<
    t_TeamsGetMembershipForUserLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsGetMembershipForUserLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_membership>
  | Response<404, t_basic_error>
>

const teamsAddOrUpdateMembershipForUserLegacy = b((r) => ({
  with200: r.with200<t_team_membership>(s_team_membership),
  with403: r.with403<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsAddOrUpdateMembershipForUserLegacy = (
  params: Params<
    t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateMembershipForUserLegacyBodySchema | undefined,
    void
  >,
  respond: (typeof teamsAddOrUpdateMembershipForUserLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_membership>
  | Response<403, void>
  | Response<404, t_basic_error>
  | Response<422, void>
>

const teamsRemoveMembershipForUserLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsRemoveMembershipForUserLegacy = (
  params: Params<
    t_TeamsRemoveMembershipForUserLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsRemoveMembershipForUserLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<403, void>
>

const teamsListProjectsLegacy = b((r) => ({
  with200: r.with200<t_team_project[]>(z.array(s_team_project)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsListProjectsLegacy = (
  params: Params<
    t_TeamsListProjectsLegacyParamSchema,
    t_TeamsListProjectsLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListProjectsLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_project[]>
  | Response<404, t_basic_error>
>

const teamsCheckPermissionsForProjectLegacy = b((r) => ({
  with200: r.with200<t_team_project>(s_team_project),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsCheckPermissionsForProjectLegacy = (
  params: Params<
    t_TeamsCheckPermissionsForProjectLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsCheckPermissionsForProjectLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_project>
  | Response<404, void>
>

const teamsAddOrUpdateProjectPermissionsLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<{
    documentation_url?: string
    message?: string
  }>(
    z.object({
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsAddOrUpdateProjectPermissionsLegacy = (
  params: Params<
    t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateProjectPermissionsLegacyBodySchema | undefined,
    void
  >,
  respond: (typeof teamsAddOrUpdateProjectPermissionsLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<
      403,
      {
        documentation_url?: string
        message?: string
      }
    >
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const teamsRemoveProjectLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsRemoveProjectLegacy = (
  params: Params<t_TeamsRemoveProjectLegacyParamSchema, void, void, void>,
  respond: (typeof teamsRemoveProjectLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const teamsListReposLegacy = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsListReposLegacy = (
  params: Params<
    t_TeamsListReposLegacyParamSchema,
    t_TeamsListReposLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListReposLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<404, t_basic_error>
>

const teamsCheckPermissionsForRepoLegacy = b((r) => ({
  with200: r.with200<t_team_repository>(s_team_repository),
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsCheckPermissionsForRepoLegacy = (
  params: Params<
    t_TeamsCheckPermissionsForRepoLegacyParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof teamsCheckPermissionsForRepoLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_repository>
  | Response<204, void>
  | Response<404, void>
>

const teamsAddOrUpdateRepoPermissionsLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsAddOrUpdateRepoPermissionsLegacy = (
  params: Params<
    t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateRepoPermissionsLegacyBodySchema | undefined,
    void
  >,
  respond: (typeof teamsAddOrUpdateRepoPermissionsLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const teamsRemoveRepoLegacy = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type TeamsRemoveRepoLegacy = (
  params: Params<t_TeamsRemoveRepoLegacyParamSchema, void, void, void>,
  respond: (typeof teamsRemoveRepoLegacy)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const teamsListChildLegacy = b((r) => ({
  with200: r.with200<t_team[]>(z.array(s_team)),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type TeamsListChildLegacy = (
  params: Params<
    t_TeamsListChildLegacyParamSchema,
    t_TeamsListChildLegacyQuerySchema,
    void,
    void
  >,
  respond: (typeof teamsListChildLegacy)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team[]>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersGetAuthenticated = b((r) => ({
  with200: r.with200<t_private_user | t_public_user>(
    z.union([s_private_user, s_public_user]),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersGetAuthenticated = (
  params: Params<void, void, void, void>,
  respond: (typeof usersGetAuthenticated)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_private_user | t_public_user>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const usersUpdateAuthenticated = b((r) => ({
  with200: r.with200<t_private_user>(s_private_user),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersUpdateAuthenticated = (
  params: Params<
    void,
    void,
    t_UsersUpdateAuthenticatedBodySchema | undefined,
    void
  >,
  respond: (typeof usersUpdateAuthenticated)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_private_user>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersListBlockedByAuthenticatedUser = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListBlockedByAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListBlockedByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListBlockedByAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersCheckBlocked = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersCheckBlocked = (
  params: Params<t_UsersCheckBlockedParamSchema, void, void, void>,
  respond: (typeof usersCheckBlocked)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersBlock = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersBlock = (
  params: Params<t_UsersBlockParamSchema, void, void, void>,
  respond: (typeof usersBlock)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersUnblock = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersUnblock = (
  params: Params<t_UsersUnblockParamSchema, void, void, void>,
  respond: (typeof usersUnblock)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codespacesListForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    codespaces: t_codespace[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      codespaces: z.array(s_codespace),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesListForAuthenticatedUser = (
  params: Params<
    void,
    t_CodespacesListForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        codespaces: t_codespace[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesCreateForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_codespace>(s_codespace),
  with202: r.with202<t_codespace>(s_codespace),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with503: r.with503<{
    code?: string
    documentation_url?: string
    message?: string
  }>(
    z.object({
      code: z.string().optional(),
      message: z.string().optional(),
      documentation_url: z.string().optional(),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodespacesCreateForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_CodespacesCreateForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof codespacesCreateForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_codespace>
  | Response<202, t_codespace>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<
      503,
      {
        code?: string
        documentation_url?: string
        message?: string
      }
    >
>

const codespacesListSecretsForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    secrets: t_codespaces_secret[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      secrets: z.array(s_codespaces_secret),
    }),
  ),
  withStatus: r.withStatus,
}))

export type CodespacesListSecretsForAuthenticatedUser = (
  params: Params<
    void,
    t_CodespacesListSecretsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof codespacesListSecretsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        secrets: t_codespaces_secret[]
        total_count: number
      }
    >
>

const codespacesGetPublicKeyForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_codespaces_user_public_key>(
    s_codespaces_user_public_key,
  ),
  withStatus: r.withStatus,
}))

export type CodespacesGetPublicKeyForAuthenticatedUser = (
  params: Params<void, void, void, void>,
  respond: (typeof codespacesGetPublicKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_codespaces_user_public_key>
>

const codespacesGetSecretForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_codespaces_secret>(s_codespaces_secret),
  withStatus: r.withStatus,
}))

export type CodespacesGetSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesGetSecretForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_codespaces_secret>>

const codespacesCreateOrUpdateSecretForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof codespacesCreateOrUpdateSecretForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_empty_object>
  | Response<204, void>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const codespacesDeleteSecretForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type CodespacesDeleteSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesDeleteSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesDeleteSecretForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const codespacesListRepositoriesForSecretForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    repositories: t_minimal_repository[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repositories: z.array(s_minimal_repository),
    }),
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesListRepositoriesForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesListRepositoriesForSecretForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_minimal_repository[]
        total_count: number
      }
    >
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesSetRepositoriesForSecretForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
    void,
    t_CodespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof codespacesSetRepositoriesForSecretForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesAddRepositoryForSecretForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesAddRepositoryForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesAddRepositoryForSecretForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesRemoveRepositoryForSecretForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesRemoveRepositoryForSecretForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesGetForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_codespace>(s_codespace),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesGetForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesGetForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codespace>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesUpdateForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_codespace>(s_codespace),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesUpdateForAuthenticatedUser = (
  params: Params<
    t_CodespacesUpdateForAuthenticatedUserParamSchema,
    void,
    t_CodespacesUpdateForAuthenticatedUserBodySchema | undefined,
    void
  >,
  respond: (typeof codespacesUpdateForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codespace>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const codespacesDeleteForAuthenticatedUser = b((r) => ({
  with202: r.with202<{
    [key: string]: unknown | undefined
  }>(z.record(z.unknown())),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesDeleteForAuthenticatedUser = (
  params: Params<
    t_CodespacesDeleteForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesDeleteForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      202,
      {
        [key: string]: unknown | undefined
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesExportForAuthenticatedUser = b((r) => ({
  with202: r.with202<t_codespace_export_details>(s_codespace_export_details),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesExportForAuthenticatedUser = (
  params: Params<
    t_CodespacesExportForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesExportForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<202, t_codespace_export_details>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
  | Response<500, t_basic_error>
>

const codespacesGetExportDetailsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_codespace_export_details>(s_codespace_export_details),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesGetExportDetailsForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesGetExportDetailsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codespace_export_details>
  | Response<404, t_basic_error>
>

const codespacesCodespaceMachinesForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    machines: t_codespace_machine[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      machines: z.array(s_codespace_machine),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesCodespaceMachinesForAuthenticatedUser = (
  params: Params<
    t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesCodespaceMachinesForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        machines: t_codespace_machine[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesPublishForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_codespace_with_full_repository>(
    s_codespace_with_full_repository,
  ),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type CodespacesPublishForAuthenticatedUser = (
  params: Params<
    t_CodespacesPublishForAuthenticatedUserParamSchema,
    void,
    t_CodespacesPublishForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof codespacesPublishForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_codespace_with_full_repository>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const codespacesStartForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_codespace>(s_codespace),
  with304: r.with304<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with401: r.with401<t_basic_error>(s_basic_error),
  with402: r.with402<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesStartForAuthenticatedUser = (
  params: Params<
    t_CodespacesStartForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesStartForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codespace>
  | Response<304, void>
  | Response<400, t_scim_error>
  | Response<401, t_basic_error>
  | Response<402, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
  | Response<500, t_basic_error>
>

const codespacesStopForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_codespace>(s_codespace),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with500: r.with500<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type CodespacesStopForAuthenticatedUser = (
  params: Params<
    t_CodespacesStopForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof codespacesStopForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_codespace>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<500, t_basic_error>
>

const packagesListDockerMigrationConflictingPackagesForAuthenticatedUser = b(
  (r) => ({
    with200: r.with200<t_package[]>(z.array(s_package)),
    withStatus: r.withStatus,
  }),
)

export type PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser =
  (
    params: Params<void, void, void, void>,
    respond: (typeof packagesListDockerMigrationConflictingPackagesForAuthenticatedUser)["responder"],
    ctx: RouterContext,
  ) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_package[]>>

const usersSetPrimaryEmailVisibilityForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_email[]>(z.array(s_email)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof usersSetPrimaryEmailVisibilityForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_email[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersListEmailsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_email[]>(z.array(s_email)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListEmailsForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListEmailsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListEmailsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_email[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersAddEmailForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_email[]>(z.array(s_email)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersAddEmailForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersAddEmailForAuthenticatedUserBodySchema | undefined,
    void
  >,
  respond: (typeof usersAddEmailForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_email[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersDeleteEmailForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersDeleteEmailForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersDeleteEmailForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof usersDeleteEmailForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersListFollowersForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListFollowersForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListFollowersForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListFollowersForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const usersListFollowedByAuthenticatedUser = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListFollowedByAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListFollowedByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListFollowedByAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const usersCheckPersonIsFollowedByAuthenticated = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersCheckPersonIsFollowedByAuthenticated = (
  params: Params<
    t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof usersCheckPersonIsFollowedByAuthenticated)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersFollow = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersFollow = (
  params: Params<t_UsersFollowParamSchema, void, void, void>,
  respond: (typeof usersFollow)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersUnfollow = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersUnfollow = (
  params: Params<t_UsersUnfollowParamSchema, void, void, void>,
  respond: (typeof usersUnfollow)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersListGpgKeysForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_gpg_key[]>(z.array(s_gpg_key)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListGpgKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListGpgKeysForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListGpgKeysForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gpg_key[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersCreateGpgKeyForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_gpg_key>(s_gpg_key),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersCreateGpgKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreateGpgKeyForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof usersCreateGpgKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_gpg_key>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersGetGpgKeyForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_gpg_key>(s_gpg_key),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersGetGpgKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetGpgKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof usersGetGpgKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_gpg_key>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersDeleteGpgKeyForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersDeleteGpgKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof usersDeleteGpgKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const appsListInstallationsForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    installations: t_installation[]
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      installations: z.array(s_installation),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListInstallationsForAuthenticatedUser = (
  params: Params<
    void,
    t_AppsListInstallationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListInstallationsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        installations: t_installation[]
        total_count: number
      }
    >
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const appsListInstallationReposForAuthenticatedUser = b((r) => ({
  with200: r.with200<{
    repositories: t_repository[]
    repository_selection?: string
    total_count: number
  }>(
    z.object({
      total_count: z.coerce.number(),
      repository_selection: z.string().optional(),
      repositories: z.array(s_repository),
    }),
  ),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListInstallationReposForAuthenticatedUser = (
  params: Params<
    t_AppsListInstallationReposForAuthenticatedUserParamSchema,
    t_AppsListInstallationReposForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListInstallationReposForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        repositories: t_repository[]
        repository_selection?: string
        total_count: number
      }
    >
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const appsAddRepoToInstallationForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsAddRepoToInstallationForAuthenticatedUser = (
  params: Params<
    t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof appsAddRepoToInstallationForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const appsRemoveRepoFromInstallationForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type AppsRemoveRepoFromInstallationForAuthenticatedUser = (
  params: Params<
    t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof appsRemoveRepoFromInstallationForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, void>
>

const interactionsGetRestrictionsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_interaction_limit_response | EmptyObject>(
    z.union([s_interaction_limit_response, z.object({})]),
  ),
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type InteractionsGetRestrictionsForAuthenticatedUser = (
  params: Params<void, void, void, void>,
  respond: (typeof interactionsGetRestrictionsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_interaction_limit_response | EmptyObject>
  | Response<204, void>
>

const interactionsSetRestrictionsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_interaction_limit_response>(
    s_interaction_limit_response,
  ),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type InteractionsSetRestrictionsForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_InteractionsSetRestrictionsForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof interactionsSetRestrictionsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_interaction_limit_response>
  | Response<422, t_validation_error>
>

const interactionsRemoveRestrictionsForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type InteractionsRemoveRestrictionsForAuthenticatedUser = (
  params: Params<void, void, void, void>,
  respond: (typeof interactionsRemoveRestrictionsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<204, void>>

const issuesListForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_issue[]>(z.array(s_issue)),
  with304: r.with304<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type IssuesListForAuthenticatedUser = (
  params: Params<void, t_IssuesListForAuthenticatedUserQuerySchema, void, void>,
  respond: (typeof issuesListForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_issue[]>
  | Response<304, void>
  | Response<404, t_basic_error>
>

const usersListPublicSshKeysForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_key[]>(z.array(s_key)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListPublicSshKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListPublicSshKeysForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_key[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersCreatePublicSshKeyForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_key>(s_key),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersCreatePublicSshKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreatePublicSshKeyForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof usersCreatePublicSshKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_key>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersGetPublicSshKeyForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_key>(s_key),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersGetPublicSshKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof usersGetPublicSshKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_key>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersDeletePublicSshKeyForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersDeletePublicSshKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof usersDeletePublicSshKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const appsListSubscriptionsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_user_marketplace_purchase[]>(
    z.array(s_user_marketplace_purchase),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListSubscriptionsForAuthenticatedUser = (
  params: Params<
    void,
    t_AppsListSubscriptionsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListSubscriptionsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_user_marketplace_purchase[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<404, t_basic_error>
>

const appsListSubscriptionsForAuthenticatedUserStubbed = b((r) => ({
  with200: r.with200<t_user_marketplace_purchase[]>(
    z.array(s_user_marketplace_purchase),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type AppsListSubscriptionsForAuthenticatedUserStubbed = (
  params: Params<
    void,
    t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
    void,
    void
  >,
  respond: (typeof appsListSubscriptionsForAuthenticatedUserStubbed)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_user_marketplace_purchase[]>
  | Response<304, void>
  | Response<401, t_basic_error>
>

const orgsListMembershipsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_org_membership[]>(z.array(s_org_membership)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsListMembershipsForAuthenticatedUser = (
  params: Params<
    void,
    t_OrgsListMembershipsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListMembershipsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_membership[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const orgsGetMembershipForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_org_membership>(s_org_membership),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsGetMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsGetMembershipForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof orgsGetMembershipForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_membership>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const orgsUpdateMembershipForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_org_membership>(s_org_membership),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type OrgsUpdateMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsUpdateMembershipForAuthenticatedUserParamSchema,
    void,
    t_OrgsUpdateMembershipForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof orgsUpdateMembershipForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_org_membership>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const migrationsListForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_migration[]>(z.array(s_migration)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsListForAuthenticatedUser = (
  params: Params<
    void,
    t_MigrationsListForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof migrationsListForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_migration[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const migrationsStartForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_migration>(s_migration),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type MigrationsStartForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_MigrationsStartForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof migrationsStartForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_migration>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const migrationsGetStatusForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_migration>(s_migration),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsGetStatusForAuthenticatedUser = (
  params: Params<
    t_MigrationsGetStatusForAuthenticatedUserParamSchema,
    t_MigrationsGetStatusForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof migrationsGetStatusForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_migration>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const migrationsGetArchiveForAuthenticatedUser = b((r) => ({
  with302: r.with302<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsGetArchiveForAuthenticatedUser = (
  params: Params<
    t_MigrationsGetArchiveForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof migrationsGetArchiveForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<302, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const migrationsDeleteArchiveForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsDeleteArchiveForAuthenticatedUser = (
  params: Params<
    t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof migrationsDeleteArchiveForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const migrationsUnlockRepoForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsUnlockRepoForAuthenticatedUser = (
  params: Params<
    t_MigrationsUnlockRepoForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof migrationsUnlockRepoForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const migrationsListReposForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MigrationsListReposForAuthenticatedUser = (
  params: Params<
    t_MigrationsListReposForAuthenticatedUserParamSchema,
    t_MigrationsListReposForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof migrationsListReposForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<404, t_basic_error>
>

const orgsListForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_organization_simple[]>(z.array(s_organization_simple)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type OrgsListForAuthenticatedUser = (
  params: Params<void, t_OrgsListForAuthenticatedUserQuerySchema, void, void>,
  respond: (typeof orgsListForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_organization_simple[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const packagesListPackagesForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_package[]>(z.array(s_package)),
  with400: r.with400<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type PackagesListPackagesForAuthenticatedUser = (
  params: Params<
    void,
    t_PackagesListPackagesForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesListPackagesForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_package[]> | Response<400, void>
>

const packagesGetPackageForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_package>(s_package),
  withStatus: r.withStatus,
}))

export type PackagesGetPackageForAuthenticatedUser = (
  params: Params<
    t_PackagesGetPackageForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesGetPackageForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_package>>

const packagesDeletePackageForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesDeletePackageForAuthenticatedUser = (
  params: Params<
    t_PackagesDeletePackageForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesDeletePackageForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesRestorePackageForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesRestorePackageForAuthenticatedUser = (
  params: Params<
    t_PackagesRestorePackageForAuthenticatedUserParamSchema,
    t_PackagesRestorePackageForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesRestorePackageForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser = b(
  (r) => ({
    with200: r.with200<t_package_version[]>(z.array(s_package_version)),
    with401: r.with401<t_basic_error>(s_basic_error),
    with403: r.with403<t_basic_error>(s_basic_error),
    with404: r.with404<t_basic_error>(s_basic_error),
    withStatus: r.withStatus,
  }),
)

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
    t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_package_version[]>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesGetPackageVersionForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_package_version>(s_package_version),
  withStatus: r.withStatus,
}))

export type PackagesGetPackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesGetPackageVersionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesGetPackageVersionForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_package_version>>

const packagesDeletePackageVersionForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesDeletePackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesDeletePackageVersionForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesRestorePackageVersionForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesRestorePackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesRestorePackageVersionForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const projectsCreateForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_project>(s_project),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error_simple>(s_validation_error_simple),
  withStatus: r.withStatus,
}))

export type ProjectsCreateForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_ProjectsCreateForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof projectsCreateForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_project>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error_simple>
>

const usersListPublicEmailsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_email[]>(z.array(s_email)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListPublicEmailsForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListPublicEmailsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListPublicEmailsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_email[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposListForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_repository[]>(z.array(s_repository)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposListForAuthenticatedUser = (
  params: Params<void, t_ReposListForAuthenticatedUserQuerySchema, void, void>,
  respond: (typeof reposListForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<422, t_validation_error>
>

const reposCreateForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_full_repository>(s_full_repository),
  with304: r.with304<void>(z.undefined()),
  with400: r.with400<t_scim_error>(s_scim_error),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ReposCreateForAuthenticatedUser = (
  params: Params<void, void, t_ReposCreateForAuthenticatedUserBodySchema, void>,
  respond: (typeof reposCreateForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_full_repository>
  | Response<304, void>
  | Response<400, t_scim_error>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const reposListInvitationsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_repository_invitation[]>(
    z.array(s_repository_invitation),
  ),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposListInvitationsForAuthenticatedUser = (
  params: Params<
    void,
    t_ReposListInvitationsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListInvitationsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_repository_invitation[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const reposAcceptInvitationForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposAcceptInvitationForAuthenticatedUser = (
  params: Params<
    t_ReposAcceptInvitationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposAcceptInvitationForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const reposDeclineInvitationForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with409: r.with409<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ReposDeclineInvitationForAuthenticatedUser = (
  params: Params<
    t_ReposDeclineInvitationForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof reposDeclineInvitationForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<409, t_basic_error>
>

const usersListSocialAccountsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_social_account[]>(z.array(s_social_account)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListSocialAccountsForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListSocialAccountsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListSocialAccountsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_social_account[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersAddSocialAccountForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_social_account[]>(z.array(s_social_account)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersAddSocialAccountForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersAddSocialAccountForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof usersAddSocialAccountForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_social_account[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersDeleteSocialAccountForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersDeleteSocialAccountForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersDeleteSocialAccountForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof usersDeleteSocialAccountForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersListSshSigningKeysForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_ssh_signing_key[]>(z.array(s_ssh_signing_key)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListSshSigningKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListSshSigningKeysForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ssh_signing_key[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersCreateSshSigningKeyForAuthenticatedUser = b((r) => ({
  with201: r.with201<t_ssh_signing_key>(s_ssh_signing_key),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersCreateSshSigningKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreateSshSigningKeyForAuthenticatedUserBodySchema,
    void
  >,
  respond: (typeof usersCreateSshSigningKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<201, t_ssh_signing_key>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const usersGetSshSigningKeyForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_ssh_signing_key>(s_ssh_signing_key),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersGetSshSigningKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof usersGetSshSigningKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_ssh_signing_key>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersDeleteSshSigningKeyForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersDeleteSshSigningKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof usersDeleteSshSigningKeyForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const activityListReposStarredByAuthenticatedUser = b((r) => ({
  with200: r.with200<t_starred_repository[]>(z.array(s_starred_repository)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityListReposStarredByAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListReposStarredByAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListReposStarredByAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_starred_repository[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const activityCheckRepoIsStarredByAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityCheckRepoIsStarredByAuthenticatedUser = (
  params: Params<
    t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof activityCheckRepoIsStarredByAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const activityStarRepoForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityStarRepoForAuthenticatedUser = (
  params: Params<
    t_ActivityStarRepoForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof activityStarRepoForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const activityUnstarRepoForAuthenticatedUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityUnstarRepoForAuthenticatedUser = (
  params: Params<
    t_ActivityUnstarRepoForAuthenticatedUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof activityUnstarRepoForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const activityListWatchedReposForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  with304: r.with304<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type ActivityListWatchedReposForAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListWatchedReposForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListWatchedReposForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_minimal_repository[]>
  | Response<304, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const teamsListForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_team_full[]>(z.array(s_team_full)),
  with304: r.with304<void>(z.undefined()),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type TeamsListForAuthenticatedUser = (
  params: Params<void, t_TeamsListForAuthenticatedUserQuerySchema, void, void>,
  respond: (typeof teamsListForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_team_full[]>
  | Response<304, void>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const usersGetById = b((r) => ({
  with200: r.with200<t_private_user | t_public_user>(
    z.union([s_private_user, s_public_user]),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersGetById = (
  params: Params<t_UsersGetByIdParamSchema, void, void, void>,
  respond: (typeof usersGetById)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_private_user | t_public_user>
  | Response<404, t_basic_error>
>

const usersList = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  with304: r.with304<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type UsersList = (
  params: Params<void, t_UsersListQuerySchema, void, void>,
  respond: (typeof usersList)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_simple_user[]>
  | Response<304, void>
>

const usersGetByUsername = b((r) => ({
  with200: r.with200<t_private_user | t_public_user>(
    z.union([s_private_user, s_public_user]),
  ),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersGetByUsername = (
  params: Params<t_UsersGetByUsernameParamSchema, void, void, void>,
  respond: (typeof usersGetByUsername)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_private_user | t_public_user>
  | Response<404, t_basic_error>
>

const usersListAttestations = b((r) => ({
  with200: r.with200<{
    attestations?: {
      bundle?: {
        dsseEnvelope?: {
          [key: string]: unknown | undefined
        }
        mediaType?: string
        verificationMaterial?: {
          [key: string]: unknown | undefined
        }
      }
      bundle_url?: string
      repository_id?: number
    }[]
  }>(
    z.object({
      attestations: z
        .array(
          z.object({
            bundle: z
              .object({
                mediaType: z.string().optional(),
                verificationMaterial: z.record(z.unknown()).optional(),
                dsseEnvelope: z.record(z.unknown()).optional(),
              })
              .optional(),
            repository_id: z.coerce.number().optional(),
            bundle_url: z.string().optional(),
          }),
        )
        .optional(),
    }),
  ),
  with201: r.with201<t_empty_object>(s_empty_object),
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type UsersListAttestations = (
  params: Params<
    t_UsersListAttestationsParamSchema,
    t_UsersListAttestationsQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListAttestations)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<
      200,
      {
        attestations?: {
          bundle?: {
            dsseEnvelope?: {
              [key: string]: unknown | undefined
            }
            mediaType?: string
            verificationMaterial?: {
              [key: string]: unknown | undefined
            }
          }
          bundle_url?: string
          repository_id?: number
        }[]
      }
    >
  | Response<201, t_empty_object>
  | Response<204, void>
  | Response<404, t_basic_error>
>

const packagesListDockerMigrationConflictingPackagesForUser = b((r) => ({
  with200: r.with200<t_package[]>(z.array(s_package)),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesListDockerMigrationConflictingPackagesForUser = (
  params: Params<
    t_PackagesListDockerMigrationConflictingPackagesForUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesListDockerMigrationConflictingPackagesForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_package[]>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const activityListEventsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  withStatus: r.withStatus,
}))

export type ActivityListEventsForAuthenticatedUser = (
  params: Params<
    t_ActivityListEventsForAuthenticatedUserParamSchema,
    t_ActivityListEventsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListEventsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_event[]>>

const activityListOrgEventsForAuthenticatedUser = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  withStatus: r.withStatus,
}))

export type ActivityListOrgEventsForAuthenticatedUser = (
  params: Params<
    t_ActivityListOrgEventsForAuthenticatedUserParamSchema,
    t_ActivityListOrgEventsForAuthenticatedUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListOrgEventsForAuthenticatedUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_event[]>>

const activityListPublicEventsForUser = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  withStatus: r.withStatus,
}))

export type ActivityListPublicEventsForUser = (
  params: Params<
    t_ActivityListPublicEventsForUserParamSchema,
    t_ActivityListPublicEventsForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListPublicEventsForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_event[]>>

const usersListFollowersForUser = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  withStatus: r.withStatus,
}))

export type UsersListFollowersForUser = (
  params: Params<
    t_UsersListFollowersForUserParamSchema,
    t_UsersListFollowersForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListFollowersForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_user[]>>

const usersListFollowingForUser = b((r) => ({
  with200: r.with200<t_simple_user[]>(z.array(s_simple_user)),
  withStatus: r.withStatus,
}))

export type UsersListFollowingForUser = (
  params: Params<
    t_UsersListFollowingForUserParamSchema,
    t_UsersListFollowingForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListFollowingForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_simple_user[]>>

const usersCheckFollowingForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with404: r.with404<void>(z.undefined()),
  withStatus: r.withStatus,
}))

export type UsersCheckFollowingForUser = (
  params: Params<t_UsersCheckFollowingForUserParamSchema, void, void, void>,
  respond: (typeof usersCheckFollowingForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<204, void> | Response<404, void>
>

const gistsListForUser = b((r) => ({
  with200: r.with200<t_base_gist[]>(z.array(s_base_gist)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type GistsListForUser = (
  params: Params<
    t_GistsListForUserParamSchema,
    t_GistsListForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof gistsListForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_base_gist[]>
  | Response<422, t_validation_error>
>

const usersListGpgKeysForUser = b((r) => ({
  with200: r.with200<t_gpg_key[]>(z.array(s_gpg_key)),
  withStatus: r.withStatus,
}))

export type UsersListGpgKeysForUser = (
  params: Params<
    t_UsersListGpgKeysForUserParamSchema,
    t_UsersListGpgKeysForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListGpgKeysForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_gpg_key[]>>

const usersGetContextForUser = b((r) => ({
  with200: r.with200<t_hovercard>(s_hovercard),
  with404: r.with404<t_basic_error>(s_basic_error),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type UsersGetContextForUser = (
  params: Params<
    t_UsersGetContextForUserParamSchema,
    t_UsersGetContextForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersGetContextForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_hovercard>
  | Response<404, t_basic_error>
  | Response<422, t_validation_error>
>

const appsGetUserInstallation = b((r) => ({
  with200: r.with200<t_installation>(s_installation),
  withStatus: r.withStatus,
}))

export type AppsGetUserInstallation = (
  params: Params<t_AppsGetUserInstallationParamSchema, void, void, void>,
  respond: (typeof appsGetUserInstallation)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_installation>>

const usersListPublicKeysForUser = b((r) => ({
  with200: r.with200<t_key_simple[]>(z.array(s_key_simple)),
  withStatus: r.withStatus,
}))

export type UsersListPublicKeysForUser = (
  params: Params<
    t_UsersListPublicKeysForUserParamSchema,
    t_UsersListPublicKeysForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListPublicKeysForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_key_simple[]>>

const orgsListForUser = b((r) => ({
  with200: r.with200<t_organization_simple[]>(z.array(s_organization_simple)),
  withStatus: r.withStatus,
}))

export type OrgsListForUser = (
  params: Params<
    t_OrgsListForUserParamSchema,
    t_OrgsListForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof orgsListForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_organization_simple[]>
>

const packagesListPackagesForUser = b((r) => ({
  with200: r.with200<t_package[]>(z.array(s_package)),
  with400: r.with400<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesListPackagesForUser = (
  params: Params<
    t_PackagesListPackagesForUserParamSchema,
    t_PackagesListPackagesForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesListPackagesForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_package[]>
  | Response<400, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
>

const packagesGetPackageForUser = b((r) => ({
  with200: r.with200<t_package>(s_package),
  withStatus: r.withStatus,
}))

export type PackagesGetPackageForUser = (
  params: Params<t_PackagesGetPackageForUserParamSchema, void, void, void>,
  respond: (typeof packagesGetPackageForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_package>>

const packagesDeletePackageForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesDeletePackageForUser = (
  params: Params<t_PackagesDeletePackageForUserParamSchema, void, void, void>,
  respond: (typeof packagesDeletePackageForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesRestorePackageForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesRestorePackageForUser = (
  params: Params<
    t_PackagesRestorePackageForUserParamSchema,
    t_PackagesRestorePackageForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof packagesRestorePackageForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesGetAllPackageVersionsForPackageOwnedByUser = b((r) => ({
  with200: r.with200<t_package_version[]>(z.array(s_package_version)),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesGetAllPackageVersionsForPackageOwnedByUser = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesGetAllPackageVersionsForPackageOwnedByUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_package_version[]>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesGetPackageVersionForUser = b((r) => ({
  with200: r.with200<t_package_version>(s_package_version),
  withStatus: r.withStatus,
}))

export type PackagesGetPackageVersionForUser = (
  params: Params<
    t_PackagesGetPackageVersionForUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesGetPackageVersionForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_package_version>>

const packagesDeletePackageVersionForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesDeletePackageVersionForUser = (
  params: Params<
    t_PackagesDeletePackageVersionForUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesDeletePackageVersionForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const packagesRestorePackageVersionForUser = b((r) => ({
  with204: r.with204<void>(z.undefined()),
  with401: r.with401<t_basic_error>(s_basic_error),
  with403: r.with403<t_basic_error>(s_basic_error),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type PackagesRestorePackageVersionForUser = (
  params: Params<
    t_PackagesRestorePackageVersionForUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof packagesRestorePackageVersionForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<401, t_basic_error>
  | Response<403, t_basic_error>
  | Response<404, t_basic_error>
>

const projectsListForUser = b((r) => ({
  with200: r.with200<t_project[]>(z.array(s_project)),
  with422: r.with422<t_validation_error>(s_validation_error),
  withStatus: r.withStatus,
}))

export type ProjectsListForUser = (
  params: Params<
    t_ProjectsListForUserParamSchema,
    t_ProjectsListForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof projectsListForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_project[]>
  | Response<422, t_validation_error>
>

const activityListReceivedEventsForUser = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  withStatus: r.withStatus,
}))

export type ActivityListReceivedEventsForUser = (
  params: Params<
    t_ActivityListReceivedEventsForUserParamSchema,
    t_ActivityListReceivedEventsForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListReceivedEventsForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_event[]>>

const activityListReceivedPublicEventsForUser = b((r) => ({
  with200: r.with200<t_event[]>(z.array(s_event)),
  withStatus: r.withStatus,
}))

export type ActivityListReceivedPublicEventsForUser = (
  params: Params<
    t_ActivityListReceivedPublicEventsForUserParamSchema,
    t_ActivityListReceivedPublicEventsForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListReceivedPublicEventsForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_event[]>>

const reposListForUser = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  withStatus: r.withStatus,
}))

export type ReposListForUser = (
  params: Params<
    t_ReposListForUserParamSchema,
    t_ReposListForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof reposListForUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_minimal_repository[]>
>

const billingGetGithubActionsBillingUser = b((r) => ({
  with200: r.with200<t_actions_billing_usage>(s_actions_billing_usage),
  withStatus: r.withStatus,
}))

export type BillingGetGithubActionsBillingUser = (
  params: Params<
    t_BillingGetGithubActionsBillingUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof billingGetGithubActionsBillingUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_actions_billing_usage>
>

const billingGetGithubPackagesBillingUser = b((r) => ({
  with200: r.with200<t_packages_billing_usage>(s_packages_billing_usage),
  withStatus: r.withStatus,
}))

export type BillingGetGithubPackagesBillingUser = (
  params: Params<
    t_BillingGetGithubPackagesBillingUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof billingGetGithubPackagesBillingUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_packages_billing_usage>
>

const billingGetSharedStorageBillingUser = b((r) => ({
  with200: r.with200<t_combined_billing_usage>(s_combined_billing_usage),
  withStatus: r.withStatus,
}))

export type BillingGetSharedStorageBillingUser = (
  params: Params<
    t_BillingGetSharedStorageBillingUserParamSchema,
    void,
    void,
    void
  >,
  respond: (typeof billingGetSharedStorageBillingUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_combined_billing_usage>
>

const usersListSocialAccountsForUser = b((r) => ({
  with200: r.with200<t_social_account[]>(z.array(s_social_account)),
  withStatus: r.withStatus,
}))

export type UsersListSocialAccountsForUser = (
  params: Params<
    t_UsersListSocialAccountsForUserParamSchema,
    t_UsersListSocialAccountsForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListSocialAccountsForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_social_account[]>>

const usersListSshSigningKeysForUser = b((r) => ({
  with200: r.with200<t_ssh_signing_key[]>(z.array(s_ssh_signing_key)),
  withStatus: r.withStatus,
}))

export type UsersListSshSigningKeysForUser = (
  params: Params<
    t_UsersListSshSigningKeysForUserParamSchema,
    t_UsersListSshSigningKeysForUserQuerySchema,
    void,
    void
  >,
  respond: (typeof usersListSshSigningKeysForUser)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, t_ssh_signing_key[]>>

const activityListReposStarredByUser = b((r) => ({
  with200: r.with200<t_starred_repository[] | t_repository[]>(
    z.union([z.array(s_starred_repository), z.array(s_repository)]),
  ),
  withStatus: r.withStatus,
}))

export type ActivityListReposStarredByUser = (
  params: Params<
    t_ActivityListReposStarredByUserParamSchema,
    t_ActivityListReposStarredByUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListReposStarredByUser)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_starred_repository[] | t_repository[]>
>

const activityListReposWatchedByUser = b((r) => ({
  with200: r.with200<t_minimal_repository[]>(z.array(s_minimal_repository)),
  withStatus: r.withStatus,
}))

export type ActivityListReposWatchedByUser = (
  params: Params<
    t_ActivityListReposWatchedByUserParamSchema,
    t_ActivityListReposWatchedByUserQuerySchema,
    void,
    void
  >,
  respond: (typeof activityListReposWatchedByUser)["responder"],
  ctx: RouterContext,
) => Promise<
  KoaRuntimeResponse<unknown> | Response<200, t_minimal_repository[]>
>

const metaGetAllVersions = b((r) => ({
  with200: r.with200<string[]>(z.array(z.string())),
  with404: r.with404<t_basic_error>(s_basic_error),
  withStatus: r.withStatus,
}))

export type MetaGetAllVersions = (
  params: Params<void, void, void, void>,
  respond: (typeof metaGetAllVersions)["responder"],
  ctx: RouterContext,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, string[]>
  | Response<404, t_basic_error>
>

const metaGetZen = b((r) => ({
  with200: r.with200<string>(z.string()),
  withStatus: r.withStatus,
}))

export type MetaGetZen = (
  params: Params<void, void, void, void>,
  respond: (typeof metaGetZen)["responder"],
  ctx: RouterContext,
) => Promise<KoaRuntimeResponse<unknown> | Response<200, string>>

export type Implementation = {
  metaRoot: MetaRoot
  securityAdvisoriesListGlobalAdvisories: SecurityAdvisoriesListGlobalAdvisories
  securityAdvisoriesGetGlobalAdvisory: SecurityAdvisoriesGetGlobalAdvisory
  appsGetAuthenticated: AppsGetAuthenticated
  appsCreateFromManifest: AppsCreateFromManifest
  appsGetWebhookConfigForApp: AppsGetWebhookConfigForApp
  appsUpdateWebhookConfigForApp: AppsUpdateWebhookConfigForApp
  appsListWebhookDeliveries: AppsListWebhookDeliveries
  appsGetWebhookDelivery: AppsGetWebhookDelivery
  appsRedeliverWebhookDelivery: AppsRedeliverWebhookDelivery
  appsListInstallationRequestsForAuthenticatedApp: AppsListInstallationRequestsForAuthenticatedApp
  appsListInstallations: AppsListInstallations
  appsGetInstallation: AppsGetInstallation
  appsDeleteInstallation: AppsDeleteInstallation
  appsCreateInstallationAccessToken: AppsCreateInstallationAccessToken
  appsSuspendInstallation: AppsSuspendInstallation
  appsUnsuspendInstallation: AppsUnsuspendInstallation
  appsDeleteAuthorization: AppsDeleteAuthorization
  appsCheckToken: AppsCheckToken
  appsResetToken: AppsResetToken
  appsDeleteToken: AppsDeleteToken
  appsScopeToken: AppsScopeToken
  appsGetBySlug: AppsGetBySlug
  classroomGetAnAssignment: ClassroomGetAnAssignment
  classroomListAcceptedAssignmentsForAnAssignment: ClassroomListAcceptedAssignmentsForAnAssignment
  classroomGetAssignmentGrades: ClassroomGetAssignmentGrades
  classroomListClassrooms: ClassroomListClassrooms
  classroomGetAClassroom: ClassroomGetAClassroom
  classroomListAssignmentsForAClassroom: ClassroomListAssignmentsForAClassroom
  codesOfConductGetAllCodesOfConduct: CodesOfConductGetAllCodesOfConduct
  codesOfConductGetConductCode: CodesOfConductGetConductCode
  emojisGet: EmojisGet
  codeSecurityGetConfigurationsForEnterprise: CodeSecurityGetConfigurationsForEnterprise
  codeSecurityCreateConfigurationForEnterprise: CodeSecurityCreateConfigurationForEnterprise
  codeSecurityGetDefaultConfigurationsForEnterprise: CodeSecurityGetDefaultConfigurationsForEnterprise
  codeSecurityGetSingleConfigurationForEnterprise: CodeSecurityGetSingleConfigurationForEnterprise
  codeSecurityUpdateEnterpriseConfiguration: CodeSecurityUpdateEnterpriseConfiguration
  codeSecurityDeleteConfigurationForEnterprise: CodeSecurityDeleteConfigurationForEnterprise
  codeSecurityAttachEnterpriseConfiguration: CodeSecurityAttachEnterpriseConfiguration
  codeSecuritySetConfigurationAsDefaultForEnterprise: CodeSecuritySetConfigurationAsDefaultForEnterprise
  codeSecurityGetRepositoriesForEnterpriseConfiguration: CodeSecurityGetRepositoriesForEnterpriseConfiguration
  dependabotListAlertsForEnterprise: DependabotListAlertsForEnterprise
  secretScanningListAlertsForEnterprise: SecretScanningListAlertsForEnterprise
  activityListPublicEvents: ActivityListPublicEvents
  activityGetFeeds: ActivityGetFeeds
  gistsList: GistsList
  gistsCreate: GistsCreate
  gistsListPublic: GistsListPublic
  gistsListStarred: GistsListStarred
  gistsGet: GistsGet
  gistsUpdate: GistsUpdate
  gistsDelete: GistsDelete
  gistsListComments: GistsListComments
  gistsCreateComment: GistsCreateComment
  gistsGetComment: GistsGetComment
  gistsUpdateComment: GistsUpdateComment
  gistsDeleteComment: GistsDeleteComment
  gistsListCommits: GistsListCommits
  gistsListForks: GistsListForks
  gistsFork: GistsFork
  gistsCheckIsStarred: GistsCheckIsStarred
  gistsStar: GistsStar
  gistsUnstar: GistsUnstar
  gistsGetRevision: GistsGetRevision
  gitignoreGetAllTemplates: GitignoreGetAllTemplates
  gitignoreGetTemplate: GitignoreGetTemplate
  appsListReposAccessibleToInstallation: AppsListReposAccessibleToInstallation
  appsRevokeInstallationAccessToken: AppsRevokeInstallationAccessToken
  issuesList: IssuesList
  licensesGetAllCommonlyUsed: LicensesGetAllCommonlyUsed
  licensesGet: LicensesGet
  markdownRender: MarkdownRender
  markdownRenderRaw: MarkdownRenderRaw
  appsGetSubscriptionPlanForAccount: AppsGetSubscriptionPlanForAccount
  appsListPlans: AppsListPlans
  appsListAccountsForPlan: AppsListAccountsForPlan
  appsGetSubscriptionPlanForAccountStubbed: AppsGetSubscriptionPlanForAccountStubbed
  appsListPlansStubbed: AppsListPlansStubbed
  appsListAccountsForPlanStubbed: AppsListAccountsForPlanStubbed
  metaGet: MetaGet
  activityListPublicEventsForRepoNetwork: ActivityListPublicEventsForRepoNetwork
  activityListNotificationsForAuthenticatedUser: ActivityListNotificationsForAuthenticatedUser
  activityMarkNotificationsAsRead: ActivityMarkNotificationsAsRead
  activityGetThread: ActivityGetThread
  activityMarkThreadAsRead: ActivityMarkThreadAsRead
  activityMarkThreadAsDone: ActivityMarkThreadAsDone
  activityGetThreadSubscriptionForAuthenticatedUser: ActivityGetThreadSubscriptionForAuthenticatedUser
  activitySetThreadSubscription: ActivitySetThreadSubscription
  activityDeleteThreadSubscription: ActivityDeleteThreadSubscription
  metaGetOctocat: MetaGetOctocat
  orgsList: OrgsList
  billingGetGithubBillingUsageReportOrg: BillingGetGithubBillingUsageReportOrg
  orgsGet: OrgsGet
  orgsUpdate: OrgsUpdate
  orgsDelete: OrgsDelete
  actionsGetActionsCacheUsageForOrg: ActionsGetActionsCacheUsageForOrg
  actionsGetActionsCacheUsageByRepoForOrg: ActionsGetActionsCacheUsageByRepoForOrg
  actionsListHostedRunnersForOrg: ActionsListHostedRunnersForOrg
  actionsCreateHostedRunnerForOrg: ActionsCreateHostedRunnerForOrg
  actionsGetHostedRunnersGithubOwnedImagesForOrg: ActionsGetHostedRunnersGithubOwnedImagesForOrg
  actionsGetHostedRunnersPartnerImagesForOrg: ActionsGetHostedRunnersPartnerImagesForOrg
  actionsGetHostedRunnersLimitsForOrg: ActionsGetHostedRunnersLimitsForOrg
  actionsGetHostedRunnersMachineSpecsForOrg: ActionsGetHostedRunnersMachineSpecsForOrg
  actionsGetHostedRunnersPlatformsForOrg: ActionsGetHostedRunnersPlatformsForOrg
  actionsGetHostedRunnerForOrg: ActionsGetHostedRunnerForOrg
  actionsUpdateHostedRunnerForOrg: ActionsUpdateHostedRunnerForOrg
  actionsDeleteHostedRunnerForOrg: ActionsDeleteHostedRunnerForOrg
  oidcGetOidcCustomSubTemplateForOrg: OidcGetOidcCustomSubTemplateForOrg
  oidcUpdateOidcCustomSubTemplateForOrg: OidcUpdateOidcCustomSubTemplateForOrg
  actionsGetGithubActionsPermissionsOrganization: ActionsGetGithubActionsPermissionsOrganization
  actionsSetGithubActionsPermissionsOrganization: ActionsSetGithubActionsPermissionsOrganization
  actionsListSelectedRepositoriesEnabledGithubActionsOrganization: ActionsListSelectedRepositoriesEnabledGithubActionsOrganization
  actionsSetSelectedRepositoriesEnabledGithubActionsOrganization: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization
  actionsEnableSelectedRepositoryGithubActionsOrganization: ActionsEnableSelectedRepositoryGithubActionsOrganization
  actionsDisableSelectedRepositoryGithubActionsOrganization: ActionsDisableSelectedRepositoryGithubActionsOrganization
  actionsGetAllowedActionsOrganization: ActionsGetAllowedActionsOrganization
  actionsSetAllowedActionsOrganization: ActionsSetAllowedActionsOrganization
  actionsGetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization
  actionsSetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization
  actionsListSelfHostedRunnerGroupsForOrg: ActionsListSelfHostedRunnerGroupsForOrg
  actionsCreateSelfHostedRunnerGroupForOrg: ActionsCreateSelfHostedRunnerGroupForOrg
  actionsGetSelfHostedRunnerGroupForOrg: ActionsGetSelfHostedRunnerGroupForOrg
  actionsUpdateSelfHostedRunnerGroupForOrg: ActionsUpdateSelfHostedRunnerGroupForOrg
  actionsDeleteSelfHostedRunnerGroupFromOrg: ActionsDeleteSelfHostedRunnerGroupFromOrg
  actionsListGithubHostedRunnersInGroupForOrg: ActionsListGithubHostedRunnersInGroupForOrg
  actionsListRepoAccessToSelfHostedRunnerGroupInOrg: ActionsListRepoAccessToSelfHostedRunnerGroupInOrg
  actionsSetRepoAccessToSelfHostedRunnerGroupInOrg: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg
  actionsAddRepoAccessToSelfHostedRunnerGroupInOrg: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg
  actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
  actionsListSelfHostedRunnersInGroupForOrg: ActionsListSelfHostedRunnersInGroupForOrg
  actionsSetSelfHostedRunnersInGroupForOrg: ActionsSetSelfHostedRunnersInGroupForOrg
  actionsAddSelfHostedRunnerToGroupForOrg: ActionsAddSelfHostedRunnerToGroupForOrg
  actionsRemoveSelfHostedRunnerFromGroupForOrg: ActionsRemoveSelfHostedRunnerFromGroupForOrg
  actionsListSelfHostedRunnersForOrg: ActionsListSelfHostedRunnersForOrg
  actionsListRunnerApplicationsForOrg: ActionsListRunnerApplicationsForOrg
  actionsGenerateRunnerJitconfigForOrg: ActionsGenerateRunnerJitconfigForOrg
  actionsCreateRegistrationTokenForOrg: ActionsCreateRegistrationTokenForOrg
  actionsCreateRemoveTokenForOrg: ActionsCreateRemoveTokenForOrg
  actionsGetSelfHostedRunnerForOrg: ActionsGetSelfHostedRunnerForOrg
  actionsDeleteSelfHostedRunnerFromOrg: ActionsDeleteSelfHostedRunnerFromOrg
  actionsListLabelsForSelfHostedRunnerForOrg: ActionsListLabelsForSelfHostedRunnerForOrg
  actionsAddCustomLabelsToSelfHostedRunnerForOrg: ActionsAddCustomLabelsToSelfHostedRunnerForOrg
  actionsSetCustomLabelsForSelfHostedRunnerForOrg: ActionsSetCustomLabelsForSelfHostedRunnerForOrg
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg
  actionsRemoveCustomLabelFromSelfHostedRunnerForOrg: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg
  actionsListOrgSecrets: ActionsListOrgSecrets
  actionsGetOrgPublicKey: ActionsGetOrgPublicKey
  actionsGetOrgSecret: ActionsGetOrgSecret
  actionsCreateOrUpdateOrgSecret: ActionsCreateOrUpdateOrgSecret
  actionsDeleteOrgSecret: ActionsDeleteOrgSecret
  actionsListSelectedReposForOrgSecret: ActionsListSelectedReposForOrgSecret
  actionsSetSelectedReposForOrgSecret: ActionsSetSelectedReposForOrgSecret
  actionsAddSelectedRepoToOrgSecret: ActionsAddSelectedRepoToOrgSecret
  actionsRemoveSelectedRepoFromOrgSecret: ActionsRemoveSelectedRepoFromOrgSecret
  actionsListOrgVariables: ActionsListOrgVariables
  actionsCreateOrgVariable: ActionsCreateOrgVariable
  actionsGetOrgVariable: ActionsGetOrgVariable
  actionsUpdateOrgVariable: ActionsUpdateOrgVariable
  actionsDeleteOrgVariable: ActionsDeleteOrgVariable
  actionsListSelectedReposForOrgVariable: ActionsListSelectedReposForOrgVariable
  actionsSetSelectedReposForOrgVariable: ActionsSetSelectedReposForOrgVariable
  actionsAddSelectedRepoToOrgVariable: ActionsAddSelectedRepoToOrgVariable
  actionsRemoveSelectedRepoFromOrgVariable: ActionsRemoveSelectedRepoFromOrgVariable
  orgsListAttestations: OrgsListAttestations
  orgsListBlockedUsers: OrgsListBlockedUsers
  orgsCheckBlockedUser: OrgsCheckBlockedUser
  orgsBlockUser: OrgsBlockUser
  orgsUnblockUser: OrgsUnblockUser
  campaignsListOrgCampaigns: CampaignsListOrgCampaigns
  campaignsCreateCampaign: CampaignsCreateCampaign
  campaignsGetCampaignSummary: CampaignsGetCampaignSummary
  campaignsUpdateCampaign: CampaignsUpdateCampaign
  campaignsDeleteCampaign: CampaignsDeleteCampaign
  codeScanningListAlertsForOrg: CodeScanningListAlertsForOrg
  codeSecurityGetConfigurationsForOrg: CodeSecurityGetConfigurationsForOrg
  codeSecurityCreateConfiguration: CodeSecurityCreateConfiguration
  codeSecurityGetDefaultConfigurations: CodeSecurityGetDefaultConfigurations
  codeSecurityDetachConfiguration: CodeSecurityDetachConfiguration
  codeSecurityGetConfiguration: CodeSecurityGetConfiguration
  codeSecurityUpdateConfiguration: CodeSecurityUpdateConfiguration
  codeSecurityDeleteConfiguration: CodeSecurityDeleteConfiguration
  codeSecurityAttachConfiguration: CodeSecurityAttachConfiguration
  codeSecuritySetConfigurationAsDefault: CodeSecuritySetConfigurationAsDefault
  codeSecurityGetRepositoriesForConfiguration: CodeSecurityGetRepositoriesForConfiguration
  codespacesListInOrganization: CodespacesListInOrganization
  codespacesSetCodespacesAccess: CodespacesSetCodespacesAccess
  codespacesSetCodespacesAccessUsers: CodespacesSetCodespacesAccessUsers
  codespacesDeleteCodespacesAccessUsers: CodespacesDeleteCodespacesAccessUsers
  codespacesListOrgSecrets: CodespacesListOrgSecrets
  codespacesGetOrgPublicKey: CodespacesGetOrgPublicKey
  codespacesGetOrgSecret: CodespacesGetOrgSecret
  codespacesCreateOrUpdateOrgSecret: CodespacesCreateOrUpdateOrgSecret
  codespacesDeleteOrgSecret: CodespacesDeleteOrgSecret
  codespacesListSelectedReposForOrgSecret: CodespacesListSelectedReposForOrgSecret
  codespacesSetSelectedReposForOrgSecret: CodespacesSetSelectedReposForOrgSecret
  codespacesAddSelectedRepoToOrgSecret: CodespacesAddSelectedRepoToOrgSecret
  codespacesRemoveSelectedRepoFromOrgSecret: CodespacesRemoveSelectedRepoFromOrgSecret
  copilotGetCopilotOrganizationDetails: CopilotGetCopilotOrganizationDetails
  copilotListCopilotSeats: CopilotListCopilotSeats
  copilotAddCopilotSeatsForTeams: CopilotAddCopilotSeatsForTeams
  copilotCancelCopilotSeatAssignmentForTeams: CopilotCancelCopilotSeatAssignmentForTeams
  copilotAddCopilotSeatsForUsers: CopilotAddCopilotSeatsForUsers
  copilotCancelCopilotSeatAssignmentForUsers: CopilotCancelCopilotSeatAssignmentForUsers
  copilotCopilotMetricsForOrganization: CopilotCopilotMetricsForOrganization
  dependabotListAlertsForOrg: DependabotListAlertsForOrg
  dependabotListOrgSecrets: DependabotListOrgSecrets
  dependabotGetOrgPublicKey: DependabotGetOrgPublicKey
  dependabotGetOrgSecret: DependabotGetOrgSecret
  dependabotCreateOrUpdateOrgSecret: DependabotCreateOrUpdateOrgSecret
  dependabotDeleteOrgSecret: DependabotDeleteOrgSecret
  dependabotListSelectedReposForOrgSecret: DependabotListSelectedReposForOrgSecret
  dependabotSetSelectedReposForOrgSecret: DependabotSetSelectedReposForOrgSecret
  dependabotAddSelectedRepoToOrgSecret: DependabotAddSelectedRepoToOrgSecret
  dependabotRemoveSelectedRepoFromOrgSecret: DependabotRemoveSelectedRepoFromOrgSecret
  packagesListDockerMigrationConflictingPackagesForOrganization: PackagesListDockerMigrationConflictingPackagesForOrganization
  activityListPublicOrgEvents: ActivityListPublicOrgEvents
  orgsListFailedInvitations: OrgsListFailedInvitations
  orgsListWebhooks: OrgsListWebhooks
  orgsCreateWebhook: OrgsCreateWebhook
  orgsGetWebhook: OrgsGetWebhook
  orgsUpdateWebhook: OrgsUpdateWebhook
  orgsDeleteWebhook: OrgsDeleteWebhook
  orgsGetWebhookConfigForOrg: OrgsGetWebhookConfigForOrg
  orgsUpdateWebhookConfigForOrg: OrgsUpdateWebhookConfigForOrg
  orgsListWebhookDeliveries: OrgsListWebhookDeliveries
  orgsGetWebhookDelivery: OrgsGetWebhookDelivery
  orgsRedeliverWebhookDelivery: OrgsRedeliverWebhookDelivery
  orgsPingWebhook: OrgsPingWebhook
  apiInsightsGetRouteStatsByActor: ApiInsightsGetRouteStatsByActor
  apiInsightsGetSubjectStats: ApiInsightsGetSubjectStats
  apiInsightsGetSummaryStats: ApiInsightsGetSummaryStats
  apiInsightsGetSummaryStatsByUser: ApiInsightsGetSummaryStatsByUser
  apiInsightsGetSummaryStatsByActor: ApiInsightsGetSummaryStatsByActor
  apiInsightsGetTimeStats: ApiInsightsGetTimeStats
  apiInsightsGetTimeStatsByUser: ApiInsightsGetTimeStatsByUser
  apiInsightsGetTimeStatsByActor: ApiInsightsGetTimeStatsByActor
  apiInsightsGetUserStats: ApiInsightsGetUserStats
  appsGetOrgInstallation: AppsGetOrgInstallation
  orgsListAppInstallations: OrgsListAppInstallations
  interactionsGetRestrictionsForOrg: InteractionsGetRestrictionsForOrg
  interactionsSetRestrictionsForOrg: InteractionsSetRestrictionsForOrg
  interactionsRemoveRestrictionsForOrg: InteractionsRemoveRestrictionsForOrg
  orgsListPendingInvitations: OrgsListPendingInvitations
  orgsCreateInvitation: OrgsCreateInvitation
  orgsCancelInvitation: OrgsCancelInvitation
  orgsListInvitationTeams: OrgsListInvitationTeams
  orgsListIssueTypes: OrgsListIssueTypes
  orgsCreateIssueType: OrgsCreateIssueType
  orgsUpdateIssueType: OrgsUpdateIssueType
  orgsDeleteIssueType: OrgsDeleteIssueType
  issuesListForOrg: IssuesListForOrg
  orgsListMembers: OrgsListMembers
  orgsCheckMembershipForUser: OrgsCheckMembershipForUser
  orgsRemoveMember: OrgsRemoveMember
  codespacesGetCodespacesForUserInOrg: CodespacesGetCodespacesForUserInOrg
  codespacesDeleteFromOrganization: CodespacesDeleteFromOrganization
  codespacesStopInOrganization: CodespacesStopInOrganization
  copilotGetCopilotSeatDetailsForUser: CopilotGetCopilotSeatDetailsForUser
  orgsGetMembershipForUser: OrgsGetMembershipForUser
  orgsSetMembershipForUser: OrgsSetMembershipForUser
  orgsRemoveMembershipForUser: OrgsRemoveMembershipForUser
  migrationsListForOrg: MigrationsListForOrg
  migrationsStartForOrg: MigrationsStartForOrg
  migrationsGetStatusForOrg: MigrationsGetStatusForOrg
  migrationsDownloadArchiveForOrg: MigrationsDownloadArchiveForOrg
  migrationsDeleteArchiveForOrg: MigrationsDeleteArchiveForOrg
  migrationsUnlockRepoForOrg: MigrationsUnlockRepoForOrg
  migrationsListReposForOrg: MigrationsListReposForOrg
  orgsListOrgRoles: OrgsListOrgRoles
  orgsRevokeAllOrgRolesTeam: OrgsRevokeAllOrgRolesTeam
  orgsAssignTeamToOrgRole: OrgsAssignTeamToOrgRole
  orgsRevokeOrgRoleTeam: OrgsRevokeOrgRoleTeam
  orgsRevokeAllOrgRolesUser: OrgsRevokeAllOrgRolesUser
  orgsAssignUserToOrgRole: OrgsAssignUserToOrgRole
  orgsRevokeOrgRoleUser: OrgsRevokeOrgRoleUser
  orgsGetOrgRole: OrgsGetOrgRole
  orgsListOrgRoleTeams: OrgsListOrgRoleTeams
  orgsListOrgRoleUsers: OrgsListOrgRoleUsers
  orgsListOutsideCollaborators: OrgsListOutsideCollaborators
  orgsConvertMemberToOutsideCollaborator: OrgsConvertMemberToOutsideCollaborator
  orgsRemoveOutsideCollaborator: OrgsRemoveOutsideCollaborator
  packagesListPackagesForOrganization: PackagesListPackagesForOrganization
  packagesGetPackageForOrganization: PackagesGetPackageForOrganization
  packagesDeletePackageForOrg: PackagesDeletePackageForOrg
  packagesRestorePackageForOrg: PackagesRestorePackageForOrg
  packagesGetAllPackageVersionsForPackageOwnedByOrg: PackagesGetAllPackageVersionsForPackageOwnedByOrg
  packagesGetPackageVersionForOrganization: PackagesGetPackageVersionForOrganization
  packagesDeletePackageVersionForOrg: PackagesDeletePackageVersionForOrg
  packagesRestorePackageVersionForOrg: PackagesRestorePackageVersionForOrg
  orgsListPatGrantRequests: OrgsListPatGrantRequests
  orgsReviewPatGrantRequestsInBulk: OrgsReviewPatGrantRequestsInBulk
  orgsReviewPatGrantRequest: OrgsReviewPatGrantRequest
  orgsListPatGrantRequestRepositories: OrgsListPatGrantRequestRepositories
  orgsListPatGrants: OrgsListPatGrants
  orgsUpdatePatAccesses: OrgsUpdatePatAccesses
  orgsUpdatePatAccess: OrgsUpdatePatAccess
  orgsListPatGrantRepositories: OrgsListPatGrantRepositories
  privateRegistriesListOrgPrivateRegistries: PrivateRegistriesListOrgPrivateRegistries
  privateRegistriesCreateOrgPrivateRegistry: PrivateRegistriesCreateOrgPrivateRegistry
  privateRegistriesGetOrgPublicKey: PrivateRegistriesGetOrgPublicKey
  privateRegistriesGetOrgPrivateRegistry: PrivateRegistriesGetOrgPrivateRegistry
  privateRegistriesUpdateOrgPrivateRegistry: PrivateRegistriesUpdateOrgPrivateRegistry
  privateRegistriesDeleteOrgPrivateRegistry: PrivateRegistriesDeleteOrgPrivateRegistry
  projectsListForOrg: ProjectsListForOrg
  projectsCreateForOrg: ProjectsCreateForOrg
  orgsGetAllCustomProperties: OrgsGetAllCustomProperties
  orgsCreateOrUpdateCustomProperties: OrgsCreateOrUpdateCustomProperties
  orgsGetCustomProperty: OrgsGetCustomProperty
  orgsCreateOrUpdateCustomProperty: OrgsCreateOrUpdateCustomProperty
  orgsRemoveCustomProperty: OrgsRemoveCustomProperty
  orgsListCustomPropertiesValuesForRepos: OrgsListCustomPropertiesValuesForRepos
  orgsCreateOrUpdateCustomPropertiesValuesForRepos: OrgsCreateOrUpdateCustomPropertiesValuesForRepos
  orgsListPublicMembers: OrgsListPublicMembers
  orgsCheckPublicMembershipForUser: OrgsCheckPublicMembershipForUser
  orgsSetPublicMembershipForAuthenticatedUser: OrgsSetPublicMembershipForAuthenticatedUser
  orgsRemovePublicMembershipForAuthenticatedUser: OrgsRemovePublicMembershipForAuthenticatedUser
  reposListForOrg: ReposListForOrg
  reposCreateInOrg: ReposCreateInOrg
  reposGetOrgRulesets: ReposGetOrgRulesets
  reposCreateOrgRuleset: ReposCreateOrgRuleset
  reposGetOrgRuleSuites: ReposGetOrgRuleSuites
  reposGetOrgRuleSuite: ReposGetOrgRuleSuite
  reposGetOrgRuleset: ReposGetOrgRuleset
  reposUpdateOrgRuleset: ReposUpdateOrgRuleset
  reposDeleteOrgRuleset: ReposDeleteOrgRuleset
  orgsGetOrgRulesetHistory: OrgsGetOrgRulesetHistory
  orgsGetOrgRulesetVersion: OrgsGetOrgRulesetVersion
  secretScanningListAlertsForOrg: SecretScanningListAlertsForOrg
  securityAdvisoriesListOrgRepositoryAdvisories: SecurityAdvisoriesListOrgRepositoryAdvisories
  orgsListSecurityManagerTeams: OrgsListSecurityManagerTeams
  orgsAddSecurityManagerTeam: OrgsAddSecurityManagerTeam
  orgsRemoveSecurityManagerTeam: OrgsRemoveSecurityManagerTeam
  billingGetGithubActionsBillingOrg: BillingGetGithubActionsBillingOrg
  billingGetGithubPackagesBillingOrg: BillingGetGithubPackagesBillingOrg
  billingGetSharedStorageBillingOrg: BillingGetSharedStorageBillingOrg
  hostedComputeListNetworkConfigurationsForOrg: HostedComputeListNetworkConfigurationsForOrg
  hostedComputeCreateNetworkConfigurationForOrg: HostedComputeCreateNetworkConfigurationForOrg
  hostedComputeGetNetworkConfigurationForOrg: HostedComputeGetNetworkConfigurationForOrg
  hostedComputeUpdateNetworkConfigurationForOrg: HostedComputeUpdateNetworkConfigurationForOrg
  hostedComputeDeleteNetworkConfigurationFromOrg: HostedComputeDeleteNetworkConfigurationFromOrg
  hostedComputeGetNetworkSettingsForOrg: HostedComputeGetNetworkSettingsForOrg
  copilotCopilotMetricsForTeam: CopilotCopilotMetricsForTeam
  teamsList: TeamsList
  teamsCreate: TeamsCreate
  teamsGetByName: TeamsGetByName
  teamsUpdateInOrg: TeamsUpdateInOrg
  teamsDeleteInOrg: TeamsDeleteInOrg
  teamsListDiscussionsInOrg: TeamsListDiscussionsInOrg
  teamsCreateDiscussionInOrg: TeamsCreateDiscussionInOrg
  teamsGetDiscussionInOrg: TeamsGetDiscussionInOrg
  teamsUpdateDiscussionInOrg: TeamsUpdateDiscussionInOrg
  teamsDeleteDiscussionInOrg: TeamsDeleteDiscussionInOrg
  teamsListDiscussionCommentsInOrg: TeamsListDiscussionCommentsInOrg
  teamsCreateDiscussionCommentInOrg: TeamsCreateDiscussionCommentInOrg
  teamsGetDiscussionCommentInOrg: TeamsGetDiscussionCommentInOrg
  teamsUpdateDiscussionCommentInOrg: TeamsUpdateDiscussionCommentInOrg
  teamsDeleteDiscussionCommentInOrg: TeamsDeleteDiscussionCommentInOrg
  reactionsListForTeamDiscussionCommentInOrg: ReactionsListForTeamDiscussionCommentInOrg
  reactionsCreateForTeamDiscussionCommentInOrg: ReactionsCreateForTeamDiscussionCommentInOrg
  reactionsDeleteForTeamDiscussionComment: ReactionsDeleteForTeamDiscussionComment
  reactionsListForTeamDiscussionInOrg: ReactionsListForTeamDiscussionInOrg
  reactionsCreateForTeamDiscussionInOrg: ReactionsCreateForTeamDiscussionInOrg
  reactionsDeleteForTeamDiscussion: ReactionsDeleteForTeamDiscussion
  teamsListPendingInvitationsInOrg: TeamsListPendingInvitationsInOrg
  teamsListMembersInOrg: TeamsListMembersInOrg
  teamsGetMembershipForUserInOrg: TeamsGetMembershipForUserInOrg
  teamsAddOrUpdateMembershipForUserInOrg: TeamsAddOrUpdateMembershipForUserInOrg
  teamsRemoveMembershipForUserInOrg: TeamsRemoveMembershipForUserInOrg
  teamsListProjectsInOrg: TeamsListProjectsInOrg
  teamsCheckPermissionsForProjectInOrg: TeamsCheckPermissionsForProjectInOrg
  teamsAddOrUpdateProjectPermissionsInOrg: TeamsAddOrUpdateProjectPermissionsInOrg
  teamsRemoveProjectInOrg: TeamsRemoveProjectInOrg
  teamsListReposInOrg: TeamsListReposInOrg
  teamsCheckPermissionsForRepoInOrg: TeamsCheckPermissionsForRepoInOrg
  teamsAddOrUpdateRepoPermissionsInOrg: TeamsAddOrUpdateRepoPermissionsInOrg
  teamsRemoveRepoInOrg: TeamsRemoveRepoInOrg
  teamsListChildInOrg: TeamsListChildInOrg
  orgsEnableOrDisableSecurityProductOnAllOrgRepos: OrgsEnableOrDisableSecurityProductOnAllOrgRepos
  projectsGetCard: ProjectsGetCard
  projectsUpdateCard: ProjectsUpdateCard
  projectsDeleteCard: ProjectsDeleteCard
  projectsMoveCard: ProjectsMoveCard
  projectsGetColumn: ProjectsGetColumn
  projectsUpdateColumn: ProjectsUpdateColumn
  projectsDeleteColumn: ProjectsDeleteColumn
  projectsListCards: ProjectsListCards
  projectsCreateCard: ProjectsCreateCard
  projectsMoveColumn: ProjectsMoveColumn
  projectsGet: ProjectsGet
  projectsUpdate: ProjectsUpdate
  projectsDelete: ProjectsDelete
  projectsListCollaborators: ProjectsListCollaborators
  projectsAddCollaborator: ProjectsAddCollaborator
  projectsRemoveCollaborator: ProjectsRemoveCollaborator
  projectsGetPermissionForUser: ProjectsGetPermissionForUser
  projectsListColumns: ProjectsListColumns
  projectsCreateColumn: ProjectsCreateColumn
  rateLimitGet: RateLimitGet
  reposGet: ReposGet
  reposUpdate: ReposUpdate
  reposDelete: ReposDelete
  actionsListArtifactsForRepo: ActionsListArtifactsForRepo
  actionsGetArtifact: ActionsGetArtifact
  actionsDeleteArtifact: ActionsDeleteArtifact
  actionsDownloadArtifact: ActionsDownloadArtifact
  actionsGetActionsCacheUsage: ActionsGetActionsCacheUsage
  actionsGetActionsCacheList: ActionsGetActionsCacheList
  actionsDeleteActionsCacheByKey: ActionsDeleteActionsCacheByKey
  actionsDeleteActionsCacheById: ActionsDeleteActionsCacheById
  actionsGetJobForWorkflowRun: ActionsGetJobForWorkflowRun
  actionsDownloadJobLogsForWorkflowRun: ActionsDownloadJobLogsForWorkflowRun
  actionsReRunJobForWorkflowRun: ActionsReRunJobForWorkflowRun
  actionsGetCustomOidcSubClaimForRepo: ActionsGetCustomOidcSubClaimForRepo
  actionsSetCustomOidcSubClaimForRepo: ActionsSetCustomOidcSubClaimForRepo
  actionsListRepoOrganizationSecrets: ActionsListRepoOrganizationSecrets
  actionsListRepoOrganizationVariables: ActionsListRepoOrganizationVariables
  actionsGetGithubActionsPermissionsRepository: ActionsGetGithubActionsPermissionsRepository
  actionsSetGithubActionsPermissionsRepository: ActionsSetGithubActionsPermissionsRepository
  actionsGetWorkflowAccessToRepository: ActionsGetWorkflowAccessToRepository
  actionsSetWorkflowAccessToRepository: ActionsSetWorkflowAccessToRepository
  actionsGetAllowedActionsRepository: ActionsGetAllowedActionsRepository
  actionsSetAllowedActionsRepository: ActionsSetAllowedActionsRepository
  actionsGetGithubActionsDefaultWorkflowPermissionsRepository: ActionsGetGithubActionsDefaultWorkflowPermissionsRepository
  actionsSetGithubActionsDefaultWorkflowPermissionsRepository: ActionsSetGithubActionsDefaultWorkflowPermissionsRepository
  actionsListSelfHostedRunnersForRepo: ActionsListSelfHostedRunnersForRepo
  actionsListRunnerApplicationsForRepo: ActionsListRunnerApplicationsForRepo
  actionsGenerateRunnerJitconfigForRepo: ActionsGenerateRunnerJitconfigForRepo
  actionsCreateRegistrationTokenForRepo: ActionsCreateRegistrationTokenForRepo
  actionsCreateRemoveTokenForRepo: ActionsCreateRemoveTokenForRepo
  actionsGetSelfHostedRunnerForRepo: ActionsGetSelfHostedRunnerForRepo
  actionsDeleteSelfHostedRunnerFromRepo: ActionsDeleteSelfHostedRunnerFromRepo
  actionsListLabelsForSelfHostedRunnerForRepo: ActionsListLabelsForSelfHostedRunnerForRepo
  actionsAddCustomLabelsToSelfHostedRunnerForRepo: ActionsAddCustomLabelsToSelfHostedRunnerForRepo
  actionsSetCustomLabelsForSelfHostedRunnerForRepo: ActionsSetCustomLabelsForSelfHostedRunnerForRepo
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo
  actionsRemoveCustomLabelFromSelfHostedRunnerForRepo: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo
  actionsListWorkflowRunsForRepo: ActionsListWorkflowRunsForRepo
  actionsGetWorkflowRun: ActionsGetWorkflowRun
  actionsDeleteWorkflowRun: ActionsDeleteWorkflowRun
  actionsGetReviewsForRun: ActionsGetReviewsForRun
  actionsApproveWorkflowRun: ActionsApproveWorkflowRun
  actionsListWorkflowRunArtifacts: ActionsListWorkflowRunArtifacts
  actionsGetWorkflowRunAttempt: ActionsGetWorkflowRunAttempt
  actionsListJobsForWorkflowRunAttempt: ActionsListJobsForWorkflowRunAttempt
  actionsDownloadWorkflowRunAttemptLogs: ActionsDownloadWorkflowRunAttemptLogs
  actionsCancelWorkflowRun: ActionsCancelWorkflowRun
  actionsReviewCustomGatesForRun: ActionsReviewCustomGatesForRun
  actionsForceCancelWorkflowRun: ActionsForceCancelWorkflowRun
  actionsListJobsForWorkflowRun: ActionsListJobsForWorkflowRun
  actionsDownloadWorkflowRunLogs: ActionsDownloadWorkflowRunLogs
  actionsDeleteWorkflowRunLogs: ActionsDeleteWorkflowRunLogs
  actionsGetPendingDeploymentsForRun: ActionsGetPendingDeploymentsForRun
  actionsReviewPendingDeploymentsForRun: ActionsReviewPendingDeploymentsForRun
  actionsReRunWorkflow: ActionsReRunWorkflow
  actionsReRunWorkflowFailedJobs: ActionsReRunWorkflowFailedJobs
  actionsGetWorkflowRunUsage: ActionsGetWorkflowRunUsage
  actionsListRepoSecrets: ActionsListRepoSecrets
  actionsGetRepoPublicKey: ActionsGetRepoPublicKey
  actionsGetRepoSecret: ActionsGetRepoSecret
  actionsCreateOrUpdateRepoSecret: ActionsCreateOrUpdateRepoSecret
  actionsDeleteRepoSecret: ActionsDeleteRepoSecret
  actionsListRepoVariables: ActionsListRepoVariables
  actionsCreateRepoVariable: ActionsCreateRepoVariable
  actionsGetRepoVariable: ActionsGetRepoVariable
  actionsUpdateRepoVariable: ActionsUpdateRepoVariable
  actionsDeleteRepoVariable: ActionsDeleteRepoVariable
  actionsListRepoWorkflows: ActionsListRepoWorkflows
  actionsGetWorkflow: ActionsGetWorkflow
  actionsDisableWorkflow: ActionsDisableWorkflow
  actionsCreateWorkflowDispatch: ActionsCreateWorkflowDispatch
  actionsEnableWorkflow: ActionsEnableWorkflow
  actionsListWorkflowRuns: ActionsListWorkflowRuns
  actionsGetWorkflowUsage: ActionsGetWorkflowUsage
  reposListActivities: ReposListActivities
  issuesListAssignees: IssuesListAssignees
  issuesCheckUserCanBeAssigned: IssuesCheckUserCanBeAssigned
  reposCreateAttestation: ReposCreateAttestation
  reposListAttestations: ReposListAttestations
  reposListAutolinks: ReposListAutolinks
  reposCreateAutolink: ReposCreateAutolink
  reposGetAutolink: ReposGetAutolink
  reposDeleteAutolink: ReposDeleteAutolink
  reposCheckAutomatedSecurityFixes: ReposCheckAutomatedSecurityFixes
  reposEnableAutomatedSecurityFixes: ReposEnableAutomatedSecurityFixes
  reposDisableAutomatedSecurityFixes: ReposDisableAutomatedSecurityFixes
  reposListBranches: ReposListBranches
  reposGetBranch: ReposGetBranch
  reposGetBranchProtection: ReposGetBranchProtection
  reposUpdateBranchProtection: ReposUpdateBranchProtection
  reposDeleteBranchProtection: ReposDeleteBranchProtection
  reposGetAdminBranchProtection: ReposGetAdminBranchProtection
  reposSetAdminBranchProtection: ReposSetAdminBranchProtection
  reposDeleteAdminBranchProtection: ReposDeleteAdminBranchProtection
  reposGetPullRequestReviewProtection: ReposGetPullRequestReviewProtection
  reposUpdatePullRequestReviewProtection: ReposUpdatePullRequestReviewProtection
  reposDeletePullRequestReviewProtection: ReposDeletePullRequestReviewProtection
  reposGetCommitSignatureProtection: ReposGetCommitSignatureProtection
  reposCreateCommitSignatureProtection: ReposCreateCommitSignatureProtection
  reposDeleteCommitSignatureProtection: ReposDeleteCommitSignatureProtection
  reposGetStatusChecksProtection: ReposGetStatusChecksProtection
  reposUpdateStatusCheckProtection: ReposUpdateStatusCheckProtection
  reposRemoveStatusCheckProtection: ReposRemoveStatusCheckProtection
  reposGetAllStatusCheckContexts: ReposGetAllStatusCheckContexts
  reposAddStatusCheckContexts: ReposAddStatusCheckContexts
  reposSetStatusCheckContexts: ReposSetStatusCheckContexts
  reposRemoveStatusCheckContexts: ReposRemoveStatusCheckContexts
  reposGetAccessRestrictions: ReposGetAccessRestrictions
  reposDeleteAccessRestrictions: ReposDeleteAccessRestrictions
  reposGetAppsWithAccessToProtectedBranch: ReposGetAppsWithAccessToProtectedBranch
  reposAddAppAccessRestrictions: ReposAddAppAccessRestrictions
  reposSetAppAccessRestrictions: ReposSetAppAccessRestrictions
  reposRemoveAppAccessRestrictions: ReposRemoveAppAccessRestrictions
  reposGetTeamsWithAccessToProtectedBranch: ReposGetTeamsWithAccessToProtectedBranch
  reposAddTeamAccessRestrictions: ReposAddTeamAccessRestrictions
  reposSetTeamAccessRestrictions: ReposSetTeamAccessRestrictions
  reposRemoveTeamAccessRestrictions: ReposRemoveTeamAccessRestrictions
  reposGetUsersWithAccessToProtectedBranch: ReposGetUsersWithAccessToProtectedBranch
  reposAddUserAccessRestrictions: ReposAddUserAccessRestrictions
  reposSetUserAccessRestrictions: ReposSetUserAccessRestrictions
  reposRemoveUserAccessRestrictions: ReposRemoveUserAccessRestrictions
  reposRenameBranch: ReposRenameBranch
  checksCreate: ChecksCreate
  checksGet: ChecksGet
  checksUpdate: ChecksUpdate
  checksListAnnotations: ChecksListAnnotations
  checksRerequestRun: ChecksRerequestRun
  checksCreateSuite: ChecksCreateSuite
  checksSetSuitesPreferences: ChecksSetSuitesPreferences
  checksGetSuite: ChecksGetSuite
  checksListForSuite: ChecksListForSuite
  checksRerequestSuite: ChecksRerequestSuite
  codeScanningListAlertsForRepo: CodeScanningListAlertsForRepo
  codeScanningGetAlert: CodeScanningGetAlert
  codeScanningUpdateAlert: CodeScanningUpdateAlert
  codeScanningGetAutofix: CodeScanningGetAutofix
  codeScanningCreateAutofix: CodeScanningCreateAutofix
  codeScanningCommitAutofix: CodeScanningCommitAutofix
  codeScanningListAlertInstances: CodeScanningListAlertInstances
  codeScanningListRecentAnalyses: CodeScanningListRecentAnalyses
  codeScanningGetAnalysis: CodeScanningGetAnalysis
  codeScanningDeleteAnalysis: CodeScanningDeleteAnalysis
  codeScanningListCodeqlDatabases: CodeScanningListCodeqlDatabases
  codeScanningGetCodeqlDatabase: CodeScanningGetCodeqlDatabase
  codeScanningDeleteCodeqlDatabase: CodeScanningDeleteCodeqlDatabase
  codeScanningCreateVariantAnalysis: CodeScanningCreateVariantAnalysis
  codeScanningGetVariantAnalysis: CodeScanningGetVariantAnalysis
  codeScanningGetVariantAnalysisRepoTask: CodeScanningGetVariantAnalysisRepoTask
  codeScanningGetDefaultSetup: CodeScanningGetDefaultSetup
  codeScanningUpdateDefaultSetup: CodeScanningUpdateDefaultSetup
  codeScanningUploadSarif: CodeScanningUploadSarif
  codeScanningGetSarif: CodeScanningGetSarif
  codeSecurityGetConfigurationForRepository: CodeSecurityGetConfigurationForRepository
  reposCodeownersErrors: ReposCodeownersErrors
  codespacesListInRepositoryForAuthenticatedUser: CodespacesListInRepositoryForAuthenticatedUser
  codespacesCreateWithRepoForAuthenticatedUser: CodespacesCreateWithRepoForAuthenticatedUser
  codespacesListDevcontainersInRepositoryForAuthenticatedUser: CodespacesListDevcontainersInRepositoryForAuthenticatedUser
  codespacesRepoMachinesForAuthenticatedUser: CodespacesRepoMachinesForAuthenticatedUser
  codespacesPreFlightWithRepoForAuthenticatedUser: CodespacesPreFlightWithRepoForAuthenticatedUser
  codespacesCheckPermissionsForDevcontainer: CodespacesCheckPermissionsForDevcontainer
  codespacesListRepoSecrets: CodespacesListRepoSecrets
  codespacesGetRepoPublicKey: CodespacesGetRepoPublicKey
  codespacesGetRepoSecret: CodespacesGetRepoSecret
  codespacesCreateOrUpdateRepoSecret: CodespacesCreateOrUpdateRepoSecret
  codespacesDeleteRepoSecret: CodespacesDeleteRepoSecret
  reposListCollaborators: ReposListCollaborators
  reposCheckCollaborator: ReposCheckCollaborator
  reposAddCollaborator: ReposAddCollaborator
  reposRemoveCollaborator: ReposRemoveCollaborator
  reposGetCollaboratorPermissionLevel: ReposGetCollaboratorPermissionLevel
  reposListCommitCommentsForRepo: ReposListCommitCommentsForRepo
  reposGetCommitComment: ReposGetCommitComment
  reposUpdateCommitComment: ReposUpdateCommitComment
  reposDeleteCommitComment: ReposDeleteCommitComment
  reactionsListForCommitComment: ReactionsListForCommitComment
  reactionsCreateForCommitComment: ReactionsCreateForCommitComment
  reactionsDeleteForCommitComment: ReactionsDeleteForCommitComment
  reposListCommits: ReposListCommits
  reposListBranchesForHeadCommit: ReposListBranchesForHeadCommit
  reposListCommentsForCommit: ReposListCommentsForCommit
  reposCreateCommitComment: ReposCreateCommitComment
  reposListPullRequestsAssociatedWithCommit: ReposListPullRequestsAssociatedWithCommit
  reposGetCommit: ReposGetCommit
  checksListForRef: ChecksListForRef
  checksListSuitesForRef: ChecksListSuitesForRef
  reposGetCombinedStatusForRef: ReposGetCombinedStatusForRef
  reposListCommitStatusesForRef: ReposListCommitStatusesForRef
  reposGetCommunityProfileMetrics: ReposGetCommunityProfileMetrics
  reposCompareCommits: ReposCompareCommits
  reposGetContent: ReposGetContent
  reposCreateOrUpdateFileContents: ReposCreateOrUpdateFileContents
  reposDeleteFile: ReposDeleteFile
  reposListContributors: ReposListContributors
  dependabotListAlertsForRepo: DependabotListAlertsForRepo
  dependabotGetAlert: DependabotGetAlert
  dependabotUpdateAlert: DependabotUpdateAlert
  dependabotListRepoSecrets: DependabotListRepoSecrets
  dependabotGetRepoPublicKey: DependabotGetRepoPublicKey
  dependabotGetRepoSecret: DependabotGetRepoSecret
  dependabotCreateOrUpdateRepoSecret: DependabotCreateOrUpdateRepoSecret
  dependabotDeleteRepoSecret: DependabotDeleteRepoSecret
  dependencyGraphDiffRange: DependencyGraphDiffRange
  dependencyGraphExportSbom: DependencyGraphExportSbom
  dependencyGraphCreateRepositorySnapshot: DependencyGraphCreateRepositorySnapshot
  reposListDeployments: ReposListDeployments
  reposCreateDeployment: ReposCreateDeployment
  reposGetDeployment: ReposGetDeployment
  reposDeleteDeployment: ReposDeleteDeployment
  reposListDeploymentStatuses: ReposListDeploymentStatuses
  reposCreateDeploymentStatus: ReposCreateDeploymentStatus
  reposGetDeploymentStatus: ReposGetDeploymentStatus
  reposCreateDispatchEvent: ReposCreateDispatchEvent
  reposGetAllEnvironments: ReposGetAllEnvironments
  reposGetEnvironment: ReposGetEnvironment
  reposCreateOrUpdateEnvironment: ReposCreateOrUpdateEnvironment
  reposDeleteAnEnvironment: ReposDeleteAnEnvironment
  reposListDeploymentBranchPolicies: ReposListDeploymentBranchPolicies
  reposCreateDeploymentBranchPolicy: ReposCreateDeploymentBranchPolicy
  reposGetDeploymentBranchPolicy: ReposGetDeploymentBranchPolicy
  reposUpdateDeploymentBranchPolicy: ReposUpdateDeploymentBranchPolicy
  reposDeleteDeploymentBranchPolicy: ReposDeleteDeploymentBranchPolicy
  reposGetAllDeploymentProtectionRules: ReposGetAllDeploymentProtectionRules
  reposCreateDeploymentProtectionRule: ReposCreateDeploymentProtectionRule
  reposListCustomDeploymentRuleIntegrations: ReposListCustomDeploymentRuleIntegrations
  reposGetCustomDeploymentProtectionRule: ReposGetCustomDeploymentProtectionRule
  reposDisableDeploymentProtectionRule: ReposDisableDeploymentProtectionRule
  actionsListEnvironmentSecrets: ActionsListEnvironmentSecrets
  actionsGetEnvironmentPublicKey: ActionsGetEnvironmentPublicKey
  actionsGetEnvironmentSecret: ActionsGetEnvironmentSecret
  actionsCreateOrUpdateEnvironmentSecret: ActionsCreateOrUpdateEnvironmentSecret
  actionsDeleteEnvironmentSecret: ActionsDeleteEnvironmentSecret
  actionsListEnvironmentVariables: ActionsListEnvironmentVariables
  actionsCreateEnvironmentVariable: ActionsCreateEnvironmentVariable
  actionsGetEnvironmentVariable: ActionsGetEnvironmentVariable
  actionsUpdateEnvironmentVariable: ActionsUpdateEnvironmentVariable
  actionsDeleteEnvironmentVariable: ActionsDeleteEnvironmentVariable
  activityListRepoEvents: ActivityListRepoEvents
  reposListForks: ReposListForks
  reposCreateFork: ReposCreateFork
  gitCreateBlob: GitCreateBlob
  gitGetBlob: GitGetBlob
  gitCreateCommit: GitCreateCommit
  gitGetCommit: GitGetCommit
  gitListMatchingRefs: GitListMatchingRefs
  gitGetRef: GitGetRef
  gitCreateRef: GitCreateRef
  gitUpdateRef: GitUpdateRef
  gitDeleteRef: GitDeleteRef
  gitCreateTag: GitCreateTag
  gitGetTag: GitGetTag
  gitCreateTree: GitCreateTree
  gitGetTree: GitGetTree
  reposListWebhooks: ReposListWebhooks
  reposCreateWebhook: ReposCreateWebhook
  reposGetWebhook: ReposGetWebhook
  reposUpdateWebhook: ReposUpdateWebhook
  reposDeleteWebhook: ReposDeleteWebhook
  reposGetWebhookConfigForRepo: ReposGetWebhookConfigForRepo
  reposUpdateWebhookConfigForRepo: ReposUpdateWebhookConfigForRepo
  reposListWebhookDeliveries: ReposListWebhookDeliveries
  reposGetWebhookDelivery: ReposGetWebhookDelivery
  reposRedeliverWebhookDelivery: ReposRedeliverWebhookDelivery
  reposPingWebhook: ReposPingWebhook
  reposTestPushWebhook: ReposTestPushWebhook
  migrationsGetImportStatus: MigrationsGetImportStatus
  migrationsStartImport: MigrationsStartImport
  migrationsUpdateImport: MigrationsUpdateImport
  migrationsCancelImport: MigrationsCancelImport
  migrationsGetCommitAuthors: MigrationsGetCommitAuthors
  migrationsMapCommitAuthor: MigrationsMapCommitAuthor
  migrationsGetLargeFiles: MigrationsGetLargeFiles
  migrationsSetLfsPreference: MigrationsSetLfsPreference
  appsGetRepoInstallation: AppsGetRepoInstallation
  interactionsGetRestrictionsForRepo: InteractionsGetRestrictionsForRepo
  interactionsSetRestrictionsForRepo: InteractionsSetRestrictionsForRepo
  interactionsRemoveRestrictionsForRepo: InteractionsRemoveRestrictionsForRepo
  reposListInvitations: ReposListInvitations
  reposUpdateInvitation: ReposUpdateInvitation
  reposDeleteInvitation: ReposDeleteInvitation
  issuesListForRepo: IssuesListForRepo
  issuesCreate: IssuesCreate
  issuesListCommentsForRepo: IssuesListCommentsForRepo
  issuesGetComment: IssuesGetComment
  issuesUpdateComment: IssuesUpdateComment
  issuesDeleteComment: IssuesDeleteComment
  reactionsListForIssueComment: ReactionsListForIssueComment
  reactionsCreateForIssueComment: ReactionsCreateForIssueComment
  reactionsDeleteForIssueComment: ReactionsDeleteForIssueComment
  issuesListEventsForRepo: IssuesListEventsForRepo
  issuesGetEvent: IssuesGetEvent
  issuesGet: IssuesGet
  issuesUpdate: IssuesUpdate
  issuesAddAssignees: IssuesAddAssignees
  issuesRemoveAssignees: IssuesRemoveAssignees
  issuesCheckUserCanBeAssignedToIssue: IssuesCheckUserCanBeAssignedToIssue
  issuesListComments: IssuesListComments
  issuesCreateComment: IssuesCreateComment
  issuesListEvents: IssuesListEvents
  issuesListLabelsOnIssue: IssuesListLabelsOnIssue
  issuesAddLabels: IssuesAddLabels
  issuesSetLabels: IssuesSetLabels
  issuesRemoveAllLabels: IssuesRemoveAllLabels
  issuesRemoveLabel: IssuesRemoveLabel
  issuesLock: IssuesLock
  issuesUnlock: IssuesUnlock
  reactionsListForIssue: ReactionsListForIssue
  reactionsCreateForIssue: ReactionsCreateForIssue
  reactionsDeleteForIssue: ReactionsDeleteForIssue
  issuesRemoveSubIssue: IssuesRemoveSubIssue
  issuesListSubIssues: IssuesListSubIssues
  issuesAddSubIssue: IssuesAddSubIssue
  issuesReprioritizeSubIssue: IssuesReprioritizeSubIssue
  issuesListEventsForTimeline: IssuesListEventsForTimeline
  reposListDeployKeys: ReposListDeployKeys
  reposCreateDeployKey: ReposCreateDeployKey
  reposGetDeployKey: ReposGetDeployKey
  reposDeleteDeployKey: ReposDeleteDeployKey
  issuesListLabelsForRepo: IssuesListLabelsForRepo
  issuesCreateLabel: IssuesCreateLabel
  issuesGetLabel: IssuesGetLabel
  issuesUpdateLabel: IssuesUpdateLabel
  issuesDeleteLabel: IssuesDeleteLabel
  reposListLanguages: ReposListLanguages
  licensesGetForRepo: LicensesGetForRepo
  reposMergeUpstream: ReposMergeUpstream
  reposMerge: ReposMerge
  issuesListMilestones: IssuesListMilestones
  issuesCreateMilestone: IssuesCreateMilestone
  issuesGetMilestone: IssuesGetMilestone
  issuesUpdateMilestone: IssuesUpdateMilestone
  issuesDeleteMilestone: IssuesDeleteMilestone
  issuesListLabelsForMilestone: IssuesListLabelsForMilestone
  activityListRepoNotificationsForAuthenticatedUser: ActivityListRepoNotificationsForAuthenticatedUser
  activityMarkRepoNotificationsAsRead: ActivityMarkRepoNotificationsAsRead
  reposGetPages: ReposGetPages
  reposCreatePagesSite: ReposCreatePagesSite
  reposUpdateInformationAboutPagesSite: ReposUpdateInformationAboutPagesSite
  reposDeletePagesSite: ReposDeletePagesSite
  reposListPagesBuilds: ReposListPagesBuilds
  reposRequestPagesBuild: ReposRequestPagesBuild
  reposGetLatestPagesBuild: ReposGetLatestPagesBuild
  reposGetPagesBuild: ReposGetPagesBuild
  reposCreatePagesDeployment: ReposCreatePagesDeployment
  reposGetPagesDeployment: ReposGetPagesDeployment
  reposCancelPagesDeployment: ReposCancelPagesDeployment
  reposGetPagesHealthCheck: ReposGetPagesHealthCheck
  reposCheckPrivateVulnerabilityReporting: ReposCheckPrivateVulnerabilityReporting
  reposEnablePrivateVulnerabilityReporting: ReposEnablePrivateVulnerabilityReporting
  reposDisablePrivateVulnerabilityReporting: ReposDisablePrivateVulnerabilityReporting
  projectsListForRepo: ProjectsListForRepo
  projectsCreateForRepo: ProjectsCreateForRepo
  reposGetCustomPropertiesValues: ReposGetCustomPropertiesValues
  reposCreateOrUpdateCustomPropertiesValues: ReposCreateOrUpdateCustomPropertiesValues
  pullsList: PullsList
  pullsCreate: PullsCreate
  pullsListReviewCommentsForRepo: PullsListReviewCommentsForRepo
  pullsGetReviewComment: PullsGetReviewComment
  pullsUpdateReviewComment: PullsUpdateReviewComment
  pullsDeleteReviewComment: PullsDeleteReviewComment
  reactionsListForPullRequestReviewComment: ReactionsListForPullRequestReviewComment
  reactionsCreateForPullRequestReviewComment: ReactionsCreateForPullRequestReviewComment
  reactionsDeleteForPullRequestComment: ReactionsDeleteForPullRequestComment
  pullsGet: PullsGet
  pullsUpdate: PullsUpdate
  codespacesCreateWithPrForAuthenticatedUser: CodespacesCreateWithPrForAuthenticatedUser
  pullsListReviewComments: PullsListReviewComments
  pullsCreateReviewComment: PullsCreateReviewComment
  pullsCreateReplyForReviewComment: PullsCreateReplyForReviewComment
  pullsListCommits: PullsListCommits
  pullsListFiles: PullsListFiles
  pullsCheckIfMerged: PullsCheckIfMerged
  pullsMerge: PullsMerge
  pullsListRequestedReviewers: PullsListRequestedReviewers
  pullsRequestReviewers: PullsRequestReviewers
  pullsRemoveRequestedReviewers: PullsRemoveRequestedReviewers
  pullsListReviews: PullsListReviews
  pullsCreateReview: PullsCreateReview
  pullsGetReview: PullsGetReview
  pullsUpdateReview: PullsUpdateReview
  pullsDeletePendingReview: PullsDeletePendingReview
  pullsListCommentsForReview: PullsListCommentsForReview
  pullsDismissReview: PullsDismissReview
  pullsSubmitReview: PullsSubmitReview
  pullsUpdateBranch: PullsUpdateBranch
  reposGetReadme: ReposGetReadme
  reposGetReadmeInDirectory: ReposGetReadmeInDirectory
  reposListReleases: ReposListReleases
  reposCreateRelease: ReposCreateRelease
  reposGetReleaseAsset: ReposGetReleaseAsset
  reposUpdateReleaseAsset: ReposUpdateReleaseAsset
  reposDeleteReleaseAsset: ReposDeleteReleaseAsset
  reposGenerateReleaseNotes: ReposGenerateReleaseNotes
  reposGetLatestRelease: ReposGetLatestRelease
  reposGetReleaseByTag: ReposGetReleaseByTag
  reposGetRelease: ReposGetRelease
  reposUpdateRelease: ReposUpdateRelease
  reposDeleteRelease: ReposDeleteRelease
  reposListReleaseAssets: ReposListReleaseAssets
  reposUploadReleaseAsset: ReposUploadReleaseAsset
  reactionsListForRelease: ReactionsListForRelease
  reactionsCreateForRelease: ReactionsCreateForRelease
  reactionsDeleteForRelease: ReactionsDeleteForRelease
  reposGetBranchRules: ReposGetBranchRules
  reposGetRepoRulesets: ReposGetRepoRulesets
  reposCreateRepoRuleset: ReposCreateRepoRuleset
  reposGetRepoRuleSuites: ReposGetRepoRuleSuites
  reposGetRepoRuleSuite: ReposGetRepoRuleSuite
  reposGetRepoRuleset: ReposGetRepoRuleset
  reposUpdateRepoRuleset: ReposUpdateRepoRuleset
  reposDeleteRepoRuleset: ReposDeleteRepoRuleset
  reposGetRepoRulesetHistory: ReposGetRepoRulesetHistory
  reposGetRepoRulesetVersion: ReposGetRepoRulesetVersion
  secretScanningListAlertsForRepo: SecretScanningListAlertsForRepo
  secretScanningGetAlert: SecretScanningGetAlert
  secretScanningUpdateAlert: SecretScanningUpdateAlert
  secretScanningListLocationsForAlert: SecretScanningListLocationsForAlert
  secretScanningCreatePushProtectionBypass: SecretScanningCreatePushProtectionBypass
  secretScanningGetScanHistory: SecretScanningGetScanHistory
  securityAdvisoriesListRepositoryAdvisories: SecurityAdvisoriesListRepositoryAdvisories
  securityAdvisoriesCreateRepositoryAdvisory: SecurityAdvisoriesCreateRepositoryAdvisory
  securityAdvisoriesCreatePrivateVulnerabilityReport: SecurityAdvisoriesCreatePrivateVulnerabilityReport
  securityAdvisoriesGetRepositoryAdvisory: SecurityAdvisoriesGetRepositoryAdvisory
  securityAdvisoriesUpdateRepositoryAdvisory: SecurityAdvisoriesUpdateRepositoryAdvisory
  securityAdvisoriesCreateRepositoryAdvisoryCveRequest: SecurityAdvisoriesCreateRepositoryAdvisoryCveRequest
  securityAdvisoriesCreateFork: SecurityAdvisoriesCreateFork
  activityListStargazersForRepo: ActivityListStargazersForRepo
  reposGetCodeFrequencyStats: ReposGetCodeFrequencyStats
  reposGetCommitActivityStats: ReposGetCommitActivityStats
  reposGetContributorsStats: ReposGetContributorsStats
  reposGetParticipationStats: ReposGetParticipationStats
  reposGetPunchCardStats: ReposGetPunchCardStats
  reposCreateCommitStatus: ReposCreateCommitStatus
  activityListWatchersForRepo: ActivityListWatchersForRepo
  activityGetRepoSubscription: ActivityGetRepoSubscription
  activitySetRepoSubscription: ActivitySetRepoSubscription
  activityDeleteRepoSubscription: ActivityDeleteRepoSubscription
  reposListTags: ReposListTags
  reposListTagProtection: ReposListTagProtection
  reposCreateTagProtection: ReposCreateTagProtection
  reposDeleteTagProtection: ReposDeleteTagProtection
  reposDownloadTarballArchive: ReposDownloadTarballArchive
  reposListTeams: ReposListTeams
  reposGetAllTopics: ReposGetAllTopics
  reposReplaceAllTopics: ReposReplaceAllTopics
  reposGetClones: ReposGetClones
  reposGetTopPaths: ReposGetTopPaths
  reposGetTopReferrers: ReposGetTopReferrers
  reposGetViews: ReposGetViews
  reposTransfer: ReposTransfer
  reposCheckVulnerabilityAlerts: ReposCheckVulnerabilityAlerts
  reposEnableVulnerabilityAlerts: ReposEnableVulnerabilityAlerts
  reposDisableVulnerabilityAlerts: ReposDisableVulnerabilityAlerts
  reposDownloadZipballArchive: ReposDownloadZipballArchive
  reposCreateUsingTemplate: ReposCreateUsingTemplate
  reposListPublic: ReposListPublic
  searchCode: SearchCode
  searchCommits: SearchCommits
  searchIssuesAndPullRequests: SearchIssuesAndPullRequests
  searchLabels: SearchLabels
  searchRepos: SearchRepos
  searchTopics: SearchTopics
  searchUsers: SearchUsers
  teamsGetLegacy: TeamsGetLegacy
  teamsUpdateLegacy: TeamsUpdateLegacy
  teamsDeleteLegacy: TeamsDeleteLegacy
  teamsListDiscussionsLegacy: TeamsListDiscussionsLegacy
  teamsCreateDiscussionLegacy: TeamsCreateDiscussionLegacy
  teamsGetDiscussionLegacy: TeamsGetDiscussionLegacy
  teamsUpdateDiscussionLegacy: TeamsUpdateDiscussionLegacy
  teamsDeleteDiscussionLegacy: TeamsDeleteDiscussionLegacy
  teamsListDiscussionCommentsLegacy: TeamsListDiscussionCommentsLegacy
  teamsCreateDiscussionCommentLegacy: TeamsCreateDiscussionCommentLegacy
  teamsGetDiscussionCommentLegacy: TeamsGetDiscussionCommentLegacy
  teamsUpdateDiscussionCommentLegacy: TeamsUpdateDiscussionCommentLegacy
  teamsDeleteDiscussionCommentLegacy: TeamsDeleteDiscussionCommentLegacy
  reactionsListForTeamDiscussionCommentLegacy: ReactionsListForTeamDiscussionCommentLegacy
  reactionsCreateForTeamDiscussionCommentLegacy: ReactionsCreateForTeamDiscussionCommentLegacy
  reactionsListForTeamDiscussionLegacy: ReactionsListForTeamDiscussionLegacy
  reactionsCreateForTeamDiscussionLegacy: ReactionsCreateForTeamDiscussionLegacy
  teamsListPendingInvitationsLegacy: TeamsListPendingInvitationsLegacy
  teamsListMembersLegacy: TeamsListMembersLegacy
  teamsGetMemberLegacy: TeamsGetMemberLegacy
  teamsAddMemberLegacy: TeamsAddMemberLegacy
  teamsRemoveMemberLegacy: TeamsRemoveMemberLegacy
  teamsGetMembershipForUserLegacy: TeamsGetMembershipForUserLegacy
  teamsAddOrUpdateMembershipForUserLegacy: TeamsAddOrUpdateMembershipForUserLegacy
  teamsRemoveMembershipForUserLegacy: TeamsRemoveMembershipForUserLegacy
  teamsListProjectsLegacy: TeamsListProjectsLegacy
  teamsCheckPermissionsForProjectLegacy: TeamsCheckPermissionsForProjectLegacy
  teamsAddOrUpdateProjectPermissionsLegacy: TeamsAddOrUpdateProjectPermissionsLegacy
  teamsRemoveProjectLegacy: TeamsRemoveProjectLegacy
  teamsListReposLegacy: TeamsListReposLegacy
  teamsCheckPermissionsForRepoLegacy: TeamsCheckPermissionsForRepoLegacy
  teamsAddOrUpdateRepoPermissionsLegacy: TeamsAddOrUpdateRepoPermissionsLegacy
  teamsRemoveRepoLegacy: TeamsRemoveRepoLegacy
  teamsListChildLegacy: TeamsListChildLegacy
  usersGetAuthenticated: UsersGetAuthenticated
  usersUpdateAuthenticated: UsersUpdateAuthenticated
  usersListBlockedByAuthenticatedUser: UsersListBlockedByAuthenticatedUser
  usersCheckBlocked: UsersCheckBlocked
  usersBlock: UsersBlock
  usersUnblock: UsersUnblock
  codespacesListForAuthenticatedUser: CodespacesListForAuthenticatedUser
  codespacesCreateForAuthenticatedUser: CodespacesCreateForAuthenticatedUser
  codespacesListSecretsForAuthenticatedUser: CodespacesListSecretsForAuthenticatedUser
  codespacesGetPublicKeyForAuthenticatedUser: CodespacesGetPublicKeyForAuthenticatedUser
  codespacesGetSecretForAuthenticatedUser: CodespacesGetSecretForAuthenticatedUser
  codespacesCreateOrUpdateSecretForAuthenticatedUser: CodespacesCreateOrUpdateSecretForAuthenticatedUser
  codespacesDeleteSecretForAuthenticatedUser: CodespacesDeleteSecretForAuthenticatedUser
  codespacesListRepositoriesForSecretForAuthenticatedUser: CodespacesListRepositoriesForSecretForAuthenticatedUser
  codespacesSetRepositoriesForSecretForAuthenticatedUser: CodespacesSetRepositoriesForSecretForAuthenticatedUser
  codespacesAddRepositoryForSecretForAuthenticatedUser: CodespacesAddRepositoryForSecretForAuthenticatedUser
  codespacesRemoveRepositoryForSecretForAuthenticatedUser: CodespacesRemoveRepositoryForSecretForAuthenticatedUser
  codespacesGetForAuthenticatedUser: CodespacesGetForAuthenticatedUser
  codespacesUpdateForAuthenticatedUser: CodespacesUpdateForAuthenticatedUser
  codespacesDeleteForAuthenticatedUser: CodespacesDeleteForAuthenticatedUser
  codespacesExportForAuthenticatedUser: CodespacesExportForAuthenticatedUser
  codespacesGetExportDetailsForAuthenticatedUser: CodespacesGetExportDetailsForAuthenticatedUser
  codespacesCodespaceMachinesForAuthenticatedUser: CodespacesCodespaceMachinesForAuthenticatedUser
  codespacesPublishForAuthenticatedUser: CodespacesPublishForAuthenticatedUser
  codespacesStartForAuthenticatedUser: CodespacesStartForAuthenticatedUser
  codespacesStopForAuthenticatedUser: CodespacesStopForAuthenticatedUser
  packagesListDockerMigrationConflictingPackagesForAuthenticatedUser: PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser
  usersSetPrimaryEmailVisibilityForAuthenticatedUser: UsersSetPrimaryEmailVisibilityForAuthenticatedUser
  usersListEmailsForAuthenticatedUser: UsersListEmailsForAuthenticatedUser
  usersAddEmailForAuthenticatedUser: UsersAddEmailForAuthenticatedUser
  usersDeleteEmailForAuthenticatedUser: UsersDeleteEmailForAuthenticatedUser
  usersListFollowersForAuthenticatedUser: UsersListFollowersForAuthenticatedUser
  usersListFollowedByAuthenticatedUser: UsersListFollowedByAuthenticatedUser
  usersCheckPersonIsFollowedByAuthenticated: UsersCheckPersonIsFollowedByAuthenticated
  usersFollow: UsersFollow
  usersUnfollow: UsersUnfollow
  usersListGpgKeysForAuthenticatedUser: UsersListGpgKeysForAuthenticatedUser
  usersCreateGpgKeyForAuthenticatedUser: UsersCreateGpgKeyForAuthenticatedUser
  usersGetGpgKeyForAuthenticatedUser: UsersGetGpgKeyForAuthenticatedUser
  usersDeleteGpgKeyForAuthenticatedUser: UsersDeleteGpgKeyForAuthenticatedUser
  appsListInstallationsForAuthenticatedUser: AppsListInstallationsForAuthenticatedUser
  appsListInstallationReposForAuthenticatedUser: AppsListInstallationReposForAuthenticatedUser
  appsAddRepoToInstallationForAuthenticatedUser: AppsAddRepoToInstallationForAuthenticatedUser
  appsRemoveRepoFromInstallationForAuthenticatedUser: AppsRemoveRepoFromInstallationForAuthenticatedUser
  interactionsGetRestrictionsForAuthenticatedUser: InteractionsGetRestrictionsForAuthenticatedUser
  interactionsSetRestrictionsForAuthenticatedUser: InteractionsSetRestrictionsForAuthenticatedUser
  interactionsRemoveRestrictionsForAuthenticatedUser: InteractionsRemoveRestrictionsForAuthenticatedUser
  issuesListForAuthenticatedUser: IssuesListForAuthenticatedUser
  usersListPublicSshKeysForAuthenticatedUser: UsersListPublicSshKeysForAuthenticatedUser
  usersCreatePublicSshKeyForAuthenticatedUser: UsersCreatePublicSshKeyForAuthenticatedUser
  usersGetPublicSshKeyForAuthenticatedUser: UsersGetPublicSshKeyForAuthenticatedUser
  usersDeletePublicSshKeyForAuthenticatedUser: UsersDeletePublicSshKeyForAuthenticatedUser
  appsListSubscriptionsForAuthenticatedUser: AppsListSubscriptionsForAuthenticatedUser
  appsListSubscriptionsForAuthenticatedUserStubbed: AppsListSubscriptionsForAuthenticatedUserStubbed
  orgsListMembershipsForAuthenticatedUser: OrgsListMembershipsForAuthenticatedUser
  orgsGetMembershipForAuthenticatedUser: OrgsGetMembershipForAuthenticatedUser
  orgsUpdateMembershipForAuthenticatedUser: OrgsUpdateMembershipForAuthenticatedUser
  migrationsListForAuthenticatedUser: MigrationsListForAuthenticatedUser
  migrationsStartForAuthenticatedUser: MigrationsStartForAuthenticatedUser
  migrationsGetStatusForAuthenticatedUser: MigrationsGetStatusForAuthenticatedUser
  migrationsGetArchiveForAuthenticatedUser: MigrationsGetArchiveForAuthenticatedUser
  migrationsDeleteArchiveForAuthenticatedUser: MigrationsDeleteArchiveForAuthenticatedUser
  migrationsUnlockRepoForAuthenticatedUser: MigrationsUnlockRepoForAuthenticatedUser
  migrationsListReposForAuthenticatedUser: MigrationsListReposForAuthenticatedUser
  orgsListForAuthenticatedUser: OrgsListForAuthenticatedUser
  packagesListPackagesForAuthenticatedUser: PackagesListPackagesForAuthenticatedUser
  packagesGetPackageForAuthenticatedUser: PackagesGetPackageForAuthenticatedUser
  packagesDeletePackageForAuthenticatedUser: PackagesDeletePackageForAuthenticatedUser
  packagesRestorePackageForAuthenticatedUser: PackagesRestorePackageForAuthenticatedUser
  packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser
  packagesGetPackageVersionForAuthenticatedUser: PackagesGetPackageVersionForAuthenticatedUser
  packagesDeletePackageVersionForAuthenticatedUser: PackagesDeletePackageVersionForAuthenticatedUser
  packagesRestorePackageVersionForAuthenticatedUser: PackagesRestorePackageVersionForAuthenticatedUser
  projectsCreateForAuthenticatedUser: ProjectsCreateForAuthenticatedUser
  usersListPublicEmailsForAuthenticatedUser: UsersListPublicEmailsForAuthenticatedUser
  reposListForAuthenticatedUser: ReposListForAuthenticatedUser
  reposCreateForAuthenticatedUser: ReposCreateForAuthenticatedUser
  reposListInvitationsForAuthenticatedUser: ReposListInvitationsForAuthenticatedUser
  reposAcceptInvitationForAuthenticatedUser: ReposAcceptInvitationForAuthenticatedUser
  reposDeclineInvitationForAuthenticatedUser: ReposDeclineInvitationForAuthenticatedUser
  usersListSocialAccountsForAuthenticatedUser: UsersListSocialAccountsForAuthenticatedUser
  usersAddSocialAccountForAuthenticatedUser: UsersAddSocialAccountForAuthenticatedUser
  usersDeleteSocialAccountForAuthenticatedUser: UsersDeleteSocialAccountForAuthenticatedUser
  usersListSshSigningKeysForAuthenticatedUser: UsersListSshSigningKeysForAuthenticatedUser
  usersCreateSshSigningKeyForAuthenticatedUser: UsersCreateSshSigningKeyForAuthenticatedUser
  usersGetSshSigningKeyForAuthenticatedUser: UsersGetSshSigningKeyForAuthenticatedUser
  usersDeleteSshSigningKeyForAuthenticatedUser: UsersDeleteSshSigningKeyForAuthenticatedUser
  activityListReposStarredByAuthenticatedUser: ActivityListReposStarredByAuthenticatedUser
  activityCheckRepoIsStarredByAuthenticatedUser: ActivityCheckRepoIsStarredByAuthenticatedUser
  activityStarRepoForAuthenticatedUser: ActivityStarRepoForAuthenticatedUser
  activityUnstarRepoForAuthenticatedUser: ActivityUnstarRepoForAuthenticatedUser
  activityListWatchedReposForAuthenticatedUser: ActivityListWatchedReposForAuthenticatedUser
  teamsListForAuthenticatedUser: TeamsListForAuthenticatedUser
  usersGetById: UsersGetById
  usersList: UsersList
  usersGetByUsername: UsersGetByUsername
  usersListAttestations: UsersListAttestations
  packagesListDockerMigrationConflictingPackagesForUser: PackagesListDockerMigrationConflictingPackagesForUser
  activityListEventsForAuthenticatedUser: ActivityListEventsForAuthenticatedUser
  activityListOrgEventsForAuthenticatedUser: ActivityListOrgEventsForAuthenticatedUser
  activityListPublicEventsForUser: ActivityListPublicEventsForUser
  usersListFollowersForUser: UsersListFollowersForUser
  usersListFollowingForUser: UsersListFollowingForUser
  usersCheckFollowingForUser: UsersCheckFollowingForUser
  gistsListForUser: GistsListForUser
  usersListGpgKeysForUser: UsersListGpgKeysForUser
  usersGetContextForUser: UsersGetContextForUser
  appsGetUserInstallation: AppsGetUserInstallation
  usersListPublicKeysForUser: UsersListPublicKeysForUser
  orgsListForUser: OrgsListForUser
  packagesListPackagesForUser: PackagesListPackagesForUser
  packagesGetPackageForUser: PackagesGetPackageForUser
  packagesDeletePackageForUser: PackagesDeletePackageForUser
  packagesRestorePackageForUser: PackagesRestorePackageForUser
  packagesGetAllPackageVersionsForPackageOwnedByUser: PackagesGetAllPackageVersionsForPackageOwnedByUser
  packagesGetPackageVersionForUser: PackagesGetPackageVersionForUser
  packagesDeletePackageVersionForUser: PackagesDeletePackageVersionForUser
  packagesRestorePackageVersionForUser: PackagesRestorePackageVersionForUser
  projectsListForUser: ProjectsListForUser
  activityListReceivedEventsForUser: ActivityListReceivedEventsForUser
  activityListReceivedPublicEventsForUser: ActivityListReceivedPublicEventsForUser
  reposListForUser: ReposListForUser
  billingGetGithubActionsBillingUser: BillingGetGithubActionsBillingUser
  billingGetGithubPackagesBillingUser: BillingGetGithubPackagesBillingUser
  billingGetSharedStorageBillingUser: BillingGetSharedStorageBillingUser
  usersListSocialAccountsForUser: UsersListSocialAccountsForUser
  usersListSshSigningKeysForUser: UsersListSshSigningKeysForUser
  activityListReposStarredByUser: ActivityListReposStarredByUser
  activityListReposWatchedByUser: ActivityListReposWatchedByUser
  metaGetAllVersions: MetaGetAllVersions
  metaGetZen: MetaGetZen
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  router.get("metaRoot", "/", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .metaRoot(input, metaRoot.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = metaRoot.validator(status, body)
    ctx.status = status
    return next()
  })

  const securityAdvisoriesListGlobalAdvisoriesQuerySchema = z.object({
    ghsa_id: z.string().optional(),
    type: z
      .enum(["reviewed", "malware", "unreviewed"])
      .optional()
      .default("reviewed"),
    cve_id: z.string().optional(),
    ecosystem: s_security_advisory_ecosystems.optional(),
    severity: z
      .enum(["unknown", "low", "medium", "high", "critical"])
      .optional(),
    cwes: z.union([z.string(), z.array(z.string())]).optional(),
    is_withdrawn: PermissiveBoolean.optional(),
    affects: z.union([z.string(), z.array(z.string()).max(1000)]).optional(),
    published: z.string().optional(),
    updated: z.string().optional(),
    modified: z.string().optional(),
    epss_percentage: z.string().optional(),
    epss_percentile: z.string().optional(),
    before: z.string().optional(),
    after: z.string().optional(),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().min(1).max(100).optional().default(30),
    sort: z
      .enum(["updated", "published", "epss_percentage", "epss_percentile"])
      .optional()
      .default("published"),
  })

  router.get(
    "securityAdvisoriesListGlobalAdvisories",
    "/advisories",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          securityAdvisoriesListGlobalAdvisoriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesListGlobalAdvisories(
          input,
          securityAdvisoriesListGlobalAdvisories.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesListGlobalAdvisories.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesGetGlobalAdvisoryParamSchema = z.object({
    ghsa_id: z.string(),
  })

  router.get(
    "securityAdvisoriesGetGlobalAdvisory",
    "/advisories/:ghsa_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesGetGlobalAdvisoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesGetGlobalAdvisory(
          input,
          securityAdvisoriesGetGlobalAdvisory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesGetGlobalAdvisory.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get("appsGetAuthenticated", "/app", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .appsGetAuthenticated(input, appsGetAuthenticated.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = appsGetAuthenticated.validator(status, body)
    ctx.status = status
    return next()
  })

  const appsCreateFromManifestParamSchema = z.object({ code: z.string() })

  router.post(
    "appsCreateFromManifest",
    "/app-manifests/:code/conversions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsCreateFromManifestParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsCreateFromManifest(input, appsCreateFromManifest.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsCreateFromManifest.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get(
    "appsGetWebhookConfigForApp",
    "/app/hook/config",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetWebhookConfigForApp(
          input,
          appsGetWebhookConfigForApp.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetWebhookConfigForApp.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsUpdateWebhookConfigForAppBodySchema = z.object({
    url: s_webhook_config_url.optional(),
    content_type: s_webhook_config_content_type.optional(),
    secret: s_webhook_config_secret.optional(),
    insecure_ssl: s_webhook_config_insecure_ssl.optional(),
  })

  router.patch(
    "appsUpdateWebhookConfigForApp",
    "/app/hook/config",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          appsUpdateWebhookConfigForAppBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .appsUpdateWebhookConfigForApp(
          input,
          appsUpdateWebhookConfigForApp.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsUpdateWebhookConfigForApp.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    cursor: z.string().optional(),
  })

  router.get(
    "appsListWebhookDeliveries",
    "/app/hook/deliveries",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListWebhookDeliveriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListWebhookDeliveries(
          input,
          appsListWebhookDeliveries.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListWebhookDeliveries.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsGetWebhookDeliveryParamSchema = z.object({
    delivery_id: z.coerce.number(),
  })

  router.get(
    "appsGetWebhookDelivery",
    "/app/hook/deliveries/:delivery_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsGetWebhookDeliveryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetWebhookDelivery(input, appsGetWebhookDelivery.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetWebhookDelivery.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsRedeliverWebhookDeliveryParamSchema = z.object({
    delivery_id: z.coerce.number(),
  })

  router.post(
    "appsRedeliverWebhookDelivery",
    "/app/hook/deliveries/:delivery_id/attempts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsRedeliverWebhookDeliveryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsRedeliverWebhookDelivery(
          input,
          appsRedeliverWebhookDelivery.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsRedeliverWebhookDelivery.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsListInstallationRequestsForAuthenticatedAppQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListInstallationRequestsForAuthenticatedApp",
    "/app/installation-requests",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListInstallationRequestsForAuthenticatedAppQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListInstallationRequestsForAuthenticatedApp(
          input,
          appsListInstallationRequestsForAuthenticatedApp.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListInstallationRequestsForAuthenticatedApp.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const appsListInstallationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    since: z.string().datetime({ offset: true }).optional(),
    outdated: z.string().optional(),
  })

  router.get(
    "appsListInstallations",
    "/app/installations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListInstallationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListInstallations(input, appsListInstallations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListInstallations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsGetInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.get(
    "appsGetInstallation",
    "/app/installations/:installation_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsGetInstallationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetInstallation(input, appsGetInstallation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsDeleteInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.delete(
    "appsDeleteInstallation",
    "/app/installations/:installation_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsDeleteInstallationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsDeleteInstallation(input, appsDeleteInstallation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsDeleteInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsCreateInstallationAccessTokenParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsCreateInstallationAccessTokenBodySchema = z
    .object({
      repositories: z.array(z.string()).optional(),
      repository_ids: z.array(z.coerce.number()).optional(),
      permissions: s_app_permissions.optional(),
    })
    .optional()

  router.post(
    "appsCreateInstallationAccessToken",
    "/app/installations/:installation_id/access_tokens",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsCreateInstallationAccessTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          appsCreateInstallationAccessTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .appsCreateInstallationAccessToken(
          input,
          appsCreateInstallationAccessToken.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsCreateInstallationAccessToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsSuspendInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.put(
    "appsSuspendInstallation",
    "/app/installations/:installation_id/suspended",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsSuspendInstallationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsSuspendInstallation(input, appsSuspendInstallation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsSuspendInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsUnsuspendInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.delete(
    "appsUnsuspendInstallation",
    "/app/installations/:installation_id/suspended",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsUnsuspendInstallationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsUnsuspendInstallation(
          input,
          appsUnsuspendInstallation.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsUnsuspendInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsDeleteAuthorizationParamSchema = z.object({ client_id: z.string() })

  const appsDeleteAuthorizationBodySchema = z.object({
    access_token: z.string(),
  })

  router.delete(
    "appsDeleteAuthorization",
    "/applications/:client_id/grant",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsDeleteAuthorizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          appsDeleteAuthorizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .appsDeleteAuthorization(input, appsDeleteAuthorization.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsDeleteAuthorization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsCheckTokenParamSchema = z.object({ client_id: z.string() })

  const appsCheckTokenBodySchema = z.object({ access_token: z.string() })

  router.post(
    "appsCheckToken",
    "/applications/:client_id/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsCheckTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          appsCheckTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .appsCheckToken(input, appsCheckToken.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsCheckToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsResetTokenParamSchema = z.object({ client_id: z.string() })

  const appsResetTokenBodySchema = z.object({ access_token: z.string() })

  router.patch(
    "appsResetToken",
    "/applications/:client_id/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsResetTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          appsResetTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .appsResetToken(input, appsResetToken.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsResetToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsDeleteTokenParamSchema = z.object({ client_id: z.string() })

  const appsDeleteTokenBodySchema = z.object({ access_token: z.string() })

  router.delete(
    "appsDeleteToken",
    "/applications/:client_id/token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsDeleteTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          appsDeleteTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .appsDeleteToken(input, appsDeleteToken.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsDeleteToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsScopeTokenParamSchema = z.object({ client_id: z.string() })

  const appsScopeTokenBodySchema = z.object({
    access_token: z.string(),
    target: z.string().optional(),
    target_id: z.coerce.number().optional(),
    repositories: z.array(z.string()).optional(),
    repository_ids: z.array(z.coerce.number()).optional(),
    permissions: s_app_permissions.optional(),
  })

  router.post(
    "appsScopeToken",
    "/applications/:client_id/token/scoped",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsScopeTokenParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          appsScopeTokenBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .appsScopeToken(input, appsScopeToken.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsScopeToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsGetBySlugParamSchema = z.object({ app_slug: z.string() })

  router.get("appsGetBySlug", "/apps/:app_slug", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        appsGetBySlugParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .appsGetBySlug(input, appsGetBySlug.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = appsGetBySlug.validator(status, body)
    ctx.status = status
    return next()
  })

  const classroomGetAnAssignmentParamSchema = z.object({
    assignment_id: z.coerce.number(),
  })

  router.get(
    "classroomGetAnAssignment",
    "/assignments/:assignment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          classroomGetAnAssignmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .classroomGetAnAssignment(
          input,
          classroomGetAnAssignment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = classroomGetAnAssignment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const classroomListAcceptedAssignmentsForAnAssignmentParamSchema = z.object({
    assignment_id: z.coerce.number(),
  })

  const classroomListAcceptedAssignmentsForAnAssignmentQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "classroomListAcceptedAssignmentsForAnAssignment",
    "/assignments/:assignment_id/accepted_assignments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          classroomListAcceptedAssignmentsForAnAssignmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          classroomListAcceptedAssignmentsForAnAssignmentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .classroomListAcceptedAssignmentsForAnAssignment(
          input,
          classroomListAcceptedAssignmentsForAnAssignment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = classroomListAcceptedAssignmentsForAnAssignment.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const classroomGetAssignmentGradesParamSchema = z.object({
    assignment_id: z.coerce.number(),
  })

  router.get(
    "classroomGetAssignmentGrades",
    "/assignments/:assignment_id/grades",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          classroomGetAssignmentGradesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .classroomGetAssignmentGrades(
          input,
          classroomGetAssignmentGrades.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = classroomGetAssignmentGrades.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const classroomListClassroomsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get("classroomListClassrooms", "/classrooms", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        classroomListClassroomsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .classroomListClassrooms(input, classroomListClassrooms.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = classroomListClassrooms.validator(status, body)
    ctx.status = status
    return next()
  })

  const classroomGetAClassroomParamSchema = z.object({
    classroom_id: z.coerce.number(),
  })

  router.get(
    "classroomGetAClassroom",
    "/classrooms/:classroom_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          classroomGetAClassroomParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .classroomGetAClassroom(input, classroomGetAClassroom.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = classroomGetAClassroom.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const classroomListAssignmentsForAClassroomParamSchema = z.object({
    classroom_id: z.coerce.number(),
  })

  const classroomListAssignmentsForAClassroomQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "classroomListAssignmentsForAClassroom",
    "/classrooms/:classroom_id/assignments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          classroomListAssignmentsForAClassroomParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          classroomListAssignmentsForAClassroomQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .classroomListAssignmentsForAClassroom(
          input,
          classroomListAssignmentsForAClassroom.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = classroomListAssignmentsForAClassroom.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get(
    "codesOfConductGetAllCodesOfConduct",
    "/codes_of_conduct",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codesOfConductGetAllCodesOfConduct(
          input,
          codesOfConductGetAllCodesOfConduct.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codesOfConductGetAllCodesOfConduct.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codesOfConductGetConductCodeParamSchema = z.object({ key: z.string() })

  router.get(
    "codesOfConductGetConductCode",
    "/codes_of_conduct/:key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codesOfConductGetConductCodeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codesOfConductGetConductCode(
          input,
          codesOfConductGetConductCode.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codesOfConductGetConductCode.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get("emojisGet", "/emojis", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .emojisGet(input, emojisGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = emojisGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const codeSecurityGetConfigurationsForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const codeSecurityGetConfigurationsForEnterpriseQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
  })

  router.get(
    "codeSecurityGetConfigurationsForEnterprise",
    "/enterprises/:enterprise/code-security/configurations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetConfigurationsForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeSecurityGetConfigurationsForEnterpriseQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetConfigurationsForEnterprise(
          input,
          codeSecurityGetConfigurationsForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetConfigurationsForEnterprise.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecurityCreateConfigurationForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const codeSecurityCreateConfigurationForEnterpriseBodySchema = z.object({
    name: z.string(),
    description: z.string().max(255),
    advanced_security: z
      .enum(["enabled", "disabled", "code_security", "secret_protection"])
      .optional()
      .default("disabled"),
    dependency_graph: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("enabled"),
    dependency_graph_autosubmit_action: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    dependency_graph_autosubmit_action_options: z
      .object({ labeled_runners: PermissiveBoolean.optional().default(false) })
      .optional(),
    dependabot_alerts: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    dependabot_security_updates: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    code_scanning_default_setup: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    code_scanning_default_setup_options:
      s_code_scanning_default_setup_options.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_push_protection: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_validity_checks: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_non_provider_patterns: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_generic_secrets: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    private_vulnerability_reporting: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    enforcement: z
      .enum(["enforced", "unenforced"])
      .optional()
      .default("enforced"),
  })

  router.post(
    "codeSecurityCreateConfigurationForEnterprise",
    "/enterprises/:enterprise/code-security/configurations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityCreateConfigurationForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecurityCreateConfigurationForEnterpriseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityCreateConfigurationForEnterprise(
          input,
          codeSecurityCreateConfigurationForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityCreateConfigurationForEnterprise.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetDefaultConfigurationsForEnterpriseParamSchema = z.object(
    { enterprise: z.string() },
  )

  router.get(
    "codeSecurityGetDefaultConfigurationsForEnterprise",
    "/enterprises/:enterprise/code-security/configurations/defaults",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetDefaultConfigurationsForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetDefaultConfigurationsForEnterprise(
          input,
          codeSecurityGetDefaultConfigurationsForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetDefaultConfigurationsForEnterprise.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetSingleConfigurationForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  router.get(
    "codeSecurityGetSingleConfigurationForEnterprise",
    "/enterprises/:enterprise/code-security/configurations/:configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetSingleConfigurationForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetSingleConfigurationForEnterprise(
          input,
          codeSecurityGetSingleConfigurationForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetSingleConfigurationForEnterprise.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecurityUpdateEnterpriseConfigurationParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityUpdateEnterpriseConfigurationBodySchema = z.object({
    name: z.string().optional(),
    description: z.string().max(255).optional(),
    advanced_security: z
      .enum(["enabled", "disabled", "code_security", "secret_protection"])
      .optional(),
    dependency_graph: z.enum(["enabled", "disabled", "not_set"]).optional(),
    dependency_graph_autosubmit_action: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    dependency_graph_autosubmit_action_options: z
      .object({ labeled_runners: PermissiveBoolean.optional() })
      .optional(),
    dependabot_alerts: z.enum(["enabled", "disabled", "not_set"]).optional(),
    dependabot_security_updates: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    code_scanning_default_setup: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    code_scanning_default_setup_options:
      s_code_scanning_default_setup_options.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning: z.enum(["enabled", "disabled", "not_set"]).optional(),
    secret_scanning_push_protection: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_validity_checks: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_non_provider_patterns: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_generic_secrets: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    private_vulnerability_reporting: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    enforcement: z.enum(["enforced", "unenforced"]).optional(),
  })

  router.patch(
    "codeSecurityUpdateEnterpriseConfiguration",
    "/enterprises/:enterprise/code-security/configurations/:configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityUpdateEnterpriseConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecurityUpdateEnterpriseConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityUpdateEnterpriseConfiguration(
          input,
          codeSecurityUpdateEnterpriseConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityUpdateEnterpriseConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecurityDeleteConfigurationForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  router.delete(
    "codeSecurityDeleteConfigurationForEnterprise",
    "/enterprises/:enterprise/code-security/configurations/:configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityDeleteConfigurationForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityDeleteConfigurationForEnterprise(
          input,
          codeSecurityDeleteConfigurationForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityDeleteConfigurationForEnterprise.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecurityAttachEnterpriseConfigurationParamSchema = z.object({
    enterprise: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityAttachEnterpriseConfigurationBodySchema = z.object({
    scope: z.enum(["all", "all_without_configurations"]),
  })

  router.post(
    "codeSecurityAttachEnterpriseConfiguration",
    "/enterprises/:enterprise/code-security/configurations/:configuration_id/attach",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityAttachEnterpriseConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecurityAttachEnterpriseConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityAttachEnterpriseConfiguration(
          input,
          codeSecurityAttachEnterpriseConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityAttachEnterpriseConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema =
    z.object({ enterprise: z.string(), configuration_id: z.coerce.number() })

  const codeSecuritySetConfigurationAsDefaultForEnterpriseBodySchema = z.object(
    {
      default_for_new_repos: z
        .enum(["all", "none", "private_and_internal", "public"])
        .optional(),
    },
  )

  router.put(
    "codeSecuritySetConfigurationAsDefaultForEnterprise",
    "/enterprises/:enterprise/code-security/configurations/:configuration_id/defaults",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecuritySetConfigurationAsDefaultForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecuritySetConfigurationAsDefaultForEnterpriseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecuritySetConfigurationAsDefaultForEnterprise(
          input,
          codeSecuritySetConfigurationAsDefaultForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecuritySetConfigurationAsDefaultForEnterprise.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema =
    z.object({ enterprise: z.string(), configuration_id: z.coerce.number() })

  const codeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema =
    z.object({
      per_page: z.coerce.number().optional().default(30),
      before: z.string().optional(),
      after: z.string().optional(),
      status: z.string().optional().default("all"),
    })

  router.get(
    "codeSecurityGetRepositoriesForEnterpriseConfiguration",
    "/enterprises/:enterprise/code-security/configurations/:configuration_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetRepositoriesForEnterpriseConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeSecurityGetRepositoriesForEnterpriseConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetRepositoriesForEnterpriseConfiguration(
          input,
          codeSecurityGetRepositoriesForEnterpriseConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        codeSecurityGetRepositoriesForEnterpriseConfiguration.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const dependabotListAlertsForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const dependabotListAlertsForEnterpriseQuerySchema = z.object({
    state: z.string().optional(),
    severity: z.string().optional(),
    ecosystem: z.string().optional(),
    package: z.string().optional(),
    epss_percentage: z.string().optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z
      .enum(["created", "updated", "epss_percentage"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    before: z.string().optional(),
    after: z.string().optional(),
    first: z.coerce.number().min(1).max(100).optional().default(30),
    last: z.coerce.number().min(1).max(100).optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "dependabotListAlertsForEnterprise",
    "/enterprises/:enterprise/dependabot/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotListAlertsForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          dependabotListAlertsForEnterpriseQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotListAlertsForEnterprise(
          input,
          dependabotListAlertsForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotListAlertsForEnterprise.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const secretScanningListAlertsForEnterpriseParamSchema = z.object({
    enterprise: z.string(),
  })

  const secretScanningListAlertsForEnterpriseQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.string().optional(),
    resolution: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    validity: z.string().optional(),
    is_publicly_leaked: PermissiveBoolean.optional().default(false),
    is_multi_repo: PermissiveBoolean.optional().default(false),
  })

  router.get(
    "secretScanningListAlertsForEnterprise",
    "/enterprises/:enterprise/secret-scanning/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningListAlertsForEnterpriseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          secretScanningListAlertsForEnterpriseQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .secretScanningListAlertsForEnterprise(
          input,
          secretScanningListAlertsForEnterprise.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningListAlertsForEnterprise.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListPublicEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("activityListPublicEvents", "/events", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        activityListPublicEventsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .activityListPublicEvents(input, activityListPublicEvents.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = activityListPublicEvents.validator(status, body)
    ctx.status = status
    return next()
  })

  router.get("activityGetFeeds", "/feeds", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .activityGetFeeds(input, activityGetFeeds.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = activityGetFeeds.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsListQuerySchema = z.object({
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("gistsList", "/gists", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        gistsListQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsList(input, gistsList.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsList.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsCreateBodySchema = z.object({
    description: z.string().optional(),
    files: z.record(z.object({ content: z.string() })),
    public: z
      .union([
        PermissiveBoolean.default(false),
        z.enum(["true", "false"]).default("false"),
      ])
      .optional(),
  })

  router.post("gistsCreate", "/gists", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        gistsCreateBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .gistsCreate(input, gistsCreate.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsCreate.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsListPublicQuerySchema = z.object({
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("gistsListPublic", "/gists/public", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        gistsListPublicQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsListPublic(input, gistsListPublic.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsListPublic.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsListStarredQuerySchema = z.object({
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("gistsListStarred", "/gists/starred", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        gistsListStarredQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsListStarred(input, gistsListStarred.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsListStarred.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsGetParamSchema = z.object({ gist_id: z.string() })

  router.get("gistsGet", "/gists/:gist_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsGetParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsGet(input, gistsGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsUpdateParamSchema = z.object({ gist_id: z.string() })

  const gistsUpdateBodySchema = z
    .object({
      description: z.string().optional(),
      files: z
        .record(
          z
            .object({
              content: z.string().optional(),
              filename: z.string().nullable().optional(),
            })
            .nullable(),
        )
        .optional(),
    })
    .nullable()

  router.patch("gistsUpdate", "/gists/:gist_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsUpdateParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        gistsUpdateBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .gistsUpdate(input, gistsUpdate.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsUpdate.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsDeleteParamSchema = z.object({ gist_id: z.string() })

  router.delete("gistsDelete", "/gists/:gist_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsDeleteParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsDelete(input, gistsDelete.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsDelete.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsListCommentsParamSchema = z.object({ gist_id: z.string() })

  const gistsListCommentsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "gistsListComments",
    "/gists/:gist_id/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsListCommentsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          gistsListCommentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gistsListComments(input, gistsListComments.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsListComments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsCreateCommentParamSchema = z.object({ gist_id: z.string() })

  const gistsCreateCommentBodySchema = z.object({ body: z.string().max(65535) })

  router.post(
    "gistsCreateComment",
    "/gists/:gist_id/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsCreateCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gistsCreateCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gistsCreateComment(input, gistsCreateComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsCreateComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsGetCommentParamSchema = z.object({
    gist_id: z.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "gistsGetComment",
    "/gists/:gist_id/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsGetCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gistsGetComment(input, gistsGetComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsGetComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsUpdateCommentParamSchema = z.object({
    gist_id: z.string(),
    comment_id: z.coerce.number(),
  })

  const gistsUpdateCommentBodySchema = z.object({ body: z.string().max(65535) })

  router.patch(
    "gistsUpdateComment",
    "/gists/:gist_id/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsUpdateCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gistsUpdateCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gistsUpdateComment(input, gistsUpdateComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsUpdateComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsDeleteCommentParamSchema = z.object({
    gist_id: z.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "gistsDeleteComment",
    "/gists/:gist_id/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsDeleteCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gistsDeleteComment(input, gistsDeleteComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsDeleteComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsListCommitsParamSchema = z.object({ gist_id: z.string() })

  const gistsListCommitsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "gistsListCommits",
    "/gists/:gist_id/commits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsListCommitsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          gistsListCommitsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gistsListCommits(input, gistsListCommits.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsListCommits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsListForksParamSchema = z.object({ gist_id: z.string() })

  const gistsListForksQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("gistsListForks", "/gists/:gist_id/forks", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsListForksParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        gistsListForksQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsListForks(input, gistsListForks.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsListForks.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsForkParamSchema = z.object({ gist_id: z.string() })

  router.post("gistsFork", "/gists/:gist_id/forks", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsForkParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsFork(input, gistsFork.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsFork.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsCheckIsStarredParamSchema = z.object({ gist_id: z.string() })

  router.get(
    "gistsCheckIsStarred",
    "/gists/:gist_id/star",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsCheckIsStarredParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gistsCheckIsStarred(input, gistsCheckIsStarred.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsCheckIsStarred.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsStarParamSchema = z.object({ gist_id: z.string() })

  router.put("gistsStar", "/gists/:gist_id/star", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsStarParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsStar(input, gistsStar.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsStar.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsUnstarParamSchema = z.object({ gist_id: z.string() })

  router.delete("gistsUnstar", "/gists/:gist_id/star", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsUnstarParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsUnstar(input, gistsUnstar.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsUnstar.validator(status, body)
    ctx.status = status
    return next()
  })

  const gistsGetRevisionParamSchema = z.object({
    gist_id: z.string(),
    sha: z.string(),
  })

  router.get("gistsGetRevision", "/gists/:gist_id/:sha", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        gistsGetRevisionParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .gistsGetRevision(input, gistsGetRevision.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = gistsGetRevision.validator(status, body)
    ctx.status = status
    return next()
  })

  router.get(
    "gitignoreGetAllTemplates",
    "/gitignore/templates",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitignoreGetAllTemplates(
          input,
          gitignoreGetAllTemplates.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitignoreGetAllTemplates.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitignoreGetTemplateParamSchema = z.object({ name: z.string() })

  router.get(
    "gitignoreGetTemplate",
    "/gitignore/templates/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitignoreGetTemplateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitignoreGetTemplate(input, gitignoreGetTemplate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitignoreGetTemplate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsListReposAccessibleToInstallationQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListReposAccessibleToInstallation",
    "/installation/repositories",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListReposAccessibleToInstallationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListReposAccessibleToInstallation(
          input,
          appsListReposAccessibleToInstallation.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListReposAccessibleToInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.delete(
    "appsRevokeInstallationAccessToken",
    "/installation/token",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsRevokeInstallationAccessToken(
          input,
          appsRevokeInstallationAccessToken.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsRevokeInstallationAccessToken.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional()
      .default("assigned"),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    labels: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.string().datetime({ offset: true }).optional(),
    collab: PermissiveBoolean.optional(),
    orgs: PermissiveBoolean.optional(),
    owned: PermissiveBoolean.optional(),
    pulls: PermissiveBoolean.optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("issuesList", "/issues", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        issuesListQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .issuesList(input, issuesList.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = issuesList.validator(status, body)
    ctx.status = status
    return next()
  })

  const licensesGetAllCommonlyUsedQuerySchema = z.object({
    featured: PermissiveBoolean.optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("licensesGetAllCommonlyUsed", "/licenses", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        licensesGetAllCommonlyUsedQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .licensesGetAllCommonlyUsed(
        input,
        licensesGetAllCommonlyUsed.responder,
        ctx,
      )
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = licensesGetAllCommonlyUsed.validator(status, body)
    ctx.status = status
    return next()
  })

  const licensesGetParamSchema = z.object({ license: z.string() })

  router.get("licensesGet", "/licenses/:license", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        licensesGetParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .licensesGet(input, licensesGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = licensesGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const markdownRenderBodySchema = z.object({
    text: z.string(),
    mode: z.enum(["markdown", "gfm"]).optional().default("markdown"),
    context: z.string().optional(),
  })

  router.post("markdownRender", "/markdown", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        markdownRenderBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .markdownRender(input, markdownRender.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = markdownRender.validator(status, body)
    ctx.status = status
    return next()
  })

  const markdownRenderRawBodySchema = z.string().optional()

  router.post("markdownRenderRaw", "/markdown/raw", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        markdownRenderRawBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .markdownRenderRaw(input, markdownRenderRaw.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = markdownRenderRaw.validator(status, body)
    ctx.status = status
    return next()
  })

  const appsGetSubscriptionPlanForAccountParamSchema = z.object({
    account_id: z.coerce.number(),
  })

  router.get(
    "appsGetSubscriptionPlanForAccount",
    "/marketplace_listing/accounts/:account_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsGetSubscriptionPlanForAccountParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetSubscriptionPlanForAccount(
          input,
          appsGetSubscriptionPlanForAccount.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetSubscriptionPlanForAccount.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsListPlansQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListPlans",
    "/marketplace_listing/plans",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListPlansQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListPlans(input, appsListPlans.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListPlans.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsListAccountsForPlanParamSchema = z.object({
    plan_id: z.coerce.number(),
  })

  const appsListAccountsForPlanQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListAccountsForPlan",
    "/marketplace_listing/plans/:plan_id/accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsListAccountsForPlanParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          appsListAccountsForPlanQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListAccountsForPlan(input, appsListAccountsForPlan.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListAccountsForPlan.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsGetSubscriptionPlanForAccountStubbedParamSchema = z.object({
    account_id: z.coerce.number(),
  })

  router.get(
    "appsGetSubscriptionPlanForAccountStubbed",
    "/marketplace_listing/stubbed/accounts/:account_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsGetSubscriptionPlanForAccountStubbedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetSubscriptionPlanForAccountStubbed(
          input,
          appsGetSubscriptionPlanForAccountStubbed.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetSubscriptionPlanForAccountStubbed.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const appsListPlansStubbedQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListPlansStubbed",
    "/marketplace_listing/stubbed/plans",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListPlansStubbedQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListPlansStubbed(input, appsListPlansStubbed.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListPlansStubbed.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsListAccountsForPlanStubbedParamSchema = z.object({
    plan_id: z.coerce.number(),
  })

  const appsListAccountsForPlanStubbedQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListAccountsForPlanStubbed",
    "/marketplace_listing/stubbed/plans/:plan_id/accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsListAccountsForPlanStubbedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          appsListAccountsForPlanStubbedQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListAccountsForPlanStubbed(
          input,
          appsListAccountsForPlanStubbed.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListAccountsForPlanStubbed.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get("metaGet", "/meta", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .metaGet(input, metaGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = metaGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const activityListPublicEventsForRepoNetworkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListPublicEventsForRepoNetworkQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListPublicEventsForRepoNetwork",
    "/networks/:owner/:repo/events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListPublicEventsForRepoNetworkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListPublicEventsForRepoNetworkQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListPublicEventsForRepoNetwork(
          input,
          activityListPublicEventsForRepoNetwork.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListPublicEventsForRepoNetwork.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListNotificationsForAuthenticatedUserQuerySchema = z.object({
    all: PermissiveBoolean.optional().default(false),
    participating: PermissiveBoolean.optional().default(false),
    since: z.string().datetime({ offset: true }).optional(),
    before: z.string().datetime({ offset: true }).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(50),
  })

  router.get(
    "activityListNotificationsForAuthenticatedUser",
    "/notifications",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          activityListNotificationsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListNotificationsForAuthenticatedUser(
          input,
          activityListNotificationsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListNotificationsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const activityMarkNotificationsAsReadBodySchema = z
    .object({
      last_read_at: z.string().datetime({ offset: true }).optional(),
      read: PermissiveBoolean.optional(),
    })
    .optional()

  router.put(
    "activityMarkNotificationsAsRead",
    "/notifications",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          activityMarkNotificationsAsReadBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .activityMarkNotificationsAsRead(
          input,
          activityMarkNotificationsAsRead.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityMarkNotificationsAsRead.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityGetThreadParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  router.get(
    "activityGetThread",
    "/notifications/threads/:thread_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityGetThreadParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityGetThread(input, activityGetThread.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityGetThread.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityMarkThreadAsReadParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  router.patch(
    "activityMarkThreadAsRead",
    "/notifications/threads/:thread_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityMarkThreadAsReadParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityMarkThreadAsRead(
          input,
          activityMarkThreadAsRead.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityMarkThreadAsRead.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityMarkThreadAsDoneParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  router.delete(
    "activityMarkThreadAsDone",
    "/notifications/threads/:thread_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityMarkThreadAsDoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityMarkThreadAsDone(
          input,
          activityMarkThreadAsDone.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityMarkThreadAsDone.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityGetThreadSubscriptionForAuthenticatedUserParamSchema = z.object(
    { thread_id: z.coerce.number() },
  )

  router.get(
    "activityGetThreadSubscriptionForAuthenticatedUser",
    "/notifications/threads/:thread_id/subscription",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityGetThreadSubscriptionForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityGetThreadSubscriptionForAuthenticatedUser(
          input,
          activityGetThreadSubscriptionForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityGetThreadSubscriptionForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const activitySetThreadSubscriptionParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  const activitySetThreadSubscriptionBodySchema = z
    .object({ ignored: PermissiveBoolean.optional().default(false) })
    .optional()

  router.put(
    "activitySetThreadSubscription",
    "/notifications/threads/:thread_id/subscription",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activitySetThreadSubscriptionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          activitySetThreadSubscriptionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .activitySetThreadSubscription(
          input,
          activitySetThreadSubscription.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activitySetThreadSubscription.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityDeleteThreadSubscriptionParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  router.delete(
    "activityDeleteThreadSubscription",
    "/notifications/threads/:thread_id/subscription",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityDeleteThreadSubscriptionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityDeleteThreadSubscription(
          input,
          activityDeleteThreadSubscription.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityDeleteThreadSubscription.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const metaGetOctocatQuerySchema = z.object({ s: z.string().optional() })

  router.get("metaGetOctocat", "/octocat", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        metaGetOctocatQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .metaGetOctocat(input, metaGetOctocat.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = metaGetOctocat.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsListQuerySchema = z.object({
    since: z.coerce.number().optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get("orgsList", "/organizations", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        orgsListQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .orgsList(input, orgsList.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsList.validator(status, body)
    ctx.status = status
    return next()
  })

  const billingGetGithubBillingUsageReportOrgParamSchema = z.object({
    org: z.string(),
  })

  const billingGetGithubBillingUsageReportOrgQuerySchema = z.object({
    year: z.coerce.number().optional(),
    month: z.coerce.number().optional(),
    day: z.coerce.number().optional(),
    hour: z.coerce.number().optional(),
  })

  router.get(
    "billingGetGithubBillingUsageReportOrg",
    "/organizations/:org/settings/billing/usage",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          billingGetGithubBillingUsageReportOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          billingGetGithubBillingUsageReportOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .billingGetGithubBillingUsageReportOrg(
          input,
          billingGetGithubBillingUsageReportOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = billingGetGithubBillingUsageReportOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetParamSchema = z.object({ org: z.string() })

  router.get("orgsGet", "/orgs/:org", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsGetParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .orgsGet(input, orgsGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsUpdateParamSchema = z.object({ org: z.string() })

  const orgsUpdateBodySchema = z
    .object({
      billing_email: z.string().optional(),
      company: z.string().optional(),
      email: z.string().optional(),
      twitter_username: z.string().optional(),
      location: z.string().optional(),
      name: z.string().optional(),
      description: z.string().optional(),
      has_organization_projects: PermissiveBoolean.optional(),
      has_repository_projects: PermissiveBoolean.optional(),
      default_repository_permission: z
        .enum(["read", "write", "admin", "none"])
        .optional()
        .default("read"),
      members_can_create_repositories:
        PermissiveBoolean.optional().default(true),
      members_can_create_internal_repositories: PermissiveBoolean.optional(),
      members_can_create_private_repositories: PermissiveBoolean.optional(),
      members_can_create_public_repositories: PermissiveBoolean.optional(),
      members_allowed_repository_creation_type: z
        .enum(["all", "private", "none"])
        .optional(),
      members_can_create_pages: PermissiveBoolean.optional().default(true),
      members_can_create_public_pages:
        PermissiveBoolean.optional().default(true),
      members_can_create_private_pages:
        PermissiveBoolean.optional().default(true),
      members_can_fork_private_repositories:
        PermissiveBoolean.optional().default(false),
      web_commit_signoff_required: PermissiveBoolean.optional().default(false),
      blog: z.string().optional(),
      advanced_security_enabled_for_new_repositories:
        PermissiveBoolean.optional(),
      dependabot_alerts_enabled_for_new_repositories:
        PermissiveBoolean.optional(),
      dependabot_security_updates_enabled_for_new_repositories:
        PermissiveBoolean.optional(),
      dependency_graph_enabled_for_new_repositories:
        PermissiveBoolean.optional(),
      secret_scanning_enabled_for_new_repositories:
        PermissiveBoolean.optional(),
      secret_scanning_push_protection_enabled_for_new_repositories:
        PermissiveBoolean.optional(),
      secret_scanning_push_protection_custom_link_enabled:
        PermissiveBoolean.optional(),
      secret_scanning_push_protection_custom_link: z.string().optional(),
      deploy_keys_enabled_for_repositories: PermissiveBoolean.optional(),
    })
    .optional()

  router.patch("orgsUpdate", "/orgs/:org", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsUpdateParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        orgsUpdateBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .orgsUpdate(input, orgsUpdate.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsUpdate.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsDeleteParamSchema = z.object({ org: z.string() })

  router.delete("orgsDelete", "/orgs/:org", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsDeleteParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .orgsDelete(input, orgsDelete.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsDelete.validator(status, body)
    ctx.status = status
    return next()
  })

  const actionsGetActionsCacheUsageForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetActionsCacheUsageForOrg",
    "/orgs/:org/actions/cache/usage",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetActionsCacheUsageForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetActionsCacheUsageForOrg(
          input,
          actionsGetActionsCacheUsageForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetActionsCacheUsageForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetActionsCacheUsageByRepoForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGetActionsCacheUsageByRepoForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsGetActionsCacheUsageByRepoForOrg",
    "/orgs/:org/actions/cache/usage-by-repository",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetActionsCacheUsageByRepoForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsGetActionsCacheUsageByRepoForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetActionsCacheUsageByRepoForOrg(
          input,
          actionsGetActionsCacheUsageByRepoForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetActionsCacheUsageByRepoForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListHostedRunnersForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsListHostedRunnersForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListHostedRunnersForOrg",
    "/orgs/:org/actions/hosted-runners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListHostedRunnersForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListHostedRunnersForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListHostedRunnersForOrg(
          input,
          actionsListHostedRunnersForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListHostedRunnersForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsCreateHostedRunnerForOrgBodySchema = z.object({
    name: z.string(),
    image: z.object({
      id: z.string().optional(),
      source: z.enum(["github", "partner", "custom"]).optional(),
    }),
    size: z.string(),
    runner_group_id: z.coerce.number(),
    maximum_runners: z.coerce.number().optional(),
    enable_static_ip: PermissiveBoolean.optional(),
  })

  router.post(
    "actionsCreateHostedRunnerForOrg",
    "/orgs/:org/actions/hosted-runners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateHostedRunnerForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateHostedRunnerForOrg(
          input,
          actionsCreateHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateHostedRunnerForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetHostedRunnersGithubOwnedImagesForOrg",
    "/orgs/:org/actions/hosted-runners/images/github-owned",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetHostedRunnersGithubOwnedImagesForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetHostedRunnersGithubOwnedImagesForOrg(
          input,
          actionsGetHostedRunnersGithubOwnedImagesForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetHostedRunnersGithubOwnedImagesForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsGetHostedRunnersPartnerImagesForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetHostedRunnersPartnerImagesForOrg",
    "/orgs/:org/actions/hosted-runners/images/partner",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetHostedRunnersPartnerImagesForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetHostedRunnersPartnerImagesForOrg(
          input,
          actionsGetHostedRunnersPartnerImagesForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetHostedRunnersPartnerImagesForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsGetHostedRunnersLimitsForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetHostedRunnersLimitsForOrg",
    "/orgs/:org/actions/hosted-runners/limits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetHostedRunnersLimitsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetHostedRunnersLimitsForOrg(
          input,
          actionsGetHostedRunnersLimitsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetHostedRunnersLimitsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetHostedRunnersMachineSpecsForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetHostedRunnersMachineSpecsForOrg",
    "/orgs/:org/actions/hosted-runners/machine-sizes",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetHostedRunnersMachineSpecsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetHostedRunnersMachineSpecsForOrg(
          input,
          actionsGetHostedRunnersMachineSpecsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetHostedRunnersMachineSpecsForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsGetHostedRunnersPlatformsForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetHostedRunnersPlatformsForOrg",
    "/orgs/:org/actions/hosted-runners/platforms",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetHostedRunnersPlatformsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetHostedRunnersPlatformsForOrg(
          input,
          actionsGetHostedRunnersPlatformsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetHostedRunnersPlatformsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    hosted_runner_id: z.coerce.number(),
  })

  router.get(
    "actionsGetHostedRunnerForOrg",
    "/orgs/:org/actions/hosted-runners/:hosted_runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetHostedRunnerForOrg(
          input,
          actionsGetHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetHostedRunnerForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsUpdateHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    hosted_runner_id: z.coerce.number(),
  })

  const actionsUpdateHostedRunnerForOrgBodySchema = z.object({
    name: z.string().optional(),
    runner_group_id: z.coerce.number().optional(),
    maximum_runners: z.coerce.number().optional(),
    enable_static_ip: PermissiveBoolean.optional(),
  })

  router.patch(
    "actionsUpdateHostedRunnerForOrg",
    "/orgs/:org/actions/hosted-runners/:hosted_runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsUpdateHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsUpdateHostedRunnerForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsUpdateHostedRunnerForOrg(
          input,
          actionsUpdateHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsUpdateHostedRunnerForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    hosted_runner_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteHostedRunnerForOrg",
    "/orgs/:org/actions/hosted-runners/:hosted_runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteHostedRunnerForOrg(
          input,
          actionsDeleteHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteHostedRunnerForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oidcGetOidcCustomSubTemplateForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "oidcGetOidcCustomSubTemplateForOrg",
    "/orgs/:org/actions/oidc/customization/sub",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oidcGetOidcCustomSubTemplateForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .oidcGetOidcCustomSubTemplateForOrg(
          input,
          oidcGetOidcCustomSubTemplateForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oidcGetOidcCustomSubTemplateForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const oidcUpdateOidcCustomSubTemplateForOrgParamSchema = z.object({
    org: z.string(),
  })

  const oidcUpdateOidcCustomSubTemplateForOrgBodySchema = s_oidc_custom_sub

  router.put(
    "oidcUpdateOidcCustomSubTemplateForOrg",
    "/orgs/:org/actions/oidc/customization/sub",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          oidcUpdateOidcCustomSubTemplateForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          oidcUpdateOidcCustomSubTemplateForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .oidcUpdateOidcCustomSubTemplateForOrg(
          input,
          oidcUpdateOidcCustomSubTemplateForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = oidcUpdateOidcCustomSubTemplateForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetGithubActionsPermissionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetGithubActionsPermissionsOrganization",
    "/orgs/:org/actions/permissions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetGithubActionsPermissionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetGithubActionsPermissionsOrganization(
          input,
          actionsGetGithubActionsPermissionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetGithubActionsPermissionsOrganization.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsSetGithubActionsPermissionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const actionsSetGithubActionsPermissionsOrganizationBodySchema = z.object({
    enabled_repositories: s_enabled_repositories,
    allowed_actions: s_allowed_actions.optional(),
  })

  router.put(
    "actionsSetGithubActionsPermissionsOrganization",
    "/orgs/:org/actions/permissions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetGithubActionsPermissionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetGithubActionsPermissionsOrganizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetGithubActionsPermissionsOrganization(
          input,
          actionsSetGithubActionsPermissionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetGithubActionsPermissionsOrganization.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema =
    z.object({ org: z.string() })

  const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema =
    z.object({
      per_page: z.coerce.number().optional().default(30),
      page: z.coerce.number().optional().default(1),
    })

  router.get(
    "actionsListSelectedRepositoriesEnabledGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
          input,
          actionsListSelectedRepositoriesEnabledGithubActionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsListSelectedRepositoriesEnabledGithubActionsOrganization.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema =
    z.object({ org: z.string() })

  const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema =
    z.object({ selected_repository_ids: z.array(z.coerce.number()) })

  router.put(
    "actionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
          input,
          actionsSetSelectedRepositoriesEnabledGithubActionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsSetSelectedRepositoriesEnabledGithubActionsOrganization.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema =
    z.object({ org: z.string(), repository_id: z.coerce.number() })

  router.put(
    "actionsEnableSelectedRepositoryGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsEnableSelectedRepositoryGithubActionsOrganization(
          input,
          actionsEnableSelectedRepositoryGithubActionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsEnableSelectedRepositoryGithubActionsOrganization.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema =
    z.object({ org: z.string(), repository_id: z.coerce.number() })

  router.delete(
    "actionsDisableSelectedRepositoryGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDisableSelectedRepositoryGithubActionsOrganization(
          input,
          actionsDisableSelectedRepositoryGithubActionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsDisableSelectedRepositoryGithubActionsOrganization.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsGetAllowedActionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsGetAllowedActionsOrganization",
    "/orgs/:org/actions/permissions/selected-actions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetAllowedActionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetAllowedActionsOrganization(
          input,
          actionsGetAllowedActionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetAllowedActionsOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsSetAllowedActionsOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const actionsSetAllowedActionsOrganizationBodySchema =
    s_selected_actions.optional()

  router.put(
    "actionsSetAllowedActionsOrganization",
    "/orgs/:org/actions/permissions/selected-actions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetAllowedActionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetAllowedActionsOrganizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetAllowedActionsOrganization(
          input,
          actionsSetAllowedActionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetAllowedActionsOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema =
    z.object({ org: z.string() })

  router.get(
    "actionsGetGithubActionsDefaultWorkflowPermissionsOrganization",
    "/orgs/:org/actions/permissions/workflow",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
          input,
          actionsGetGithubActionsDefaultWorkflowPermissionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsGetGithubActionsDefaultWorkflowPermissionsOrganization.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema =
    z.object({ org: z.string() })

  const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema =
    s_actions_set_default_workflow_permissions.optional()

  router.put(
    "actionsSetGithubActionsDefaultWorkflowPermissionsOrganization",
    "/orgs/:org/actions/permissions/workflow",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
          input,
          actionsSetGithubActionsDefaultWorkflowPermissionsOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsSetGithubActionsDefaultWorkflowPermissionsOrganization.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsListSelfHostedRunnerGroupsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsListSelfHostedRunnerGroupsForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    visible_to_repository: z.string().optional(),
  })

  router.get(
    "actionsListSelfHostedRunnerGroupsForOrg",
    "/orgs/:org/actions/runner-groups",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListSelfHostedRunnerGroupsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListSelfHostedRunnerGroupsForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListSelfHostedRunnerGroupsForOrg(
          input,
          actionsListSelfHostedRunnerGroupsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListSelfHostedRunnerGroupsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsCreateSelfHostedRunnerGroupForOrgBodySchema = z.object({
    name: z.string(),
    visibility: z
      .enum(["selected", "all", "private"])
      .optional()
      .default("all"),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
    runners: z.array(z.coerce.number()).optional(),
    allows_public_repositories: PermissiveBoolean.optional().default(false),
    restricted_to_workflows: PermissiveBoolean.optional().default(false),
    selected_workflows: z.array(z.string()).optional(),
    network_configuration_id: z.string().optional(),
  })

  router.post(
    "actionsCreateSelfHostedRunnerGroupForOrg",
    "/orgs/:org/actions/runner-groups",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateSelfHostedRunnerGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateSelfHostedRunnerGroupForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateSelfHostedRunnerGroupForOrg(
          input,
          actionsCreateSelfHostedRunnerGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateSelfHostedRunnerGroupForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsGetSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  router.get(
    "actionsGetSelfHostedRunnerGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetSelfHostedRunnerGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetSelfHostedRunnerGroupForOrg(
          input,
          actionsGetSelfHostedRunnerGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetSelfHostedRunnerGroupForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsUpdateSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsUpdateSelfHostedRunnerGroupForOrgBodySchema = z.object({
    name: z.string(),
    visibility: z.enum(["selected", "all", "private"]).optional(),
    allows_public_repositories: PermissiveBoolean.optional().default(false),
    restricted_to_workflows: PermissiveBoolean.optional().default(false),
    selected_workflows: z.array(z.string()).optional(),
    network_configuration_id: z.string().nullable().optional(),
  })

  router.patch(
    "actionsUpdateSelfHostedRunnerGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsUpdateSelfHostedRunnerGroupForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsUpdateSelfHostedRunnerGroupForOrg(
          input,
          actionsUpdateSelfHostedRunnerGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsUpdateSelfHostedRunnerGroupForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteSelfHostedRunnerGroupFromOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteSelfHostedRunnerGroupFromOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteSelfHostedRunnerGroupFromOrg(
          input,
          actionsDeleteSelfHostedRunnerGroupFromOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteSelfHostedRunnerGroupFromOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsListGithubHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsListGithubHostedRunnersInGroupForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListGithubHostedRunnersInGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/hosted-runners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListGithubHostedRunnersInGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListGithubHostedRunnersInGroupForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListGithubHostedRunnersInGroupForOrg(
          input,
          actionsListGithubHostedRunnersInGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListGithubHostedRunnersInGroupForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object(
    { org: z.string(), runner_group_id: z.coerce.number() },
  )

  const actionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema = z.object(
    {
      page: z.coerce.number().optional().default(1),
      per_page: z.coerce.number().optional().default(30),
    },
  )

  router.get(
    "actionsListRepoAccessToSelfHostedRunnerGroupInOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
          input,
          actionsListRepoAccessToSelfHostedRunnerGroupInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRepoAccessToSelfHostedRunnerGroupInOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
          input,
          actionsSetRepoAccessToSelfHostedRunnerGroupInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetRepoAccessToSelfHostedRunnerGroupInOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "actionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsAddRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsAddRepoAccessToSelfHostedRunnerGroupInOrg(
          input,
          actionsAddRepoAccessToSelfHostedRunnerGroupInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsAddRepoAccessToSelfHostedRunnerGroupInOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema =
    z.object({
      org: z.string(),
      runner_group_id: z.coerce.number(),
      repository_id: z.coerce.number(),
    })

  router.delete(
    "actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
          input,
          actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsListSelfHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsListSelfHostedRunnersInGroupForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListSelfHostedRunnersInGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/runners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListSelfHostedRunnersInGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListSelfHostedRunnersInGroupForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListSelfHostedRunnersInGroupForOrg(
          input,
          actionsListSelfHostedRunnersInGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListSelfHostedRunnersInGroupForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsSetSelfHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsSetSelfHostedRunnersInGroupForOrgBodySchema = z.object({
    runners: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetSelfHostedRunnersInGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/runners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetSelfHostedRunnersInGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetSelfHostedRunnersInGroupForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetSelfHostedRunnersInGroupForOrg(
          input,
          actionsSetSelfHostedRunnersInGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetSelfHostedRunnersInGroupForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsAddSelfHostedRunnerToGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
    runner_id: z.coerce.number(),
  })

  router.put(
    "actionsAddSelfHostedRunnerToGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsAddSelfHostedRunnerToGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsAddSelfHostedRunnerToGroupForOrg(
          input,
          actionsAddSelfHostedRunnerToGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsAddSelfHostedRunnerToGroupForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema = z.object({
    org: z.string(),
    runner_group_id: z.coerce.number(),
    runner_id: z.coerce.number(),
  })

  router.delete(
    "actionsRemoveSelfHostedRunnerFromGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveSelfHostedRunnerFromGroupForOrg(
          input,
          actionsRemoveSelfHostedRunnerFromGroupForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsRemoveSelfHostedRunnerFromGroupForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsListSelfHostedRunnersForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsListSelfHostedRunnersForOrgQuerySchema = z.object({
    name: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListSelfHostedRunnersForOrg",
    "/orgs/:org/actions/runners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListSelfHostedRunnersForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListSelfHostedRunnersForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListSelfHostedRunnersForOrg(
          input,
          actionsListSelfHostedRunnersForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListSelfHostedRunnersForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListRunnerApplicationsForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "actionsListRunnerApplicationsForOrg",
    "/orgs/:org/actions/runners/downloads",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRunnerApplicationsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRunnerApplicationsForOrg(
          input,
          actionsListRunnerApplicationsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRunnerApplicationsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGenerateRunnerJitconfigForOrgParamSchema = z.object({
    org: z.string(),
  })

  const actionsGenerateRunnerJitconfigForOrgBodySchema = z.object({
    name: z.string(),
    runner_group_id: z.coerce.number(),
    labels: z.array(z.string()).min(1).max(100),
    work_folder: z.string().optional().default("_work"),
  })

  router.post(
    "actionsGenerateRunnerJitconfigForOrg",
    "/orgs/:org/actions/runners/generate-jitconfig",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGenerateRunnerJitconfigForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsGenerateRunnerJitconfigForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsGenerateRunnerJitconfigForOrg(
          input,
          actionsGenerateRunnerJitconfigForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGenerateRunnerJitconfigForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateRegistrationTokenForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.post(
    "actionsCreateRegistrationTokenForOrg",
    "/orgs/:org/actions/runners/registration-token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateRegistrationTokenForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateRegistrationTokenForOrg(
          input,
          actionsCreateRegistrationTokenForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateRegistrationTokenForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateRemoveTokenForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.post(
    "actionsCreateRemoveTokenForOrg",
    "/orgs/:org/actions/runners/remove-token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateRemoveTokenForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateRemoveTokenForOrg(
          input,
          actionsCreateRemoveTokenForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateRemoveTokenForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsGetSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetSelfHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetSelfHostedRunnerForOrg(
          input,
          actionsGetSelfHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetSelfHostedRunnerForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteSelfHostedRunnerFromOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteSelfHostedRunnerFromOrg",
    "/orgs/:org/actions/runners/:runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteSelfHostedRunnerFromOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteSelfHostedRunnerFromOrg(
          input,
          actionsDeleteSelfHostedRunnerFromOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteSelfHostedRunnerFromOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListLabelsForSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsListLabelsForSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListLabelsForSelfHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListLabelsForSelfHostedRunnerForOrg(
          input,
          actionsListLabelsForSelfHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListLabelsForSelfHostedRunnerForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema = z.object({
    labels: z.array(z.string()).min(1).max(100),
  })

  router.post(
    "actionsAddCustomLabelsToSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsAddCustomLabelsToSelfHostedRunnerForOrg(
          input,
          actionsAddCustomLabelsToSelfHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsAddCustomLabelsToSelfHostedRunnerForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema = z.object({
    labels: z.array(z.string()).min(0).max(100),
  })

  router.put(
    "actionsSetCustomLabelsForSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetCustomLabelsForSelfHostedRunnerForOrg(
          input,
          actionsSetCustomLabelsForSelfHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetCustomLabelsForSelfHostedRunnerForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema =
    z.object({ org: z.string(), runner_id: z.coerce.number() })

  router.delete(
    "actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
          input,
          actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema =
    z.object({
      org: z.string(),
      runner_id: z.coerce.number(),
      name: z.string(),
    })

  router.delete(
    "actionsRemoveCustomLabelFromSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runner_id/labels/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
          input,
          actionsRemoveCustomLabelFromSelfHostedRunnerForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsRemoveCustomLabelFromSelfHostedRunnerForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsListOrgSecretsParamSchema = z.object({ org: z.string() })

  const actionsListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListOrgSecrets",
    "/orgs/:org/actions/secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListOrgSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListOrgSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListOrgSecrets(input, actionsListOrgSecrets.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListOrgSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetOrgPublicKeyParamSchema = z.object({ org: z.string() })

  router.get(
    "actionsGetOrgPublicKey",
    "/orgs/:org/actions/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetOrgPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetOrgPublicKey(input, actionsGetOrgPublicKey.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetOrgPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "actionsGetOrgSecret",
    "/orgs/:org/actions/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetOrgSecret(input, actionsGetOrgSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsCreateOrUpdateOrgSecretBodySchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      ),
    key_id: z.string(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.put(
    "actionsCreateOrUpdateOrgSecret",
    "/orgs/:org/actions/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateOrUpdateOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateOrUpdateOrgSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateOrUpdateOrgSecret(
          input,
          actionsCreateOrUpdateOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateOrUpdateOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "actionsDeleteOrgSecret",
    "/orgs/:org/actions/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteOrgSecret(input, actionsDeleteOrgSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "actionsListSelectedReposForOrgSecret",
    "/orgs/:org/actions/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListSelectedReposForOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListSelectedReposForOrgSecretQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListSelectedReposForOrgSecret(
          input,
          actionsListSelectedReposForOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListSelectedReposForOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const actionsSetSelectedReposForOrgSecretBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetSelectedReposForOrgSecret",
    "/orgs/:org/actions/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetSelectedReposForOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetSelectedReposForOrgSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetSelectedReposForOrgSecret(
          input,
          actionsSetSelectedReposForOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetSelectedReposForOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "actionsAddSelectedRepoToOrgSecret",
    "/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsAddSelectedRepoToOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsAddSelectedRepoToOrgSecret(
          input,
          actionsAddSelectedRepoToOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsAddSelectedRepoToOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "actionsRemoveSelectedRepoFromOrgSecret",
    "/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveSelectedRepoFromOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveSelectedRepoFromOrgSecret(
          input,
          actionsRemoveSelectedRepoFromOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsRemoveSelectedRepoFromOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListOrgVariablesParamSchema = z.object({ org: z.string() })

  const actionsListOrgVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListOrgVariables",
    "/orgs/:org/actions/variables",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListOrgVariablesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListOrgVariablesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListOrgVariables(input, actionsListOrgVariables.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListOrgVariables.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateOrgVariableParamSchema = z.object({ org: z.string() })

  const actionsCreateOrgVariableBodySchema = z.object({
    name: z.string(),
    value: z.string(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.post(
    "actionsCreateOrgVariable",
    "/orgs/:org/actions/variables",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateOrgVariableBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateOrgVariable(
          input,
          actionsCreateOrgVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateOrgVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  router.get(
    "actionsGetOrgVariable",
    "/orgs/:org/actions/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetOrgVariable(input, actionsGetOrgVariable.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetOrgVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsUpdateOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsUpdateOrgVariableBodySchema = z.object({
    name: z.string().optional(),
    value: z.string().optional(),
    visibility: z.enum(["all", "private", "selected"]).optional(),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.patch(
    "actionsUpdateOrgVariable",
    "/orgs/:org/actions/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsUpdateOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsUpdateOrgVariableBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsUpdateOrgVariable(
          input,
          actionsUpdateOrgVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsUpdateOrgVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  router.delete(
    "actionsDeleteOrgVariable",
    "/orgs/:org/actions/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteOrgVariable(
          input,
          actionsDeleteOrgVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteOrgVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListSelectedReposForOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsListSelectedReposForOrgVariableQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "actionsListSelectedReposForOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListSelectedReposForOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListSelectedReposForOrgVariableQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListSelectedReposForOrgVariable(
          input,
          actionsListSelectedReposForOrgVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListSelectedReposForOrgVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsSetSelectedReposForOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
  })

  const actionsSetSelectedReposForOrgVariableBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetSelectedReposForOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetSelectedReposForOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetSelectedReposForOrgVariableBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetSelectedReposForOrgVariable(
          input,
          actionsSetSelectedReposForOrgVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetSelectedReposForOrgVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsAddSelectedRepoToOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "actionsAddSelectedRepoToOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsAddSelectedRepoToOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsAddSelectedRepoToOrgVariable(
          input,
          actionsAddSelectedRepoToOrgVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsAddSelectedRepoToOrgVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveSelectedRepoFromOrgVariableParamSchema = z.object({
    org: z.string(),
    name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "actionsRemoveSelectedRepoFromOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveSelectedRepoFromOrgVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveSelectedRepoFromOrgVariable(
          input,
          actionsRemoveSelectedRepoFromOrgVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsRemoveSelectedRepoFromOrgVariable.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const orgsListAttestationsParamSchema = z.object({
    org: z.string(),
    subject_digest: z.string(),
  })

  const orgsListAttestationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    predicate_type: z.string().optional(),
  })

  router.get(
    "orgsListAttestations",
    "/orgs/:org/attestations/:subject_digest",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListAttestationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListAttestationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListAttestations(input, orgsListAttestations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListAttestations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListBlockedUsersParamSchema = z.object({ org: z.string() })

  const orgsListBlockedUsersQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("orgsListBlockedUsers", "/orgs/:org/blocks", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsListBlockedUsersParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        orgsListBlockedUsersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .orgsListBlockedUsers(input, orgsListBlockedUsers.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsListBlockedUsers.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsCheckBlockedUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.get(
    "orgsCheckBlockedUser",
    "/orgs/:org/blocks/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCheckBlockedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsCheckBlockedUser(input, orgsCheckBlockedUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCheckBlockedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsBlockUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.put(
    "orgsBlockUser",
    "/orgs/:org/blocks/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsBlockUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsBlockUser(input, orgsBlockUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsBlockUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsUnblockUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.delete(
    "orgsUnblockUser",
    "/orgs/:org/blocks/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsUnblockUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsUnblockUser(input, orgsUnblockUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsUnblockUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const campaignsListOrgCampaignsParamSchema = z.object({ org: z.string() })

  const campaignsListOrgCampaignsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    state: s_campaign_state.optional(),
    sort: z
      .enum(["created", "updated", "ends_at", "published"])
      .optional()
      .default("created"),
  })

  router.get(
    "campaignsListOrgCampaigns",
    "/orgs/:org/campaigns",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          campaignsListOrgCampaignsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          campaignsListOrgCampaignsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .campaignsListOrgCampaigns(
          input,
          campaignsListOrgCampaigns.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = campaignsListOrgCampaigns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const campaignsCreateCampaignParamSchema = z.object({ org: z.string() })

  const campaignsCreateCampaignBodySchema = z.object({
    name: z.string().min(1).max(50),
    description: z.string().min(1).max(255),
    managers: z.array(z.string()).max(10).optional(),
    team_managers: z.array(z.string()).max(10).optional(),
    ends_at: z.string().datetime({ offset: true }),
    contact_link: z.string().nullable().optional(),
    code_scanning_alerts: z
      .array(
        z.object({
          repository_id: z.coerce.number(),
          alert_numbers: z.array(z.coerce.number()).min(1),
        }),
      )
      .min(1),
    generate_issues: PermissiveBoolean.optional().default(false),
  })

  router.post(
    "campaignsCreateCampaign",
    "/orgs/:org/campaigns",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          campaignsCreateCampaignParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          campaignsCreateCampaignBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .campaignsCreateCampaign(input, campaignsCreateCampaign.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = campaignsCreateCampaign.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const campaignsGetCampaignSummaryParamSchema = z.object({
    org: z.string(),
    campaign_number: z.coerce.number(),
  })

  router.get(
    "campaignsGetCampaignSummary",
    "/orgs/:org/campaigns/:campaign_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          campaignsGetCampaignSummaryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .campaignsGetCampaignSummary(
          input,
          campaignsGetCampaignSummary.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = campaignsGetCampaignSummary.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const campaignsUpdateCampaignParamSchema = z.object({
    org: z.string(),
    campaign_number: z.coerce.number(),
  })

  const campaignsUpdateCampaignBodySchema = z.object({
    name: z.string().min(1).max(50).optional(),
    description: z.string().min(1).max(255).optional(),
    managers: z.array(z.string()).max(10).optional(),
    team_managers: z.array(z.string()).max(10).optional(),
    ends_at: z.string().datetime({ offset: true }).optional(),
    contact_link: z.string().nullable().optional(),
    state: s_campaign_state.optional(),
  })

  router.patch(
    "campaignsUpdateCampaign",
    "/orgs/:org/campaigns/:campaign_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          campaignsUpdateCampaignParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          campaignsUpdateCampaignBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .campaignsUpdateCampaign(input, campaignsUpdateCampaign.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = campaignsUpdateCampaign.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const campaignsDeleteCampaignParamSchema = z.object({
    org: z.string(),
    campaign_number: z.coerce.number(),
  })

  router.delete(
    "campaignsDeleteCampaign",
    "/orgs/:org/campaigns/:campaign_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          campaignsDeleteCampaignParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .campaignsDeleteCampaign(input, campaignsDeleteCampaign.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = campaignsDeleteCampaign.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningListAlertsForOrgParamSchema = z.object({ org: z.string() })

  const codeScanningListAlertsForOrgQuerySchema = z.object({
    tool_name: s_code_scanning_analysis_tool_name.optional(),
    tool_guid: s_code_scanning_analysis_tool_guid.optional(),
    before: z.string().optional(),
    after: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    state: s_code_scanning_alert_state_query.optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    severity: s_code_scanning_alert_severity.optional(),
  })

  router.get(
    "codeScanningListAlertsForOrg",
    "/orgs/:org/code-scanning/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningListAlertsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeScanningListAlertsForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningListAlertsForOrg(
          input,
          codeScanningListAlertsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningListAlertsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetConfigurationsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const codeSecurityGetConfigurationsForOrgQuerySchema = z.object({
    target_type: z.enum(["global", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
  })

  router.get(
    "codeSecurityGetConfigurationsForOrg",
    "/orgs/:org/code-security/configurations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetConfigurationsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeSecurityGetConfigurationsForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetConfigurationsForOrg(
          input,
          codeSecurityGetConfigurationsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetConfigurationsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityCreateConfigurationParamSchema = z.object({
    org: z.string(),
  })

  const codeSecurityCreateConfigurationBodySchema = z.object({
    name: z.string(),
    description: z.string().max(255),
    advanced_security: z
      .enum(["enabled", "disabled", "code_security", "secret_protection"])
      .optional()
      .default("disabled"),
    dependency_graph: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("enabled"),
    dependency_graph_autosubmit_action: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    dependency_graph_autosubmit_action_options: z
      .object({ labeled_runners: PermissiveBoolean.optional().default(false) })
      .optional(),
    dependabot_alerts: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    dependabot_security_updates: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    code_scanning_default_setup: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    code_scanning_default_setup_options:
      s_code_scanning_default_setup_options.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("not_set"),
    secret_scanning: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_push_protection: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_delegated_bypass: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_delegated_bypass_options: z
      .object({
        reviewers: z
          .array(
            z.object({
              reviewer_id: z.coerce.number(),
              reviewer_type: z.enum(["TEAM", "ROLE"]),
            }),
          )
          .optional(),
      })
      .optional(),
    secret_scanning_validity_checks: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_non_provider_patterns: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_generic_secrets: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    private_vulnerability_reporting: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    enforcement: z
      .enum(["enforced", "unenforced"])
      .optional()
      .default("enforced"),
  })

  router.post(
    "codeSecurityCreateConfiguration",
    "/orgs/:org/code-security/configurations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityCreateConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecurityCreateConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityCreateConfiguration(
          input,
          codeSecurityCreateConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityCreateConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetDefaultConfigurationsParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "codeSecurityGetDefaultConfigurations",
    "/orgs/:org/code-security/configurations/defaults",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetDefaultConfigurationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetDefaultConfigurations(
          input,
          codeSecurityGetDefaultConfigurations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetDefaultConfigurations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityDetachConfigurationParamSchema = z.object({
    org: z.string(),
  })

  const codeSecurityDetachConfigurationBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.delete(
    "codeSecurityDetachConfiguration",
    "/orgs/:org/code-security/configurations/detach",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityDetachConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecurityDetachConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityDetachConfiguration(
          input,
          codeSecurityDetachConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityDetachConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  router.get(
    "codeSecurityGetConfiguration",
    "/orgs/:org/code-security/configurations/:configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetConfiguration(
          input,
          codeSecurityGetConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityUpdateConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityUpdateConfigurationBodySchema = z.object({
    name: z.string().optional(),
    description: z.string().max(255).optional(),
    advanced_security: z
      .enum(["enabled", "disabled", "code_security", "secret_protection"])
      .optional(),
    dependency_graph: z.enum(["enabled", "disabled", "not_set"]).optional(),
    dependency_graph_autosubmit_action: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    dependency_graph_autosubmit_action_options: z
      .object({ labeled_runners: PermissiveBoolean.optional() })
      .optional(),
    dependabot_alerts: z.enum(["enabled", "disabled", "not_set"]).optional(),
    dependabot_security_updates: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    code_scanning_default_setup: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    code_scanning_default_setup_options:
      s_code_scanning_default_setup_options.optional(),
    code_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional()
      .default("disabled"),
    secret_scanning: z.enum(["enabled", "disabled", "not_set"]).optional(),
    secret_scanning_push_protection: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_delegated_bypass: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_delegated_bypass_options: z
      .object({
        reviewers: z
          .array(
            z.object({
              reviewer_id: z.coerce.number(),
              reviewer_type: z.enum(["TEAM", "ROLE"]),
            }),
          )
          .optional(),
      })
      .optional(),
    secret_scanning_validity_checks: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_non_provider_patterns: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_generic_secrets: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    secret_scanning_delegated_alert_dismissal: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    private_vulnerability_reporting: z
      .enum(["enabled", "disabled", "not_set"])
      .optional(),
    enforcement: z.enum(["enforced", "unenforced"]).optional(),
  })

  router.patch(
    "codeSecurityUpdateConfiguration",
    "/orgs/:org/code-security/configurations/:configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityUpdateConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecurityUpdateConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityUpdateConfiguration(
          input,
          codeSecurityUpdateConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityUpdateConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityDeleteConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  router.delete(
    "codeSecurityDeleteConfiguration",
    "/orgs/:org/code-security/configurations/:configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityDeleteConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityDeleteConfiguration(
          input,
          codeSecurityDeleteConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityDeleteConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityAttachConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityAttachConfigurationBodySchema = z.object({
    scope: z.enum([
      "all",
      "all_without_configurations",
      "public",
      "private_or_internal",
      "selected",
    ]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.post(
    "codeSecurityAttachConfiguration",
    "/orgs/:org/code-security/configurations/:configuration_id/attach",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityAttachConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecurityAttachConfigurationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityAttachConfiguration(
          input,
          codeSecurityAttachConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityAttachConfiguration.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecuritySetConfigurationAsDefaultParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecuritySetConfigurationAsDefaultBodySchema = z.object({
    default_for_new_repos: z
      .enum(["all", "none", "private_and_internal", "public"])
      .optional(),
  })

  router.put(
    "codeSecuritySetConfigurationAsDefault",
    "/orgs/:org/code-security/configurations/:configuration_id/defaults",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecuritySetConfigurationAsDefaultParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeSecuritySetConfigurationAsDefaultBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeSecuritySetConfigurationAsDefault(
          input,
          codeSecuritySetConfigurationAsDefault.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecuritySetConfigurationAsDefault.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetRepositoriesForConfigurationParamSchema = z.object({
    org: z.string(),
    configuration_id: z.coerce.number(),
  })

  const codeSecurityGetRepositoriesForConfigurationQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    status: z.string().optional().default("all"),
  })

  router.get(
    "codeSecurityGetRepositoriesForConfiguration",
    "/orgs/:org/code-security/configurations/:configuration_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetRepositoriesForConfigurationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeSecurityGetRepositoriesForConfigurationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetRepositoriesForConfiguration(
          input,
          codeSecurityGetRepositoriesForConfiguration.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetRepositoriesForConfiguration.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesListInOrganizationParamSchema = z.object({ org: z.string() })

  const codespacesListInOrganizationQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "codespacesListInOrganization",
    "/orgs/:org/codespaces",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesListInOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesListInOrganizationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListInOrganization(
          input,
          codespacesListInOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesListInOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesSetCodespacesAccessParamSchema = z.object({ org: z.string() })

  const codespacesSetCodespacesAccessBodySchema = z.object({
    visibility: z.enum([
      "disabled",
      "selected_members",
      "all_members",
      "all_members_and_outside_collaborators",
    ]),
    selected_usernames: z.array(z.string()).max(100).optional(),
  })

  router.put(
    "codespacesSetCodespacesAccess",
    "/orgs/:org/codespaces/access",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesSetCodespacesAccessParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesSetCodespacesAccessBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesSetCodespacesAccess(
          input,
          codespacesSetCodespacesAccess.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesSetCodespacesAccess.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesSetCodespacesAccessUsersParamSchema = z.object({
    org: z.string(),
  })

  const codespacesSetCodespacesAccessUsersBodySchema = z.object({
    selected_usernames: z.array(z.string()).max(100),
  })

  router.post(
    "codespacesSetCodespacesAccessUsers",
    "/orgs/:org/codespaces/access/selected_users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesSetCodespacesAccessUsersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesSetCodespacesAccessUsersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesSetCodespacesAccessUsers(
          input,
          codespacesSetCodespacesAccessUsers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesSetCodespacesAccessUsers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesDeleteCodespacesAccessUsersParamSchema = z.object({
    org: z.string(),
  })

  const codespacesDeleteCodespacesAccessUsersBodySchema = z.object({
    selected_usernames: z.array(z.string()).max(100),
  })

  router.delete(
    "codespacesDeleteCodespacesAccessUsers",
    "/orgs/:org/codespaces/access/selected_users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesDeleteCodespacesAccessUsersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesDeleteCodespacesAccessUsersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesDeleteCodespacesAccessUsers(
          input,
          codespacesDeleteCodespacesAccessUsers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesDeleteCodespacesAccessUsers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesListOrgSecretsParamSchema = z.object({ org: z.string() })

  const codespacesListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "codespacesListOrgSecrets",
    "/orgs/:org/codespaces/secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesListOrgSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesListOrgSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListOrgSecrets(
          input,
          codespacesListOrgSecrets.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesListOrgSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesGetOrgPublicKeyParamSchema = z.object({ org: z.string() })

  router.get(
    "codespacesGetOrgPublicKey",
    "/orgs/:org/codespaces/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetOrgPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetOrgPublicKey(
          input,
          codespacesGetOrgPublicKey.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetOrgPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesGetOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "codespacesGetOrgSecret",
    "/orgs/:org/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetOrgSecret(input, codespacesGetOrgSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesCreateOrUpdateOrgSecretBodySchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      )
      .optional(),
    key_id: z.string().optional(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.put(
    "codespacesCreateOrUpdateOrgSecret",
    "/orgs/:org/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesCreateOrUpdateOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesCreateOrUpdateOrgSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesCreateOrUpdateOrgSecret(
          input,
          codespacesCreateOrUpdateOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCreateOrUpdateOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesDeleteOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "codespacesDeleteOrgSecret",
    "/orgs/:org/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesDeleteOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesDeleteOrgSecret(
          input,
          codespacesDeleteOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesDeleteOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "codespacesListSelectedReposForOrgSecret",
    "/orgs/:org/codespaces/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesListSelectedReposForOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesListSelectedReposForOrgSecretQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListSelectedReposForOrgSecret(
          input,
          codespacesListSelectedReposForOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesListSelectedReposForOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const codespacesSetSelectedReposForOrgSecretBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "codespacesSetSelectedReposForOrgSecret",
    "/orgs/:org/codespaces/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesSetSelectedReposForOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesSetSelectedReposForOrgSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesSetSelectedReposForOrgSecret(
          input,
          codespacesSetSelectedReposForOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesSetSelectedReposForOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "codespacesAddSelectedRepoToOrgSecret",
    "/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesAddSelectedRepoToOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesAddSelectedRepoToOrgSecret(
          input,
          codespacesAddSelectedRepoToOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesAddSelectedRepoToOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "codespacesRemoveSelectedRepoFromOrgSecret",
    "/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesRemoveSelectedRepoFromOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesRemoveSelectedRepoFromOrgSecret(
          input,
          codespacesRemoveSelectedRepoFromOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesRemoveSelectedRepoFromOrgSecret.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const copilotGetCopilotOrganizationDetailsParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "copilotGetCopilotOrganizationDetails",
    "/orgs/:org/copilot/billing",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotGetCopilotOrganizationDetailsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .copilotGetCopilotOrganizationDetails(
          input,
          copilotGetCopilotOrganizationDetails.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotGetCopilotOrganizationDetails.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const copilotListCopilotSeatsParamSchema = z.object({ org: z.string() })

  const copilotListCopilotSeatsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(50),
  })

  router.get(
    "copilotListCopilotSeats",
    "/orgs/:org/copilot/billing/seats",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotListCopilotSeatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          copilotListCopilotSeatsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .copilotListCopilotSeats(input, copilotListCopilotSeats.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotListCopilotSeats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const copilotAddCopilotSeatsForTeamsParamSchema = z.object({
    org: z.string(),
  })

  const copilotAddCopilotSeatsForTeamsBodySchema = z.object({
    selected_teams: z.array(z.string()).min(1),
  })

  router.post(
    "copilotAddCopilotSeatsForTeams",
    "/orgs/:org/copilot/billing/selected_teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotAddCopilotSeatsForTeamsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          copilotAddCopilotSeatsForTeamsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .copilotAddCopilotSeatsForTeams(
          input,
          copilotAddCopilotSeatsForTeams.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotAddCopilotSeatsForTeams.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const copilotCancelCopilotSeatAssignmentForTeamsParamSchema = z.object({
    org: z.string(),
  })

  const copilotCancelCopilotSeatAssignmentForTeamsBodySchema = z.object({
    selected_teams: z.array(z.string()).min(1),
  })

  router.delete(
    "copilotCancelCopilotSeatAssignmentForTeams",
    "/orgs/:org/copilot/billing/selected_teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotCancelCopilotSeatAssignmentForTeamsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          copilotCancelCopilotSeatAssignmentForTeamsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .copilotCancelCopilotSeatAssignmentForTeams(
          input,
          copilotCancelCopilotSeatAssignmentForTeams.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotCancelCopilotSeatAssignmentForTeams.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const copilotAddCopilotSeatsForUsersParamSchema = z.object({
    org: z.string(),
  })

  const copilotAddCopilotSeatsForUsersBodySchema = z.object({
    selected_usernames: z.array(z.string()).min(1),
  })

  router.post(
    "copilotAddCopilotSeatsForUsers",
    "/orgs/:org/copilot/billing/selected_users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotAddCopilotSeatsForUsersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          copilotAddCopilotSeatsForUsersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .copilotAddCopilotSeatsForUsers(
          input,
          copilotAddCopilotSeatsForUsers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotAddCopilotSeatsForUsers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const copilotCancelCopilotSeatAssignmentForUsersParamSchema = z.object({
    org: z.string(),
  })

  const copilotCancelCopilotSeatAssignmentForUsersBodySchema = z.object({
    selected_usernames: z.array(z.string()).min(1),
  })

  router.delete(
    "copilotCancelCopilotSeatAssignmentForUsers",
    "/orgs/:org/copilot/billing/selected_users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotCancelCopilotSeatAssignmentForUsersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          copilotCancelCopilotSeatAssignmentForUsersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .copilotCancelCopilotSeatAssignmentForUsers(
          input,
          copilotCancelCopilotSeatAssignmentForUsers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotCancelCopilotSeatAssignmentForUsers.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const copilotCopilotMetricsForOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const copilotCopilotMetricsForOrganizationQuerySchema = z.object({
    since: z.string().optional(),
    until: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(28),
  })

  router.get(
    "copilotCopilotMetricsForOrganization",
    "/orgs/:org/copilot/metrics",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotCopilotMetricsForOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          copilotCopilotMetricsForOrganizationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .copilotCopilotMetricsForOrganization(
          input,
          copilotCopilotMetricsForOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotCopilotMetricsForOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotListAlertsForOrgParamSchema = z.object({ org: z.string() })

  const dependabotListAlertsForOrgQuerySchema = z.object({
    state: z.string().optional(),
    severity: z.string().optional(),
    ecosystem: z.string().optional(),
    package: z.string().optional(),
    epss_percentage: z.string().optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z
      .enum(["created", "updated", "epss_percentage"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    before: z.string().optional(),
    after: z.string().optional(),
    first: z.coerce.number().min(1).max(100).optional().default(30),
    last: z.coerce.number().min(1).max(100).optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "dependabotListAlertsForOrg",
    "/orgs/:org/dependabot/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotListAlertsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          dependabotListAlertsForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotListAlertsForOrg(
          input,
          dependabotListAlertsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotListAlertsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotListOrgSecretsParamSchema = z.object({ org: z.string() })

  const dependabotListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "dependabotListOrgSecrets",
    "/orgs/:org/dependabot/secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotListOrgSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          dependabotListOrgSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotListOrgSecrets(
          input,
          dependabotListOrgSecrets.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotListOrgSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotGetOrgPublicKeyParamSchema = z.object({ org: z.string() })

  router.get(
    "dependabotGetOrgPublicKey",
    "/orgs/:org/dependabot/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotGetOrgPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotGetOrgPublicKey(
          input,
          dependabotGetOrgPublicKey.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotGetOrgPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotGetOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "dependabotGetOrgSecret",
    "/orgs/:org/dependabot/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotGetOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotGetOrgSecret(input, dependabotGetOrgSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotGetOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotCreateOrUpdateOrgSecretBodySchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      )
      .optional(),
    key_id: z.string().optional(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.string()).optional(),
  })

  router.put(
    "dependabotCreateOrUpdateOrgSecret",
    "/orgs/:org/dependabot/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotCreateOrUpdateOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          dependabotCreateOrUpdateOrgSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .dependabotCreateOrUpdateOrgSecret(
          input,
          dependabotCreateOrUpdateOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotCreateOrUpdateOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotDeleteOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "dependabotDeleteOrgSecret",
    "/orgs/:org/dependabot/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotDeleteOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotDeleteOrgSecret(
          input,
          dependabotDeleteOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotDeleteOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "dependabotListSelectedReposForOrgSecret",
    "/orgs/:org/dependabot/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotListSelectedReposForOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          dependabotListSelectedReposForOrgSecretQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotListSelectedReposForOrgSecret(
          input,
          dependabotListSelectedReposForOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotListSelectedReposForOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const dependabotSetSelectedReposForOrgSecretBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "dependabotSetSelectedReposForOrgSecret",
    "/orgs/:org/dependabot/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotSetSelectedReposForOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          dependabotSetSelectedReposForOrgSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .dependabotSetSelectedReposForOrgSecret(
          input,
          dependabotSetSelectedReposForOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotSetSelectedReposForOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "dependabotAddSelectedRepoToOrgSecret",
    "/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotAddSelectedRepoToOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotAddSelectedRepoToOrgSecret(
          input,
          dependabotAddSelectedRepoToOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotAddSelectedRepoToOrgSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "dependabotRemoveSelectedRepoFromOrgSecret",
    "/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotRemoveSelectedRepoFromOrgSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotRemoveSelectedRepoFromOrgSecret(
          input,
          dependabotRemoveSelectedRepoFromOrgSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotRemoveSelectedRepoFromOrgSecret.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesListDockerMigrationConflictingPackagesForOrganizationParamSchema =
    z.object({ org: z.string() })

  router.get(
    "packagesListDockerMigrationConflictingPackagesForOrganization",
    "/orgs/:org/docker/conflicts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesListDockerMigrationConflictingPackagesForOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesListDockerMigrationConflictingPackagesForOrganization(
          input,
          packagesListDockerMigrationConflictingPackagesForOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        packagesListDockerMigrationConflictingPackagesForOrganization.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const activityListPublicOrgEventsParamSchema = z.object({ org: z.string() })

  const activityListPublicOrgEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListPublicOrgEvents",
    "/orgs/:org/events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListPublicOrgEventsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListPublicOrgEventsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListPublicOrgEvents(
          input,
          activityListPublicOrgEvents.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListPublicOrgEvents.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListFailedInvitationsParamSchema = z.object({ org: z.string() })

  const orgsListFailedInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListFailedInvitations",
    "/orgs/:org/failed_invitations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListFailedInvitationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListFailedInvitationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListFailedInvitations(
          input,
          orgsListFailedInvitations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListFailedInvitations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListWebhooksParamSchema = z.object({ org: z.string() })

  const orgsListWebhooksQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("orgsListWebhooks", "/orgs/:org/hooks", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsListWebhooksParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        orgsListWebhooksQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .orgsListWebhooks(input, orgsListWebhooks.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsListWebhooks.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsCreateWebhookParamSchema = z.object({ org: z.string() })

  const orgsCreateWebhookBodySchema = z.object({
    name: z.string(),
    config: z.object({
      url: s_webhook_config_url,
      content_type: s_webhook_config_content_type.optional(),
      secret: s_webhook_config_secret.optional(),
      insecure_ssl: s_webhook_config_insecure_ssl.optional(),
      username: z.string().optional(),
      password: z.string().optional(),
    }),
    events: z.array(z.string()).optional().default(["push"]),
    active: PermissiveBoolean.optional().default(true),
  })

  router.post("orgsCreateWebhook", "/orgs/:org/hooks", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsCreateWebhookParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        orgsCreateWebhookBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .orgsCreateWebhook(input, orgsCreateWebhook.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsCreateWebhook.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsGetWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "orgsGetWebhook",
    "/orgs/:org/hooks/:hook_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetWebhook(input, orgsGetWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsUpdateWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsUpdateWebhookBodySchema = z
    .object({
      config: z
        .object({
          url: s_webhook_config_url,
          content_type: s_webhook_config_content_type.optional(),
          secret: s_webhook_config_secret.optional(),
          insecure_ssl: s_webhook_config_insecure_ssl.optional(),
        })
        .optional(),
      events: z.array(z.string()).optional().default(["push"]),
      active: PermissiveBoolean.optional().default(true),
      name: z.string().optional(),
    })
    .optional()

  router.patch(
    "orgsUpdateWebhook",
    "/orgs/:org/hooks/:hook_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsUpdateWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsUpdateWebhookBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsUpdateWebhook(input, orgsUpdateWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsUpdateWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsDeleteWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  router.delete(
    "orgsDeleteWebhook",
    "/orgs/:org/hooks/:hook_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsDeleteWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsDeleteWebhook(input, orgsDeleteWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsDeleteWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetWebhookConfigForOrgParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "orgsGetWebhookConfigForOrg",
    "/orgs/:org/hooks/:hook_id/config",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetWebhookConfigForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetWebhookConfigForOrg(
          input,
          orgsGetWebhookConfigForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetWebhookConfigForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsUpdateWebhookConfigForOrgParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsUpdateWebhookConfigForOrgBodySchema = z
    .object({
      url: s_webhook_config_url.optional(),
      content_type: s_webhook_config_content_type.optional(),
      secret: s_webhook_config_secret.optional(),
      insecure_ssl: s_webhook_config_insecure_ssl.optional(),
    })
    .optional()

  router.patch(
    "orgsUpdateWebhookConfigForOrg",
    "/orgs/:org/hooks/:hook_id/config",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsUpdateWebhookConfigForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsUpdateWebhookConfigForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsUpdateWebhookConfigForOrg(
          input,
          orgsUpdateWebhookConfigForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsUpdateWebhookConfigForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListWebhookDeliveriesParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  const orgsListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    cursor: z.string().optional(),
  })

  router.get(
    "orgsListWebhookDeliveries",
    "/orgs/:org/hooks/:hook_id/deliveries",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListWebhookDeliveriesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListWebhookDeliveriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListWebhookDeliveries(
          input,
          orgsListWebhookDeliveries.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListWebhookDeliveries.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetWebhookDeliveryParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.get(
    "orgsGetWebhookDelivery",
    "/orgs/:org/hooks/:hook_id/deliveries/:delivery_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetWebhookDeliveryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetWebhookDelivery(input, orgsGetWebhookDelivery.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetWebhookDelivery.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRedeliverWebhookDeliveryParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.post(
    "orgsRedeliverWebhookDelivery",
    "/orgs/:org/hooks/:hook_id/deliveries/:delivery_id/attempts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRedeliverWebhookDeliveryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRedeliverWebhookDelivery(
          input,
          orgsRedeliverWebhookDelivery.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRedeliverWebhookDelivery.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsPingWebhookParamSchema = z.object({
    org: z.string(),
    hook_id: z.coerce.number(),
  })

  router.post(
    "orgsPingWebhook",
    "/orgs/:org/hooks/:hook_id/pings",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsPingWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsPingWebhook(input, orgsPingWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsPingWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetRouteStatsByActorParamSchema = z.object({
    org: z.string(),
    actor_type: z.enum([
      "installation",
      "classic_pat",
      "fine_grained_pat",
      "oauth_app",
      "github_app_user_to_server",
    ]),
    actor_id: z.coerce.number(),
  })

  const apiInsightsGetRouteStatsByActorQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z
            .enum([
              "last_rate_limited_timestamp",
              "last_request_timestamp",
              "rate_limited_request_count",
              "http_method",
              "api_route",
              "total_request_count",
            ])
            .default("total_request_count"),
        ),
      )
      .optional(),
    api_route_substring: z.string().optional(),
  })

  router.get(
    "apiInsightsGetRouteStatsByActor",
    "/orgs/:org/insights/api/route-stats/:actor_type/:actor_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetRouteStatsByActorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetRouteStatsByActorQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetRouteStatsByActor(
          input,
          apiInsightsGetRouteStatsByActor.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetRouteStatsByActor.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetSubjectStatsParamSchema = z.object({ org: z.string() })

  const apiInsightsGetSubjectStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z
            .enum([
              "last_rate_limited_timestamp",
              "last_request_timestamp",
              "rate_limited_request_count",
              "subject_name",
              "total_request_count",
            ])
            .default("total_request_count"),
        ),
      )
      .optional(),
    subject_name_substring: z.string().optional(),
  })

  router.get(
    "apiInsightsGetSubjectStats",
    "/orgs/:org/insights/api/subject-stats",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetSubjectStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetSubjectStatsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetSubjectStats(
          input,
          apiInsightsGetSubjectStats.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetSubjectStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetSummaryStatsParamSchema = z.object({ org: z.string() })

  const apiInsightsGetSummaryStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
  })

  router.get(
    "apiInsightsGetSummaryStats",
    "/orgs/:org/insights/api/summary-stats",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetSummaryStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetSummaryStatsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetSummaryStats(
          input,
          apiInsightsGetSummaryStats.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetSummaryStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetSummaryStatsByUserParamSchema = z.object({
    org: z.string(),
    user_id: z.string(),
  })

  const apiInsightsGetSummaryStatsByUserQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
  })

  router.get(
    "apiInsightsGetSummaryStatsByUser",
    "/orgs/:org/insights/api/summary-stats/users/:user_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetSummaryStatsByUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetSummaryStatsByUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetSummaryStatsByUser(
          input,
          apiInsightsGetSummaryStatsByUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetSummaryStatsByUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetSummaryStatsByActorParamSchema = z.object({
    org: z.string(),
    actor_type: z.enum([
      "installation",
      "classic_pat",
      "fine_grained_pat",
      "oauth_app",
      "github_app_user_to_server",
    ]),
    actor_id: z.coerce.number(),
  })

  const apiInsightsGetSummaryStatsByActorQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
  })

  router.get(
    "apiInsightsGetSummaryStatsByActor",
    "/orgs/:org/insights/api/summary-stats/:actor_type/:actor_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetSummaryStatsByActorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetSummaryStatsByActorQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetSummaryStatsByActor(
          input,
          apiInsightsGetSummaryStatsByActor.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetSummaryStatsByActor.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetTimeStatsParamSchema = z.object({ org: z.string() })

  const apiInsightsGetTimeStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    timestamp_increment: z.string(),
  })

  router.get(
    "apiInsightsGetTimeStats",
    "/orgs/:org/insights/api/time-stats",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetTimeStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetTimeStatsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetTimeStats(input, apiInsightsGetTimeStats.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetTimeStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetTimeStatsByUserParamSchema = z.object({
    org: z.string(),
    user_id: z.string(),
  })

  const apiInsightsGetTimeStatsByUserQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    timestamp_increment: z.string(),
  })

  router.get(
    "apiInsightsGetTimeStatsByUser",
    "/orgs/:org/insights/api/time-stats/users/:user_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetTimeStatsByUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetTimeStatsByUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetTimeStatsByUser(
          input,
          apiInsightsGetTimeStatsByUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetTimeStatsByUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetTimeStatsByActorParamSchema = z.object({
    org: z.string(),
    actor_type: z.enum([
      "installation",
      "classic_pat",
      "fine_grained_pat",
      "oauth_app",
      "github_app_user_to_server",
    ]),
    actor_id: z.coerce.number(),
  })

  const apiInsightsGetTimeStatsByActorQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    timestamp_increment: z.string(),
  })

  router.get(
    "apiInsightsGetTimeStatsByActor",
    "/orgs/:org/insights/api/time-stats/:actor_type/:actor_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetTimeStatsByActorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetTimeStatsByActorQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetTimeStatsByActor(
          input,
          apiInsightsGetTimeStatsByActor.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetTimeStatsByActor.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const apiInsightsGetUserStatsParamSchema = z.object({
    org: z.string(),
    user_id: z.string(),
  })

  const apiInsightsGetUserStatsQuerySchema = z.object({
    min_timestamp: z.string(),
    max_timestamp: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(
          z
            .enum([
              "last_rate_limited_timestamp",
              "last_request_timestamp",
              "rate_limited_request_count",
              "subject_name",
              "total_request_count",
            ])
            .default("total_request_count"),
        ),
      )
      .optional(),
    actor_name_substring: z.string().optional(),
  })

  router.get(
    "apiInsightsGetUserStats",
    "/orgs/:org/insights/api/user-stats/:user_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          apiInsightsGetUserStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          apiInsightsGetUserStatsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .apiInsightsGetUserStats(input, apiInsightsGetUserStats.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = apiInsightsGetUserStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsGetOrgInstallationParamSchema = z.object({ org: z.string() })

  router.get(
    "appsGetOrgInstallation",
    "/orgs/:org/installation",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsGetOrgInstallationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetOrgInstallation(input, appsGetOrgInstallation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetOrgInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListAppInstallationsParamSchema = z.object({ org: z.string() })

  const orgsListAppInstallationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListAppInstallations",
    "/orgs/:org/installations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListAppInstallationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListAppInstallationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListAppInstallations(
          input,
          orgsListAppInstallations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListAppInstallations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const interactionsGetRestrictionsForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "interactionsGetRestrictionsForOrg",
    "/orgs/:org/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          interactionsGetRestrictionsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .interactionsGetRestrictionsForOrg(
          input,
          interactionsGetRestrictionsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsGetRestrictionsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const interactionsSetRestrictionsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const interactionsSetRestrictionsForOrgBodySchema = s_interaction_limit

  router.put(
    "interactionsSetRestrictionsForOrg",
    "/orgs/:org/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          interactionsSetRestrictionsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          interactionsSetRestrictionsForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .interactionsSetRestrictionsForOrg(
          input,
          interactionsSetRestrictionsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsSetRestrictionsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const interactionsRemoveRestrictionsForOrgParamSchema = z.object({
    org: z.string(),
  })

  router.delete(
    "interactionsRemoveRestrictionsForOrg",
    "/orgs/:org/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          interactionsRemoveRestrictionsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .interactionsRemoveRestrictionsForOrg(
          input,
          interactionsRemoveRestrictionsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsRemoveRestrictionsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListPendingInvitationsParamSchema = z.object({ org: z.string() })

  const orgsListPendingInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    role: z
      .enum([
        "all",
        "admin",
        "direct_member",
        "billing_manager",
        "hiring_manager",
      ])
      .optional()
      .default("all"),
    invitation_source: z
      .enum(["all", "member", "scim"])
      .optional()
      .default("all"),
  })

  router.get(
    "orgsListPendingInvitations",
    "/orgs/:org/invitations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListPendingInvitationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListPendingInvitationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListPendingInvitations(
          input,
          orgsListPendingInvitations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListPendingInvitations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsCreateInvitationParamSchema = z.object({ org: z.string() })

  const orgsCreateInvitationBodySchema = z
    .object({
      invitee_id: z.coerce.number().optional(),
      email: z.string().optional(),
      role: z
        .enum(["admin", "direct_member", "billing_manager", "reinstate"])
        .optional()
        .default("direct_member"),
      team_ids: z.array(z.coerce.number()).optional(),
    })
    .optional()

  router.post(
    "orgsCreateInvitation",
    "/orgs/:org/invitations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCreateInvitationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsCreateInvitationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsCreateInvitation(input, orgsCreateInvitation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCreateInvitation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsCancelInvitationParamSchema = z.object({
    org: z.string(),
    invitation_id: z.coerce.number(),
  })

  router.delete(
    "orgsCancelInvitation",
    "/orgs/:org/invitations/:invitation_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCancelInvitationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsCancelInvitation(input, orgsCancelInvitation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCancelInvitation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListInvitationTeamsParamSchema = z.object({
    org: z.string(),
    invitation_id: z.coerce.number(),
  })

  const orgsListInvitationTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListInvitationTeams",
    "/orgs/:org/invitations/:invitation_id/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListInvitationTeamsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListInvitationTeamsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListInvitationTeams(input, orgsListInvitationTeams.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListInvitationTeams.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListIssueTypesParamSchema = z.object({ org: z.string() })

  router.get(
    "orgsListIssueTypes",
    "/orgs/:org/issue-types",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListIssueTypesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListIssueTypes(input, orgsListIssueTypes.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListIssueTypes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsCreateIssueTypeParamSchema = z.object({ org: z.string() })

  const orgsCreateIssueTypeBodySchema = s_organization_create_issue_type

  router.post(
    "orgsCreateIssueType",
    "/orgs/:org/issue-types",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCreateIssueTypeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsCreateIssueTypeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsCreateIssueType(input, orgsCreateIssueType.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCreateIssueType.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsUpdateIssueTypeParamSchema = z.object({
    org: z.string(),
    issue_type_id: z.coerce.number(),
  })

  const orgsUpdateIssueTypeBodySchema = s_organization_update_issue_type

  router.put(
    "orgsUpdateIssueType",
    "/orgs/:org/issue-types/:issue_type_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsUpdateIssueTypeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsUpdateIssueTypeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsUpdateIssueType(input, orgsUpdateIssueType.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsUpdateIssueType.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsDeleteIssueTypeParamSchema = z.object({
    org: z.string(),
    issue_type_id: z.coerce.number(),
  })

  router.delete(
    "orgsDeleteIssueType",
    "/orgs/:org/issue-types/:issue_type_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsDeleteIssueTypeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsDeleteIssueType(input, orgsDeleteIssueType.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsDeleteIssueType.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListForOrgParamSchema = z.object({ org: z.string() })

  const issuesListForOrgQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional()
      .default("assigned"),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    labels: z.string().optional(),
    type: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("issuesListForOrg", "/orgs/:org/issues", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        issuesListForOrgParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        issuesListForOrgQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .issuesListForOrg(input, issuesListForOrg.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = issuesListForOrg.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsListMembersParamSchema = z.object({ org: z.string() })

  const orgsListMembersQuerySchema = z.object({
    filter: z.enum(["2fa_disabled", "all"]).optional().default("all"),
    role: z.enum(["all", "admin", "member"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("orgsListMembers", "/orgs/:org/members", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsListMembersParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        orgsListMembersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .orgsListMembers(input, orgsListMembers.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsListMembers.validator(status, body)
    ctx.status = status
    return next()
  })

  const orgsCheckMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.get(
    "orgsCheckMembershipForUser",
    "/orgs/:org/members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCheckMembershipForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsCheckMembershipForUser(
          input,
          orgsCheckMembershipForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCheckMembershipForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRemoveMemberParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.delete(
    "orgsRemoveMember",
    "/orgs/:org/members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRemoveMemberParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRemoveMember(input, orgsRemoveMember.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRemoveMember.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesGetCodespacesForUserInOrgParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const codespacesGetCodespacesForUserInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "codespacesGetCodespacesForUserInOrg",
    "/orgs/:org/members/:username/codespaces",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetCodespacesForUserInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesGetCodespacesForUserInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetCodespacesForUserInOrg(
          input,
          codespacesGetCodespacesForUserInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetCodespacesForUserInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesDeleteFromOrganizationParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    codespace_name: z.string(),
  })

  router.delete(
    "codespacesDeleteFromOrganization",
    "/orgs/:org/members/:username/codespaces/:codespace_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesDeleteFromOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesDeleteFromOrganization(
          input,
          codespacesDeleteFromOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesDeleteFromOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesStopInOrganizationParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    codespace_name: z.string(),
  })

  router.post(
    "codespacesStopInOrganization",
    "/orgs/:org/members/:username/codespaces/:codespace_name/stop",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesStopInOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesStopInOrganization(
          input,
          codespacesStopInOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesStopInOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const copilotGetCopilotSeatDetailsForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.get(
    "copilotGetCopilotSeatDetailsForUser",
    "/orgs/:org/members/:username/copilot",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotGetCopilotSeatDetailsForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .copilotGetCopilotSeatDetailsForUser(
          input,
          copilotGetCopilotSeatDetailsForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotGetCopilotSeatDetailsForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.get(
    "orgsGetMembershipForUser",
    "/orgs/:org/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetMembershipForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetMembershipForUser(
          input,
          orgsGetMembershipForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetMembershipForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsSetMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsSetMembershipForUserBodySchema = z
    .object({ role: z.enum(["admin", "member"]).optional().default("member") })
    .optional()

  router.put(
    "orgsSetMembershipForUser",
    "/orgs/:org/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsSetMembershipForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsSetMembershipForUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsSetMembershipForUser(
          input,
          orgsSetMembershipForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsSetMembershipForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRemoveMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.delete(
    "orgsRemoveMembershipForUser",
    "/orgs/:org/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRemoveMembershipForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRemoveMembershipForUser(
          input,
          orgsRemoveMembershipForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRemoveMembershipForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsListForOrgParamSchema = z.object({ org: z.string() })

  const migrationsListForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    exclude: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.enum(["repositories"])),
      )
      .optional(),
  })

  router.get(
    "migrationsListForOrg",
    "/orgs/:org/migrations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsListForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          migrationsListForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsListForOrg(input, migrationsListForOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsListForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsStartForOrgParamSchema = z.object({ org: z.string() })

  const migrationsStartForOrgBodySchema = z.object({
    repositories: z.array(z.string()),
    lock_repositories: PermissiveBoolean.optional().default(false),
    exclude_metadata: PermissiveBoolean.optional().default(false),
    exclude_git_data: PermissiveBoolean.optional().default(false),
    exclude_attachments: PermissiveBoolean.optional().default(false),
    exclude_releases: PermissiveBoolean.optional().default(false),
    exclude_owner_projects: PermissiveBoolean.optional().default(false),
    org_metadata_only: PermissiveBoolean.optional().default(false),
    exclude: z.array(z.enum(["repositories"])).optional(),
  })

  router.post(
    "migrationsStartForOrg",
    "/orgs/:org/migrations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsStartForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          migrationsStartForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .migrationsStartForOrg(input, migrationsStartForOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsStartForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsGetStatusForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsGetStatusForOrgQuerySchema = z.object({
    exclude: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.enum(["repositories"])),
      )
      .optional(),
  })

  router.get(
    "migrationsGetStatusForOrg",
    "/orgs/:org/migrations/:migration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsGetStatusForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          migrationsGetStatusForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsGetStatusForOrg(
          input,
          migrationsGetStatusForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsGetStatusForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsDownloadArchiveForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  router.get(
    "migrationsDownloadArchiveForOrg",
    "/orgs/:org/migrations/:migration_id/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsDownloadArchiveForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsDownloadArchiveForOrg(
          input,
          migrationsDownloadArchiveForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsDownloadArchiveForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsDeleteArchiveForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  router.delete(
    "migrationsDeleteArchiveForOrg",
    "/orgs/:org/migrations/:migration_id/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsDeleteArchiveForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsDeleteArchiveForOrg(
          input,
          migrationsDeleteArchiveForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsDeleteArchiveForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsUnlockRepoForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
    repo_name: z.string(),
  })

  router.delete(
    "migrationsUnlockRepoForOrg",
    "/orgs/:org/migrations/:migration_id/repos/:repo_name/lock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsUnlockRepoForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsUnlockRepoForOrg(
          input,
          migrationsUnlockRepoForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsUnlockRepoForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsListReposForOrgParamSchema = z.object({
    org: z.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsListReposForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "migrationsListReposForOrg",
    "/orgs/:org/migrations/:migration_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsListReposForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          migrationsListReposForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsListReposForOrg(
          input,
          migrationsListReposForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsListReposForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListOrgRolesParamSchema = z.object({ org: z.string() })

  router.get(
    "orgsListOrgRoles",
    "/orgs/:org/organization-roles",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListOrgRolesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListOrgRoles(input, orgsListOrgRoles.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListOrgRoles.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRevokeAllOrgRolesTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  router.delete(
    "orgsRevokeAllOrgRolesTeam",
    "/orgs/:org/organization-roles/teams/:team_slug",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRevokeAllOrgRolesTeamParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRevokeAllOrgRolesTeam(
          input,
          orgsRevokeAllOrgRolesTeam.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRevokeAllOrgRolesTeam.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsAssignTeamToOrgRoleParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    role_id: z.coerce.number(),
  })

  router.put(
    "orgsAssignTeamToOrgRole",
    "/orgs/:org/organization-roles/teams/:team_slug/:role_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsAssignTeamToOrgRoleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsAssignTeamToOrgRole(input, orgsAssignTeamToOrgRole.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsAssignTeamToOrgRole.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRevokeOrgRoleTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    role_id: z.coerce.number(),
  })

  router.delete(
    "orgsRevokeOrgRoleTeam",
    "/orgs/:org/organization-roles/teams/:team_slug/:role_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRevokeOrgRoleTeamParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRevokeOrgRoleTeam(input, orgsRevokeOrgRoleTeam.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRevokeOrgRoleTeam.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRevokeAllOrgRolesUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.delete(
    "orgsRevokeAllOrgRolesUser",
    "/orgs/:org/organization-roles/users/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRevokeAllOrgRolesUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRevokeAllOrgRolesUser(
          input,
          orgsRevokeAllOrgRolesUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRevokeAllOrgRolesUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsAssignUserToOrgRoleParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    role_id: z.coerce.number(),
  })

  router.put(
    "orgsAssignUserToOrgRole",
    "/orgs/:org/organization-roles/users/:username/:role_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsAssignUserToOrgRoleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsAssignUserToOrgRole(input, orgsAssignUserToOrgRole.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsAssignUserToOrgRole.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRevokeOrgRoleUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
    role_id: z.coerce.number(),
  })

  router.delete(
    "orgsRevokeOrgRoleUser",
    "/orgs/:org/organization-roles/users/:username/:role_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRevokeOrgRoleUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRevokeOrgRoleUser(input, orgsRevokeOrgRoleUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRevokeOrgRoleUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetOrgRoleParamSchema = z.object({
    org: z.string(),
    role_id: z.coerce.number(),
  })

  router.get(
    "orgsGetOrgRole",
    "/orgs/:org/organization-roles/:role_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetOrgRoleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetOrgRole(input, orgsGetOrgRole.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetOrgRole.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListOrgRoleTeamsParamSchema = z.object({
    org: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsListOrgRoleTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListOrgRoleTeams",
    "/orgs/:org/organization-roles/:role_id/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListOrgRoleTeamsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListOrgRoleTeamsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListOrgRoleTeams(input, orgsListOrgRoleTeams.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListOrgRoleTeams.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListOrgRoleUsersParamSchema = z.object({
    org: z.string(),
    role_id: z.coerce.number(),
  })

  const orgsListOrgRoleUsersQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListOrgRoleUsers",
    "/orgs/:org/organization-roles/:role_id/users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListOrgRoleUsersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListOrgRoleUsersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListOrgRoleUsers(input, orgsListOrgRoleUsers.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListOrgRoleUsers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListOutsideCollaboratorsParamSchema = z.object({ org: z.string() })

  const orgsListOutsideCollaboratorsQuerySchema = z.object({
    filter: z.enum(["2fa_disabled", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListOutsideCollaborators",
    "/orgs/:org/outside_collaborators",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListOutsideCollaboratorsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListOutsideCollaboratorsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListOutsideCollaborators(
          input,
          orgsListOutsideCollaborators.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListOutsideCollaborators.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsConvertMemberToOutsideCollaboratorParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  const orgsConvertMemberToOutsideCollaboratorBodySchema = z
    .object({ async: PermissiveBoolean.optional().default(false) })
    .optional()

  router.put(
    "orgsConvertMemberToOutsideCollaborator",
    "/orgs/:org/outside_collaborators/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsConvertMemberToOutsideCollaboratorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsConvertMemberToOutsideCollaboratorBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsConvertMemberToOutsideCollaborator(
          input,
          orgsConvertMemberToOutsideCollaborator.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsConvertMemberToOutsideCollaborator.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRemoveOutsideCollaboratorParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.delete(
    "orgsRemoveOutsideCollaborator",
    "/orgs/:org/outside_collaborators/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRemoveOutsideCollaboratorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRemoveOutsideCollaborator(
          input,
          orgsRemoveOutsideCollaborator.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRemoveOutsideCollaborator.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesListPackagesForOrganizationParamSchema = z.object({
    org: z.string(),
  })

  const packagesListPackagesForOrganizationQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "packagesListPackagesForOrganization",
    "/orgs/:org/packages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesListPackagesForOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          packagesListPackagesForOrganizationQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesListPackagesForOrganization(
          input,
          packagesListPackagesForOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesListPackagesForOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesGetPackageForOrganizationParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
  })

  router.get(
    "packagesGetPackageForOrganization",
    "/orgs/:org/packages/:package_type/:package_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetPackageForOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetPackageForOrganization(
          input,
          packagesGetPackageForOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetPackageForOrganization.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesDeletePackageForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
  })

  router.delete(
    "packagesDeletePackageForOrg",
    "/orgs/:org/packages/:package_type/:package_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesDeletePackageForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesDeletePackageForOrg(
          input,
          packagesDeletePackageForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesDeletePackageForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesRestorePackageForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
  })

  const packagesRestorePackageForOrgQuerySchema = z.object({
    token: z.string().optional(),
  })

  router.post(
    "packagesRestorePackageForOrg",
    "/orgs/:org/packages/:package_type/:package_name/restore",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesRestorePackageForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          packagesRestorePackageForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesRestorePackageForOrg(
          input,
          packagesRestorePackageForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesRestorePackageForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema = z.object(
    {
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
      org: z.string(),
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema = z.object(
    {
      page: z.coerce.number().optional().default(1),
      per_page: z.coerce.number().optional().default(30),
      state: z.enum(["active", "deleted"]).optional().default("active"),
    },
  )

  router.get(
    "packagesGetAllPackageVersionsForPackageOwnedByOrg",
    "/orgs/:org/packages/:package_type/:package_name/versions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          packagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetAllPackageVersionsForPackageOwnedByOrg(
          input,
          packagesGetAllPackageVersionsForPackageOwnedByOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetAllPackageVersionsForPackageOwnedByOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesGetPackageVersionForOrganizationParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
    package_version_id: z.coerce.number(),
  })

  router.get(
    "packagesGetPackageVersionForOrganization",
    "/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetPackageVersionForOrganizationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetPackageVersionForOrganization(
          input,
          packagesGetPackageVersionForOrganization.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetPackageVersionForOrganization.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesDeletePackageVersionForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
    package_version_id: z.coerce.number(),
  })

  router.delete(
    "packagesDeletePackageVersionForOrg",
    "/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesDeletePackageVersionForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesDeletePackageVersionForOrg(
          input,
          packagesDeletePackageVersionForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesDeletePackageVersionForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesRestorePackageVersionForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    org: z.string(),
    package_version_id: z.coerce.number(),
  })

  router.post(
    "packagesRestorePackageVersionForOrg",
    "/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id/restore",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesRestorePackageVersionForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesRestorePackageVersionForOrg(
          input,
          packagesRestorePackageVersionForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesRestorePackageVersionForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListPatGrantRequestsParamSchema = z.object({ org: z.string() })

  const orgsListPatGrantRequestsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    sort: z.enum(["created_at"]).optional().default("created_at"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    owner: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(10),
      )
      .optional(),
    repository: z.string().optional(),
    permission: z.string().optional(),
    last_used_before: z.string().datetime({ offset: true }).optional(),
    last_used_after: z.string().datetime({ offset: true }).optional(),
    token_id: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(50),
      )
      .optional(),
  })

  router.get(
    "orgsListPatGrantRequests",
    "/orgs/:org/personal-access-token-requests",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListPatGrantRequestsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListPatGrantRequestsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListPatGrantRequests(
          input,
          orgsListPatGrantRequests.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListPatGrantRequests.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsReviewPatGrantRequestsInBulkParamSchema = z.object({
    org: z.string(),
  })

  const orgsReviewPatGrantRequestsInBulkBodySchema = z.object({
    pat_request_ids: z.array(z.coerce.number()).min(1).max(100).optional(),
    action: z.enum(["approve", "deny"]),
    reason: z.string().max(1024).nullable().optional(),
  })

  router.post(
    "orgsReviewPatGrantRequestsInBulk",
    "/orgs/:org/personal-access-token-requests",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsReviewPatGrantRequestsInBulkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsReviewPatGrantRequestsInBulkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsReviewPatGrantRequestsInBulk(
          input,
          orgsReviewPatGrantRequestsInBulk.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsReviewPatGrantRequestsInBulk.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsReviewPatGrantRequestParamSchema = z.object({
    org: z.string(),
    pat_request_id: z.coerce.number(),
  })

  const orgsReviewPatGrantRequestBodySchema = z.object({
    action: z.enum(["approve", "deny"]),
    reason: z.string().max(1024).nullable().optional(),
  })

  router.post(
    "orgsReviewPatGrantRequest",
    "/orgs/:org/personal-access-token-requests/:pat_request_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsReviewPatGrantRequestParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsReviewPatGrantRequestBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsReviewPatGrantRequest(
          input,
          orgsReviewPatGrantRequest.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsReviewPatGrantRequest.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListPatGrantRequestRepositoriesParamSchema = z.object({
    org: z.string(),
    pat_request_id: z.coerce.number(),
  })

  const orgsListPatGrantRequestRepositoriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListPatGrantRequestRepositories",
    "/orgs/:org/personal-access-token-requests/:pat_request_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListPatGrantRequestRepositoriesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListPatGrantRequestRepositoriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListPatGrantRequestRepositories(
          input,
          orgsListPatGrantRequestRepositories.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListPatGrantRequestRepositories.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListPatGrantsParamSchema = z.object({ org: z.string() })

  const orgsListPatGrantsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    sort: z.enum(["created_at"]).optional().default("created_at"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    owner: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(10),
      )
      .optional(),
    repository: z.string().optional(),
    permission: z.string().optional(),
    last_used_before: z.string().datetime({ offset: true }).optional(),
    last_used_after: z.string().datetime({ offset: true }).optional(),
    token_id: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()).max(50),
      )
      .optional(),
  })

  router.get(
    "orgsListPatGrants",
    "/orgs/:org/personal-access-tokens",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListPatGrantsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListPatGrantsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListPatGrants(input, orgsListPatGrants.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListPatGrants.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsUpdatePatAccessesParamSchema = z.object({ org: z.string() })

  const orgsUpdatePatAccessesBodySchema = z.object({
    action: z.enum(["revoke"]),
    pat_ids: z.array(z.coerce.number()).min(1).max(100),
  })

  router.post(
    "orgsUpdatePatAccesses",
    "/orgs/:org/personal-access-tokens",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsUpdatePatAccessesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsUpdatePatAccessesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsUpdatePatAccesses(input, orgsUpdatePatAccesses.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsUpdatePatAccesses.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsUpdatePatAccessParamSchema = z.object({
    org: z.string(),
    pat_id: z.coerce.number(),
  })

  const orgsUpdatePatAccessBodySchema = z.object({ action: z.enum(["revoke"]) })

  router.post(
    "orgsUpdatePatAccess",
    "/orgs/:org/personal-access-tokens/:pat_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsUpdatePatAccessParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsUpdatePatAccessBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsUpdatePatAccess(input, orgsUpdatePatAccess.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsUpdatePatAccess.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListPatGrantRepositoriesParamSchema = z.object({
    org: z.string(),
    pat_id: z.coerce.number(),
  })

  const orgsListPatGrantRepositoriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListPatGrantRepositories",
    "/orgs/:org/personal-access-tokens/:pat_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListPatGrantRepositoriesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListPatGrantRepositoriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListPatGrantRepositories(
          input,
          orgsListPatGrantRepositories.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListPatGrantRepositories.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const privateRegistriesListOrgPrivateRegistriesParamSchema = z.object({
    org: z.string(),
  })

  const privateRegistriesListOrgPrivateRegistriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "privateRegistriesListOrgPrivateRegistries",
    "/orgs/:org/private-registries",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          privateRegistriesListOrgPrivateRegistriesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          privateRegistriesListOrgPrivateRegistriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .privateRegistriesListOrgPrivateRegistries(
          input,
          privateRegistriesListOrgPrivateRegistries.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = privateRegistriesListOrgPrivateRegistries.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const privateRegistriesCreateOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
  })

  const privateRegistriesCreateOrgPrivateRegistryBodySchema = z.object({
    registry_type: z.enum(["maven_repository"]),
    username: z.string().nullable().optional(),
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      ),
    key_id: z.string(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.post(
    "privateRegistriesCreateOrgPrivateRegistry",
    "/orgs/:org/private-registries",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          privateRegistriesCreateOrgPrivateRegistryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          privateRegistriesCreateOrgPrivateRegistryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .privateRegistriesCreateOrgPrivateRegistry(
          input,
          privateRegistriesCreateOrgPrivateRegistry.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = privateRegistriesCreateOrgPrivateRegistry.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const privateRegistriesGetOrgPublicKeyParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "privateRegistriesGetOrgPublicKey",
    "/orgs/:org/private-registries/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          privateRegistriesGetOrgPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .privateRegistriesGetOrgPublicKey(
          input,
          privateRegistriesGetOrgPublicKey.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = privateRegistriesGetOrgPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const privateRegistriesGetOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "privateRegistriesGetOrgPrivateRegistry",
    "/orgs/:org/private-registries/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          privateRegistriesGetOrgPrivateRegistryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .privateRegistriesGetOrgPrivateRegistry(
          input,
          privateRegistriesGetOrgPrivateRegistry.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = privateRegistriesGetOrgPrivateRegistry.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const privateRegistriesUpdateOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  const privateRegistriesUpdateOrgPrivateRegistryBodySchema = z.object({
    registry_type: z.enum(["maven_repository"]).optional(),
    username: z.string().nullable().optional(),
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      )
      .optional(),
    key_id: z.string().optional(),
    visibility: z.enum(["all", "private", "selected"]).optional(),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.patch(
    "privateRegistriesUpdateOrgPrivateRegistry",
    "/orgs/:org/private-registries/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          privateRegistriesUpdateOrgPrivateRegistryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          privateRegistriesUpdateOrgPrivateRegistryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .privateRegistriesUpdateOrgPrivateRegistry(
          input,
          privateRegistriesUpdateOrgPrivateRegistry.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = privateRegistriesUpdateOrgPrivateRegistry.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const privateRegistriesDeleteOrgPrivateRegistryParamSchema = z.object({
    org: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "privateRegistriesDeleteOrgPrivateRegistry",
    "/orgs/:org/private-registries/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          privateRegistriesDeleteOrgPrivateRegistryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .privateRegistriesDeleteOrgPrivateRegistry(
          input,
          privateRegistriesDeleteOrgPrivateRegistry.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = privateRegistriesDeleteOrgPrivateRegistry.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const projectsListForOrgParamSchema = z.object({ org: z.string() })

  const projectsListForOrgQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("projectsListForOrg", "/orgs/:org/projects", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        projectsListForOrgParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        projectsListForOrgQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .projectsListForOrg(input, projectsListForOrg.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = projectsListForOrg.validator(status, body)
    ctx.status = status
    return next()
  })

  const projectsCreateForOrgParamSchema = z.object({ org: z.string() })

  const projectsCreateForOrgBodySchema = z.object({
    name: z.string(),
    body: z.string().optional(),
  })

  router.post(
    "projectsCreateForOrg",
    "/orgs/:org/projects",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsCreateForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsCreateForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsCreateForOrg(input, projectsCreateForOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsCreateForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetAllCustomPropertiesParamSchema = z.object({ org: z.string() })

  router.get(
    "orgsGetAllCustomProperties",
    "/orgs/:org/properties/schema",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetAllCustomPropertiesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetAllCustomProperties(
          input,
          orgsGetAllCustomProperties.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetAllCustomProperties.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsCreateOrUpdateCustomPropertiesParamSchema = z.object({
    org: z.string(),
  })

  const orgsCreateOrUpdateCustomPropertiesBodySchema = z.object({
    properties: z.array(s_custom_property).min(1).max(100),
  })

  router.patch(
    "orgsCreateOrUpdateCustomProperties",
    "/orgs/:org/properties/schema",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCreateOrUpdateCustomPropertiesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsCreateOrUpdateCustomPropertiesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsCreateOrUpdateCustomProperties(
          input,
          orgsCreateOrUpdateCustomProperties.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCreateOrUpdateCustomProperties.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetCustomPropertyParamSchema = z.object({
    org: z.string(),
    custom_property_name: z.string(),
  })

  router.get(
    "orgsGetCustomProperty",
    "/orgs/:org/properties/schema/:custom_property_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetCustomPropertyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetCustomProperty(input, orgsGetCustomProperty.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetCustomProperty.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsCreateOrUpdateCustomPropertyParamSchema = z.object({
    org: z.string(),
    custom_property_name: z.string(),
  })

  const orgsCreateOrUpdateCustomPropertyBodySchema =
    s_custom_property_set_payload

  router.put(
    "orgsCreateOrUpdateCustomProperty",
    "/orgs/:org/properties/schema/:custom_property_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCreateOrUpdateCustomPropertyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsCreateOrUpdateCustomPropertyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsCreateOrUpdateCustomProperty(
          input,
          orgsCreateOrUpdateCustomProperty.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCreateOrUpdateCustomProperty.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRemoveCustomPropertyParamSchema = z.object({
    org: z.string(),
    custom_property_name: z.string(),
  })

  router.delete(
    "orgsRemoveCustomProperty",
    "/orgs/:org/properties/schema/:custom_property_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRemoveCustomPropertyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRemoveCustomProperty(
          input,
          orgsRemoveCustomProperty.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRemoveCustomProperty.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListCustomPropertiesValuesForReposParamSchema = z.object({
    org: z.string(),
  })

  const orgsListCustomPropertiesValuesForReposQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    repository_query: z.string().optional(),
  })

  router.get(
    "orgsListCustomPropertiesValuesForRepos",
    "/orgs/:org/properties/values",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListCustomPropertiesValuesForReposParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListCustomPropertiesValuesForReposQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListCustomPropertiesValuesForRepos(
          input,
          orgsListCustomPropertiesValuesForRepos.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListCustomPropertiesValuesForRepos.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema = z.object({
    org: z.string(),
  })

  const orgsCreateOrUpdateCustomPropertiesValuesForReposBodySchema = z.object({
    repository_names: z.array(z.string()).min(1).max(30),
    properties: z.array(s_custom_property_value),
  })

  router.patch(
    "orgsCreateOrUpdateCustomPropertiesValuesForRepos",
    "/orgs/:org/properties/values",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCreateOrUpdateCustomPropertiesValuesForReposParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsCreateOrUpdateCustomPropertiesValuesForReposBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsCreateOrUpdateCustomPropertiesValuesForRepos(
          input,
          orgsCreateOrUpdateCustomPropertiesValuesForRepos.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCreateOrUpdateCustomPropertiesValuesForRepos.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const orgsListPublicMembersParamSchema = z.object({ org: z.string() })

  const orgsListPublicMembersQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListPublicMembers",
    "/orgs/:org/public_members",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListPublicMembersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsListPublicMembersQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListPublicMembers(input, orgsListPublicMembers.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListPublicMembers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsCheckPublicMembershipForUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.get(
    "orgsCheckPublicMembershipForUser",
    "/orgs/:org/public_members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsCheckPublicMembershipForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsCheckPublicMembershipForUser(
          input,
          orgsCheckPublicMembershipForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsCheckPublicMembershipForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsSetPublicMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.put(
    "orgsSetPublicMembershipForAuthenticatedUser",
    "/orgs/:org/public_members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsSetPublicMembershipForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsSetPublicMembershipForAuthenticatedUser(
          input,
          orgsSetPublicMembershipForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsSetPublicMembershipForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const orgsRemovePublicMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
    username: z.string(),
  })

  router.delete(
    "orgsRemovePublicMembershipForAuthenticatedUser",
    "/orgs/:org/public_members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRemovePublicMembershipForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRemovePublicMembershipForAuthenticatedUser(
          input,
          orgsRemovePublicMembershipForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRemovePublicMembershipForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposListForOrgParamSchema = z.object({ org: z.string() })

  const reposListForOrgQuerySchema = z.object({
    type: z
      .enum(["all", "public", "private", "forks", "sources", "member"])
      .optional()
      .default("all"),
    sort: z
      .enum(["created", "updated", "pushed", "full_name"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("reposListForOrg", "/orgs/:org/repos", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        reposListForOrgParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        reposListForOrgQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .reposListForOrg(input, reposListForOrg.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposListForOrg.validator(status, body)
    ctx.status = status
    return next()
  })

  const reposCreateInOrgParamSchema = z.object({ org: z.string() })

  const reposCreateInOrgBodySchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    homepage: z.string().optional(),
    private: PermissiveBoolean.optional().default(false),
    visibility: z.enum(["public", "private"]).optional(),
    has_issues: PermissiveBoolean.optional().default(true),
    has_projects: PermissiveBoolean.optional().default(true),
    has_wiki: PermissiveBoolean.optional().default(true),
    has_downloads: PermissiveBoolean.optional().default(true),
    is_template: PermissiveBoolean.optional().default(false),
    team_id: z.coerce.number().optional(),
    auto_init: PermissiveBoolean.optional().default(false),
    gitignore_template: z.string().optional(),
    license_template: z.string().optional(),
    allow_squash_merge: PermissiveBoolean.optional().default(true),
    allow_merge_commit: PermissiveBoolean.optional().default(true),
    allow_rebase_merge: PermissiveBoolean.optional().default(true),
    allow_auto_merge: PermissiveBoolean.optional().default(false),
    delete_branch_on_merge: PermissiveBoolean.optional().default(false),
    use_squash_pr_title_as_default: PermissiveBoolean.optional().default(false),
    squash_merge_commit_title: z
      .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
      .optional(),
    squash_merge_commit_message: z
      .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
      .optional(),
    merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
    merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
    custom_properties: z.record(z.unknown()).optional(),
  })

  router.post("reposCreateInOrg", "/orgs/:org/repos", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        reposCreateInOrgParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        reposCreateInOrgBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .reposCreateInOrg(input, reposCreateInOrg.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposCreateInOrg.validator(status, body)
    ctx.status = status
    return next()
  })

  const reposGetOrgRulesetsParamSchema = z.object({ org: z.string() })

  const reposGetOrgRulesetsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    targets: z.string().optional(),
  })

  router.get(
    "reposGetOrgRulesets",
    "/orgs/:org/rulesets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetOrgRulesetsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetOrgRulesetsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetOrgRulesets(input, reposGetOrgRulesets.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetOrgRulesets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateOrgRulesetParamSchema = z.object({ org: z.string() })

  const reposCreateOrgRulesetBodySchema = z.object({
    name: z.string(),
    target: z
      .enum(["branch", "tag", "push", "repository"])
      .optional()
      .default("branch"),
    enforcement: s_repository_rule_enforcement,
    bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
    conditions: s_org_ruleset_conditions.optional(),
    rules: z.array(s_repository_rule).optional(),
  })

  router.post(
    "reposCreateOrgRuleset",
    "/orgs/:org/rulesets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateOrgRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateOrgRulesetBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateOrgRuleset(input, reposCreateOrgRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateOrgRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetOrgRuleSuitesParamSchema = z.object({ org: z.string() })

  const reposGetOrgRuleSuitesQuerySchema = z.object({
    ref: z.string().optional(),
    repository_name: z.string().optional(),
    time_period: z
      .enum(["hour", "day", "week", "month"])
      .optional()
      .default("day"),
    actor_name: z.string().optional(),
    rule_suite_result: z
      .enum(["pass", "fail", "bypass", "all"])
      .optional()
      .default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposGetOrgRuleSuites",
    "/orgs/:org/rulesets/rule-suites",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetOrgRuleSuitesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetOrgRuleSuitesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetOrgRuleSuites(input, reposGetOrgRuleSuites.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetOrgRuleSuites.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetOrgRuleSuiteParamSchema = z.object({
    org: z.string(),
    rule_suite_id: z.coerce.number(),
  })

  router.get(
    "reposGetOrgRuleSuite",
    "/orgs/:org/rulesets/rule-suites/:rule_suite_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetOrgRuleSuiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetOrgRuleSuite(input, reposGetOrgRuleSuite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetOrgRuleSuite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetOrgRulesetParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  router.get(
    "reposGetOrgRuleset",
    "/orgs/:org/rulesets/:ruleset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetOrgRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetOrgRuleset(input, reposGetOrgRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetOrgRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateOrgRulesetParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposUpdateOrgRulesetBodySchema = z
    .object({
      name: z.string().optional(),
      target: z.enum(["branch", "tag", "push", "repository"]).optional(),
      enforcement: s_repository_rule_enforcement.optional(),
      bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
      conditions: s_org_ruleset_conditions.optional(),
      rules: z.array(s_repository_rule).optional(),
    })
    .optional()

  router.put(
    "reposUpdateOrgRuleset",
    "/orgs/:org/rulesets/:ruleset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateOrgRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateOrgRulesetBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateOrgRuleset(input, reposUpdateOrgRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateOrgRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteOrgRulesetParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteOrgRuleset",
    "/orgs/:org/rulesets/:ruleset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteOrgRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteOrgRuleset(input, reposDeleteOrgRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteOrgRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetOrgRulesetHistoryParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const orgsGetOrgRulesetHistoryQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsGetOrgRulesetHistory",
    "/orgs/:org/rulesets/:ruleset_id/history",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetOrgRulesetHistoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          orgsGetOrgRulesetHistoryQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetOrgRulesetHistory(
          input,
          orgsGetOrgRulesetHistory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetOrgRulesetHistory.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetOrgRulesetVersionParamSchema = z.object({
    org: z.string(),
    ruleset_id: z.coerce.number(),
    version_id: z.coerce.number(),
  })

  router.get(
    "orgsGetOrgRulesetVersion",
    "/orgs/:org/rulesets/:ruleset_id/history/:version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetOrgRulesetVersionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetOrgRulesetVersion(
          input,
          orgsGetOrgRulesetVersion.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetOrgRulesetVersion.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const secretScanningListAlertsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const secretScanningListAlertsForOrgQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.string().optional(),
    resolution: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    validity: z.string().optional(),
    is_publicly_leaked: PermissiveBoolean.optional().default(false),
    is_multi_repo: PermissiveBoolean.optional().default(false),
  })

  router.get(
    "secretScanningListAlertsForOrg",
    "/orgs/:org/secret-scanning/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningListAlertsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          secretScanningListAlertsForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .secretScanningListAlertsForOrg(
          input,
          secretScanningListAlertsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningListAlertsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesListOrgRepositoryAdvisoriesParamSchema = z.object({
    org: z.string(),
  })

  const securityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .enum(["created", "updated", "published"])
      .optional()
      .default("created"),
    before: z.string().optional(),
    after: z.string().optional(),
    per_page: z.coerce.number().min(1).max(100).optional().default(30),
    state: z.enum(["triage", "draft", "published", "closed"]).optional(),
  })

  router.get(
    "securityAdvisoriesListOrgRepositoryAdvisories",
    "/orgs/:org/security-advisories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesListOrgRepositoryAdvisoriesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          securityAdvisoriesListOrgRepositoryAdvisoriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesListOrgRepositoryAdvisories(
          input,
          securityAdvisoriesListOrgRepositoryAdvisories.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesListOrgRepositoryAdvisories.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const orgsListSecurityManagerTeamsParamSchema = z.object({ org: z.string() })

  router.get(
    "orgsListSecurityManagerTeams",
    "/orgs/:org/security-managers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsListSecurityManagerTeamsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListSecurityManagerTeams(
          input,
          orgsListSecurityManagerTeams.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListSecurityManagerTeams.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsAddSecurityManagerTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  router.put(
    "orgsAddSecurityManagerTeam",
    "/orgs/:org/security-managers/teams/:team_slug",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsAddSecurityManagerTeamParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsAddSecurityManagerTeam(
          input,
          orgsAddSecurityManagerTeam.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsAddSecurityManagerTeam.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsRemoveSecurityManagerTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  router.delete(
    "orgsRemoveSecurityManagerTeam",
    "/orgs/:org/security-managers/teams/:team_slug",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsRemoveSecurityManagerTeamParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsRemoveSecurityManagerTeam(
          input,
          orgsRemoveSecurityManagerTeam.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsRemoveSecurityManagerTeam.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const billingGetGithubActionsBillingOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "billingGetGithubActionsBillingOrg",
    "/orgs/:org/settings/billing/actions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          billingGetGithubActionsBillingOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .billingGetGithubActionsBillingOrg(
          input,
          billingGetGithubActionsBillingOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = billingGetGithubActionsBillingOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const billingGetGithubPackagesBillingOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "billingGetGithubPackagesBillingOrg",
    "/orgs/:org/settings/billing/packages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          billingGetGithubPackagesBillingOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .billingGetGithubPackagesBillingOrg(
          input,
          billingGetGithubPackagesBillingOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = billingGetGithubPackagesBillingOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const billingGetSharedStorageBillingOrgParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "billingGetSharedStorageBillingOrg",
    "/orgs/:org/settings/billing/shared-storage",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          billingGetSharedStorageBillingOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .billingGetSharedStorageBillingOrg(
          input,
          billingGetSharedStorageBillingOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = billingGetSharedStorageBillingOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const hostedComputeListNetworkConfigurationsForOrgParamSchema = z.object({
    org: z.string(),
  })

  const hostedComputeListNetworkConfigurationsForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "hostedComputeListNetworkConfigurationsForOrg",
    "/orgs/:org/settings/network-configurations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          hostedComputeListNetworkConfigurationsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          hostedComputeListNetworkConfigurationsForOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .hostedComputeListNetworkConfigurationsForOrg(
          input,
          hostedComputeListNetworkConfigurationsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = hostedComputeListNetworkConfigurationsForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const hostedComputeCreateNetworkConfigurationForOrgParamSchema = z.object({
    org: z.string(),
  })

  const hostedComputeCreateNetworkConfigurationForOrgBodySchema = z.object({
    name: z.string(),
    compute_service: z.enum(["none", "actions"]).optional(),
    network_settings_ids: z.array(z.string()).min(1).max(1),
  })

  router.post(
    "hostedComputeCreateNetworkConfigurationForOrg",
    "/orgs/:org/settings/network-configurations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          hostedComputeCreateNetworkConfigurationForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          hostedComputeCreateNetworkConfigurationForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .hostedComputeCreateNetworkConfigurationForOrg(
          input,
          hostedComputeCreateNetworkConfigurationForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = hostedComputeCreateNetworkConfigurationForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const hostedComputeGetNetworkConfigurationForOrgParamSchema = z.object({
    org: z.string(),
    network_configuration_id: z.string(),
  })

  router.get(
    "hostedComputeGetNetworkConfigurationForOrg",
    "/orgs/:org/settings/network-configurations/:network_configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          hostedComputeGetNetworkConfigurationForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .hostedComputeGetNetworkConfigurationForOrg(
          input,
          hostedComputeGetNetworkConfigurationForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = hostedComputeGetNetworkConfigurationForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const hostedComputeUpdateNetworkConfigurationForOrgParamSchema = z.object({
    org: z.string(),
    network_configuration_id: z.string(),
  })

  const hostedComputeUpdateNetworkConfigurationForOrgBodySchema = z.object({
    name: z.string().optional(),
    compute_service: z.enum(["none", "actions"]).optional(),
    network_settings_ids: z.array(z.string()).min(0).max(1).optional(),
  })

  router.patch(
    "hostedComputeUpdateNetworkConfigurationForOrg",
    "/orgs/:org/settings/network-configurations/:network_configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          hostedComputeUpdateNetworkConfigurationForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          hostedComputeUpdateNetworkConfigurationForOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .hostedComputeUpdateNetworkConfigurationForOrg(
          input,
          hostedComputeUpdateNetworkConfigurationForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = hostedComputeUpdateNetworkConfigurationForOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const hostedComputeDeleteNetworkConfigurationFromOrgParamSchema = z.object({
    org: z.string(),
    network_configuration_id: z.string(),
  })

  router.delete(
    "hostedComputeDeleteNetworkConfigurationFromOrg",
    "/orgs/:org/settings/network-configurations/:network_configuration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          hostedComputeDeleteNetworkConfigurationFromOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .hostedComputeDeleteNetworkConfigurationFromOrg(
          input,
          hostedComputeDeleteNetworkConfigurationFromOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = hostedComputeDeleteNetworkConfigurationFromOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const hostedComputeGetNetworkSettingsForOrgParamSchema = z.object({
    org: z.string(),
    network_settings_id: z.string(),
  })

  router.get(
    "hostedComputeGetNetworkSettingsForOrg",
    "/orgs/:org/settings/network-settings/:network_settings_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          hostedComputeGetNetworkSettingsForOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .hostedComputeGetNetworkSettingsForOrg(
          input,
          hostedComputeGetNetworkSettingsForOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = hostedComputeGetNetworkSettingsForOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const copilotCopilotMetricsForTeamParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const copilotCopilotMetricsForTeamQuerySchema = z.object({
    since: z.string().optional(),
    until: z.string().optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(28),
  })

  router.get(
    "copilotCopilotMetricsForTeam",
    "/orgs/:org/team/:team_slug/copilot/metrics",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          copilotCopilotMetricsForTeamParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          copilotCopilotMetricsForTeamQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .copilotCopilotMetricsForTeam(
          input,
          copilotCopilotMetricsForTeam.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = copilotCopilotMetricsForTeam.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListParamSchema = z.object({ org: z.string() })

  const teamsListQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("teamsList", "/orgs/:org/teams", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        teamsListParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        teamsListQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .teamsList(input, teamsList.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = teamsList.validator(status, body)
    ctx.status = status
    return next()
  })

  const teamsCreateParamSchema = z.object({ org: z.string() })

  const teamsCreateBodySchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    maintainers: z.array(z.string()).optional(),
    repo_names: z.array(z.string()).optional(),
    privacy: z.enum(["secret", "closed"]).optional(),
    notification_setting: z
      .enum(["notifications_enabled", "notifications_disabled"])
      .optional(),
    permission: z.enum(["pull", "push"]).optional().default("pull"),
    parent_team_id: z.coerce.number().optional(),
  })

  router.post("teamsCreate", "/orgs/:org/teams", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        teamsCreateParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        teamsCreateBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .teamsCreate(input, teamsCreate.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = teamsCreate.validator(status, body)
    ctx.status = status
    return next()
  })

  const teamsGetByNameParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  router.get(
    "teamsGetByName",
    "/orgs/:org/teams/:team_slug",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetByNameParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetByName(input, teamsGetByName.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetByName.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsUpdateInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsUpdateInOrgBodySchema = z
    .object({
      name: z.string().optional(),
      description: z.string().optional(),
      privacy: z.enum(["secret", "closed"]).optional(),
      notification_setting: z
        .enum(["notifications_enabled", "notifications_disabled"])
        .optional(),
      permission: z.enum(["pull", "push", "admin"]).optional().default("pull"),
      parent_team_id: z.coerce.number().nullable().optional(),
    })
    .optional()

  router.patch(
    "teamsUpdateInOrg",
    "/orgs/:org/teams/:team_slug",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsUpdateInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsUpdateInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsUpdateInOrg(input, teamsUpdateInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsUpdateInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsDeleteInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  router.delete(
    "teamsDeleteInOrg",
    "/orgs/:org/teams/:team_slug",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsDeleteInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsDeleteInOrg(input, teamsDeleteInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsDeleteInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListDiscussionsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListDiscussionsInOrgQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    pinned: z.string().optional(),
  })

  router.get(
    "teamsListDiscussionsInOrg",
    "/orgs/:org/teams/:team_slug/discussions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListDiscussionsInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListDiscussionsInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListDiscussionsInOrg(
          input,
          teamsListDiscussionsInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListDiscussionsInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCreateDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsCreateDiscussionInOrgBodySchema = z.object({
    title: z.string(),
    body: z.string(),
    private: PermissiveBoolean.optional().default(false),
  })

  router.post(
    "teamsCreateDiscussionInOrg",
    "/orgs/:org/teams/:team_slug/discussions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCreateDiscussionInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsCreateDiscussionInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsCreateDiscussionInOrg(
          input,
          teamsCreateDiscussionInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCreateDiscussionInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsGetDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetDiscussionInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetDiscussionInOrg(input, teamsGetDiscussionInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetDiscussionInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsUpdateDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionInOrgBodySchema = z
    .object({ title: z.string().optional(), body: z.string().optional() })
    .optional()

  router.patch(
    "teamsUpdateDiscussionInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsUpdateDiscussionInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsUpdateDiscussionInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsUpdateDiscussionInOrg(
          input,
          teamsUpdateDiscussionInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsUpdateDiscussionInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsDeleteDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsDeleteDiscussionInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsDeleteDiscussionInOrg(
          input,
          teamsDeleteDiscussionInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsDeleteDiscussionInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListDiscussionCommentsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsListDiscussionCommentsInOrgQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListDiscussionCommentsInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListDiscussionCommentsInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListDiscussionCommentsInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListDiscussionCommentsInOrg(
          input,
          teamsListDiscussionCommentsInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListDiscussionCommentsInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCreateDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsCreateDiscussionCommentInOrgBodySchema = z.object({
    body: z.string(),
  })

  router.post(
    "teamsCreateDiscussionCommentInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCreateDiscussionCommentInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsCreateDiscussionCommentInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsCreateDiscussionCommentInOrg(
          input,
          teamsCreateDiscussionCommentInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCreateDiscussionCommentInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsGetDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionCommentInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetDiscussionCommentInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetDiscussionCommentInOrg(
          input,
          teamsGetDiscussionCommentInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetDiscussionCommentInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsUpdateDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionCommentInOrgBodySchema = z.object({
    body: z.string(),
  })

  router.patch(
    "teamsUpdateDiscussionCommentInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsUpdateDiscussionCommentInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsUpdateDiscussionCommentInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsUpdateDiscussionCommentInOrg(
          input,
          teamsUpdateDiscussionCommentInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsUpdateDiscussionCommentInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsDeleteDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionCommentInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsDeleteDiscussionCommentInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsDeleteDiscussionCommentInOrg(
          input,
          teamsDeleteDiscussionCommentInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsDeleteDiscussionCommentInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForTeamDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionCommentInOrgQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForTeamDiscussionCommentInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForTeamDiscussionCommentInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForTeamDiscussionCommentInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForTeamDiscussionCommentInOrg(
          input,
          reactionsListForTeamDiscussionCommentInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForTeamDiscussionCommentInOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForTeamDiscussionCommentInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionCommentInOrgBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionCommentInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForTeamDiscussionCommentInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForTeamDiscussionCommentInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForTeamDiscussionCommentInOrg(
          input,
          reactionsCreateForTeamDiscussionCommentInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForTeamDiscussionCommentInOrg.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reactionsDeleteForTeamDiscussionCommentParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForTeamDiscussionComment",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsDeleteForTeamDiscussionCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsDeleteForTeamDiscussionComment(
          input,
          reactionsDeleteForTeamDiscussionComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsDeleteForTeamDiscussionComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForTeamDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionInOrgQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForTeamDiscussionInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForTeamDiscussionInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForTeamDiscussionInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForTeamDiscussionInOrg(
          input,
          reactionsListForTeamDiscussionInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForTeamDiscussionInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForTeamDiscussionInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionInOrgBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionInOrg",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForTeamDiscussionInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForTeamDiscussionInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForTeamDiscussionInOrg(
          input,
          reactionsCreateForTeamDiscussionInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForTeamDiscussionInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsDeleteForTeamDiscussionParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    discussion_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForTeamDiscussion",
    "/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions/:reaction_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsDeleteForTeamDiscussionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsDeleteForTeamDiscussion(
          input,
          reactionsDeleteForTeamDiscussion.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsDeleteForTeamDiscussion.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListPendingInvitationsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListPendingInvitationsInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListPendingInvitationsInOrg",
    "/orgs/:org/teams/:team_slug/invitations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListPendingInvitationsInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListPendingInvitationsInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListPendingInvitationsInOrg(
          input,
          teamsListPendingInvitationsInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListPendingInvitationsInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListMembersInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListMembersInOrgQuerySchema = z.object({
    role: z.enum(["member", "maintainer", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListMembersInOrg",
    "/orgs/:org/teams/:team_slug/members",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListMembersInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListMembersInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListMembersInOrg(input, teamsListMembersInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListMembersInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsGetMembershipForUserInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    username: z.string(),
  })

  router.get(
    "teamsGetMembershipForUserInOrg",
    "/orgs/:org/teams/:team_slug/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetMembershipForUserInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetMembershipForUserInOrg(
          input,
          teamsGetMembershipForUserInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetMembershipForUserInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsAddOrUpdateMembershipForUserInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    username: z.string(),
  })

  const teamsAddOrUpdateMembershipForUserInOrgBodySchema = z
    .object({
      role: z.enum(["member", "maintainer"]).optional().default("member"),
    })
    .optional()

  router.put(
    "teamsAddOrUpdateMembershipForUserInOrg",
    "/orgs/:org/teams/:team_slug/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsAddOrUpdateMembershipForUserInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsAddOrUpdateMembershipForUserInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsAddOrUpdateMembershipForUserInOrg(
          input,
          teamsAddOrUpdateMembershipForUserInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsAddOrUpdateMembershipForUserInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsRemoveMembershipForUserInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    username: z.string(),
  })

  router.delete(
    "teamsRemoveMembershipForUserInOrg",
    "/orgs/:org/teams/:team_slug/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsRemoveMembershipForUserInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsRemoveMembershipForUserInOrg(
          input,
          teamsRemoveMembershipForUserInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsRemoveMembershipForUserInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListProjectsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListProjectsInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListProjectsInOrg",
    "/orgs/:org/teams/:team_slug/projects",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListProjectsInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListProjectsInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListProjectsInOrg(input, teamsListProjectsInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListProjectsInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCheckPermissionsForProjectInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    project_id: z.coerce.number(),
  })

  router.get(
    "teamsCheckPermissionsForProjectInOrg",
    "/orgs/:org/teams/:team_slug/projects/:project_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCheckPermissionsForProjectInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsCheckPermissionsForProjectInOrg(
          input,
          teamsCheckPermissionsForProjectInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCheckPermissionsForProjectInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsAddOrUpdateProjectPermissionsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    project_id: z.coerce.number(),
  })

  const teamsAddOrUpdateProjectPermissionsInOrgBodySchema = z
    .object({ permission: z.enum(["read", "write", "admin"]).optional() })
    .nullable()
    .optional()

  router.put(
    "teamsAddOrUpdateProjectPermissionsInOrg",
    "/orgs/:org/teams/:team_slug/projects/:project_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsAddOrUpdateProjectPermissionsInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsAddOrUpdateProjectPermissionsInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsAddOrUpdateProjectPermissionsInOrg(
          input,
          teamsAddOrUpdateProjectPermissionsInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsAddOrUpdateProjectPermissionsInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsRemoveProjectInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    project_id: z.coerce.number(),
  })

  router.delete(
    "teamsRemoveProjectInOrg",
    "/orgs/:org/teams/:team_slug/projects/:project_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsRemoveProjectInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsRemoveProjectInOrg(input, teamsRemoveProjectInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsRemoveProjectInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListReposInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListReposInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListReposInOrg",
    "/orgs/:org/teams/:team_slug/repos",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListReposInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListReposInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListReposInOrg(input, teamsListReposInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListReposInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCheckPermissionsForRepoInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "teamsCheckPermissionsForRepoInOrg",
    "/orgs/:org/teams/:team_slug/repos/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCheckPermissionsForRepoInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsCheckPermissionsForRepoInOrg(
          input,
          teamsCheckPermissionsForRepoInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCheckPermissionsForRepoInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsAddOrUpdateRepoPermissionsInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsAddOrUpdateRepoPermissionsInOrgBodySchema = z
    .object({ permission: z.string().optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateRepoPermissionsInOrg",
    "/orgs/:org/teams/:team_slug/repos/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsAddOrUpdateRepoPermissionsInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsAddOrUpdateRepoPermissionsInOrgBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsAddOrUpdateRepoPermissionsInOrg(
          input,
          teamsAddOrUpdateRepoPermissionsInOrg.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsAddOrUpdateRepoPermissionsInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsRemoveRepoInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "teamsRemoveRepoInOrg",
    "/orgs/:org/teams/:team_slug/repos/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsRemoveRepoInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsRemoveRepoInOrg(input, teamsRemoveRepoInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsRemoveRepoInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListChildInOrgParamSchema = z.object({
    org: z.string(),
    team_slug: z.string(),
  })

  const teamsListChildInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListChildInOrg",
    "/orgs/:org/teams/:team_slug/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListChildInOrgParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListChildInOrgQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListChildInOrg(input, teamsListChildInOrg.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListChildInOrg.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema = z.object({
    org: z.string(),
    security_product: z.enum([
      "dependency_graph",
      "dependabot_alerts",
      "dependabot_security_updates",
      "advanced_security",
      "code_scanning_default_setup",
      "secret_scanning",
      "secret_scanning_push_protection",
    ]),
    enablement: z.enum(["enable_all", "disable_all"]),
  })

  const orgsEnableOrDisableSecurityProductOnAllOrgReposBodySchema = z
    .object({ query_suite: z.enum(["default", "extended"]).optional() })
    .optional()

  router.post(
    "orgsEnableOrDisableSecurityProductOnAllOrgRepos",
    "/orgs/:org/:security_product/:enablement",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsEnableOrDisableSecurityProductOnAllOrgReposBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsEnableOrDisableSecurityProductOnAllOrgRepos(
          input,
          orgsEnableOrDisableSecurityProductOnAllOrgRepos.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsEnableOrDisableSecurityProductOnAllOrgRepos.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const projectsGetCardParamSchema = z.object({ card_id: z.coerce.number() })

  router.get(
    "projectsGetCard",
    "/projects/columns/cards/:card_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsGetCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsGetCard(input, projectsGetCard.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsGetCard.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsUpdateCardParamSchema = z.object({ card_id: z.coerce.number() })

  const projectsUpdateCardBodySchema = z
    .object({
      note: z.string().nullable().optional(),
      archived: PermissiveBoolean.optional(),
    })
    .optional()

  router.patch(
    "projectsUpdateCard",
    "/projects/columns/cards/:card_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsUpdateCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsUpdateCardBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsUpdateCard(input, projectsUpdateCard.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsUpdateCard.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsDeleteCardParamSchema = z.object({ card_id: z.coerce.number() })

  router.delete(
    "projectsDeleteCard",
    "/projects/columns/cards/:card_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsDeleteCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsDeleteCard(input, projectsDeleteCard.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsDeleteCard.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsMoveCardParamSchema = z.object({ card_id: z.coerce.number() })

  const projectsMoveCardBodySchema = z.object({
    position: z.string().regex(new RegExp("^(?:top|bottom|after:\\d+)$")),
    column_id: z.coerce.number().optional(),
  })

  router.post(
    "projectsMoveCard",
    "/projects/columns/cards/:card_id/moves",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsMoveCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsMoveCardBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsMoveCard(input, projectsMoveCard.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsMoveCard.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsGetColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  router.get(
    "projectsGetColumn",
    "/projects/columns/:column_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsGetColumnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsGetColumn(input, projectsGetColumn.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsGetColumn.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsUpdateColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsUpdateColumnBodySchema = z.object({ name: z.string() })

  router.patch(
    "projectsUpdateColumn",
    "/projects/columns/:column_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsUpdateColumnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsUpdateColumnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsUpdateColumn(input, projectsUpdateColumn.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsUpdateColumn.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsDeleteColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  router.delete(
    "projectsDeleteColumn",
    "/projects/columns/:column_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsDeleteColumnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsDeleteColumn(input, projectsDeleteColumn.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsDeleteColumn.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsListCardsParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsListCardsQuerySchema = z.object({
    archived_state: z
      .enum(["all", "archived", "not_archived"])
      .optional()
      .default("not_archived"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "projectsListCards",
    "/projects/columns/:column_id/cards",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsListCardsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          projectsListCardsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsListCards(input, projectsListCards.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsListCards.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsCreateCardParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsCreateCardBodySchema = z.union([
    z.object({ note: z.string().nullable() }),
    z.object({ content_id: z.coerce.number(), content_type: z.string() }),
  ])

  router.post(
    "projectsCreateCard",
    "/projects/columns/:column_id/cards",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsCreateCardParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsCreateCardBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsCreateCard(input, projectsCreateCard.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsCreateCard.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsMoveColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsMoveColumnBodySchema = z.object({
    position: z.string().regex(new RegExp("^(?:first|last|after:\\d+)$")),
  })

  router.post(
    "projectsMoveColumn",
    "/projects/columns/:column_id/moves",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsMoveColumnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsMoveColumnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsMoveColumn(input, projectsMoveColumn.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsMoveColumn.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsGetParamSchema = z.object({ project_id: z.coerce.number() })

  router.get("projectsGet", "/projects/:project_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        projectsGetParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .projectsGet(input, projectsGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = projectsGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const projectsUpdateParamSchema = z.object({ project_id: z.coerce.number() })

  const projectsUpdateBodySchema = z
    .object({
      name: z.string().optional(),
      body: z.string().nullable().optional(),
      state: z.string().optional(),
      organization_permission: z
        .enum(["read", "write", "admin", "none"])
        .optional(),
      private: PermissiveBoolean.optional(),
    })
    .optional()

  router.patch("projectsUpdate", "/projects/:project_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        projectsUpdateParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        projectsUpdateBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .projectsUpdate(input, projectsUpdate.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = projectsUpdate.validator(status, body)
    ctx.status = status
    return next()
  })

  const projectsDeleteParamSchema = z.object({ project_id: z.coerce.number() })

  router.delete(
    "projectsDelete",
    "/projects/:project_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsDeleteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsDelete(input, projectsDelete.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsDelete.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsListCollaboratorsParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsListCollaboratorsQuerySchema = z.object({
    affiliation: z.enum(["outside", "direct", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "projectsListCollaborators",
    "/projects/:project_id/collaborators",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsListCollaboratorsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          projectsListCollaboratorsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsListCollaborators(
          input,
          projectsListCollaborators.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsListCollaborators.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsAddCollaboratorParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.string(),
  })

  const projectsAddCollaboratorBodySchema = z
    .object({
      permission: z
        .enum(["read", "write", "admin"])
        .optional()
        .default("write"),
    })
    .nullable()
    .optional()

  router.put(
    "projectsAddCollaborator",
    "/projects/:project_id/collaborators/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsAddCollaboratorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsAddCollaboratorBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsAddCollaborator(input, projectsAddCollaborator.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsAddCollaborator.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsRemoveCollaboratorParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.string(),
  })

  router.delete(
    "projectsRemoveCollaborator",
    "/projects/:project_id/collaborators/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsRemoveCollaboratorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsRemoveCollaborator(
          input,
          projectsRemoveCollaborator.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsRemoveCollaborator.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsGetPermissionForUserParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.string(),
  })

  router.get(
    "projectsGetPermissionForUser",
    "/projects/:project_id/collaborators/:username/permission",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsGetPermissionForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsGetPermissionForUser(
          input,
          projectsGetPermissionForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsGetPermissionForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsListColumnsParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsListColumnsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "projectsListColumns",
    "/projects/:project_id/columns",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsListColumnsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          projectsListColumnsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsListColumns(input, projectsListColumns.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsListColumns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsCreateColumnParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsCreateColumnBodySchema = z.object({ name: z.string() })

  router.post(
    "projectsCreateColumn",
    "/projects/:project_id/columns",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsCreateColumnParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsCreateColumnBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsCreateColumn(input, projectsCreateColumn.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsCreateColumn.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get("rateLimitGet", "/rate_limit", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .rateLimitGet(input, rateLimitGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = rateLimitGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const reposGetParamSchema = z.object({ owner: z.string(), repo: z.string() })

  router.get("reposGet", "/repos/:owner/:repo", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        reposGetParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .reposGet(input, reposGet.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposGet.validator(status, body)
    ctx.status = status
    return next()
  })

  const reposUpdateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposUpdateBodySchema = z
    .object({
      name: z.string().optional(),
      description: z.string().optional(),
      homepage: z.string().optional(),
      private: PermissiveBoolean.optional().default(false),
      visibility: z.enum(["public", "private"]).optional(),
      security_and_analysis: z
        .object({
          advanced_security: z
            .object({ status: z.string().optional() })
            .optional(),
          code_security: z.object({ status: z.string().optional() }).optional(),
          secret_scanning: z
            .object({ status: z.string().optional() })
            .optional(),
          secret_scanning_push_protection: z
            .object({ status: z.string().optional() })
            .optional(),
          secret_scanning_ai_detection: z
            .object({ status: z.string().optional() })
            .optional(),
          secret_scanning_non_provider_patterns: z
            .object({ status: z.string().optional() })
            .optional(),
        })
        .nullable()
        .optional(),
      has_issues: PermissiveBoolean.optional().default(true),
      has_projects: PermissiveBoolean.optional().default(true),
      has_wiki: PermissiveBoolean.optional().default(true),
      is_template: PermissiveBoolean.optional().default(false),
      default_branch: z.string().optional(),
      allow_squash_merge: PermissiveBoolean.optional().default(true),
      allow_merge_commit: PermissiveBoolean.optional().default(true),
      allow_rebase_merge: PermissiveBoolean.optional().default(true),
      allow_auto_merge: PermissiveBoolean.optional().default(false),
      delete_branch_on_merge: PermissiveBoolean.optional().default(false),
      allow_update_branch: PermissiveBoolean.optional().default(false),
      use_squash_pr_title_as_default:
        PermissiveBoolean.optional().default(false),
      squash_merge_commit_title: z
        .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
        .optional(),
      squash_merge_commit_message: z
        .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
        .optional(),
      merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
      merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
      archived: PermissiveBoolean.optional().default(false),
      allow_forking: PermissiveBoolean.optional().default(false),
      web_commit_signoff_required: PermissiveBoolean.optional().default(false),
    })
    .optional()

  router.patch("reposUpdate", "/repos/:owner/:repo", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        reposUpdateParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        reposUpdateBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .reposUpdate(input, reposUpdate.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposUpdate.validator(status, body)
    ctx.status = status
    return next()
  })

  const reposDeleteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete("reposDelete", "/repos/:owner/:repo", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        reposDeleteParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .reposDelete(input, reposDelete.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposDelete.validator(status, body)
    ctx.status = status
    return next()
  })

  const actionsListArtifactsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListArtifactsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    name: z.string().optional(),
  })

  router.get(
    "actionsListArtifactsForRepo",
    "/repos/:owner/:repo/actions/artifacts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListArtifactsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListArtifactsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListArtifactsForRepo(
          input,
          actionsListArtifactsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListArtifactsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetArtifactParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    artifact_id: z.coerce.number(),
  })

  router.get(
    "actionsGetArtifact",
    "/repos/:owner/:repo/actions/artifacts/:artifact_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetArtifactParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetArtifact(input, actionsGetArtifact.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetArtifact.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteArtifactParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    artifact_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteArtifact",
    "/repos/:owner/:repo/actions/artifacts/:artifact_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteArtifactParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteArtifact(input, actionsDeleteArtifact.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteArtifact.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDownloadArtifactParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    artifact_id: z.coerce.number(),
    archive_format: z.string(),
  })

  router.get(
    "actionsDownloadArtifact",
    "/repos/:owner/:repo/actions/artifacts/:artifact_id/:archive_format",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDownloadArtifactParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDownloadArtifact(input, actionsDownloadArtifact.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDownloadArtifact.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetActionsCacheUsageParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "actionsGetActionsCacheUsage",
    "/repos/:owner/:repo/actions/cache/usage",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetActionsCacheUsageParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetActionsCacheUsage(
          input,
          actionsGetActionsCacheUsage.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetActionsCacheUsage.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetActionsCacheListParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGetActionsCacheListQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    ref: z.string().optional(),
    key: z.string().optional(),
    sort: z
      .enum(["created_at", "last_accessed_at", "size_in_bytes"])
      .optional()
      .default("last_accessed_at"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
  })

  router.get(
    "actionsGetActionsCacheList",
    "/repos/:owner/:repo/actions/caches",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetActionsCacheListParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsGetActionsCacheListQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetActionsCacheList(
          input,
          actionsGetActionsCacheList.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetActionsCacheList.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteActionsCacheByKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsDeleteActionsCacheByKeyQuerySchema = z.object({
    key: z.string(),
    ref: z.string().optional(),
  })

  router.delete(
    "actionsDeleteActionsCacheByKey",
    "/repos/:owner/:repo/actions/caches",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteActionsCacheByKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsDeleteActionsCacheByKeyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteActionsCacheByKey(
          input,
          actionsDeleteActionsCacheByKey.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteActionsCacheByKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteActionsCacheByIdParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    cache_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteActionsCacheById",
    "/repos/:owner/:repo/actions/caches/:cache_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteActionsCacheByIdParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteActionsCacheById(
          input,
          actionsDeleteActionsCacheById.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteActionsCacheById.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetJobForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    job_id: z.coerce.number(),
  })

  router.get(
    "actionsGetJobForWorkflowRun",
    "/repos/:owner/:repo/actions/jobs/:job_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetJobForWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetJobForWorkflowRun(
          input,
          actionsGetJobForWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetJobForWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDownloadJobLogsForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    job_id: z.coerce.number(),
  })

  router.get(
    "actionsDownloadJobLogsForWorkflowRun",
    "/repos/:owner/:repo/actions/jobs/:job_id/logs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDownloadJobLogsForWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDownloadJobLogsForWorkflowRun(
          input,
          actionsDownloadJobLogsForWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDownloadJobLogsForWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsReRunJobForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    job_id: z.coerce.number(),
  })

  const actionsReRunJobForWorkflowRunBodySchema = z
    .object({
      enable_debug_logging: PermissiveBoolean.optional().default(false),
    })
    .nullable()
    .optional()

  router.post(
    "actionsReRunJobForWorkflowRun",
    "/repos/:owner/:repo/actions/jobs/:job_id/rerun",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsReRunJobForWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsReRunJobForWorkflowRunBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsReRunJobForWorkflowRun(
          input,
          actionsReRunJobForWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsReRunJobForWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetCustomOidcSubClaimForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "actionsGetCustomOidcSubClaimForRepo",
    "/repos/:owner/:repo/actions/oidc/customization/sub",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetCustomOidcSubClaimForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetCustomOidcSubClaimForRepo(
          input,
          actionsGetCustomOidcSubClaimForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetCustomOidcSubClaimForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsSetCustomOidcSubClaimForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetCustomOidcSubClaimForRepoBodySchema = z.object({
    use_default: PermissiveBoolean,
    include_claim_keys: z.array(z.string()).optional(),
  })

  router.put(
    "actionsSetCustomOidcSubClaimForRepo",
    "/repos/:owner/:repo/actions/oidc/customization/sub",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetCustomOidcSubClaimForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetCustomOidcSubClaimForRepoBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetCustomOidcSubClaimForRepo(
          input,
          actionsSetCustomOidcSubClaimForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetCustomOidcSubClaimForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListRepoOrganizationSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoOrganizationSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListRepoOrganizationSecrets",
    "/repos/:owner/:repo/actions/organization-secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRepoOrganizationSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListRepoOrganizationSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRepoOrganizationSecrets(
          input,
          actionsListRepoOrganizationSecrets.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRepoOrganizationSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListRepoOrganizationVariablesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoOrganizationVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListRepoOrganizationVariables",
    "/repos/:owner/:repo/actions/organization-variables",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRepoOrganizationVariablesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListRepoOrganizationVariablesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRepoOrganizationVariables(
          input,
          actionsListRepoOrganizationVariables.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRepoOrganizationVariables.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetGithubActionsPermissionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "actionsGetGithubActionsPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetGithubActionsPermissionsRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetGithubActionsPermissionsRepository(
          input,
          actionsGetGithubActionsPermissionsRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetGithubActionsPermissionsRepository.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsSetGithubActionsPermissionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetGithubActionsPermissionsRepositoryBodySchema = z.object({
    enabled: s_actions_enabled,
    allowed_actions: s_allowed_actions.optional(),
  })

  router.put(
    "actionsSetGithubActionsPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetGithubActionsPermissionsRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetGithubActionsPermissionsRepositoryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetGithubActionsPermissionsRepository(
          input,
          actionsSetGithubActionsPermissionsRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetGithubActionsPermissionsRepository.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsGetWorkflowAccessToRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "actionsGetWorkflowAccessToRepository",
    "/repos/:owner/:repo/actions/permissions/access",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetWorkflowAccessToRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetWorkflowAccessToRepository(
          input,
          actionsGetWorkflowAccessToRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetWorkflowAccessToRepository.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsSetWorkflowAccessToRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetWorkflowAccessToRepositoryBodySchema =
    s_actions_workflow_access_to_repository

  router.put(
    "actionsSetWorkflowAccessToRepository",
    "/repos/:owner/:repo/actions/permissions/access",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetWorkflowAccessToRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetWorkflowAccessToRepositoryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetWorkflowAccessToRepository(
          input,
          actionsSetWorkflowAccessToRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetWorkflowAccessToRepository.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetAllowedActionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "actionsGetAllowedActionsRepository",
    "/repos/:owner/:repo/actions/permissions/selected-actions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetAllowedActionsRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetAllowedActionsRepository(
          input,
          actionsGetAllowedActionsRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetAllowedActionsRepository.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsSetAllowedActionsRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsSetAllowedActionsRepositoryBodySchema =
    s_selected_actions.optional()

  router.put(
    "actionsSetAllowedActionsRepository",
    "/repos/:owner/:repo/actions/permissions/selected-actions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetAllowedActionsRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetAllowedActionsRepositoryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetAllowedActionsRepository(
          input,
          actionsSetAllowedActionsRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetAllowedActionsRepository.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema =
    z.object({ owner: z.string(), repo: z.string() })

  router.get(
    "actionsGetGithubActionsDefaultWorkflowPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions/workflow",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
          input,
          actionsGetGithubActionsDefaultWorkflowPermissionsRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsGetGithubActionsDefaultWorkflowPermissionsRepository.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema =
    z.object({ owner: z.string(), repo: z.string() })

  const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema =
    s_actions_set_default_workflow_permissions

  router.put(
    "actionsSetGithubActionsDefaultWorkflowPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions/workflow",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
          input,
          actionsSetGithubActionsDefaultWorkflowPermissionsRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsSetGithubActionsDefaultWorkflowPermissionsRepository.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsListSelfHostedRunnersForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListSelfHostedRunnersForRepoQuerySchema = z.object({
    name: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListSelfHostedRunnersForRepo",
    "/repos/:owner/:repo/actions/runners",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListSelfHostedRunnersForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListSelfHostedRunnersForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListSelfHostedRunnersForRepo(
          input,
          actionsListSelfHostedRunnersForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListSelfHostedRunnersForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListRunnerApplicationsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "actionsListRunnerApplicationsForRepo",
    "/repos/:owner/:repo/actions/runners/downloads",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRunnerApplicationsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRunnerApplicationsForRepo(
          input,
          actionsListRunnerApplicationsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRunnerApplicationsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGenerateRunnerJitconfigForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsGenerateRunnerJitconfigForRepoBodySchema = z.object({
    name: z.string(),
    runner_group_id: z.coerce.number(),
    labels: z.array(z.string()).min(1).max(100),
    work_folder: z.string().optional().default("_work"),
  })

  router.post(
    "actionsGenerateRunnerJitconfigForRepo",
    "/repos/:owner/:repo/actions/runners/generate-jitconfig",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGenerateRunnerJitconfigForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsGenerateRunnerJitconfigForRepoBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsGenerateRunnerJitconfigForRepo(
          input,
          actionsGenerateRunnerJitconfigForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGenerateRunnerJitconfigForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateRegistrationTokenForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.post(
    "actionsCreateRegistrationTokenForRepo",
    "/repos/:owner/:repo/actions/runners/registration-token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateRegistrationTokenForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateRegistrationTokenForRepo(
          input,
          actionsCreateRegistrationTokenForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateRegistrationTokenForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateRemoveTokenForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.post(
    "actionsCreateRemoveTokenForRepo",
    "/repos/:owner/:repo/actions/runners/remove-token",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateRemoveTokenForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateRemoveTokenForRepo(
          input,
          actionsCreateRemoveTokenForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateRemoveTokenForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsGetSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetSelfHostedRunnerForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetSelfHostedRunnerForRepo(
          input,
          actionsGetSelfHostedRunnerForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetSelfHostedRunnerForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteSelfHostedRunnerFromRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteSelfHostedRunnerFromRepo",
    "/repos/:owner/:repo/actions/runners/:runner_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteSelfHostedRunnerFromRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteSelfHostedRunnerFromRepo(
          input,
          actionsDeleteSelfHostedRunnerFromRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteSelfHostedRunnerFromRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListLabelsForSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsListLabelsForSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListLabelsForSelfHostedRunnerForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListLabelsForSelfHostedRunnerForRepo(
          input,
          actionsListLabelsForSelfHostedRunnerForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListLabelsForSelfHostedRunnerForRepo.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema = z.object({
    labels: z.array(z.string()).min(1).max(100),
  })

  router.post(
    "actionsAddCustomLabelsToSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsAddCustomLabelsToSelfHostedRunnerForRepo(
          input,
          actionsAddCustomLabelsToSelfHostedRunnerForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsAddCustomLabelsToSelfHostedRunnerForRepo.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    runner_id: z.coerce.number(),
  })

  const actionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema = z.object({
    labels: z.array(z.string()).min(0).max(100),
  })

  router.put(
    "actionsSetCustomLabelsForSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsSetCustomLabelsForSelfHostedRunnerForRepo(
          input,
          actionsSetCustomLabelsForSelfHostedRunnerForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsSetCustomLabelsForSelfHostedRunnerForRepo.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema =
    z.object({
      owner: z.string(),
      repo: z.string(),
      runner_id: z.coerce.number(),
    })

  router.delete(
    "actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runner_id/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
          input,
          actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const actionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema =
    z.object({
      owner: z.string(),
      repo: z.string(),
      runner_id: z.coerce.number(),
      name: z.string(),
    })

  router.delete(
    "actionsRemoveCustomLabelFromSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runner_id/labels/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
          input,
          actionsRemoveCustomLabelFromSelfHostedRunnerForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsRemoveCustomLabelFromSelfHostedRunnerForRepo.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const actionsListWorkflowRunsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListWorkflowRunsForRepoQuerySchema = z.object({
    actor: z.string().optional(),
    branch: z.string().optional(),
    event: z.string().optional(),
    status: z
      .enum([
        "completed",
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "skipped",
        "stale",
        "success",
        "timed_out",
        "in_progress",
        "queued",
        "requested",
        "waiting",
        "pending",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    created: z.string().datetime({ offset: true }).optional(),
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
    check_suite_id: z.coerce.number().optional(),
    head_sha: z.string().optional(),
  })

  router.get(
    "actionsListWorkflowRunsForRepo",
    "/repos/:owner/:repo/actions/runs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListWorkflowRunsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListWorkflowRunsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListWorkflowRunsForRepo(
          input,
          actionsListWorkflowRunsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListWorkflowRunsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsGetWorkflowRunQuerySchema = z.object({
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
  })

  router.get(
    "actionsGetWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:run_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsGetWorkflowRunQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetWorkflowRun(input, actionsGetWorkflowRun.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:run_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteWorkflowRun(
          input,
          actionsDeleteWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetReviewsForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsGetReviewsForRun",
    "/repos/:owner/:repo/actions/runs/:run_id/approvals",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetReviewsForRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetReviewsForRun(input, actionsGetReviewsForRun.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetReviewsForRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsApproveWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.post(
    "actionsApproveWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:run_id/approve",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsApproveWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsApproveWorkflowRun(
          input,
          actionsApproveWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsApproveWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListWorkflowRunArtifactsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsListWorkflowRunArtifactsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    name: z.string().optional(),
  })

  router.get(
    "actionsListWorkflowRunArtifacts",
    "/repos/:owner/:repo/actions/runs/:run_id/artifacts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListWorkflowRunArtifactsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListWorkflowRunArtifactsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListWorkflowRunArtifacts(
          input,
          actionsListWorkflowRunArtifacts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListWorkflowRunArtifacts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetWorkflowRunAttemptParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  const actionsGetWorkflowRunAttemptQuerySchema = z.object({
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
  })

  router.get(
    "actionsGetWorkflowRunAttempt",
    "/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetWorkflowRunAttemptParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsGetWorkflowRunAttemptQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetWorkflowRunAttempt(
          input,
          actionsGetWorkflowRunAttempt.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetWorkflowRunAttempt.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListJobsForWorkflowRunAttemptParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  const actionsListJobsForWorkflowRunAttemptQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListJobsForWorkflowRunAttempt",
    "/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/jobs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListJobsForWorkflowRunAttemptParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListJobsForWorkflowRunAttemptQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListJobsForWorkflowRunAttempt(
          input,
          actionsListJobsForWorkflowRunAttempt.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListJobsForWorkflowRunAttempt.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDownloadWorkflowRunAttemptLogsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  router.get(
    "actionsDownloadWorkflowRunAttemptLogs",
    "/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/logs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDownloadWorkflowRunAttemptLogsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDownloadWorkflowRunAttemptLogs(
          input,
          actionsDownloadWorkflowRunAttemptLogs.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDownloadWorkflowRunAttemptLogs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCancelWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.post(
    "actionsCancelWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:run_id/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCancelWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsCancelWorkflowRun(
          input,
          actionsCancelWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCancelWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsReviewCustomGatesForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReviewCustomGatesForRunBodySchema = z.union([
    s_review_custom_gates_comment_required,
    s_review_custom_gates_state_required,
  ])

  router.post(
    "actionsReviewCustomGatesForRun",
    "/repos/:owner/:repo/actions/runs/:run_id/deployment_protection_rule",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsReviewCustomGatesForRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsReviewCustomGatesForRunBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsReviewCustomGatesForRun(
          input,
          actionsReviewCustomGatesForRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsReviewCustomGatesForRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsForceCancelWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.post(
    "actionsForceCancelWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:run_id/force-cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsForceCancelWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsForceCancelWorkflowRun(
          input,
          actionsForceCancelWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsForceCancelWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListJobsForWorkflowRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsListJobsForWorkflowRunQuerySchema = z.object({
    filter: z.enum(["latest", "all"]).optional().default("latest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListJobsForWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:run_id/jobs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListJobsForWorkflowRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListJobsForWorkflowRunQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListJobsForWorkflowRun(
          input,
          actionsListJobsForWorkflowRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListJobsForWorkflowRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDownloadWorkflowRunLogsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsDownloadWorkflowRunLogs",
    "/repos/:owner/:repo/actions/runs/:run_id/logs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDownloadWorkflowRunLogsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDownloadWorkflowRunLogs(
          input,
          actionsDownloadWorkflowRunLogs.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDownloadWorkflowRunLogs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteWorkflowRunLogsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteWorkflowRunLogs",
    "/repos/:owner/:repo/actions/runs/:run_id/logs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteWorkflowRunLogsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteWorkflowRunLogs(
          input,
          actionsDeleteWorkflowRunLogs.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteWorkflowRunLogs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetPendingDeploymentsForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsGetPendingDeploymentsForRun",
    "/repos/:owner/:repo/actions/runs/:run_id/pending_deployments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetPendingDeploymentsForRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetPendingDeploymentsForRun(
          input,
          actionsGetPendingDeploymentsForRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetPendingDeploymentsForRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsReviewPendingDeploymentsForRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReviewPendingDeploymentsForRunBodySchema = z.object({
    environment_ids: z.array(z.coerce.number()),
    state: z.enum(["approved", "rejected"]),
    comment: z.string(),
  })

  router.post(
    "actionsReviewPendingDeploymentsForRun",
    "/repos/:owner/:repo/actions/runs/:run_id/pending_deployments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsReviewPendingDeploymentsForRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsReviewPendingDeploymentsForRunBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsReviewPendingDeploymentsForRun(
          input,
          actionsReviewPendingDeploymentsForRun.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsReviewPendingDeploymentsForRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsReRunWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReRunWorkflowBodySchema = z
    .object({
      enable_debug_logging: PermissiveBoolean.optional().default(false),
    })
    .nullable()
    .optional()

  router.post(
    "actionsReRunWorkflow",
    "/repos/:owner/:repo/actions/runs/:run_id/rerun",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsReRunWorkflowParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsReRunWorkflowBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsReRunWorkflow(input, actionsReRunWorkflow.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsReRunWorkflow.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsReRunWorkflowFailedJobsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  const actionsReRunWorkflowFailedJobsBodySchema = z
    .object({
      enable_debug_logging: PermissiveBoolean.optional().default(false),
    })
    .nullable()
    .optional()

  router.post(
    "actionsReRunWorkflowFailedJobs",
    "/repos/:owner/:repo/actions/runs/:run_id/rerun-failed-jobs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsReRunWorkflowFailedJobsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsReRunWorkflowFailedJobsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsReRunWorkflowFailedJobs(
          input,
          actionsReRunWorkflowFailedJobs.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsReRunWorkflowFailedJobs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetWorkflowRunUsageParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsGetWorkflowRunUsage",
    "/repos/:owner/:repo/actions/runs/:run_id/timing",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetWorkflowRunUsageParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetWorkflowRunUsage(
          input,
          actionsGetWorkflowRunUsage.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetWorkflowRunUsage.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListRepoSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListRepoSecrets",
    "/repos/:owner/:repo/actions/secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRepoSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListRepoSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRepoSecrets(input, actionsListRepoSecrets.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRepoSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetRepoPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "actionsGetRepoPublicKey",
    "/repos/:owner/:repo/actions/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetRepoPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetRepoPublicKey(input, actionsGetRepoPublicKey.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetRepoPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "actionsGetRepoSecret",
    "/repos/:owner/:repo/actions/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetRepoSecret(input, actionsGetRepoSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const actionsCreateOrUpdateRepoSecretBodySchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      ),
    key_id: z.string(),
  })

  router.put(
    "actionsCreateOrUpdateRepoSecret",
    "/repos/:owner/:repo/actions/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateOrUpdateRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateOrUpdateRepoSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateOrUpdateRepoSecret(
          input,
          actionsCreateOrUpdateRepoSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateOrUpdateRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "actionsDeleteRepoSecret",
    "/repos/:owner/:repo/actions/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteRepoSecret(input, actionsDeleteRepoSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListRepoVariablesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListRepoVariables",
    "/repos/:owner/:repo/actions/variables",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRepoVariablesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListRepoVariablesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRepoVariables(
          input,
          actionsListRepoVariables.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRepoVariables.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsCreateRepoVariableBodySchema = z.object({
    name: z.string(),
    value: z.string(),
  })

  router.post(
    "actionsCreateRepoVariable",
    "/repos/:owner/:repo/actions/variables",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateRepoVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateRepoVariableBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateRepoVariable(
          input,
          actionsCreateRepoVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateRepoVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  router.get(
    "actionsGetRepoVariable",
    "/repos/:owner/:repo/actions/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetRepoVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetRepoVariable(input, actionsGetRepoVariable.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetRepoVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsUpdateRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const actionsUpdateRepoVariableBodySchema = z.object({
    name: z.string().optional(),
    value: z.string().optional(),
  })

  router.patch(
    "actionsUpdateRepoVariable",
    "/repos/:owner/:repo/actions/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsUpdateRepoVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsUpdateRepoVariableBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsUpdateRepoVariable(
          input,
          actionsUpdateRepoVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsUpdateRepoVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteRepoVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  router.delete(
    "actionsDeleteRepoVariable",
    "/repos/:owner/:repo/actions/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteRepoVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteRepoVariable(
          input,
          actionsDeleteRepoVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteRepoVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListRepoWorkflowsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const actionsListRepoWorkflowsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListRepoWorkflows",
    "/repos/:owner/:repo/actions/workflows",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListRepoWorkflowsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListRepoWorkflowsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListRepoWorkflows(
          input,
          actionsListRepoWorkflows.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListRepoWorkflows.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  router.get(
    "actionsGetWorkflow",
    "/repos/:owner/:repo/actions/workflows/:workflow_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetWorkflowParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetWorkflow(input, actionsGetWorkflow.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetWorkflow.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDisableWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  router.put(
    "actionsDisableWorkflow",
    "/repos/:owner/:repo/actions/workflows/:workflow_id/disable",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDisableWorkflowParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDisableWorkflow(input, actionsDisableWorkflow.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDisableWorkflow.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateWorkflowDispatchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsCreateWorkflowDispatchBodySchema = z.object({
    ref: z.string(),
    inputs: z.record(z.unknown()).optional(),
  })

  router.post(
    "actionsCreateWorkflowDispatch",
    "/repos/:owner/:repo/actions/workflows/:workflow_id/dispatches",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateWorkflowDispatchParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateWorkflowDispatchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateWorkflowDispatch(
          input,
          actionsCreateWorkflowDispatch.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateWorkflowDispatch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsEnableWorkflowParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  router.put(
    "actionsEnableWorkflow",
    "/repos/:owner/:repo/actions/workflows/:workflow_id/enable",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsEnableWorkflowParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsEnableWorkflow(input, actionsEnableWorkflow.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsEnableWorkflow.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListWorkflowRunsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  const actionsListWorkflowRunsQuerySchema = z.object({
    actor: z.string().optional(),
    branch: z.string().optional(),
    event: z.string().optional(),
    status: z
      .enum([
        "completed",
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "skipped",
        "stale",
        "success",
        "timed_out",
        "in_progress",
        "queued",
        "requested",
        "waiting",
        "pending",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    created: z.string().datetime({ offset: true }).optional(),
    exclude_pull_requests: PermissiveBoolean.optional().default(false),
    check_suite_id: z.coerce.number().optional(),
    head_sha: z.string().optional(),
  })

  router.get(
    "actionsListWorkflowRuns",
    "/repos/:owner/:repo/actions/workflows/:workflow_id/runs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListWorkflowRunsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListWorkflowRunsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListWorkflowRuns(input, actionsListWorkflowRuns.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListWorkflowRuns.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetWorkflowUsageParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    workflow_id: z.union([z.coerce.number(), z.string()]),
  })

  router.get(
    "actionsGetWorkflowUsage",
    "/repos/:owner/:repo/actions/workflows/:workflow_id/timing",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetWorkflowUsageParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetWorkflowUsage(input, actionsGetWorkflowUsage.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetWorkflowUsage.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListActivitiesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListActivitiesQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    ref: z.string().optional(),
    actor: z.string().optional(),
    time_period: z.enum(["day", "week", "month", "quarter", "year"]).optional(),
    activity_type: z
      .enum([
        "push",
        "force_push",
        "branch_creation",
        "branch_deletion",
        "pr_merge",
        "merge_queue_merge",
      ])
      .optional(),
  })

  router.get(
    "reposListActivities",
    "/repos/:owner/:repo/activity",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListActivitiesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListActivitiesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListActivities(input, reposListActivities.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListActivities.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListAssigneesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListAssigneesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListAssignees",
    "/repos/:owner/:repo/assignees",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListAssigneesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListAssigneesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListAssignees(input, issuesListAssignees.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListAssignees.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesCheckUserCanBeAssignedParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    assignee: z.string(),
  })

  router.get(
    "issuesCheckUserCanBeAssigned",
    "/repos/:owner/:repo/assignees/:assignee",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesCheckUserCanBeAssignedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesCheckUserCanBeAssigned(
          input,
          issuesCheckUserCanBeAssigned.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesCheckUserCanBeAssigned.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateAttestationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateAttestationBodySchema = z.object({
    bundle: z.object({
      mediaType: z.string().optional(),
      verificationMaterial: z.record(z.unknown()).optional(),
      dsseEnvelope: z.record(z.unknown()).optional(),
    }),
  })

  router.post(
    "reposCreateAttestation",
    "/repos/:owner/:repo/attestations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateAttestationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateAttestationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateAttestation(input, reposCreateAttestation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateAttestation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListAttestationsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    subject_digest: z.string(),
  })

  const reposListAttestationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    predicate_type: z.string().optional(),
  })

  router.get(
    "reposListAttestations",
    "/repos/:owner/:repo/attestations/:subject_digest",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListAttestationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListAttestationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListAttestations(input, reposListAttestations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListAttestations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListAutolinksParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposListAutolinks",
    "/repos/:owner/:repo/autolinks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListAutolinksParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListAutolinks(input, reposListAutolinks.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListAutolinks.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateAutolinkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateAutolinkBodySchema = z.object({
    key_prefix: z.string(),
    url_template: z.string(),
    is_alphanumeric: PermissiveBoolean.optional().default(true),
  })

  router.post(
    "reposCreateAutolink",
    "/repos/:owner/:repo/autolinks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateAutolinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateAutolinkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateAutolink(input, reposCreateAutolink.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateAutolink.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAutolinkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    autolink_id: z.coerce.number(),
  })

  router.get(
    "reposGetAutolink",
    "/repos/:owner/:repo/autolinks/:autolink_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAutolinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAutolink(input, reposGetAutolink.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAutolink.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteAutolinkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    autolink_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteAutolink",
    "/repos/:owner/:repo/autolinks/:autolink_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteAutolinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteAutolink(input, reposDeleteAutolink.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteAutolink.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCheckAutomatedSecurityFixesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposCheckAutomatedSecurityFixes",
    "/repos/:owner/:repo/automated-security-fixes",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCheckAutomatedSecurityFixesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCheckAutomatedSecurityFixes(
          input,
          reposCheckAutomatedSecurityFixes.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCheckAutomatedSecurityFixes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposEnableAutomatedSecurityFixesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.put(
    "reposEnableAutomatedSecurityFixes",
    "/repos/:owner/:repo/automated-security-fixes",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposEnableAutomatedSecurityFixesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposEnableAutomatedSecurityFixes(
          input,
          reposEnableAutomatedSecurityFixes.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposEnableAutomatedSecurityFixes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDisableAutomatedSecurityFixesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "reposDisableAutomatedSecurityFixes",
    "/repos/:owner/:repo/automated-security-fixes",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDisableAutomatedSecurityFixesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDisableAutomatedSecurityFixes(
          input,
          reposDisableAutomatedSecurityFixes.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDisableAutomatedSecurityFixes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListBranchesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListBranchesQuerySchema = z.object({
    protected: PermissiveBoolean.optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListBranches",
    "/repos/:owner/:repo/branches",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListBranchesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListBranchesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListBranches(input, reposListBranches.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListBranches.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetBranch",
    "/repos/:owner/:repo/branches/:branch",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetBranchParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetBranch(input, reposGetBranch.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetBranch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetBranchProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetBranchProtection(
          input,
          reposGetBranchProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetBranchProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposUpdateBranchProtectionBodySchema = z.object({
    required_status_checks: z
      .object({
        strict: PermissiveBoolean,
        contexts: z.array(z.string()),
        checks: z
          .array(
            z.object({
              context: z.string(),
              app_id: z.coerce.number().optional(),
            }),
          )
          .optional(),
      })
      .nullable(),
    enforce_admins: PermissiveBoolean.nullable(),
    required_pull_request_reviews: z
      .object({
        dismissal_restrictions: z
          .object({
            users: z.array(z.string()).optional(),
            teams: z.array(z.string()).optional(),
            apps: z.array(z.string()).optional(),
          })
          .optional(),
        dismiss_stale_reviews: PermissiveBoolean.optional(),
        require_code_owner_reviews: PermissiveBoolean.optional(),
        required_approving_review_count: z.coerce.number().optional(),
        require_last_push_approval: PermissiveBoolean.optional().default(false),
        bypass_pull_request_allowances: z
          .object({
            users: z.array(z.string()).optional(),
            teams: z.array(z.string()).optional(),
            apps: z.array(z.string()).optional(),
          })
          .optional(),
      })
      .nullable(),
    restrictions: z
      .object({
        users: z.array(z.string()),
        teams: z.array(z.string()),
        apps: z.array(z.string()).optional(),
      })
      .nullable(),
    required_linear_history: PermissiveBoolean.optional(),
    allow_force_pushes: PermissiveBoolean.nullable().optional(),
    allow_deletions: PermissiveBoolean.optional(),
    block_creations: PermissiveBoolean.optional(),
    required_conversation_resolution: PermissiveBoolean.optional(),
    lock_branch: PermissiveBoolean.optional().default(false),
    allow_fork_syncing: PermissiveBoolean.optional().default(false),
  })

  router.put(
    "reposUpdateBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateBranchProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateBranchProtectionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateBranchProtection(
          input,
          reposUpdateBranchProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateBranchProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.delete(
    "reposDeleteBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteBranchProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteBranchProtection(
          input,
          reposDeleteBranchProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteBranchProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAdminBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetAdminBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection/enforce_admins",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAdminBranchProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAdminBranchProtection(
          input,
          reposGetAdminBranchProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAdminBranchProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposSetAdminBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.post(
    "reposSetAdminBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection/enforce_admins",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposSetAdminBranchProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposSetAdminBranchProtection(
          input,
          reposSetAdminBranchProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposSetAdminBranchProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteAdminBranchProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.delete(
    "reposDeleteAdminBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection/enforce_admins",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteAdminBranchProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteAdminBranchProtection(
          input,
          reposDeleteAdminBranchProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteAdminBranchProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetPullRequestReviewProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetPullRequestReviewProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetPullRequestReviewProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetPullRequestReviewProtection(
          input,
          reposGetPullRequestReviewProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetPullRequestReviewProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdatePullRequestReviewProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposUpdatePullRequestReviewProtectionBodySchema = z
    .object({
      dismissal_restrictions: z
        .object({
          users: z.array(z.string()).optional(),
          teams: z.array(z.string()).optional(),
          apps: z.array(z.string()).optional(),
        })
        .optional(),
      dismiss_stale_reviews: PermissiveBoolean.optional(),
      require_code_owner_reviews: PermissiveBoolean.optional(),
      required_approving_review_count: z.coerce.number().optional(),
      require_last_push_approval: PermissiveBoolean.optional().default(false),
      bypass_pull_request_allowances: z
        .object({
          users: z.array(z.string()).optional(),
          teams: z.array(z.string()).optional(),
          apps: z.array(z.string()).optional(),
        })
        .optional(),
    })
    .optional()

  router.patch(
    "reposUpdatePullRequestReviewProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdatePullRequestReviewProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdatePullRequestReviewProtectionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdatePullRequestReviewProtection(
          input,
          reposUpdatePullRequestReviewProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdatePullRequestReviewProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeletePullRequestReviewProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.delete(
    "reposDeletePullRequestReviewProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeletePullRequestReviewProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeletePullRequestReviewProtection(
          input,
          reposDeletePullRequestReviewProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeletePullRequestReviewProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCommitSignatureProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetCommitSignatureProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_signatures",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCommitSignatureProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCommitSignatureProtection(
          input,
          reposGetCommitSignatureProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCommitSignatureProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateCommitSignatureProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.post(
    "reposCreateCommitSignatureProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_signatures",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateCommitSignatureProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCreateCommitSignatureProtection(
          input,
          reposCreateCommitSignatureProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateCommitSignatureProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteCommitSignatureProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.delete(
    "reposDeleteCommitSignatureProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_signatures",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteCommitSignatureProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteCommitSignatureProtection(
          input,
          reposDeleteCommitSignatureProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteCommitSignatureProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetStatusChecksProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetStatusChecksProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetStatusChecksProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetStatusChecksProtection(
          input,
          reposGetStatusChecksProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetStatusChecksProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateStatusCheckProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposUpdateStatusCheckProtectionBodySchema = z
    .object({
      strict: PermissiveBoolean.optional(),
      contexts: z.array(z.string()).optional(),
      checks: z
        .array(
          z.object({
            context: z.string(),
            app_id: z.coerce.number().optional(),
          }),
        )
        .optional(),
    })
    .optional()

  router.patch(
    "reposUpdateStatusCheckProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateStatusCheckProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateStatusCheckProtectionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateStatusCheckProtection(
          input,
          reposUpdateStatusCheckProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateStatusCheckProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRemoveStatusCheckProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.delete(
    "reposRemoveStatusCheckProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRemoveStatusCheckProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposRemoveStatusCheckProtection(
          input,
          reposRemoveStatusCheckProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRemoveStatusCheckProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAllStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetAllStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAllStatusCheckContextsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAllStatusCheckContexts(
          input,
          reposGetAllStatusCheckContexts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAllStatusCheckContexts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposAddStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddStatusCheckContextsBodySchema = z
    .union([z.object({ contexts: z.array(z.string()) }), z.array(z.string())])
    .optional()

  router.post(
    "reposAddStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposAddStatusCheckContextsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposAddStatusCheckContextsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposAddStatusCheckContexts(
          input,
          reposAddStatusCheckContexts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposAddStatusCheckContexts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposSetStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetStatusCheckContextsBodySchema = z
    .union([z.object({ contexts: z.array(z.string()) }), z.array(z.string())])
    .optional()

  router.put(
    "reposSetStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposSetStatusCheckContextsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposSetStatusCheckContextsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposSetStatusCheckContexts(
          input,
          reposSetStatusCheckContexts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposSetStatusCheckContexts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRemoveStatusCheckContextsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveStatusCheckContextsBodySchema = z.union([
    z.object({ contexts: z.array(z.string()) }),
    z.array(z.string()),
  ])

  router.delete(
    "reposRemoveStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRemoveStatusCheckContextsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposRemoveStatusCheckContextsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposRemoveStatusCheckContexts(
          input,
          reposRemoveStatusCheckContexts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRemoveStatusCheckContexts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAccessRestrictions(
          input,
          reposGetAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.delete(
    "reposDeleteAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteAccessRestrictions(
          input,
          reposDeleteAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAppsWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetAppsWithAccessToProtectedBranch",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAppsWithAccessToProtectedBranchParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAppsWithAccessToProtectedBranch(
          input,
          reposGetAppsWithAccessToProtectedBranch.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAppsWithAccessToProtectedBranch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposAddAppAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddAppAccessRestrictionsBodySchema = z.object({
    apps: z.array(z.string()),
  })

  router.post(
    "reposAddAppAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposAddAppAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposAddAppAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposAddAppAccessRestrictions(
          input,
          reposAddAppAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposAddAppAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposSetAppAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetAppAccessRestrictionsBodySchema = z.object({
    apps: z.array(z.string()),
  })

  router.put(
    "reposSetAppAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposSetAppAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposSetAppAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposSetAppAccessRestrictions(
          input,
          reposSetAppAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposSetAppAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRemoveAppAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveAppAccessRestrictionsBodySchema = z.object({
    apps: z.array(z.string()),
  })

  router.delete(
    "reposRemoveAppAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRemoveAppAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposRemoveAppAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposRemoveAppAccessRestrictions(
          input,
          reposRemoveAppAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRemoveAppAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetTeamsWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetTeamsWithAccessToProtectedBranch",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetTeamsWithAccessToProtectedBranchParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetTeamsWithAccessToProtectedBranch(
          input,
          reposGetTeamsWithAccessToProtectedBranch.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetTeamsWithAccessToProtectedBranch.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposAddTeamAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddTeamAccessRestrictionsBodySchema = z
    .union([z.object({ teams: z.array(z.string()) }), z.array(z.string())])
    .optional()

  router.post(
    "reposAddTeamAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposAddTeamAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposAddTeamAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposAddTeamAccessRestrictions(
          input,
          reposAddTeamAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposAddTeamAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposSetTeamAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetTeamAccessRestrictionsBodySchema = z
    .union([z.object({ teams: z.array(z.string()) }), z.array(z.string())])
    .optional()

  router.put(
    "reposSetTeamAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposSetTeamAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposSetTeamAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposSetTeamAccessRestrictions(
          input,
          reposSetTeamAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposSetTeamAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRemoveTeamAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveTeamAccessRestrictionsBodySchema = z.union([
    z.object({ teams: z.array(z.string()) }),
    z.array(z.string()),
  ])

  router.delete(
    "reposRemoveTeamAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRemoveTeamAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposRemoveTeamAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposRemoveTeamAccessRestrictions(
          input,
          reposRemoveTeamAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRemoveTeamAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetUsersWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  router.get(
    "reposGetUsersWithAccessToProtectedBranch",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetUsersWithAccessToProtectedBranchParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetUsersWithAccessToProtectedBranch(
          input,
          reposGetUsersWithAccessToProtectedBranch.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetUsersWithAccessToProtectedBranch.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposAddUserAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposAddUserAccessRestrictionsBodySchema = z.object({
    users: z.array(z.string()),
  })

  router.post(
    "reposAddUserAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposAddUserAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposAddUserAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposAddUserAccessRestrictions(
          input,
          reposAddUserAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposAddUserAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposSetUserAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposSetUserAccessRestrictionsBodySchema = z.object({
    users: z.array(z.string()),
  })

  router.put(
    "reposSetUserAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposSetUserAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposSetUserAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposSetUserAccessRestrictions(
          input,
          reposSetUserAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposSetUserAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRemoveUserAccessRestrictionsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRemoveUserAccessRestrictionsBodySchema = z.object({
    users: z.array(z.string()),
  })

  router.delete(
    "reposRemoveUserAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRemoveUserAccessRestrictionsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposRemoveUserAccessRestrictionsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposRemoveUserAccessRestrictions(
          input,
          reposRemoveUserAccessRestrictions.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRemoveUserAccessRestrictions.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRenameBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposRenameBranchBodySchema = z.object({ new_name: z.string() })

  router.post(
    "reposRenameBranch",
    "/repos/:owner/:repo/branches/:branch/rename",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRenameBranchParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposRenameBranchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposRenameBranch(input, reposRenameBranch.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRenameBranch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksCreateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const checksCreateBodySchema = z.union([
    z.intersection(z.object({ status: z.object({}) }), z.record(z.unknown())),
    z.intersection(
      z.object({ status: z.object({}).optional() }),
      z.record(z.unknown()),
    ),
  ])

  router.post(
    "checksCreate",
    "/repos/:owner/:repo/check-runs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksCreateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          checksCreateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .checksCreate(input, checksCreate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksCreate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksGetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  router.get(
    "checksGet",
    "/repos/:owner/:repo/check-runs/:check_run_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksGetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksGet(input, checksGet.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksGet.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksUpdateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  const checksUpdateBodySchema = z.object({
    name: z.string().optional(),
    details_url: z.string().optional(),
    external_id: z.string().optional(),
    started_at: z.string().datetime({ offset: true }).optional(),
    status: z
      .enum([
        "queued",
        "in_progress",
        "completed",
        "waiting",
        "requested",
        "pending",
      ])
      .optional(),
    conclusion: z
      .enum([
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "success",
        "skipped",
        "stale",
        "timed_out",
      ])
      .optional(),
    completed_at: z.string().datetime({ offset: true }).optional(),
    output: z
      .object({
        title: z.string().optional(),
        summary: z.string().max(65535),
        text: z.string().max(65535).optional(),
        annotations: z
          .array(
            z.object({
              path: z.string(),
              start_line: z.coerce.number(),
              end_line: z.coerce.number(),
              start_column: z.coerce.number().optional(),
              end_column: z.coerce.number().optional(),
              annotation_level: z.enum(["notice", "warning", "failure"]),
              message: z.string(),
              title: z.string().optional(),
              raw_details: z.string().optional(),
            }),
          )
          .max(50)
          .optional(),
        images: z
          .array(
            z.object({
              alt: z.string(),
              image_url: z.string(),
              caption: z.string().optional(),
            }),
          )
          .optional(),
      })
      .optional(),
    actions: z
      .array(
        z.object({
          label: z.string().max(20),
          description: z.string().max(40),
          identifier: z.string().max(20),
        }),
      )
      .max(3)
      .optional(),
  })

  router.patch(
    "checksUpdate",
    "/repos/:owner/:repo/check-runs/:check_run_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksUpdateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          checksUpdateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .checksUpdate(input, checksUpdate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksUpdate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksListAnnotationsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  const checksListAnnotationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "checksListAnnotations",
    "/repos/:owner/:repo/check-runs/:check_run_id/annotations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksListAnnotationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          checksListAnnotationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksListAnnotations(input, checksListAnnotations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksListAnnotations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksRerequestRunParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_run_id: z.coerce.number(),
  })

  router.post(
    "checksRerequestRun",
    "/repos/:owner/:repo/check-runs/:check_run_id/rerequest",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksRerequestRunParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksRerequestRun(input, checksRerequestRun.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksRerequestRun.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksCreateSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const checksCreateSuiteBodySchema = z.object({ head_sha: z.string() })

  router.post(
    "checksCreateSuite",
    "/repos/:owner/:repo/check-suites",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksCreateSuiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          checksCreateSuiteBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .checksCreateSuite(input, checksCreateSuite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksCreateSuite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksSetSuitesPreferencesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const checksSetSuitesPreferencesBodySchema = z.object({
    auto_trigger_checks: z
      .array(
        z.object({
          app_id: z.coerce.number(),
          setting: PermissiveBoolean.default(true),
        }),
      )
      .optional(),
  })

  router.patch(
    "checksSetSuitesPreferences",
    "/repos/:owner/:repo/check-suites/preferences",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksSetSuitesPreferencesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          checksSetSuitesPreferencesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .checksSetSuitesPreferences(
          input,
          checksSetSuitesPreferences.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksSetSuitesPreferences.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksGetSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_suite_id: z.coerce.number(),
  })

  router.get(
    "checksGetSuite",
    "/repos/:owner/:repo/check-suites/:check_suite_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksGetSuiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksGetSuite(input, checksGetSuite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksGetSuite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksListForSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_suite_id: z.coerce.number(),
  })

  const checksListForSuiteQuerySchema = z.object({
    check_name: z.string().optional(),
    status: z.enum(["queued", "in_progress", "completed"]).optional(),
    filter: z.enum(["latest", "all"]).optional().default("latest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "checksListForSuite",
    "/repos/:owner/:repo/check-suites/:check_suite_id/check-runs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksListForSuiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          checksListForSuiteQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksListForSuite(input, checksListForSuite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksListForSuite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksRerequestSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    check_suite_id: z.coerce.number(),
  })

  router.post(
    "checksRerequestSuite",
    "/repos/:owner/:repo/check-suites/:check_suite_id/rerequest",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksRerequestSuiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksRerequestSuite(input, checksRerequestSuite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksRerequestSuite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningListAlertsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningListAlertsForRepoQuerySchema = z.object({
    tool_name: s_code_scanning_analysis_tool_name.optional(),
    tool_guid: s_code_scanning_analysis_tool_guid.optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    ref: s_code_scanning_ref.optional(),
    pr: z.coerce.number().optional(),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    before: z.string().optional(),
    after: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    state: s_code_scanning_alert_state_query.optional(),
    severity: s_code_scanning_alert_severity.optional(),
  })

  router.get(
    "codeScanningListAlertsForRepo",
    "/repos/:owner/:repo/code-scanning/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningListAlertsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeScanningListAlertsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningListAlertsForRepo(
          input,
          codeScanningListAlertsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningListAlertsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  router.get(
    "codeScanningGetAlert",
    "/repos/:owner/:repo/code-scanning/alerts/:alert_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetAlertParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetAlert(input, codeScanningGetAlert.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetAlert.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningUpdateAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningUpdateAlertBodySchema = z.object({
    state: s_code_scanning_alert_set_state,
    dismissed_reason: s_code_scanning_alert_dismissed_reason.optional(),
    dismissed_comment: s_code_scanning_alert_dismissed_comment.optional(),
    create_request: s_code_scanning_alert_create_request.optional(),
  })

  router.patch(
    "codeScanningUpdateAlert",
    "/repos/:owner/:repo/code-scanning/alerts/:alert_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningUpdateAlertParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeScanningUpdateAlertBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeScanningUpdateAlert(input, codeScanningUpdateAlert.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningUpdateAlert.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetAutofixParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  router.get(
    "codeScanningGetAutofix",
    "/repos/:owner/:repo/code-scanning/alerts/:alert_number/autofix",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetAutofixParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetAutofix(input, codeScanningGetAutofix.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetAutofix.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningCreateAutofixParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  router.post(
    "codeScanningCreateAutofix",
    "/repos/:owner/:repo/code-scanning/alerts/:alert_number/autofix",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningCreateAutofixParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningCreateAutofix(
          input,
          codeScanningCreateAutofix.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningCreateAutofix.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningCommitAutofixParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningCommitAutofixBodySchema =
    s_code_scanning_autofix_commits.optional()

  router.post(
    "codeScanningCommitAutofix",
    "/repos/:owner/:repo/code-scanning/alerts/:alert_number/autofix/commits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningCommitAutofixParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeScanningCommitAutofixBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeScanningCommitAutofix(
          input,
          codeScanningCommitAutofix.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningCommitAutofix.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningListAlertInstancesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const codeScanningListAlertInstancesQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    ref: s_code_scanning_ref.optional(),
    pr: z.coerce.number().optional(),
  })

  router.get(
    "codeScanningListAlertInstances",
    "/repos/:owner/:repo/code-scanning/alerts/:alert_number/instances",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningListAlertInstancesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeScanningListAlertInstancesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningListAlertInstances(
          input,
          codeScanningListAlertInstances.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningListAlertInstances.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningListRecentAnalysesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningListRecentAnalysesQuerySchema = z.object({
    tool_name: s_code_scanning_analysis_tool_name.optional(),
    tool_guid: s_code_scanning_analysis_tool_guid.optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    pr: z.coerce.number().optional(),
    ref: s_code_scanning_ref.optional(),
    sarif_id: s_code_scanning_analysis_sarif_id.optional(),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z.enum(["created"]).optional().default("created"),
  })

  router.get(
    "codeScanningListRecentAnalyses",
    "/repos/:owner/:repo/code-scanning/analyses",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningListRecentAnalysesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeScanningListRecentAnalysesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningListRecentAnalyses(
          input,
          codeScanningListRecentAnalyses.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningListRecentAnalyses.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    analysis_id: z.coerce.number(),
  })

  router.get(
    "codeScanningGetAnalysis",
    "/repos/:owner/:repo/code-scanning/analyses/:analysis_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetAnalysisParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetAnalysis(input, codeScanningGetAnalysis.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetAnalysis.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningDeleteAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    analysis_id: z.coerce.number(),
  })

  const codeScanningDeleteAnalysisQuerySchema = z.object({
    confirm_delete: z.string().nullable().optional(),
  })

  router.delete(
    "codeScanningDeleteAnalysis",
    "/repos/:owner/:repo/code-scanning/analyses/:analysis_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningDeleteAnalysisParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codeScanningDeleteAnalysisQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningDeleteAnalysis(
          input,
          codeScanningDeleteAnalysis.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningDeleteAnalysis.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningListCodeqlDatabasesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "codeScanningListCodeqlDatabases",
    "/repos/:owner/:repo/code-scanning/codeql/databases",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningListCodeqlDatabasesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningListCodeqlDatabases(
          input,
          codeScanningListCodeqlDatabases.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningListCodeqlDatabases.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetCodeqlDatabaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    language: z.string(),
  })

  router.get(
    "codeScanningGetCodeqlDatabase",
    "/repos/:owner/:repo/code-scanning/codeql/databases/:language",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetCodeqlDatabaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetCodeqlDatabase(
          input,
          codeScanningGetCodeqlDatabase.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetCodeqlDatabase.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningDeleteCodeqlDatabaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    language: z.string(),
  })

  router.delete(
    "codeScanningDeleteCodeqlDatabase",
    "/repos/:owner/:repo/code-scanning/codeql/databases/:language",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningDeleteCodeqlDatabaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningDeleteCodeqlDatabase(
          input,
          codeScanningDeleteCodeqlDatabase.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningDeleteCodeqlDatabase.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningCreateVariantAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningCreateVariantAnalysisBodySchema = z.union([
    z.object({}),
    z.object({}),
    z.object({}),
  ])

  router.post(
    "codeScanningCreateVariantAnalysis",
    "/repos/:owner/:repo/code-scanning/codeql/variant-analyses",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningCreateVariantAnalysisParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeScanningCreateVariantAnalysisBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeScanningCreateVariantAnalysis(
          input,
          codeScanningCreateVariantAnalysis.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningCreateVariantAnalysis.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetVariantAnalysisParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    codeql_variant_analysis_id: z.coerce.number(),
  })

  router.get(
    "codeScanningGetVariantAnalysis",
    "/repos/:owner/:repo/code-scanning/codeql/variant-analyses/:codeql_variant_analysis_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetVariantAnalysisParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetVariantAnalysis(
          input,
          codeScanningGetVariantAnalysis.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetVariantAnalysis.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetVariantAnalysisRepoTaskParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    codeql_variant_analysis_id: z.coerce.number(),
    repo_owner: z.string(),
    repo_name: z.string(),
  })

  router.get(
    "codeScanningGetVariantAnalysisRepoTask",
    "/repos/:owner/:repo/code-scanning/codeql/variant-analyses/:codeql_variant_analysis_id/repos/:repo_owner/:repo_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetVariantAnalysisRepoTaskParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetVariantAnalysisRepoTask(
          input,
          codeScanningGetVariantAnalysisRepoTask.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetVariantAnalysisRepoTask.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetDefaultSetupParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "codeScanningGetDefaultSetup",
    "/repos/:owner/:repo/code-scanning/default-setup",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetDefaultSetupParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetDefaultSetup(
          input,
          codeScanningGetDefaultSetup.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetDefaultSetup.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningUpdateDefaultSetupParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningUpdateDefaultSetupBodySchema =
    s_code_scanning_default_setup_update

  router.patch(
    "codeScanningUpdateDefaultSetup",
    "/repos/:owner/:repo/code-scanning/default-setup",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningUpdateDefaultSetupParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeScanningUpdateDefaultSetupBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeScanningUpdateDefaultSetup(
          input,
          codeScanningUpdateDefaultSetup.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningUpdateDefaultSetup.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningUploadSarifParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codeScanningUploadSarifBodySchema = z.object({
    commit_sha: s_code_scanning_analysis_commit_sha,
    ref: s_code_scanning_ref_full,
    sarif: s_code_scanning_analysis_sarif_file,
    checkout_uri: z.string().optional(),
    started_at: z.string().datetime({ offset: true }).optional(),
    tool_name: z.string().optional(),
    validate: PermissiveBoolean.optional(),
  })

  router.post(
    "codeScanningUploadSarif",
    "/repos/:owner/:repo/code-scanning/sarifs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningUploadSarifParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codeScanningUploadSarifBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codeScanningUploadSarif(input, codeScanningUploadSarif.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningUploadSarif.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeScanningGetSarifParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    sarif_id: z.string(),
  })

  router.get(
    "codeScanningGetSarif",
    "/repos/:owner/:repo/code-scanning/sarifs/:sarif_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeScanningGetSarifParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeScanningGetSarif(input, codeScanningGetSarif.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeScanningGetSarif.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codeSecurityGetConfigurationForRepositoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "codeSecurityGetConfigurationForRepository",
    "/repos/:owner/:repo/code-security-configuration",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codeSecurityGetConfigurationForRepositoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codeSecurityGetConfigurationForRepository(
          input,
          codeSecurityGetConfigurationForRepository.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codeSecurityGetConfigurationForRepository.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposCodeownersErrorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCodeownersErrorsQuerySchema = z.object({
    ref: z.string().optional(),
  })

  router.get(
    "reposCodeownersErrors",
    "/repos/:owner/:repo/codeowners/errors",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCodeownersErrorsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposCodeownersErrorsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCodeownersErrors(input, reposCodeownersErrors.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCodeownersErrors.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesListInRepositoryForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesListInRepositoryForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "codespacesListInRepositoryForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesListInRepositoryForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesListInRepositoryForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListInRepositoryForAuthenticatedUser(
          input,
          codespacesListInRepositoryForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesListInRepositoryForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesCreateWithRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesCreateWithRepoForAuthenticatedUserBodySchema = z
    .object({
      ref: z.string().optional(),
      location: z.string().optional(),
      geo: z
        .enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"])
        .optional(),
      client_ip: z.string().optional(),
      machine: z.string().optional(),
      devcontainer_path: z.string().optional(),
      multi_repo_permissions_opt_out: PermissiveBoolean.optional(),
      working_directory: z.string().optional(),
      idle_timeout_minutes: z.coerce.number().optional(),
      display_name: z.string().optional(),
      retention_period_minutes: z.coerce.number().optional(),
    })
    .nullable()

  router.post(
    "codespacesCreateWithRepoForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesCreateWithRepoForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesCreateWithRepoForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesCreateWithRepoForAuthenticatedUser(
          input,
          codespacesCreateWithRepoForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCreateWithRepoForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema =
    z.object({ owner: z.string(), repo: z.string() })

  const codespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema =
    z.object({
      per_page: z.coerce.number().optional().default(30),
      page: z.coerce.number().optional().default(1),
    })

  router.get(
    "codespacesListDevcontainersInRepositoryForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces/devcontainers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListDevcontainersInRepositoryForAuthenticatedUser(
          input,
          codespacesListDevcontainersInRepositoryForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        codespacesListDevcontainersInRepositoryForAuthenticatedUser.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const codespacesRepoMachinesForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesRepoMachinesForAuthenticatedUserQuerySchema = z.object({
    location: z.string().optional(),
    client_ip: z.string().optional(),
    ref: z.string().optional(),
  })

  router.get(
    "codespacesRepoMachinesForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces/machines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesRepoMachinesForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesRepoMachinesForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesRepoMachinesForAuthenticatedUser(
          input,
          codespacesRepoMachinesForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesRepoMachinesForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesPreFlightWithRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesPreFlightWithRepoForAuthenticatedUserQuerySchema = z.object({
    ref: z.string().optional(),
    client_ip: z.string().optional(),
  })

  router.get(
    "codespacesPreFlightWithRepoForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces/new",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesPreFlightWithRepoForAuthenticatedUser(
          input,
          codespacesPreFlightWithRepoForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesPreFlightWithRepoForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesCheckPermissionsForDevcontainerParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesCheckPermissionsForDevcontainerQuerySchema = z.object({
    ref: z.string(),
    devcontainer_path: z.string(),
  })

  router.get(
    "codespacesCheckPermissionsForDevcontainer",
    "/repos/:owner/:repo/codespaces/permissions_check",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesCheckPermissionsForDevcontainerParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesCheckPermissionsForDevcontainerQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesCheckPermissionsForDevcontainer(
          input,
          codespacesCheckPermissionsForDevcontainer.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCheckPermissionsForDevcontainer.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesListRepoSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const codespacesListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "codespacesListRepoSecrets",
    "/repos/:owner/:repo/codespaces/secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesListRepoSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          codespacesListRepoSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListRepoSecrets(
          input,
          codespacesListRepoSecrets.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesListRepoSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesGetRepoPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "codespacesGetRepoPublicKey",
    "/repos/:owner/:repo/codespaces/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetRepoPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetRepoPublicKey(
          input,
          codespacesGetRepoPublicKey.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetRepoPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesGetRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "codespacesGetRepoSecret",
    "/repos/:owner/:repo/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetRepoSecret(input, codespacesGetRepoSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const codespacesCreateOrUpdateRepoSecretBodySchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      )
      .optional(),
    key_id: z.string().optional(),
  })

  router.put(
    "codespacesCreateOrUpdateRepoSecret",
    "/repos/:owner/:repo/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesCreateOrUpdateRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesCreateOrUpdateRepoSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesCreateOrUpdateRepoSecret(
          input,
          codespacesCreateOrUpdateRepoSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCreateOrUpdateRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesDeleteRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "codespacesDeleteRepoSecret",
    "/repos/:owner/:repo/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesDeleteRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesDeleteRepoSecret(
          input,
          codespacesDeleteRepoSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesDeleteRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListCollaboratorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListCollaboratorsQuerySchema = z.object({
    affiliation: z.enum(["outside", "direct", "all"]).optional().default("all"),
    permission: z
      .enum(["pull", "triage", "push", "maintain", "admin"])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListCollaborators",
    "/repos/:owner/:repo/collaborators",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListCollaboratorsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListCollaboratorsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListCollaborators(input, reposListCollaborators.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListCollaborators.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCheckCollaboratorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  router.get(
    "reposCheckCollaborator",
    "/repos/:owner/:repo/collaborators/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCheckCollaboratorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCheckCollaborator(input, reposCheckCollaborator.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCheckCollaborator.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposAddCollaboratorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  const reposAddCollaboratorBodySchema = z
    .object({ permission: z.string().optional().default("push") })
    .optional()

  router.put(
    "reposAddCollaborator",
    "/repos/:owner/:repo/collaborators/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposAddCollaboratorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposAddCollaboratorBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposAddCollaborator(input, reposAddCollaborator.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposAddCollaborator.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRemoveCollaboratorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  router.delete(
    "reposRemoveCollaborator",
    "/repos/:owner/:repo/collaborators/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRemoveCollaboratorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposRemoveCollaborator(input, reposRemoveCollaborator.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRemoveCollaborator.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCollaboratorPermissionLevelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    username: z.string(),
  })

  router.get(
    "reposGetCollaboratorPermissionLevel",
    "/repos/:owner/:repo/collaborators/:username/permission",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCollaboratorPermissionLevelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCollaboratorPermissionLevel(
          input,
          reposGetCollaboratorPermissionLevel.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCollaboratorPermissionLevel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListCommitCommentsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListCommitCommentsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListCommitCommentsForRepo",
    "/repos/:owner/:repo/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListCommitCommentsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListCommitCommentsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListCommitCommentsForRepo(
          input,
          reposListCommitCommentsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListCommitCommentsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "reposGetCommitComment",
    "/repos/:owner/:repo/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCommitCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCommitComment(input, reposGetCommitComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCommitComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reposUpdateCommitCommentBodySchema = z.object({ body: z.string() })

  router.patch(
    "reposUpdateCommitComment",
    "/repos/:owner/:repo/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateCommitCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateCommitCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateCommitComment(
          input,
          reposUpdateCommitComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateCommitComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteCommitComment",
    "/repos/:owner/:repo/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteCommitCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteCommitComment(
          input,
          reposDeleteCommitComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteCommitComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForCommitCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForCommitComment",
    "/repos/:owner/:repo/comments/:comment_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForCommitCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForCommitCommentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForCommitComment(
          input,
          reactionsListForCommitComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForCommitComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForCommitCommentBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForCommitComment",
    "/repos/:owner/:repo/comments/:comment_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForCommitCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForCommitCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForCommitComment(
          input,
          reactionsCreateForCommitComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForCommitComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsDeleteForCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForCommitComment",
    "/repos/:owner/:repo/comments/:comment_id/reactions/:reaction_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsDeleteForCommitCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsDeleteForCommitComment(
          input,
          reactionsDeleteForCommitComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsDeleteForCommitComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListCommitsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListCommitsQuerySchema = z.object({
    sha: z.string().optional(),
    path: z.string().optional(),
    author: z.string().optional(),
    committer: z.string().optional(),
    since: z.string().datetime({ offset: true }).optional(),
    until: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListCommits",
    "/repos/:owner/:repo/commits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListCommitsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListCommitsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListCommits(input, reposListCommits.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListCommits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListBranchesForHeadCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  router.get(
    "reposListBranchesForHeadCommit",
    "/repos/:owner/:repo/commits/:commit_sha/branches-where-head",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListBranchesForHeadCommitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListBranchesForHeadCommit(
          input,
          reposListBranchesForHeadCommit.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListBranchesForHeadCommit.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListCommentsForCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const reposListCommentsForCommitQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListCommentsForCommit",
    "/repos/:owner/:repo/commits/:commit_sha/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListCommentsForCommitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListCommentsForCommitQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListCommentsForCommit(
          input,
          reposListCommentsForCommit.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListCommentsForCommit.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateCommitCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const reposCreateCommitCommentBodySchema = z.object({
    body: z.string(),
    path: z.string().optional(),
    position: z.coerce.number().optional(),
    line: z.coerce.number().optional(),
  })

  router.post(
    "reposCreateCommitComment",
    "/repos/:owner/:repo/commits/:commit_sha/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateCommitCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateCommitCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateCommitComment(
          input,
          reposCreateCommitComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateCommitComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListPullRequestsAssociatedWithCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  const reposListPullRequestsAssociatedWithCommitQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListPullRequestsAssociatedWithCommit",
    "/repos/:owner/:repo/commits/:commit_sha/pulls",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListPullRequestsAssociatedWithCommitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListPullRequestsAssociatedWithCommitQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListPullRequestsAssociatedWithCommit(
          input,
          reposListPullRequestsAssociatedWithCommit.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListPullRequestsAssociatedWithCommit.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposGetCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposGetCommitQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "reposGetCommit",
    "/repos/:owner/:repo/commits/:ref",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCommitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetCommitQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCommit(input, reposGetCommit.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCommit.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksListForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const checksListForRefQuerySchema = z.object({
    check_name: z.string().optional(),
    status: z.enum(["queued", "in_progress", "completed"]).optional(),
    filter: z.enum(["latest", "all"]).optional().default("latest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    app_id: z.coerce.number().optional(),
  })

  router.get(
    "checksListForRef",
    "/repos/:owner/:repo/commits/:ref/check-runs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksListForRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          checksListForRefQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksListForRef(input, checksListForRef.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksListForRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const checksListSuitesForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const checksListSuitesForRefQuerySchema = z.object({
    app_id: z.coerce.number().optional(),
    check_name: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "checksListSuitesForRef",
    "/repos/:owner/:repo/commits/:ref/check-suites",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          checksListSuitesForRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          checksListSuitesForRefQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .checksListSuitesForRef(input, checksListSuitesForRef.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = checksListSuitesForRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCombinedStatusForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposGetCombinedStatusForRefQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposGetCombinedStatusForRef",
    "/repos/:owner/:repo/commits/:ref/status",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCombinedStatusForRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetCombinedStatusForRefQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCombinedStatusForRef(
          input,
          reposGetCombinedStatusForRef.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCombinedStatusForRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListCommitStatusesForRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const reposListCommitStatusesForRefQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListCommitStatusesForRef",
    "/repos/:owner/:repo/commits/:ref/statuses",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListCommitStatusesForRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListCommitStatusesForRefQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListCommitStatusesForRef(
          input,
          reposListCommitStatusesForRef.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListCommitStatusesForRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCommunityProfileMetricsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetCommunityProfileMetrics",
    "/repos/:owner/:repo/community/profile",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCommunityProfileMetricsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCommunityProfileMetrics(
          input,
          reposGetCommunityProfileMetrics.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCommunityProfileMetrics.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCompareCommitsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    basehead: z.string(),
  })

  const reposCompareCommitsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "reposCompareCommits",
    "/repos/:owner/:repo/compare/:basehead",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCompareCommitsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposCompareCommitsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCompareCommits(input, reposCompareCommits.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCompareCommits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetContentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    path: z.string(),
  })

  const reposGetContentQuerySchema = z.object({ ref: z.string().optional() })

  router.get(
    "reposGetContent",
    "/repos/:owner/:repo/contents/:path",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetContentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetContentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetContent(input, reposGetContent.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetContent.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateOrUpdateFileContentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    path: z.string(),
  })

  const reposCreateOrUpdateFileContentsBodySchema = z.object({
    message: z.string(),
    content: z.string(),
    sha: z.string().optional(),
    branch: z.string().optional(),
    committer: z
      .object({
        name: z.string(),
        email: z.string(),
        date: z.string().optional(),
      })
      .optional(),
    author: z
      .object({
        name: z.string(),
        email: z.string(),
        date: z.string().optional(),
      })
      .optional(),
  })

  router.put(
    "reposCreateOrUpdateFileContents",
    "/repos/:owner/:repo/contents/:path",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateOrUpdateFileContentsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateOrUpdateFileContentsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateOrUpdateFileContents(
          input,
          reposCreateOrUpdateFileContents.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateOrUpdateFileContents.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteFileParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    path: z.string(),
  })

  const reposDeleteFileBodySchema = z.object({
    message: z.string(),
    sha: z.string(),
    branch: z.string().optional(),
    committer: z
      .object({ name: z.string().optional(), email: z.string().optional() })
      .optional(),
    author: z
      .object({ name: z.string().optional(), email: z.string().optional() })
      .optional(),
  })

  router.delete(
    "reposDeleteFile",
    "/repos/:owner/:repo/contents/:path",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteFileParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposDeleteFileBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteFile(input, reposDeleteFile.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteFile.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListContributorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListContributorsQuerySchema = z.object({
    anon: z.string().optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListContributors",
    "/repos/:owner/:repo/contributors",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListContributorsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListContributorsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListContributors(input, reposListContributors.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListContributors.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotListAlertsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependabotListAlertsForRepoQuerySchema = z.object({
    state: z.string().optional(),
    severity: z.string().optional(),
    ecosystem: z.string().optional(),
    package: z.string().optional(),
    manifest: z.string().optional(),
    epss_percentage: z.string().optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z
      .enum(["created", "updated", "epss_percentage"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    first: z.coerce.number().min(1).max(100).optional().default(30),
    last: z.coerce.number().min(1).max(100).optional(),
  })

  router.get(
    "dependabotListAlertsForRepo",
    "/repos/:owner/:repo/dependabot/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotListAlertsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          dependabotListAlertsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotListAlertsForRepo(
          input,
          dependabotListAlertsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotListAlertsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotGetAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  router.get(
    "dependabotGetAlert",
    "/repos/:owner/:repo/dependabot/alerts/:alert_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotGetAlertParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotGetAlert(input, dependabotGetAlert.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotGetAlert.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotUpdateAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const dependabotUpdateAlertBodySchema = z.object({
    state: z.enum(["dismissed", "open"]),
    dismissed_reason: z
      .enum([
        "fix_started",
        "inaccurate",
        "no_bandwidth",
        "not_used",
        "tolerable_risk",
      ])
      .optional(),
    dismissed_comment: z.string().max(280).optional(),
  })

  router.patch(
    "dependabotUpdateAlert",
    "/repos/:owner/:repo/dependabot/alerts/:alert_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotUpdateAlertParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          dependabotUpdateAlertBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .dependabotUpdateAlert(input, dependabotUpdateAlert.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotUpdateAlert.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotListRepoSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependabotListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "dependabotListRepoSecrets",
    "/repos/:owner/:repo/dependabot/secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotListRepoSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          dependabotListRepoSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotListRepoSecrets(
          input,
          dependabotListRepoSecrets.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotListRepoSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotGetRepoPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "dependabotGetRepoPublicKey",
    "/repos/:owner/:repo/dependabot/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotGetRepoPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotGetRepoPublicKey(
          input,
          dependabotGetRepoPublicKey.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotGetRepoPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotGetRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "dependabotGetRepoSecret",
    "/repos/:owner/:repo/dependabot/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotGetRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotGetRepoSecret(input, dependabotGetRepoSecret.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotGetRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  const dependabotCreateOrUpdateRepoSecretBodySchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      )
      .optional(),
    key_id: z.string().optional(),
  })

  router.put(
    "dependabotCreateOrUpdateRepoSecret",
    "/repos/:owner/:repo/dependabot/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotCreateOrUpdateRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          dependabotCreateOrUpdateRepoSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .dependabotCreateOrUpdateRepoSecret(
          input,
          dependabotCreateOrUpdateRepoSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotCreateOrUpdateRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependabotDeleteRepoSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "dependabotDeleteRepoSecret",
    "/repos/:owner/:repo/dependabot/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependabotDeleteRepoSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependabotDeleteRepoSecret(
          input,
          dependabotDeleteRepoSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependabotDeleteRepoSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependencyGraphDiffRangeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    basehead: z.string(),
  })

  const dependencyGraphDiffRangeQuerySchema = z.object({
    name: z.string().optional(),
  })

  router.get(
    "dependencyGraphDiffRange",
    "/repos/:owner/:repo/dependency-graph/compare/:basehead",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependencyGraphDiffRangeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          dependencyGraphDiffRangeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependencyGraphDiffRange(
          input,
          dependencyGraphDiffRange.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependencyGraphDiffRange.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependencyGraphExportSbomParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "dependencyGraphExportSbom",
    "/repos/:owner/:repo/dependency-graph/sbom",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependencyGraphExportSbomParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .dependencyGraphExportSbom(
          input,
          dependencyGraphExportSbom.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependencyGraphExportSbom.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const dependencyGraphCreateRepositorySnapshotParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const dependencyGraphCreateRepositorySnapshotBodySchema = s_snapshot

  router.post(
    "dependencyGraphCreateRepositorySnapshot",
    "/repos/:owner/:repo/dependency-graph/snapshots",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          dependencyGraphCreateRepositorySnapshotParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          dependencyGraphCreateRepositorySnapshotBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .dependencyGraphCreateRepositorySnapshot(
          input,
          dependencyGraphCreateRepositorySnapshot.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = dependencyGraphCreateRepositorySnapshot.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListDeploymentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListDeploymentsQuerySchema = z.object({
    sha: z.string().optional().default("none"),
    ref: z.string().optional().default("none"),
    task: z.string().optional().default("none"),
    environment: z.string().nullable().optional().default("none"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListDeployments",
    "/repos/:owner/:repo/deployments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListDeploymentsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListDeploymentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListDeployments(input, reposListDeployments.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListDeployments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateDeploymentBodySchema = z.object({
    ref: z.string(),
    task: z.string().optional().default("deploy"),
    auto_merge: PermissiveBoolean.optional().default(true),
    required_contexts: z.array(z.string()).optional(),
    payload: z
      .union([z.record(z.unknown()), z.string().default("")])
      .optional(),
    environment: z.string().optional().default("production"),
    description: z.string().nullable().optional().default(""),
    transient_environment: PermissiveBoolean.optional().default(false),
    production_environment: PermissiveBoolean.optional(),
  })

  router.post(
    "reposCreateDeployment",
    "/repos/:owner/:repo/deployments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateDeploymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateDeploymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateDeployment(input, reposCreateDeployment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateDeployment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeployment",
    "/repos/:owner/:repo/deployments/:deployment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetDeploymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetDeployment(input, reposGetDeployment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetDeployment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteDeployment",
    "/repos/:owner/:repo/deployments/:deployment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteDeploymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteDeployment(input, reposDeleteDeployment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteDeployment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListDeploymentStatusesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  const reposListDeploymentStatusesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListDeploymentStatuses",
    "/repos/:owner/:repo/deployments/:deployment_id/statuses",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListDeploymentStatusesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListDeploymentStatusesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListDeploymentStatuses(
          input,
          reposListDeploymentStatuses.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListDeploymentStatuses.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateDeploymentStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
  })

  const reposCreateDeploymentStatusBodySchema = z.object({
    state: z.enum([
      "error",
      "failure",
      "inactive",
      "in_progress",
      "queued",
      "pending",
      "success",
    ]),
    target_url: z.string().optional().default(""),
    log_url: z.string().optional().default(""),
    description: z.string().optional().default(""),
    environment: z.string().optional(),
    environment_url: z.string().optional().default(""),
    auto_inactive: PermissiveBoolean.optional(),
  })

  router.post(
    "reposCreateDeploymentStatus",
    "/repos/:owner/:repo/deployments/:deployment_id/statuses",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateDeploymentStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateDeploymentStatusBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateDeploymentStatus(
          input,
          reposCreateDeploymentStatus.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateDeploymentStatus.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetDeploymentStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    deployment_id: z.coerce.number(),
    status_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeploymentStatus",
    "/repos/:owner/:repo/deployments/:deployment_id/statuses/:status_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetDeploymentStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetDeploymentStatus(
          input,
          reposGetDeploymentStatus.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetDeploymentStatus.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateDispatchEventParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateDispatchEventBodySchema = z.object({
    event_type: z.string().min(1).max(100),
    client_payload: z.record(z.unknown()).optional(),
  })

  router.post(
    "reposCreateDispatchEvent",
    "/repos/:owner/:repo/dispatches",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateDispatchEventParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateDispatchEventBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateDispatchEvent(
          input,
          reposCreateDispatchEvent.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateDispatchEvent.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAllEnvironmentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetAllEnvironmentsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposGetAllEnvironments",
    "/repos/:owner/:repo/environments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAllEnvironmentsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetAllEnvironmentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAllEnvironments(input, reposGetAllEnvironments.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAllEnvironments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetEnvironmentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  router.get(
    "reposGetEnvironment",
    "/repos/:owner/:repo/environments/:environment_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetEnvironmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetEnvironment(input, reposGetEnvironment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetEnvironment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateOrUpdateEnvironmentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposCreateOrUpdateEnvironmentBodySchema = z
    .object({
      wait_timer: s_wait_timer.optional(),
      prevent_self_review: s_prevent_self_review.optional(),
      reviewers: z
        .array(
          z.object({
            type: s_deployment_reviewer_type.optional(),
            id: z.coerce.number().optional(),
          }),
        )
        .nullable()
        .optional(),
      deployment_branch_policy: s_deployment_branch_policy_settings.optional(),
    })
    .nullable()
    .optional()

  router.put(
    "reposCreateOrUpdateEnvironment",
    "/repos/:owner/:repo/environments/:environment_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateOrUpdateEnvironmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateOrUpdateEnvironmentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateOrUpdateEnvironment(
          input,
          reposCreateOrUpdateEnvironment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateOrUpdateEnvironment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteAnEnvironmentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  router.delete(
    "reposDeleteAnEnvironment",
    "/repos/:owner/:repo/environments/:environment_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteAnEnvironmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteAnEnvironment(
          input,
          reposDeleteAnEnvironment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteAnEnvironment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListDeploymentBranchPoliciesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposListDeploymentBranchPoliciesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListDeploymentBranchPolicies",
    "/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListDeploymentBranchPoliciesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListDeploymentBranchPoliciesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListDeploymentBranchPolicies(
          input,
          reposListDeploymentBranchPolicies.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListDeploymentBranchPolicies.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const reposCreateDeploymentBranchPolicyBodySchema =
    s_deployment_branch_policy_name_pattern_with_type

  router.post(
    "reposCreateDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateDeploymentBranchPolicyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateDeploymentBranchPolicyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateDeploymentBranchPolicy(
          input,
          reposCreateDeploymentBranchPolicy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateDeploymentBranchPolicy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    branch_policy_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetDeploymentBranchPolicyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetDeploymentBranchPolicy(
          input,
          reposGetDeploymentBranchPolicy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetDeploymentBranchPolicy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    branch_policy_id: z.coerce.number(),
  })

  const reposUpdateDeploymentBranchPolicyBodySchema =
    s_deployment_branch_policy_name_pattern

  router.put(
    "reposUpdateDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateDeploymentBranchPolicyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateDeploymentBranchPolicyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateDeploymentBranchPolicy(
          input,
          reposUpdateDeploymentBranchPolicy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateDeploymentBranchPolicy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteDeploymentBranchPolicyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    branch_policy_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteDeploymentBranchPolicyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteDeploymentBranchPolicy(
          input,
          reposDeleteDeploymentBranchPolicy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteDeploymentBranchPolicy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAllDeploymentProtectionRulesParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
  })

  router.get(
    "reposGetAllDeploymentProtectionRules",
    "/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAllDeploymentProtectionRulesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAllDeploymentProtectionRules(
          input,
          reposGetAllDeploymentProtectionRules.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAllDeploymentProtectionRules.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateDeploymentProtectionRuleParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
  })

  const reposCreateDeploymentProtectionRuleBodySchema = z.object({
    integration_id: z.coerce.number().optional(),
  })

  router.post(
    "reposCreateDeploymentProtectionRule",
    "/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateDeploymentProtectionRuleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateDeploymentProtectionRuleBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateDeploymentProtectionRule(
          input,
          reposCreateDeploymentProtectionRule.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateDeploymentProtectionRule.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListCustomDeploymentRuleIntegrationsParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
  })

  const reposListCustomDeploymentRuleIntegrationsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "reposListCustomDeploymentRuleIntegrations",
    "/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules/apps",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListCustomDeploymentRuleIntegrationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListCustomDeploymentRuleIntegrationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListCustomDeploymentRuleIntegrations(
          input,
          reposListCustomDeploymentRuleIntegrations.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListCustomDeploymentRuleIntegrations.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposGetCustomDeploymentProtectionRuleParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    protection_rule_id: z.coerce.number(),
  })

  router.get(
    "reposGetCustomDeploymentProtectionRule",
    "/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules/:protection_rule_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCustomDeploymentProtectionRuleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCustomDeploymentProtectionRule(
          input,
          reposGetCustomDeploymentProtectionRule.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCustomDeploymentProtectionRule.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDisableDeploymentProtectionRuleParamSchema = z.object({
    environment_name: z.string(),
    repo: z.string(),
    owner: z.string(),
    protection_rule_id: z.coerce.number(),
  })

  router.delete(
    "reposDisableDeploymentProtectionRule",
    "/repos/:owner/:repo/environments/:environment_name/deployment_protection_rules/:protection_rule_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDisableDeploymentProtectionRuleParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDisableDeploymentProtectionRule(
          input,
          reposDisableDeploymentProtectionRule.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDisableDeploymentProtectionRule.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListEnvironmentSecretsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const actionsListEnvironmentSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListEnvironmentSecrets",
    "/repos/:owner/:repo/environments/:environment_name/secrets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListEnvironmentSecretsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListEnvironmentSecretsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListEnvironmentSecrets(
          input,
          actionsListEnvironmentSecrets.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListEnvironmentSecrets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetEnvironmentPublicKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  router.get(
    "actionsGetEnvironmentPublicKey",
    "/repos/:owner/:repo/environments/:environment_name/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetEnvironmentPublicKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetEnvironmentPublicKey(
          input,
          actionsGetEnvironmentPublicKey.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetEnvironmentPublicKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetEnvironmentSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    secret_name: z.string(),
  })

  router.get(
    "actionsGetEnvironmentSecret",
    "/repos/:owner/:repo/environments/:environment_name/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetEnvironmentSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetEnvironmentSecret(
          input,
          actionsGetEnvironmentSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetEnvironmentSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateOrUpdateEnvironmentSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    secret_name: z.string(),
  })

  const actionsCreateOrUpdateEnvironmentSecretBodySchema = z.object({
    encrypted_value: z
      .string()
      .regex(
        new RegExp(
          "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
        ),
      ),
    key_id: z.string(),
  })

  router.put(
    "actionsCreateOrUpdateEnvironmentSecret",
    "/repos/:owner/:repo/environments/:environment_name/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateOrUpdateEnvironmentSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateOrUpdateEnvironmentSecretBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateOrUpdateEnvironmentSecret(
          input,
          actionsCreateOrUpdateEnvironmentSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateOrUpdateEnvironmentSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteEnvironmentSecretParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    secret_name: z.string(),
  })

  router.delete(
    "actionsDeleteEnvironmentSecret",
    "/repos/:owner/:repo/environments/:environment_name/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteEnvironmentSecretParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteEnvironmentSecret(
          input,
          actionsDeleteEnvironmentSecret.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteEnvironmentSecret.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsListEnvironmentVariablesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const actionsListEnvironmentVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(10),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "actionsListEnvironmentVariables",
    "/repos/:owner/:repo/environments/:environment_name/variables",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsListEnvironmentVariablesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          actionsListEnvironmentVariablesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsListEnvironmentVariables(
          input,
          actionsListEnvironmentVariables.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsListEnvironmentVariables.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsCreateEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
  })

  const actionsCreateEnvironmentVariableBodySchema = z.object({
    name: z.string(),
    value: z.string(),
  })

  router.post(
    "actionsCreateEnvironmentVariable",
    "/repos/:owner/:repo/environments/:environment_name/variables",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsCreateEnvironmentVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsCreateEnvironmentVariableBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsCreateEnvironmentVariable(
          input,
          actionsCreateEnvironmentVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsCreateEnvironmentVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsGetEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    environment_name: z.string(),
    name: z.string(),
  })

  router.get(
    "actionsGetEnvironmentVariable",
    "/repos/:owner/:repo/environments/:environment_name/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsGetEnvironmentVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsGetEnvironmentVariable(
          input,
          actionsGetEnvironmentVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsGetEnvironmentVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsUpdateEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
    environment_name: z.string(),
  })

  const actionsUpdateEnvironmentVariableBodySchema = z.object({
    name: z.string().optional(),
    value: z.string().optional(),
  })

  router.patch(
    "actionsUpdateEnvironmentVariable",
    "/repos/:owner/:repo/environments/:environment_name/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsUpdateEnvironmentVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          actionsUpdateEnvironmentVariableBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .actionsUpdateEnvironmentVariable(
          input,
          actionsUpdateEnvironmentVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsUpdateEnvironmentVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const actionsDeleteEnvironmentVariableParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
    environment_name: z.string(),
  })

  router.delete(
    "actionsDeleteEnvironmentVariable",
    "/repos/:owner/:repo/environments/:environment_name/variables/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          actionsDeleteEnvironmentVariableParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .actionsDeleteEnvironmentVariable(
          input,
          actionsDeleteEnvironmentVariable.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = actionsDeleteEnvironmentVariable.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListRepoEventsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListRepoEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListRepoEvents",
    "/repos/:owner/:repo/events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListRepoEventsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListRepoEventsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListRepoEvents(input, activityListRepoEvents.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListRepoEvents.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListForksParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListForksQuerySchema = z.object({
    sort: z
      .enum(["newest", "oldest", "stargazers", "watchers"])
      .optional()
      .default("newest"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListForks",
    "/repos/:owner/:repo/forks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListForksParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListForksQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListForks(input, reposListForks.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListForks.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateForkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateForkBodySchema = z
    .object({
      organization: z.string().optional(),
      name: z.string().optional(),
      default_branch_only: PermissiveBoolean.optional(),
    })
    .nullable()
    .optional()

  router.post(
    "reposCreateFork",
    "/repos/:owner/:repo/forks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateForkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateForkBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateFork(input, reposCreateFork.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateFork.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitCreateBlobParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateBlobBodySchema = z.object({
    content: z.string(),
    encoding: z.string().optional().default("utf-8"),
  })

  router.post(
    "gitCreateBlob",
    "/repos/:owner/:repo/git/blobs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitCreateBlobParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gitCreateBlobBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gitCreateBlob(input, gitCreateBlob.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitCreateBlob.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitGetBlobParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    file_sha: z.string(),
  })

  router.get(
    "gitGetBlob",
    "/repos/:owner/:repo/git/blobs/:file_sha",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitGetBlobParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitGetBlob(input, gitGetBlob.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitGetBlob.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitCreateCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateCommitBodySchema = z.object({
    message: z.string(),
    tree: z.string(),
    parents: z.array(z.string()).optional(),
    author: z
      .object({
        name: z.string(),
        email: z.string(),
        date: z.string().datetime({ offset: true }).optional(),
      })
      .optional(),
    committer: z
      .object({
        name: z.string().optional(),
        email: z.string().optional(),
        date: z.string().datetime({ offset: true }).optional(),
      })
      .optional(),
    signature: z.string().optional(),
  })

  router.post(
    "gitCreateCommit",
    "/repos/:owner/:repo/git/commits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitCreateCommitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gitCreateCommitBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gitCreateCommit(input, gitCreateCommit.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitCreateCommit.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitGetCommitParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    commit_sha: z.string(),
  })

  router.get(
    "gitGetCommit",
    "/repos/:owner/:repo/git/commits/:commit_sha",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitGetCommitParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitGetCommit(input, gitGetCommit.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitGetCommit.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitListMatchingRefsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  router.get(
    "gitListMatchingRefs",
    "/repos/:owner/:repo/git/matching-refs/:ref",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitListMatchingRefsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitListMatchingRefs(input, gitListMatchingRefs.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitListMatchingRefs.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitGetRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  router.get(
    "gitGetRef",
    "/repos/:owner/:repo/git/ref/:ref",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitGetRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitGetRef(input, gitGetRef.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitGetRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitCreateRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateRefBodySchema = z.object({ ref: z.string(), sha: z.string() })

  router.post(
    "gitCreateRef",
    "/repos/:owner/:repo/git/refs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitCreateRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gitCreateRefBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gitCreateRef(input, gitCreateRef.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitCreateRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitUpdateRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  const gitUpdateRefBodySchema = z.object({
    sha: z.string(),
    force: PermissiveBoolean.optional().default(false),
  })

  router.patch(
    "gitUpdateRef",
    "/repos/:owner/:repo/git/refs/:ref",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitUpdateRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gitUpdateRefBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gitUpdateRef(input, gitUpdateRef.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitUpdateRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitDeleteRefParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  router.delete(
    "gitDeleteRef",
    "/repos/:owner/:repo/git/refs/:ref",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitDeleteRefParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitDeleteRef(input, gitDeleteRef.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitDeleteRef.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitCreateTagParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateTagBodySchema = z.object({
    tag: z.string(),
    message: z.string(),
    object: z.string(),
    type: z.enum(["commit", "tree", "blob"]),
    tagger: z
      .object({
        name: z.string(),
        email: z.string(),
        date: z.string().datetime({ offset: true }).optional(),
      })
      .optional(),
  })

  router.post(
    "gitCreateTag",
    "/repos/:owner/:repo/git/tags",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitCreateTagParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gitCreateTagBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gitCreateTag(input, gitCreateTag.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitCreateTag.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitGetTagParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tag_sha: z.string(),
  })

  router.get(
    "gitGetTag",
    "/repos/:owner/:repo/git/tags/:tag_sha",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitGetTagParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitGetTag(input, gitGetTag.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitGetTag.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitCreateTreeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const gitCreateTreeBodySchema = z.object({
    tree: z.array(
      z.object({
        path: z.string().optional(),
        mode: z
          .enum(["100644", "100755", "040000", "160000", "120000"])
          .optional(),
        type: z.enum(["blob", "tree", "commit"]).optional(),
        sha: z.string().nullable().optional(),
        content: z.string().optional(),
      }),
    ),
    base_tree: z.string().optional(),
  })

  router.post(
    "gitCreateTree",
    "/repos/:owner/:repo/git/trees",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitCreateTreeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          gitCreateTreeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .gitCreateTree(input, gitCreateTree.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitCreateTree.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gitGetTreeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tree_sha: z.string(),
  })

  const gitGetTreeQuerySchema = z.object({ recursive: z.string().optional() })

  router.get(
    "gitGetTree",
    "/repos/:owner/:repo/git/trees/:tree_sha",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gitGetTreeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          gitGetTreeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gitGetTree(input, gitGetTree.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gitGetTree.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListWebhooksParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListWebhooksQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListWebhooks",
    "/repos/:owner/:repo/hooks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListWebhooksParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListWebhooksQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListWebhooks(input, reposListWebhooks.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListWebhooks.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateWebhookBodySchema = z
    .object({
      name: z.string().optional(),
      config: z
        .object({
          url: s_webhook_config_url.optional(),
          content_type: s_webhook_config_content_type.optional(),
          secret: s_webhook_config_secret.optional(),
          insecure_ssl: s_webhook_config_insecure_ssl.optional(),
        })
        .optional(),
      events: z.array(z.string()).optional().default(["push"]),
      active: PermissiveBoolean.optional().default(true),
    })
    .nullable()
    .optional()

  router.post(
    "reposCreateWebhook",
    "/repos/:owner/:repo/hooks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateWebhookBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateWebhook(input, reposCreateWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "reposGetWebhook",
    "/repos/:owner/:repo/hooks/:hook_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetWebhook(input, reposGetWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposUpdateWebhookBodySchema = z.object({
    config: s_webhook_config.optional(),
    events: z.array(z.string()).optional().default(["push"]),
    add_events: z.array(z.string()).optional(),
    remove_events: z.array(z.string()).optional(),
    active: PermissiveBoolean.optional().default(true),
  })

  router.patch(
    "reposUpdateWebhook",
    "/repos/:owner/:repo/hooks/:hook_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateWebhookBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateWebhook(input, reposUpdateWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteWebhook",
    "/repos/:owner/:repo/hooks/:hook_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteWebhook(input, reposDeleteWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetWebhookConfigForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "reposGetWebhookConfigForRepo",
    "/repos/:owner/:repo/hooks/:hook_id/config",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetWebhookConfigForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetWebhookConfigForRepo(
          input,
          reposGetWebhookConfigForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetWebhookConfigForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateWebhookConfigForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposUpdateWebhookConfigForRepoBodySchema = z
    .object({
      url: s_webhook_config_url.optional(),
      content_type: s_webhook_config_content_type.optional(),
      secret: s_webhook_config_secret.optional(),
      insecure_ssl: s_webhook_config_insecure_ssl.optional(),
    })
    .optional()

  router.patch(
    "reposUpdateWebhookConfigForRepo",
    "/repos/:owner/:repo/hooks/:hook_id/config",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateWebhookConfigForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateWebhookConfigForRepoBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateWebhookConfigForRepo(
          input,
          reposUpdateWebhookConfigForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateWebhookConfigForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListWebhookDeliveriesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  const reposListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    cursor: z.string().optional(),
  })

  router.get(
    "reposListWebhookDeliveries",
    "/repos/:owner/:repo/hooks/:hook_id/deliveries",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListWebhookDeliveriesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListWebhookDeliveriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListWebhookDeliveries(
          input,
          reposListWebhookDeliveries.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListWebhookDeliveries.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetWebhookDeliveryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.get(
    "reposGetWebhookDelivery",
    "/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetWebhookDeliveryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetWebhookDelivery(input, reposGetWebhookDelivery.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetWebhookDelivery.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRedeliverWebhookDeliveryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.post(
    "reposRedeliverWebhookDelivery",
    "/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id/attempts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRedeliverWebhookDeliveryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposRedeliverWebhookDelivery(
          input,
          reposRedeliverWebhookDelivery.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRedeliverWebhookDelivery.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposPingWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  router.post(
    "reposPingWebhook",
    "/repos/:owner/:repo/hooks/:hook_id/pings",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposPingWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposPingWebhook(input, reposPingWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposPingWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposTestPushWebhookParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    hook_id: z.coerce.number(),
  })

  router.post(
    "reposTestPushWebhook",
    "/repos/:owner/:repo/hooks/:hook_id/tests",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposTestPushWebhookParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposTestPushWebhook(input, reposTestPushWebhook.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposTestPushWebhook.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsGetImportStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "migrationsGetImportStatus",
    "/repos/:owner/:repo/import",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsGetImportStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsGetImportStatus(
          input,
          migrationsGetImportStatus.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsGetImportStatus.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsStartImportParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsStartImportBodySchema = z.object({
    vcs_url: z.string(),
    vcs: z.enum(["subversion", "git", "mercurial", "tfvc"]).optional(),
    vcs_username: z.string().optional(),
    vcs_password: z.string().optional(),
    tfvc_project: z.string().optional(),
  })

  router.put(
    "migrationsStartImport",
    "/repos/:owner/:repo/import",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsStartImportParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          migrationsStartImportBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .migrationsStartImport(input, migrationsStartImport.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsStartImport.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsUpdateImportParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsUpdateImportBodySchema = z
    .object({
      vcs_username: z.string().optional(),
      vcs_password: z.string().optional(),
      vcs: z.enum(["subversion", "tfvc", "git", "mercurial"]).optional(),
      tfvc_project: z.string().optional(),
    })
    .nullable()
    .optional()

  router.patch(
    "migrationsUpdateImport",
    "/repos/:owner/:repo/import",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsUpdateImportParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          migrationsUpdateImportBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .migrationsUpdateImport(input, migrationsUpdateImport.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsUpdateImport.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsCancelImportParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "migrationsCancelImport",
    "/repos/:owner/:repo/import",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsCancelImportParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsCancelImport(input, migrationsCancelImport.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsCancelImport.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsGetCommitAuthorsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsGetCommitAuthorsQuerySchema = z.object({
    since: z.coerce.number().optional(),
  })

  router.get(
    "migrationsGetCommitAuthors",
    "/repos/:owner/:repo/import/authors",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsGetCommitAuthorsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          migrationsGetCommitAuthorsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsGetCommitAuthors(
          input,
          migrationsGetCommitAuthors.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsGetCommitAuthors.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsMapCommitAuthorParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    author_id: z.coerce.number(),
  })

  const migrationsMapCommitAuthorBodySchema = z
    .object({ email: z.string().optional(), name: z.string().optional() })
    .optional()

  router.patch(
    "migrationsMapCommitAuthor",
    "/repos/:owner/:repo/import/authors/:author_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsMapCommitAuthorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          migrationsMapCommitAuthorBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .migrationsMapCommitAuthor(
          input,
          migrationsMapCommitAuthor.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsMapCommitAuthor.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsGetLargeFilesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "migrationsGetLargeFiles",
    "/repos/:owner/:repo/import/large_files",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsGetLargeFilesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsGetLargeFiles(input, migrationsGetLargeFiles.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsGetLargeFiles.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsSetLfsPreferenceParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const migrationsSetLfsPreferenceBodySchema = z.object({
    use_lfs: z.enum(["opt_in", "opt_out"]),
  })

  router.patch(
    "migrationsSetLfsPreference",
    "/repos/:owner/:repo/import/lfs",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsSetLfsPreferenceParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          migrationsSetLfsPreferenceBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .migrationsSetLfsPreference(
          input,
          migrationsSetLfsPreference.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsSetLfsPreference.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsGetRepoInstallationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "appsGetRepoInstallation",
    "/repos/:owner/:repo/installation",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsGetRepoInstallationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetRepoInstallation(input, appsGetRepoInstallation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetRepoInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const interactionsGetRestrictionsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "interactionsGetRestrictionsForRepo",
    "/repos/:owner/:repo/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          interactionsGetRestrictionsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .interactionsGetRestrictionsForRepo(
          input,
          interactionsGetRestrictionsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsGetRestrictionsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const interactionsSetRestrictionsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const interactionsSetRestrictionsForRepoBodySchema = s_interaction_limit

  router.put(
    "interactionsSetRestrictionsForRepo",
    "/repos/:owner/:repo/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          interactionsSetRestrictionsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          interactionsSetRestrictionsForRepoBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .interactionsSetRestrictionsForRepo(
          input,
          interactionsSetRestrictionsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsSetRestrictionsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const interactionsRemoveRestrictionsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "interactionsRemoveRestrictionsForRepo",
    "/repos/:owner/:repo/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          interactionsRemoveRestrictionsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .interactionsRemoveRestrictionsForRepo(
          input,
          interactionsRemoveRestrictionsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsRemoveRestrictionsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListInvitationsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListInvitations",
    "/repos/:owner/:repo/invitations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListInvitationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListInvitationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListInvitations(input, reposListInvitations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListInvitations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateInvitationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    invitation_id: z.coerce.number(),
  })

  const reposUpdateInvitationBodySchema = z
    .object({
      permissions: z
        .enum(["read", "write", "maintain", "triage", "admin"])
        .optional(),
    })
    .optional()

  router.patch(
    "reposUpdateInvitation",
    "/repos/:owner/:repo/invitations/:invitation_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateInvitationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateInvitationBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateInvitation(input, reposUpdateInvitation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateInvitation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteInvitationParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    invitation_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteInvitation",
    "/repos/:owner/:repo/invitations/:invitation_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteInvitationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteInvitation(input, reposDeleteInvitation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteInvitation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListForRepoQuerySchema = z.object({
    milestone: z.string().optional(),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    assignee: z.string().optional(),
    type: z.string().optional(),
    creator: z.string().optional(),
    mentioned: z.string().optional(),
    labels: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListForRepo",
    "/repos/:owner/:repo/issues",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListForRepo(input, issuesListForRepo.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesCreateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesCreateBodySchema = z.object({
    title: z.union([z.string(), z.coerce.number()]),
    body: z.string().optional(),
    assignee: z.string().nullable().optional(),
    milestone: z.union([z.string(), z.coerce.number()]).nullable().optional(),
    labels: z
      .array(
        z.union([
          z.string(),
          z.object({
            id: z.coerce.number().optional(),
            name: z.string().optional(),
            description: z.string().nullable().optional(),
            color: z.string().nullable().optional(),
          }),
        ]),
      )
      .optional(),
    assignees: z.array(z.string()).optional(),
    type: z.string().nullable().optional(),
  })

  router.post(
    "issuesCreate",
    "/repos/:owner/:repo/issues",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesCreateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesCreateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesCreate(input, issuesCreate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesCreate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListCommentsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListCommentsForRepoQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListCommentsForRepo",
    "/repos/:owner/:repo/issues/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListCommentsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListCommentsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListCommentsForRepo(
          input,
          issuesListCommentsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListCommentsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesGetCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "issuesGetComment",
    "/repos/:owner/:repo/issues/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesGetCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesGetComment(input, issuesGetComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesGetComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesUpdateCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const issuesUpdateCommentBodySchema = z.object({ body: z.string() })

  router.patch(
    "issuesUpdateComment",
    "/repos/:owner/:repo/issues/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesUpdateCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesUpdateCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesUpdateComment(input, issuesUpdateComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesUpdateComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesDeleteCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "issuesDeleteComment",
    "/repos/:owner/:repo/issues/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesDeleteCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesDeleteComment(input, issuesDeleteComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesDeleteComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForIssueCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForIssueCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForIssueComment",
    "/repos/:owner/:repo/issues/comments/:comment_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForIssueCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForIssueCommentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForIssueComment(
          input,
          reactionsListForIssueComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForIssueComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForIssueCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForIssueCommentBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForIssueComment",
    "/repos/:owner/:repo/issues/comments/:comment_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForIssueCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForIssueCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForIssueComment(
          input,
          reactionsCreateForIssueComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForIssueComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsDeleteForIssueCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForIssueComment",
    "/repos/:owner/:repo/issues/comments/:comment_id/reactions/:reaction_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsDeleteForIssueCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsDeleteForIssueComment(
          input,
          reactionsDeleteForIssueComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsDeleteForIssueComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListEventsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListEventsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListEventsForRepo",
    "/repos/:owner/:repo/issues/events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListEventsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListEventsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListEventsForRepo(input, issuesListEventsForRepo.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListEventsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesGetEventParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    event_id: z.coerce.number(),
  })

  router.get(
    "issuesGetEvent",
    "/repos/:owner/:repo/issues/events/:event_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesGetEventParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesGetEvent(input, issuesGetEvent.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesGetEvent.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesGetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  router.get(
    "issuesGet",
    "/repos/:owner/:repo/issues/:issue_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesGetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesGet(input, issuesGet.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesGet.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesUpdateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesUpdateBodySchema = z
    .object({
      title: z.union([z.string(), z.coerce.number()]).nullable().optional(),
      body: z.string().nullable().optional(),
      assignee: z.string().nullable().optional(),
      state: z.enum(["open", "closed"]).optional(),
      state_reason: z
        .enum(["completed", "not_planned", "reopened"])
        .nullable()
        .optional(),
      milestone: z.union([z.string(), z.coerce.number()]).nullable().optional(),
      labels: z
        .array(
          z.union([
            z.string(),
            z.object({
              id: z.coerce.number().optional(),
              name: z.string().optional(),
              description: z.string().nullable().optional(),
              color: z.string().nullable().optional(),
            }),
          ]),
        )
        .optional(),
      assignees: z.array(z.string()).optional(),
      type: z.string().nullable().optional(),
    })
    .optional()

  router.patch(
    "issuesUpdate",
    "/repos/:owner/:repo/issues/:issue_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesUpdateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesUpdateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesUpdate(input, issuesUpdate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesUpdate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesAddAssigneesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddAssigneesBodySchema = z
    .object({ assignees: z.array(z.string()).optional() })
    .optional()

  router.post(
    "issuesAddAssignees",
    "/repos/:owner/:repo/issues/:issue_number/assignees",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesAddAssigneesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesAddAssigneesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesAddAssignees(input, issuesAddAssignees.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesAddAssignees.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesRemoveAssigneesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesRemoveAssigneesBodySchema = z.object({
    assignees: z.array(z.string()).optional(),
  })

  router.delete(
    "issuesRemoveAssignees",
    "/repos/:owner/:repo/issues/:issue_number/assignees",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesRemoveAssigneesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesRemoveAssigneesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesRemoveAssignees(input, issuesRemoveAssignees.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesRemoveAssignees.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesCheckUserCanBeAssignedToIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
    assignee: z.string(),
  })

  router.get(
    "issuesCheckUserCanBeAssignedToIssue",
    "/repos/:owner/:repo/issues/:issue_number/assignees/:assignee",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesCheckUserCanBeAssignedToIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesCheckUserCanBeAssignedToIssue(
          input,
          issuesCheckUserCanBeAssignedToIssue.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesCheckUserCanBeAssignedToIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListCommentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListCommentsQuerySchema = z.object({
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListComments",
    "/repos/:owner/:repo/issues/:issue_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListCommentsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListCommentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListComments(input, issuesListComments.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListComments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesCreateCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesCreateCommentBodySchema = z.object({ body: z.string() })

  router.post(
    "issuesCreateComment",
    "/repos/:owner/:repo/issues/:issue_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesCreateCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesCreateCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesCreateComment(input, issuesCreateComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesCreateComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListEventsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListEvents",
    "/repos/:owner/:repo/issues/:issue_number/events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListEventsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListEventsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListEvents(input, issuesListEvents.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListEvents.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListLabelsOnIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListLabelsOnIssueQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListLabelsOnIssue",
    "/repos/:owner/:repo/issues/:issue_number/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListLabelsOnIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListLabelsOnIssueQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListLabelsOnIssue(input, issuesListLabelsOnIssue.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListLabelsOnIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesAddLabelsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddLabelsBodySchema = z
    .union([
      z.object({ labels: z.array(z.string()).min(1).optional() }),
      z.array(z.string()).min(1),
      z.object({
        labels: z
          .array(z.object({ name: z.string() }))
          .min(1)
          .optional(),
      }),
      z.array(z.object({ name: z.string() })).min(1),
      z.string(),
    ])
    .optional()

  router.post(
    "issuesAddLabels",
    "/repos/:owner/:repo/issues/:issue_number/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesAddLabelsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesAddLabelsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesAddLabels(input, issuesAddLabels.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesAddLabels.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesSetLabelsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesSetLabelsBodySchema = z
    .union([
      z.object({ labels: z.array(z.string()).min(1).optional() }),
      z.array(z.string()).min(1),
      z.object({
        labels: z
          .array(z.object({ name: z.string() }))
          .min(1)
          .optional(),
      }),
      z.array(z.object({ name: z.string() })).min(1),
      z.string(),
    ])
    .optional()

  router.put(
    "issuesSetLabels",
    "/repos/:owner/:repo/issues/:issue_number/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesSetLabelsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesSetLabelsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesSetLabels(input, issuesSetLabels.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesSetLabels.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesRemoveAllLabelsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  router.delete(
    "issuesRemoveAllLabels",
    "/repos/:owner/:repo/issues/:issue_number/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesRemoveAllLabelsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesRemoveAllLabels(input, issuesRemoveAllLabels.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesRemoveAllLabels.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesRemoveLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
    name: z.string(),
  })

  router.delete(
    "issuesRemoveLabel",
    "/repos/:owner/:repo/issues/:issue_number/labels/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesRemoveLabelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesRemoveLabel(input, issuesRemoveLabel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesRemoveLabel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesLockParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesLockBodySchema = z
    .object({
      lock_reason: z
        .enum(["off-topic", "too heated", "resolved", "spam"])
        .optional(),
    })
    .nullable()
    .optional()

  router.put(
    "issuesLock",
    "/repos/:owner/:repo/issues/:issue_number/lock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesLockParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesLockBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesLock(input, issuesLock.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesLock.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesUnlockParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  router.delete(
    "issuesUnlock",
    "/repos/:owner/:repo/issues/:issue_number/lock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesUnlockParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesUnlock(input, issuesUnlock.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesUnlock.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const reactionsListForIssueQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForIssue",
    "/repos/:owner/:repo/issues/:issue_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForIssueQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForIssue(input, reactionsListForIssue.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const reactionsCreateForIssueBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForIssue",
    "/repos/:owner/:repo/issues/:issue_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForIssueBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForIssue(input, reactionsCreateForIssue.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsDeleteForIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForIssue",
    "/repos/:owner/:repo/issues/:issue_number/reactions/:reaction_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsDeleteForIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsDeleteForIssue(input, reactionsDeleteForIssue.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsDeleteForIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesRemoveSubIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesRemoveSubIssueBodySchema = z.object({
    sub_issue_id: z.coerce.number(),
  })

  router.delete(
    "issuesRemoveSubIssue",
    "/repos/:owner/:repo/issues/:issue_number/sub_issue",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesRemoveSubIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesRemoveSubIssueBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesRemoveSubIssue(input, issuesRemoveSubIssue.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesRemoveSubIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListSubIssuesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListSubIssuesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListSubIssues",
    "/repos/:owner/:repo/issues/:issue_number/sub_issues",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListSubIssuesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListSubIssuesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListSubIssues(input, issuesListSubIssues.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListSubIssues.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesAddSubIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddSubIssueBodySchema = z.object({
    sub_issue_id: z.coerce.number(),
    replace_parent: PermissiveBoolean.optional(),
  })

  router.post(
    "issuesAddSubIssue",
    "/repos/:owner/:repo/issues/:issue_number/sub_issues",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesAddSubIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesAddSubIssueBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesAddSubIssue(input, issuesAddSubIssue.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesAddSubIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesReprioritizeSubIssueParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesReprioritizeSubIssueBodySchema = z.object({
    sub_issue_id: z.coerce.number(),
    after_id: z.coerce.number().optional(),
    before_id: z.coerce.number().optional(),
  })

  router.patch(
    "issuesReprioritizeSubIssue",
    "/repos/:owner/:repo/issues/:issue_number/sub_issues/priority",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesReprioritizeSubIssueParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesReprioritizeSubIssueBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesReprioritizeSubIssue(
          input,
          issuesReprioritizeSubIssue.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesReprioritizeSubIssue.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListEventsForTimelineParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListEventsForTimelineQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListEventsForTimeline",
    "/repos/:owner/:repo/issues/:issue_number/timeline",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListEventsForTimelineParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListEventsForTimelineQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListEventsForTimeline(
          input,
          issuesListEventsForTimeline.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListEventsForTimeline.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListDeployKeysParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListDeployKeysQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListDeployKeys",
    "/repos/:owner/:repo/keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListDeployKeysParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListDeployKeysQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListDeployKeys(input, reposListDeployKeys.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListDeployKeys.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateDeployKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateDeployKeyBodySchema = z.object({
    title: z.string().optional(),
    key: z.string(),
    read_only: PermissiveBoolean.optional(),
  })

  router.post(
    "reposCreateDeployKey",
    "/repos/:owner/:repo/keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateDeployKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateDeployKeyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateDeployKey(input, reposCreateDeployKey.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateDeployKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetDeployKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    key_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeployKey",
    "/repos/:owner/:repo/keys/:key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetDeployKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetDeployKey(input, reposGetDeployKey.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetDeployKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteDeployKeyParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    key_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteDeployKey",
    "/repos/:owner/:repo/keys/:key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteDeployKeyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteDeployKey(input, reposDeleteDeployKey.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteDeployKey.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListLabelsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListLabelsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListLabelsForRepo",
    "/repos/:owner/:repo/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListLabelsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListLabelsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListLabelsForRepo(input, issuesListLabelsForRepo.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListLabelsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesCreateLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesCreateLabelBodySchema = z.object({
    name: z.string(),
    color: z.string().optional(),
    description: z.string().optional(),
  })

  router.post(
    "issuesCreateLabel",
    "/repos/:owner/:repo/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesCreateLabelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesCreateLabelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesCreateLabel(input, issuesCreateLabel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesCreateLabel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesGetLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  router.get(
    "issuesGetLabel",
    "/repos/:owner/:repo/labels/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesGetLabelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesGetLabel(input, issuesGetLabel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesGetLabel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesUpdateLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  const issuesUpdateLabelBodySchema = z
    .object({
      new_name: z.string().optional(),
      color: z.string().optional(),
      description: z.string().optional(),
    })
    .optional()

  router.patch(
    "issuesUpdateLabel",
    "/repos/:owner/:repo/labels/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesUpdateLabelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesUpdateLabelBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesUpdateLabel(input, issuesUpdateLabel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesUpdateLabel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesDeleteLabelParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    name: z.string(),
  })

  router.delete(
    "issuesDeleteLabel",
    "/repos/:owner/:repo/labels/:name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesDeleteLabelParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesDeleteLabel(input, issuesDeleteLabel.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesDeleteLabel.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListLanguagesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposListLanguages",
    "/repos/:owner/:repo/languages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListLanguagesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListLanguages(input, reposListLanguages.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListLanguages.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const licensesGetForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const licensesGetForRepoQuerySchema = z.object({
    ref: s_code_scanning_ref.optional(),
  })

  router.get(
    "licensesGetForRepo",
    "/repos/:owner/:repo/license",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          licensesGetForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          licensesGetForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .licensesGetForRepo(input, licensesGetForRepo.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = licensesGetForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposMergeUpstreamParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposMergeUpstreamBodySchema = z.object({ branch: z.string() })

  router.post(
    "reposMergeUpstream",
    "/repos/:owner/:repo/merge-upstream",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposMergeUpstreamParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposMergeUpstreamBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposMergeUpstream(input, reposMergeUpstream.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposMergeUpstream.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposMergeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposMergeBodySchema = z.object({
    base: z.string(),
    head: z.string(),
    commit_message: z.string().optional(),
  })

  router.post("reposMerge", "/repos/:owner/:repo/merges", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        reposMergeParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        reposMergeBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .reposMerge(input, reposMerge.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposMerge.validator(status, body)
    ctx.status = status
    return next()
  })

  const issuesListMilestonesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesListMilestonesQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    sort: z.enum(["due_on", "completeness"]).optional().default("due_on"),
    direction: z.enum(["asc", "desc"]).optional().default("asc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListMilestones",
    "/repos/:owner/:repo/milestones",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListMilestonesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListMilestonesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListMilestones(input, issuesListMilestones.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListMilestones.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesCreateMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const issuesCreateMilestoneBodySchema = z.object({
    title: z.string(),
    state: z.enum(["open", "closed"]).optional().default("open"),
    description: z.string().optional(),
    due_on: z.string().datetime({ offset: true }).optional(),
  })

  router.post(
    "issuesCreateMilestone",
    "/repos/:owner/:repo/milestones",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesCreateMilestoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesCreateMilestoneBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesCreateMilestone(input, issuesCreateMilestone.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesCreateMilestone.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesGetMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  router.get(
    "issuesGetMilestone",
    "/repos/:owner/:repo/milestones/:milestone_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesGetMilestoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesGetMilestone(input, issuesGetMilestone.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesGetMilestone.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesUpdateMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesUpdateMilestoneBodySchema = z
    .object({
      title: z.string().optional(),
      state: z.enum(["open", "closed"]).optional().default("open"),
      description: z.string().optional(),
      due_on: z.string().datetime({ offset: true }).optional(),
    })
    .optional()

  router.patch(
    "issuesUpdateMilestone",
    "/repos/:owner/:repo/milestones/:milestone_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesUpdateMilestoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          issuesUpdateMilestoneBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .issuesUpdateMilestone(input, issuesUpdateMilestone.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesUpdateMilestone.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesDeleteMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  router.delete(
    "issuesDeleteMilestone",
    "/repos/:owner/:repo/milestones/:milestone_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesDeleteMilestoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesDeleteMilestone(input, issuesDeleteMilestone.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesDeleteMilestone.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const issuesListLabelsForMilestoneParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesListLabelsForMilestoneQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListLabelsForMilestone",
    "/repos/:owner/:repo/milestones/:milestone_number/labels",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          issuesListLabelsForMilestoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          issuesListLabelsForMilestoneQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListLabelsForMilestone(
          input,
          issuesListLabelsForMilestone.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListLabelsForMilestone.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListRepoNotificationsForAuthenticatedUserParamSchema = z.object(
    { owner: z.string(), repo: z.string() },
  )

  const activityListRepoNotificationsForAuthenticatedUserQuerySchema = z.object(
    {
      all: PermissiveBoolean.optional().default(false),
      participating: PermissiveBoolean.optional().default(false),
      since: z.string().datetime({ offset: true }).optional(),
      before: z.string().datetime({ offset: true }).optional(),
      per_page: z.coerce.number().optional().default(30),
      page: z.coerce.number().optional().default(1),
    },
  )

  router.get(
    "activityListRepoNotificationsForAuthenticatedUser",
    "/repos/:owner/:repo/notifications",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListRepoNotificationsForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListRepoNotificationsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListRepoNotificationsForAuthenticatedUser(
          input,
          activityListRepoNotificationsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListRepoNotificationsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const activityMarkRepoNotificationsAsReadParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityMarkRepoNotificationsAsReadBodySchema = z
    .object({ last_read_at: z.string().datetime({ offset: true }).optional() })
    .optional()

  router.put(
    "activityMarkRepoNotificationsAsRead",
    "/repos/:owner/:repo/notifications",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityMarkRepoNotificationsAsReadParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          activityMarkRepoNotificationsAsReadBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .activityMarkRepoNotificationsAsRead(
          input,
          activityMarkRepoNotificationsAsRead.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityMarkRepoNotificationsAsRead.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetPagesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetPages",
    "/repos/:owner/:repo/pages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetPagesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetPages(input, reposGetPages.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetPages.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreatePagesSiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreatePagesSiteBodySchema = z
    .object({
      build_type: z.enum(["legacy", "workflow"]).optional(),
      source: z
        .object({
          branch: z.string(),
          path: z.enum(["/", "/docs"]).optional().default("/"),
        })
        .optional(),
    })
    .nullable()

  router.post(
    "reposCreatePagesSite",
    "/repos/:owner/:repo/pages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreatePagesSiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreatePagesSiteBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreatePagesSite(input, reposCreatePagesSite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreatePagesSite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateInformationAboutPagesSiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposUpdateInformationAboutPagesSiteBodySchema = z.object({
    cname: z.string().nullable().optional(),
    https_enforced: PermissiveBoolean.optional(),
    build_type: z.enum(["legacy", "workflow"]).optional(),
    source: z
      .union([
        z.enum(["gh-pages", "master", "master /docs"]),
        z.object({ branch: z.string(), path: z.enum(["/", "/docs"]) }),
      ])
      .optional(),
  })

  router.put(
    "reposUpdateInformationAboutPagesSite",
    "/repos/:owner/:repo/pages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateInformationAboutPagesSiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateInformationAboutPagesSiteBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateInformationAboutPagesSite(
          input,
          reposUpdateInformationAboutPagesSite.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateInformationAboutPagesSite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeletePagesSiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "reposDeletePagesSite",
    "/repos/:owner/:repo/pages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeletePagesSiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeletePagesSite(input, reposDeletePagesSite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeletePagesSite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListPagesBuildsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListPagesBuildsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListPagesBuilds",
    "/repos/:owner/:repo/pages/builds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListPagesBuildsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListPagesBuildsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListPagesBuilds(input, reposListPagesBuilds.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListPagesBuilds.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposRequestPagesBuildParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.post(
    "reposRequestPagesBuild",
    "/repos/:owner/:repo/pages/builds",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposRequestPagesBuildParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposRequestPagesBuild(input, reposRequestPagesBuild.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposRequestPagesBuild.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetLatestPagesBuildParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetLatestPagesBuild",
    "/repos/:owner/:repo/pages/builds/latest",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetLatestPagesBuildParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetLatestPagesBuild(
          input,
          reposGetLatestPagesBuild.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetLatestPagesBuild.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetPagesBuildParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    build_id: z.coerce.number(),
  })

  router.get(
    "reposGetPagesBuild",
    "/repos/:owner/:repo/pages/builds/:build_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetPagesBuildParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetPagesBuild(input, reposGetPagesBuild.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetPagesBuild.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreatePagesDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreatePagesDeploymentBodySchema = z.object({
    artifact_id: z.coerce.number().optional(),
    artifact_url: z.string().optional(),
    environment: z.string().optional().default("github-pages"),
    pages_build_version: z.string().default("GITHUB_SHA"),
    oidc_token: z.string(),
  })

  router.post(
    "reposCreatePagesDeployment",
    "/repos/:owner/:repo/pages/deployments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreatePagesDeploymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreatePagesDeploymentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreatePagesDeployment(
          input,
          reposCreatePagesDeployment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreatePagesDeployment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetPagesDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pages_deployment_id: z.union([z.coerce.number(), z.string()]),
  })

  router.get(
    "reposGetPagesDeployment",
    "/repos/:owner/:repo/pages/deployments/:pages_deployment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetPagesDeploymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetPagesDeployment(input, reposGetPagesDeployment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetPagesDeployment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCancelPagesDeploymentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pages_deployment_id: z.union([z.coerce.number(), z.string()]),
  })

  router.post(
    "reposCancelPagesDeployment",
    "/repos/:owner/:repo/pages/deployments/:pages_deployment_id/cancel",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCancelPagesDeploymentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCancelPagesDeployment(
          input,
          reposCancelPagesDeployment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCancelPagesDeployment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetPagesHealthCheckParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetPagesHealthCheck",
    "/repos/:owner/:repo/pages/health",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetPagesHealthCheckParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetPagesHealthCheck(
          input,
          reposGetPagesHealthCheck.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetPagesHealthCheck.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCheckPrivateVulnerabilityReportingParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposCheckPrivateVulnerabilityReporting",
    "/repos/:owner/:repo/private-vulnerability-reporting",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCheckPrivateVulnerabilityReportingParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCheckPrivateVulnerabilityReporting(
          input,
          reposCheckPrivateVulnerabilityReporting.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCheckPrivateVulnerabilityReporting.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposEnablePrivateVulnerabilityReportingParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.put(
    "reposEnablePrivateVulnerabilityReporting",
    "/repos/:owner/:repo/private-vulnerability-reporting",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposEnablePrivateVulnerabilityReportingParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposEnablePrivateVulnerabilityReporting(
          input,
          reposEnablePrivateVulnerabilityReporting.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposEnablePrivateVulnerabilityReporting.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposDisablePrivateVulnerabilityReportingParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "reposDisablePrivateVulnerabilityReporting",
    "/repos/:owner/:repo/private-vulnerability-reporting",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDisablePrivateVulnerabilityReportingParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDisablePrivateVulnerabilityReporting(
          input,
          reposDisablePrivateVulnerabilityReporting.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDisablePrivateVulnerabilityReporting.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const projectsListForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const projectsListForRepoQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "projectsListForRepo",
    "/repos/:owner/:repo/projects",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsListForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          projectsListForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsListForRepo(input, projectsListForRepo.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsListForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsCreateForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const projectsCreateForRepoBodySchema = z.object({
    name: z.string(),
    body: z.string().optional(),
  })

  router.post(
    "projectsCreateForRepo",
    "/repos/:owner/:repo/projects",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsCreateForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          projectsCreateForRepoBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsCreateForRepo(input, projectsCreateForRepo.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsCreateForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCustomPropertiesValuesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetCustomPropertiesValues",
    "/repos/:owner/:repo/properties/values",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCustomPropertiesValuesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCustomPropertiesValues(
          input,
          reposGetCustomPropertiesValues.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCustomPropertiesValues.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateOrUpdateCustomPropertiesValuesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateOrUpdateCustomPropertiesValuesBodySchema = z.object({
    properties: z.array(s_custom_property_value),
  })

  router.patch(
    "reposCreateOrUpdateCustomPropertiesValues",
    "/repos/:owner/:repo/properties/values",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateOrUpdateCustomPropertiesValuesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateOrUpdateCustomPropertiesValuesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateOrUpdateCustomPropertiesValues(
          input,
          reposCreateOrUpdateCustomPropertiesValues.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateOrUpdateCustomPropertiesValues.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const pullsListParamSchema = z.object({ owner: z.string(), repo: z.string() })

  const pullsListQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    head: z.string().optional(),
    base: z.string().optional(),
    sort: z
      .enum(["created", "updated", "popularity", "long-running"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("pullsList", "/repos/:owner/:repo/pulls", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        pullsListParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        pullsListQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .pullsList(input, pullsList.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = pullsList.validator(status, body)
    ctx.status = status
    return next()
  })

  const pullsCreateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const pullsCreateBodySchema = z.object({
    title: z.string().optional(),
    head: z.string(),
    head_repo: z.string().optional(),
    base: z.string(),
    body: z.string().optional(),
    maintainer_can_modify: PermissiveBoolean.optional(),
    draft: PermissiveBoolean.optional(),
    issue: z.coerce.number().optional(),
  })

  router.post("pullsCreate", "/repos/:owner/:repo/pulls", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        pullsCreateParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        pullsCreateBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .pullsCreate(input, pullsCreate.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = pullsCreate.validator(status, body)
    ctx.status = status
    return next()
  })

  const pullsListReviewCommentsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const pullsListReviewCommentsForRepoQuerySchema = z.object({
    sort: z.enum(["created", "updated", "created_at"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "pullsListReviewCommentsForRepo",
    "/repos/:owner/:repo/pulls/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsListReviewCommentsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          pullsListReviewCommentsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsListReviewCommentsForRepo(
          input,
          pullsListReviewCommentsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsListReviewCommentsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsGetReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "pullsGetReviewComment",
    "/repos/:owner/:repo/pulls/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsGetReviewCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsGetReviewComment(input, pullsGetReviewComment.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsGetReviewComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsUpdateReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const pullsUpdateReviewCommentBodySchema = z.object({ body: z.string() })

  router.patch(
    "pullsUpdateReviewComment",
    "/repos/:owner/:repo/pulls/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsUpdateReviewCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsUpdateReviewCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsUpdateReviewComment(
          input,
          pullsUpdateReviewComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsUpdateReviewComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsDeleteReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "pullsDeleteReviewComment",
    "/repos/:owner/:repo/pulls/comments/:comment_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsDeleteReviewCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsDeleteReviewComment(
          input,
          pullsDeleteReviewComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsDeleteReviewComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForPullRequestReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForPullRequestReviewCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForPullRequestReviewComment",
    "/repos/:owner/:repo/pulls/comments/:comment_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForPullRequestReviewCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForPullRequestReviewCommentQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForPullRequestReviewComment(
          input,
          reactionsListForPullRequestReviewComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForPullRequestReviewComment.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForPullRequestReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForPullRequestReviewCommentBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForPullRequestReviewComment",
    "/repos/:owner/:repo/pulls/comments/:comment_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForPullRequestReviewCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForPullRequestReviewCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForPullRequestReviewComment(
          input,
          reactionsCreateForPullRequestReviewComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForPullRequestReviewComment.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reactionsDeleteForPullRequestCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForPullRequestComment",
    "/repos/:owner/:repo/pulls/comments/:comment_id/reactions/:reaction_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsDeleteForPullRequestCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsDeleteForPullRequestComment(
          input,
          reactionsDeleteForPullRequestComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsDeleteForPullRequestComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsGetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  router.get(
    "pullsGet",
    "/repos/:owner/:repo/pulls/:pull_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsGetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsGet(input, pullsGet.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsGet.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsUpdateParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsUpdateBodySchema = z
    .object({
      title: z.string().optional(),
      body: z.string().optional(),
      state: z.enum(["open", "closed"]).optional(),
      base: z.string().optional(),
      maintainer_can_modify: PermissiveBoolean.optional(),
    })
    .optional()

  router.patch(
    "pullsUpdate",
    "/repos/:owner/:repo/pulls/:pull_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsUpdateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsUpdateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsUpdate(input, pullsUpdate.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsUpdate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesCreateWithPrForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const codespacesCreateWithPrForAuthenticatedUserBodySchema = z
    .object({
      location: z.string().optional(),
      geo: z
        .enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"])
        .optional(),
      client_ip: z.string().optional(),
      machine: z.string().optional(),
      devcontainer_path: z.string().optional(),
      multi_repo_permissions_opt_out: PermissiveBoolean.optional(),
      working_directory: z.string().optional(),
      idle_timeout_minutes: z.coerce.number().optional(),
      display_name: z.string().optional(),
      retention_period_minutes: z.coerce.number().optional(),
    })
    .nullable()

  router.post(
    "codespacesCreateWithPrForAuthenticatedUser",
    "/repos/:owner/:repo/pulls/:pull_number/codespaces",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesCreateWithPrForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesCreateWithPrForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesCreateWithPrForAuthenticatedUser(
          input,
          codespacesCreateWithPrForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCreateWithPrForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const pullsListReviewCommentsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListReviewCommentsQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "pullsListReviewComments",
    "/repos/:owner/:repo/pulls/:pull_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsListReviewCommentsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          pullsListReviewCommentsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsListReviewComments(input, pullsListReviewComments.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsListReviewComments.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsCreateReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsCreateReviewCommentBodySchema = z.object({
    body: z.string(),
    commit_id: z.string(),
    path: z.string(),
    position: z.coerce.number().optional(),
    side: z.enum(["LEFT", "RIGHT"]).optional(),
    line: z.coerce.number().optional(),
    start_line: z.coerce.number().optional(),
    start_side: z.enum(["LEFT", "RIGHT", "side"]).optional(),
    in_reply_to: z.coerce.number().optional(),
    subject_type: z.enum(["line", "file"]).optional(),
  })

  router.post(
    "pullsCreateReviewComment",
    "/repos/:owner/:repo/pulls/:pull_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsCreateReviewCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsCreateReviewCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsCreateReviewComment(
          input,
          pullsCreateReviewComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsCreateReviewComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsCreateReplyForReviewCommentParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    comment_id: z.coerce.number(),
  })

  const pullsCreateReplyForReviewCommentBodySchema = z.object({
    body: z.string(),
  })

  router.post(
    "pullsCreateReplyForReviewComment",
    "/repos/:owner/:repo/pulls/:pull_number/comments/:comment_id/replies",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsCreateReplyForReviewCommentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsCreateReplyForReviewCommentBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsCreateReplyForReviewComment(
          input,
          pullsCreateReplyForReviewComment.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsCreateReplyForReviewComment.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsListCommitsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListCommitsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "pullsListCommits",
    "/repos/:owner/:repo/pulls/:pull_number/commits",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsListCommitsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          pullsListCommitsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsListCommits(input, pullsListCommits.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsListCommits.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsListFilesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListFilesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "pullsListFiles",
    "/repos/:owner/:repo/pulls/:pull_number/files",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsListFilesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          pullsListFilesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsListFiles(input, pullsListFiles.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsListFiles.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsCheckIfMergedParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  router.get(
    "pullsCheckIfMerged",
    "/repos/:owner/:repo/pulls/:pull_number/merge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsCheckIfMergedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsCheckIfMerged(input, pullsCheckIfMerged.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsCheckIfMerged.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsMergeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsMergeBodySchema = z
    .object({
      commit_title: z.string().optional(),
      commit_message: z.string().optional(),
      sha: z.string().optional(),
      merge_method: z.enum(["merge", "squash", "rebase"]).optional(),
    })
    .nullable()
    .optional()

  router.put(
    "pullsMerge",
    "/repos/:owner/:repo/pulls/:pull_number/merge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsMergeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsMergeBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsMerge(input, pullsMerge.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsMerge.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsListRequestedReviewersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  router.get(
    "pullsListRequestedReviewers",
    "/repos/:owner/:repo/pulls/:pull_number/requested_reviewers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsListRequestedReviewersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsListRequestedReviewers(
          input,
          pullsListRequestedReviewers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsListRequestedReviewers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsRequestReviewersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsRequestReviewersBodySchema = z
    .object({
      reviewers: z.array(z.string()).optional(),
      team_reviewers: z.array(z.string()).optional(),
    })
    .optional()

  router.post(
    "pullsRequestReviewers",
    "/repos/:owner/:repo/pulls/:pull_number/requested_reviewers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsRequestReviewersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsRequestReviewersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsRequestReviewers(input, pullsRequestReviewers.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsRequestReviewers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsRemoveRequestedReviewersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsRemoveRequestedReviewersBodySchema = z.object({
    reviewers: z.array(z.string()),
    team_reviewers: z.array(z.string()).optional(),
  })

  router.delete(
    "pullsRemoveRequestedReviewers",
    "/repos/:owner/:repo/pulls/:pull_number/requested_reviewers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsRemoveRequestedReviewersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsRemoveRequestedReviewersBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsRemoveRequestedReviewers(
          input,
          pullsRemoveRequestedReviewers.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsRemoveRequestedReviewers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsListReviewsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListReviewsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "pullsListReviews",
    "/repos/:owner/:repo/pulls/:pull_number/reviews",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsListReviewsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          pullsListReviewsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsListReviews(input, pullsListReviews.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsListReviews.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsCreateReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsCreateReviewBodySchema = z
    .object({
      commit_id: z.string().optional(),
      body: z.string().optional(),
      event: z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]).optional(),
      comments: z
        .array(
          z.object({
            path: z.string(),
            position: z.coerce.number().optional(),
            body: z.string(),
            line: z.coerce.number().optional(),
            side: z.string().optional(),
            start_line: z.coerce.number().optional(),
            start_side: z.string().optional(),
          }),
        )
        .optional(),
    })
    .optional()

  router.post(
    "pullsCreateReview",
    "/repos/:owner/:repo/pulls/:pull_number/reviews",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsCreateReviewParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsCreateReviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsCreateReview(input, pullsCreateReview.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsCreateReview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsGetReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  router.get(
    "pullsGetReview",
    "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsGetReviewParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsGetReview(input, pullsGetReview.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsGetReview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsUpdateReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsUpdateReviewBodySchema = z.object({ body: z.string() })

  router.put(
    "pullsUpdateReview",
    "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsUpdateReviewParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsUpdateReviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsUpdateReview(input, pullsUpdateReview.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsUpdateReview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsDeletePendingReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  router.delete(
    "pullsDeletePendingReview",
    "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsDeletePendingReviewParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsDeletePendingReview(
          input,
          pullsDeletePendingReview.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsDeletePendingReview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsListCommentsForReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsListCommentsForReviewQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "pullsListCommentsForReview",
    "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsListCommentsForReviewParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          pullsListCommentsForReviewQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .pullsListCommentsForReview(
          input,
          pullsListCommentsForReview.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsListCommentsForReview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsDismissReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsDismissReviewBodySchema = z.object({
    message: z.string(),
    event: z.enum(["DISMISS"]).optional(),
  })

  router.put(
    "pullsDismissReview",
    "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/dismissals",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsDismissReviewParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsDismissReviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsDismissReview(input, pullsDismissReview.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsDismissReview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsSubmitReviewParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsSubmitReviewBodySchema = z.object({
    body: z.string().optional(),
    event: z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]),
  })

  router.post(
    "pullsSubmitReview",
    "/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsSubmitReviewParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsSubmitReviewBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsSubmitReview(input, pullsSubmitReview.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsSubmitReview.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pullsUpdateBranchParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    pull_number: z.coerce.number(),
  })

  const pullsUpdateBranchBodySchema = z
    .object({ expected_head_sha: z.string().optional() })
    .nullable()
    .optional()

  router.put(
    "pullsUpdateBranch",
    "/repos/:owner/:repo/pulls/:pull_number/update-branch",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pullsUpdateBranchParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          pullsUpdateBranchBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .pullsUpdateBranch(input, pullsUpdateBranch.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pullsUpdateBranch.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetReadmeParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetReadmeQuerySchema = z.object({ ref: z.string().optional() })

  router.get(
    "reposGetReadme",
    "/repos/:owner/:repo/readme",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetReadmeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetReadmeQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetReadme(input, reposGetReadme.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetReadme.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetReadmeInDirectoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    dir: z.string(),
  })

  const reposGetReadmeInDirectoryQuerySchema = z.object({
    ref: z.string().optional(),
  })

  router.get(
    "reposGetReadmeInDirectory",
    "/repos/:owner/:repo/readme/:dir",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetReadmeInDirectoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetReadmeInDirectoryQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetReadmeInDirectory(
          input,
          reposGetReadmeInDirectory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetReadmeInDirectory.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListReleasesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListReleasesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListReleases",
    "/repos/:owner/:repo/releases",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListReleasesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListReleasesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListReleases(input, reposListReleases.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListReleases.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateReleaseBodySchema = z.object({
    tag_name: z.string(),
    target_commitish: z.string().optional(),
    name: z.string().optional(),
    body: z.string().optional(),
    draft: PermissiveBoolean.optional().default(false),
    prerelease: PermissiveBoolean.optional().default(false),
    discussion_category_name: z.string().optional(),
    generate_release_notes: PermissiveBoolean.optional().default(false),
    make_latest: z.enum(["true", "false", "legacy"]).optional().default("true"),
  })

  router.post(
    "reposCreateRelease",
    "/repos/:owner/:repo/releases",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateReleaseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateRelease(input, reposCreateRelease.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    asset_id: z.coerce.number(),
  })

  router.get(
    "reposGetReleaseAsset",
    "/repos/:owner/:repo/releases/assets/:asset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetReleaseAssetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetReleaseAsset(input, reposGetReleaseAsset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetReleaseAsset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    asset_id: z.coerce.number(),
  })

  const reposUpdateReleaseAssetBodySchema = z
    .object({
      name: z.string().optional(),
      label: z.string().optional(),
      state: z.string().optional(),
    })
    .optional()

  router.patch(
    "reposUpdateReleaseAsset",
    "/repos/:owner/:repo/releases/assets/:asset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateReleaseAssetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateReleaseAssetBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateReleaseAsset(input, reposUpdateReleaseAsset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateReleaseAsset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    asset_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteReleaseAsset",
    "/repos/:owner/:repo/releases/assets/:asset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteReleaseAssetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteReleaseAsset(input, reposDeleteReleaseAsset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteReleaseAsset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGenerateReleaseNotesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGenerateReleaseNotesBodySchema = z.object({
    tag_name: z.string(),
    target_commitish: z.string().optional(),
    previous_tag_name: z.string().optional(),
    configuration_file_path: z.string().optional(),
  })

  router.post(
    "reposGenerateReleaseNotes",
    "/repos/:owner/:repo/releases/generate-notes",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGenerateReleaseNotesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposGenerateReleaseNotesBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposGenerateReleaseNotes(
          input,
          reposGenerateReleaseNotes.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGenerateReleaseNotes.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetLatestReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetLatestRelease",
    "/repos/:owner/:repo/releases/latest",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetLatestReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetLatestRelease(input, reposGetLatestRelease.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetLatestRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetReleaseByTagParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tag: z.string(),
  })

  router.get(
    "reposGetReleaseByTag",
    "/repos/:owner/:repo/releases/tags/:tag",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetReleaseByTagParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetReleaseByTag(input, reposGetReleaseByTag.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetReleaseByTag.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  router.get(
    "reposGetRelease",
    "/repos/:owner/:repo/releases/:release_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetRelease(input, reposGetRelease.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposUpdateReleaseBodySchema = z
    .object({
      tag_name: z.string().optional(),
      target_commitish: z.string().optional(),
      name: z.string().optional(),
      body: z.string().optional(),
      draft: PermissiveBoolean.optional(),
      prerelease: PermissiveBoolean.optional(),
      make_latest: z
        .enum(["true", "false", "legacy"])
        .optional()
        .default("true"),
      discussion_category_name: z.string().optional(),
    })
    .optional()

  router.patch(
    "reposUpdateRelease",
    "/repos/:owner/:repo/releases/:release_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateReleaseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateRelease(input, reposUpdateRelease.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteRelease",
    "/repos/:owner/:repo/releases/:release_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteRelease(input, reposDeleteRelease.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListReleaseAssetsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposListReleaseAssetsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListReleaseAssets",
    "/repos/:owner/:repo/releases/:release_id/assets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListReleaseAssetsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListReleaseAssetsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListReleaseAssets(input, reposListReleaseAssets.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListReleaseAssets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUploadReleaseAssetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reposUploadReleaseAssetQuerySchema = z.object({
    name: z.string(),
    label: z.string().optional(),
  })

  const reposUploadReleaseAssetBodySchema = z.string().optional()

  router.post(
    "reposUploadReleaseAsset",
    "/repos/:owner/:repo/releases/:release_id/assets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUploadReleaseAssetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposUploadReleaseAssetQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: parseRequestInput(
          reposUploadReleaseAssetBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUploadReleaseAsset(input, reposUploadReleaseAsset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUploadReleaseAsset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reactionsListForReleaseQuerySchema = z.object({
    content: z
      .enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForRelease",
    "/repos/:owner/:repo/releases/:release_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForReleaseQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForRelease(input, reactionsListForRelease.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
  })

  const reactionsCreateForReleaseBodySchema = z.object({
    content: z.enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"]),
  })

  router.post(
    "reactionsCreateForRelease",
    "/repos/:owner/:repo/releases/:release_id/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForReleaseBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForRelease(
          input,
          reactionsCreateForRelease.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsDeleteForReleaseParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    release_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForRelease",
    "/repos/:owner/:repo/releases/:release_id/reactions/:reaction_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsDeleteForReleaseParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsDeleteForRelease(
          input,
          reactionsDeleteForRelease.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsDeleteForRelease.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetBranchRulesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
  })

  const reposGetBranchRulesQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposGetBranchRules",
    "/repos/:owner/:repo/rules/branches/:branch",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetBranchRulesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetBranchRulesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetBranchRules(input, reposGetBranchRules.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetBranchRules.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetRepoRulesetsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetRepoRulesetsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    includes_parents: PermissiveBoolean.optional().default(true),
    targets: z.string().optional(),
  })

  router.get(
    "reposGetRepoRulesets",
    "/repos/:owner/:repo/rulesets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetRepoRulesetsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetRepoRulesetsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetRepoRulesets(input, reposGetRepoRulesets.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetRepoRulesets.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateRepoRulesetBodySchema = z.object({
    name: z.string(),
    target: z.enum(["branch", "tag", "push"]).optional().default("branch"),
    enforcement: s_repository_rule_enforcement,
    bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
    conditions: s_repository_ruleset_conditions.optional(),
    rules: z.array(s_repository_rule).optional(),
  })

  router.post(
    "reposCreateRepoRuleset",
    "/repos/:owner/:repo/rulesets",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateRepoRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateRepoRulesetBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateRepoRuleset(input, reposCreateRepoRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateRepoRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetRepoRuleSuitesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetRepoRuleSuitesQuerySchema = z.object({
    ref: z.string().optional(),
    time_period: z
      .enum(["hour", "day", "week", "month"])
      .optional()
      .default("day"),
    actor_name: z.string().optional(),
    rule_suite_result: z
      .enum(["pass", "fail", "bypass", "all"])
      .optional()
      .default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposGetRepoRuleSuites",
    "/repos/:owner/:repo/rulesets/rule-suites",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetRepoRuleSuitesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetRepoRuleSuitesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetRepoRuleSuites(input, reposGetRepoRuleSuites.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetRepoRuleSuites.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetRepoRuleSuiteParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    rule_suite_id: z.coerce.number(),
  })

  router.get(
    "reposGetRepoRuleSuite",
    "/repos/:owner/:repo/rulesets/rule-suites/:rule_suite_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetRepoRuleSuiteParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetRepoRuleSuite(input, reposGetRepoRuleSuite.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetRepoRuleSuite.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposGetRepoRulesetQuerySchema = z.object({
    includes_parents: PermissiveBoolean.optional().default(true),
  })

  router.get(
    "reposGetRepoRuleset",
    "/repos/:owner/:repo/rulesets/:ruleset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetRepoRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetRepoRulesetQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetRepoRuleset(input, reposGetRepoRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetRepoRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposUpdateRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposUpdateRepoRulesetBodySchema = z
    .object({
      name: z.string().optional(),
      target: z.enum(["branch", "tag", "push"]).optional(),
      enforcement: s_repository_rule_enforcement.optional(),
      bypass_actors: z.array(s_repository_ruleset_bypass_actor).optional(),
      conditions: s_repository_ruleset_conditions.optional(),
      rules: z.array(s_repository_rule).optional(),
    })
    .optional()

  router.put(
    "reposUpdateRepoRuleset",
    "/repos/:owner/:repo/rulesets/:ruleset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposUpdateRepoRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposUpdateRepoRulesetBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposUpdateRepoRuleset(input, reposUpdateRepoRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposUpdateRepoRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteRepoRulesetParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteRepoRuleset",
    "/repos/:owner/:repo/rulesets/:ruleset_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteRepoRulesetParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteRepoRuleset(input, reposDeleteRepoRuleset.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteRepoRuleset.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetRepoRulesetHistoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
  })

  const reposGetRepoRulesetHistoryQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposGetRepoRulesetHistory",
    "/repos/:owner/:repo/rulesets/:ruleset_id/history",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetRepoRulesetHistoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetRepoRulesetHistoryQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetRepoRulesetHistory(
          input,
          reposGetRepoRulesetHistory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetRepoRulesetHistory.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetRepoRulesetVersionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ruleset_id: z.coerce.number(),
    version_id: z.coerce.number(),
  })

  router.get(
    "reposGetRepoRulesetVersion",
    "/repos/:owner/:repo/rulesets/:ruleset_id/history/:version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetRepoRulesetVersionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetRepoRulesetVersion(
          input,
          reposGetRepoRulesetVersion.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetRepoRulesetVersion.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const secretScanningListAlertsForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const secretScanningListAlertsForRepoQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.string().optional(),
    resolution: z.string().optional(),
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    validity: z.string().optional(),
    is_publicly_leaked: PermissiveBoolean.optional().default(false),
    is_multi_repo: PermissiveBoolean.optional().default(false),
  })

  router.get(
    "secretScanningListAlertsForRepo",
    "/repos/:owner/:repo/secret-scanning/alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningListAlertsForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          secretScanningListAlertsForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .secretScanningListAlertsForRepo(
          input,
          secretScanningListAlertsForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningListAlertsForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const secretScanningGetAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  router.get(
    "secretScanningGetAlert",
    "/repos/:owner/:repo/secret-scanning/alerts/:alert_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningGetAlertParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .secretScanningGetAlert(input, secretScanningGetAlert.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningGetAlert.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const secretScanningUpdateAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const secretScanningUpdateAlertBodySchema = z.object({
    state: s_secret_scanning_alert_state,
    resolution: s_secret_scanning_alert_resolution.optional(),
    resolution_comment: s_secret_scanning_alert_resolution_comment.optional(),
  })

  router.patch(
    "secretScanningUpdateAlert",
    "/repos/:owner/:repo/secret-scanning/alerts/:alert_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningUpdateAlertParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          secretScanningUpdateAlertBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .secretScanningUpdateAlert(
          input,
          secretScanningUpdateAlert.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningUpdateAlert.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const secretScanningListLocationsForAlertParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    alert_number: s_alert_number,
  })

  const secretScanningListLocationsForAlertQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "secretScanningListLocationsForAlert",
    "/repos/:owner/:repo/secret-scanning/alerts/:alert_number/locations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningListLocationsForAlertParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          secretScanningListLocationsForAlertQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .secretScanningListLocationsForAlert(
          input,
          secretScanningListLocationsForAlert.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningListLocationsForAlert.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const secretScanningCreatePushProtectionBypassParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const secretScanningCreatePushProtectionBypassBodySchema = z.object({
    reason: s_secret_scanning_push_protection_bypass_reason,
    placeholder_id: s_secret_scanning_push_protection_bypass_placeholder_id,
  })

  router.post(
    "secretScanningCreatePushProtectionBypass",
    "/repos/:owner/:repo/secret-scanning/push-protection-bypasses",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningCreatePushProtectionBypassParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          secretScanningCreatePushProtectionBypassBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .secretScanningCreatePushProtectionBypass(
          input,
          secretScanningCreatePushProtectionBypass.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningCreatePushProtectionBypass.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const secretScanningGetScanHistoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "secretScanningGetScanHistory",
    "/repos/:owner/:repo/secret-scanning/scan-history",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          secretScanningGetScanHistoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .secretScanningGetScanHistory(
          input,
          secretScanningGetScanHistory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = secretScanningGetScanHistory.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesListRepositoryAdvisoriesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const securityAdvisoriesListRepositoryAdvisoriesQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    sort: z
      .enum(["created", "updated", "published"])
      .optional()
      .default("created"),
    before: z.string().optional(),
    after: z.string().optional(),
    per_page: z.coerce.number().min(1).max(100).optional().default(30),
    state: z.enum(["triage", "draft", "published", "closed"]).optional(),
  })

  router.get(
    "securityAdvisoriesListRepositoryAdvisories",
    "/repos/:owner/:repo/security-advisories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesListRepositoryAdvisoriesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          securityAdvisoriesListRepositoryAdvisoriesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesListRepositoryAdvisories(
          input,
          securityAdvisoriesListRepositoryAdvisories.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesListRepositoryAdvisories.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesCreateRepositoryAdvisoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const securityAdvisoriesCreateRepositoryAdvisoryBodySchema =
    s_repository_advisory_create

  router.post(
    "securityAdvisoriesCreateRepositoryAdvisory",
    "/repos/:owner/:repo/security-advisories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesCreateRepositoryAdvisoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          securityAdvisoriesCreateRepositoryAdvisoryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesCreateRepositoryAdvisory(
          input,
          securityAdvisoriesCreateRepositoryAdvisory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesCreateRepositoryAdvisory.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesCreatePrivateVulnerabilityReportParamSchema =
    z.object({ owner: z.string(), repo: z.string() })

  const securityAdvisoriesCreatePrivateVulnerabilityReportBodySchema =
    s_private_vulnerability_report_create

  router.post(
    "securityAdvisoriesCreatePrivateVulnerabilityReport",
    "/repos/:owner/:repo/security-advisories/reports",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesCreatePrivateVulnerabilityReportParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          securityAdvisoriesCreatePrivateVulnerabilityReportBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesCreatePrivateVulnerabilityReport(
          input,
          securityAdvisoriesCreatePrivateVulnerabilityReport.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesCreatePrivateVulnerabilityReport.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesGetRepositoryAdvisoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ghsa_id: z.string(),
  })

  router.get(
    "securityAdvisoriesGetRepositoryAdvisory",
    "/repos/:owner/:repo/security-advisories/:ghsa_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesGetRepositoryAdvisoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesGetRepositoryAdvisory(
          input,
          securityAdvisoriesGetRepositoryAdvisory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesGetRepositoryAdvisory.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesUpdateRepositoryAdvisoryParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ghsa_id: z.string(),
  })

  const securityAdvisoriesUpdateRepositoryAdvisoryBodySchema =
    s_repository_advisory_update

  router.patch(
    "securityAdvisoriesUpdateRepositoryAdvisory",
    "/repos/:owner/:repo/security-advisories/:ghsa_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesUpdateRepositoryAdvisoryParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          securityAdvisoriesUpdateRepositoryAdvisoryBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesUpdateRepositoryAdvisory(
          input,
          securityAdvisoriesUpdateRepositoryAdvisory.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesUpdateRepositoryAdvisory.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema =
    z.object({ owner: z.string(), repo: z.string(), ghsa_id: z.string() })

  router.post(
    "securityAdvisoriesCreateRepositoryAdvisoryCveRequest",
    "/repos/:owner/:repo/security-advisories/:ghsa_id/cve",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesCreateRepositoryAdvisoryCveRequestParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesCreateRepositoryAdvisoryCveRequest(
          input,
          securityAdvisoriesCreateRepositoryAdvisoryCveRequest.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesCreateRepositoryAdvisoryCveRequest.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const securityAdvisoriesCreateForkParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ghsa_id: z.string(),
  })

  router.post(
    "securityAdvisoriesCreateFork",
    "/repos/:owner/:repo/security-advisories/:ghsa_id/forks",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          securityAdvisoriesCreateForkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .securityAdvisoriesCreateFork(
          input,
          securityAdvisoriesCreateFork.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = securityAdvisoriesCreateFork.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListStargazersForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListStargazersForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListStargazersForRepo",
    "/repos/:owner/:repo/stargazers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListStargazersForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListStargazersForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListStargazersForRepo(
          input,
          activityListStargazersForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListStargazersForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCodeFrequencyStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetCodeFrequencyStats",
    "/repos/:owner/:repo/stats/code_frequency",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCodeFrequencyStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCodeFrequencyStats(
          input,
          reposGetCodeFrequencyStats.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCodeFrequencyStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetCommitActivityStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetCommitActivityStats",
    "/repos/:owner/:repo/stats/commit_activity",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetCommitActivityStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetCommitActivityStats(
          input,
          reposGetCommitActivityStats.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetCommitActivityStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetContributorsStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetContributorsStats",
    "/repos/:owner/:repo/stats/contributors",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetContributorsStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetContributorsStats(
          input,
          reposGetContributorsStats.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetContributorsStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetParticipationStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetParticipationStats",
    "/repos/:owner/:repo/stats/participation",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetParticipationStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetParticipationStats(
          input,
          reposGetParticipationStats.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetParticipationStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetPunchCardStatsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetPunchCardStats",
    "/repos/:owner/:repo/stats/punch_card",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetPunchCardStatsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetPunchCardStats(input, reposGetPunchCardStats.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetPunchCardStats.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateCommitStatusParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    sha: z.string(),
  })

  const reposCreateCommitStatusBodySchema = z.object({
    state: z.enum(["error", "failure", "pending", "success"]),
    target_url: z.string().nullable().optional(),
    description: z.string().nullable().optional(),
    context: z.string().optional().default("default"),
  })

  router.post(
    "reposCreateCommitStatus",
    "/repos/:owner/:repo/statuses/:sha",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateCommitStatusParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateCommitStatusBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateCommitStatus(input, reposCreateCommitStatus.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateCommitStatus.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListWatchersForRepoParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activityListWatchersForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListWatchersForRepo",
    "/repos/:owner/:repo/subscribers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListWatchersForRepoParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListWatchersForRepoQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListWatchersForRepo(
          input,
          activityListWatchersForRepo.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListWatchersForRepo.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityGetRepoSubscriptionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "activityGetRepoSubscription",
    "/repos/:owner/:repo/subscription",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityGetRepoSubscriptionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityGetRepoSubscription(
          input,
          activityGetRepoSubscription.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityGetRepoSubscription.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activitySetRepoSubscriptionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const activitySetRepoSubscriptionBodySchema = z
    .object({
      subscribed: PermissiveBoolean.optional(),
      ignored: PermissiveBoolean.optional(),
    })
    .optional()

  router.put(
    "activitySetRepoSubscription",
    "/repos/:owner/:repo/subscription",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activitySetRepoSubscriptionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          activitySetRepoSubscriptionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .activitySetRepoSubscription(
          input,
          activitySetRepoSubscription.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activitySetRepoSubscription.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityDeleteRepoSubscriptionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "activityDeleteRepoSubscription",
    "/repos/:owner/:repo/subscription",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityDeleteRepoSubscriptionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityDeleteRepoSubscription(
          input,
          activityDeleteRepoSubscription.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityDeleteRepoSubscription.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListTagsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListTagsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("reposListTags", "/repos/:owner/:repo/tags", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        reposListTagsParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        reposListTagsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .reposListTags(input, reposListTags.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposListTags.validator(status, body)
    ctx.status = status
    return next()
  })

  const reposListTagProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposListTagProtection",
    "/repos/:owner/:repo/tags/protection",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListTagProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListTagProtection(input, reposListTagProtection.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListTagProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateTagProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposCreateTagProtectionBodySchema = z.object({ pattern: z.string() })

  router.post(
    "reposCreateTagProtection",
    "/repos/:owner/:repo/tags/protection",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateTagProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateTagProtectionBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateTagProtection(
          input,
          reposCreateTagProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateTagProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDeleteTagProtectionParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    tag_protection_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteTagProtection",
    "/repos/:owner/:repo/tags/protection/:tag_protection_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeleteTagProtectionParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeleteTagProtection(
          input,
          reposDeleteTagProtection.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeleteTagProtection.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDownloadTarballArchiveParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  router.get(
    "reposDownloadTarballArchive",
    "/repos/:owner/:repo/tarball/:ref",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDownloadTarballArchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDownloadTarballArchive(
          input,
          reposDownloadTarballArchive.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDownloadTarballArchive.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListTeamsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposListTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListTeams",
    "/repos/:owner/:repo/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListTeamsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListTeamsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListTeams(input, reposListTeams.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListTeams.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetAllTopicsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetAllTopicsQuerySchema = z.object({
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "reposGetAllTopics",
    "/repos/:owner/:repo/topics",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetAllTopicsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetAllTopicsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetAllTopics(input, reposGetAllTopics.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetAllTopics.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposReplaceAllTopicsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposReplaceAllTopicsBodySchema = z.object({
    names: z.array(z.string()),
  })

  router.put(
    "reposReplaceAllTopics",
    "/repos/:owner/:repo/topics",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposReplaceAllTopicsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposReplaceAllTopicsBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposReplaceAllTopics(input, reposReplaceAllTopics.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposReplaceAllTopics.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetClonesParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetClonesQuerySchema = z.object({
    per: z.enum(["day", "week"]).optional().default("day"),
  })

  router.get(
    "reposGetClones",
    "/repos/:owner/:repo/traffic/clones",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetClonesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetClonesQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetClones(input, reposGetClones.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetClones.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetTopPathsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetTopPaths",
    "/repos/:owner/:repo/traffic/popular/paths",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetTopPathsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetTopPaths(input, reposGetTopPaths.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetTopPaths.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetTopReferrersParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposGetTopReferrers",
    "/repos/:owner/:repo/traffic/popular/referrers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetTopReferrersParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetTopReferrers(input, reposGetTopReferrers.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetTopReferrers.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposGetViewsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposGetViewsQuerySchema = z.object({
    per: z.enum(["day", "week"]).optional().default("day"),
  })

  router.get(
    "reposGetViews",
    "/repos/:owner/:repo/traffic/views",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposGetViewsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposGetViewsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposGetViews(input, reposGetViews.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposGetViews.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposTransferParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  const reposTransferBodySchema = z.object({
    new_owner: z.string(),
    new_name: z.string().optional(),
    team_ids: z.array(z.coerce.number()).optional(),
  })

  router.post(
    "reposTransfer",
    "/repos/:owner/:repo/transfer",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposTransferParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposTransferBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposTransfer(input, reposTransfer.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposTransfer.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCheckVulnerabilityAlertsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "reposCheckVulnerabilityAlerts",
    "/repos/:owner/:repo/vulnerability-alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCheckVulnerabilityAlertsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposCheckVulnerabilityAlerts(
          input,
          reposCheckVulnerabilityAlerts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCheckVulnerabilityAlerts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposEnableVulnerabilityAlertsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.put(
    "reposEnableVulnerabilityAlerts",
    "/repos/:owner/:repo/vulnerability-alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposEnableVulnerabilityAlertsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposEnableVulnerabilityAlerts(
          input,
          reposEnableVulnerabilityAlerts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposEnableVulnerabilityAlerts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDisableVulnerabilityAlertsParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "reposDisableVulnerabilityAlerts",
    "/repos/:owner/:repo/vulnerability-alerts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDisableVulnerabilityAlertsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDisableVulnerabilityAlerts(
          input,
          reposDisableVulnerabilityAlerts.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDisableVulnerabilityAlerts.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposDownloadZipballArchiveParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
    ref: z.string(),
  })

  router.get(
    "reposDownloadZipballArchive",
    "/repos/:owner/:repo/zipball/:ref",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDownloadZipballArchiveParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDownloadZipballArchive(
          input,
          reposDownloadZipballArchive.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDownloadZipballArchive.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateUsingTemplateParamSchema = z.object({
    template_owner: z.string(),
    template_repo: z.string(),
  })

  const reposCreateUsingTemplateBodySchema = z.object({
    owner: z.string().optional(),
    name: z.string(),
    description: z.string().optional(),
    include_all_branches: PermissiveBoolean.optional().default(false),
    private: PermissiveBoolean.optional().default(false),
  })

  router.post(
    "reposCreateUsingTemplate",
    "/repos/:template_owner/:template_repo/generate",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposCreateUsingTemplateParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reposCreateUsingTemplateBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateUsingTemplate(
          input,
          reposCreateUsingTemplate.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateUsingTemplate.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListPublicQuerySchema = z.object({
    since: z.coerce.number().optional(),
  })

  router.get("reposListPublic", "/repositories", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        reposListPublicQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .reposListPublic(input, reposListPublic.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = reposListPublic.validator(status, body)
    ctx.status = status
    return next()
  })

  const searchCodeQuerySchema = z.object({
    q: z.string(),
    sort: z.enum(["indexed"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("searchCode", "/search/code", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        searchCodeQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .searchCode(input, searchCode.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = searchCode.validator(status, body)
    ctx.status = status
    return next()
  })

  const searchCommitsQuerySchema = z.object({
    q: z.string(),
    sort: z.enum(["author-date", "committer-date"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("searchCommits", "/search/commits", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        searchCommitsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .searchCommits(input, searchCommits.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = searchCommits.validator(status, body)
    ctx.status = status
    return next()
  })

  const searchIssuesAndPullRequestsQuerySchema = z.object({
    q: z.string(),
    sort: z
      .enum([
        "comments",
        "reactions",
        "reactions-+1",
        "reactions--1",
        "reactions-smile",
        "reactions-thinking_face",
        "reactions-heart",
        "reactions-tada",
        "interactions",
        "created",
        "updated",
      ])
      .optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    advanced_search: z.string().optional(),
  })

  router.get(
    "searchIssuesAndPullRequests",
    "/search/issues",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          searchIssuesAndPullRequestsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .searchIssuesAndPullRequests(
          input,
          searchIssuesAndPullRequests.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = searchIssuesAndPullRequests.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const searchLabelsQuerySchema = z.object({
    repository_id: z.coerce.number(),
    q: z.string(),
    sort: z.enum(["created", "updated"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("searchLabels", "/search/labels", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        searchLabelsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .searchLabels(input, searchLabels.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = searchLabels.validator(status, body)
    ctx.status = status
    return next()
  })

  const searchReposQuerySchema = z.object({
    q: z.string(),
    sort: z
      .enum(["stars", "forks", "help-wanted-issues", "updated"])
      .optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("searchRepos", "/search/repositories", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        searchReposQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .searchRepos(input, searchRepos.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = searchRepos.validator(status, body)
    ctx.status = status
    return next()
  })

  const searchTopicsQuerySchema = z.object({
    q: z.string(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("searchTopics", "/search/topics", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        searchTopicsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .searchTopics(input, searchTopics.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = searchTopics.validator(status, body)
    ctx.status = status
    return next()
  })

  const searchUsersQuerySchema = z.object({
    q: z.string(),
    sort: z.enum(["followers", "repositories", "joined"]).optional(),
    order: z.enum(["desc", "asc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("searchUsers", "/search/users", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        searchUsersQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .searchUsers(input, searchUsers.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = searchUsers.validator(status, body)
    ctx.status = status
    return next()
  })

  const teamsGetLegacyParamSchema = z.object({ team_id: z.coerce.number() })

  router.get("teamsGetLegacy", "/teams/:team_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        teamsGetLegacyParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .teamsGetLegacy(input, teamsGetLegacy.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = teamsGetLegacy.validator(status, body)
    ctx.status = status
    return next()
  })

  const teamsUpdateLegacyParamSchema = z.object({ team_id: z.coerce.number() })

  const teamsUpdateLegacyBodySchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    privacy: z.enum(["secret", "closed"]).optional(),
    notification_setting: z
      .enum(["notifications_enabled", "notifications_disabled"])
      .optional(),
    permission: z.enum(["pull", "push", "admin"]).optional().default("pull"),
    parent_team_id: z.coerce.number().nullable().optional(),
  })

  router.patch("teamsUpdateLegacy", "/teams/:team_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        teamsUpdateLegacyParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: parseRequestInput(
        teamsUpdateLegacyBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .teamsUpdateLegacy(input, teamsUpdateLegacy.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = teamsUpdateLegacy.validator(status, body)
    ctx.status = status
    return next()
  })

  const teamsDeleteLegacyParamSchema = z.object({ team_id: z.coerce.number() })

  router.delete("teamsDeleteLegacy", "/teams/:team_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        teamsDeleteLegacyParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .teamsDeleteLegacy(input, teamsDeleteLegacy.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = teamsDeleteLegacy.validator(status, body)
    ctx.status = status
    return next()
  })

  const teamsListDiscussionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListDiscussionsLegacyQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListDiscussionsLegacy",
    "/teams/:team_id/discussions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListDiscussionsLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListDiscussionsLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListDiscussionsLegacy(
          input,
          teamsListDiscussionsLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListDiscussionsLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCreateDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsCreateDiscussionLegacyBodySchema = z.object({
    title: z.string(),
    body: z.string(),
    private: PermissiveBoolean.optional().default(false),
  })

  router.post(
    "teamsCreateDiscussionLegacy",
    "/teams/:team_id/discussions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCreateDiscussionLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsCreateDiscussionLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsCreateDiscussionLegacy(
          input,
          teamsCreateDiscussionLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCreateDiscussionLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsGetDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionLegacy",
    "/teams/:team_id/discussions/:discussion_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetDiscussionLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetDiscussionLegacy(
          input,
          teamsGetDiscussionLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetDiscussionLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsUpdateDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionLegacyBodySchema = z
    .object({ title: z.string().optional(), body: z.string().optional() })
    .optional()

  router.patch(
    "teamsUpdateDiscussionLegacy",
    "/teams/:team_id/discussions/:discussion_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsUpdateDiscussionLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsUpdateDiscussionLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsUpdateDiscussionLegacy(
          input,
          teamsUpdateDiscussionLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsUpdateDiscussionLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsDeleteDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionLegacy",
    "/teams/:team_id/discussions/:discussion_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsDeleteDiscussionLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsDeleteDiscussionLegacy(
          input,
          teamsDeleteDiscussionLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsDeleteDiscussionLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListDiscussionCommentsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsListDiscussionCommentsLegacyQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListDiscussionCommentsLegacy",
    "/teams/:team_id/discussions/:discussion_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListDiscussionCommentsLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListDiscussionCommentsLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListDiscussionCommentsLegacy(
          input,
          teamsListDiscussionCommentsLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListDiscussionCommentsLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCreateDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsCreateDiscussionCommentLegacyBodySchema = z.object({
    body: z.string(),
  })

  router.post(
    "teamsCreateDiscussionCommentLegacy",
    "/teams/:team_id/discussions/:discussion_number/comments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCreateDiscussionCommentLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsCreateDiscussionCommentLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsCreateDiscussionCommentLegacy(
          input,
          teamsCreateDiscussionCommentLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCreateDiscussionCommentLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsGetDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionCommentLegacy",
    "/teams/:team_id/discussions/:discussion_number/comments/:comment_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetDiscussionCommentLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetDiscussionCommentLegacy(
          input,
          teamsGetDiscussionCommentLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetDiscussionCommentLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsUpdateDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionCommentLegacyBodySchema = z.object({
    body: z.string(),
  })

  router.patch(
    "teamsUpdateDiscussionCommentLegacy",
    "/teams/:team_id/discussions/:discussion_number/comments/:comment_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsUpdateDiscussionCommentLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsUpdateDiscussionCommentLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsUpdateDiscussionCommentLegacy(
          input,
          teamsUpdateDiscussionCommentLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsUpdateDiscussionCommentLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsDeleteDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionCommentLegacy",
    "/teams/:team_id/discussions/:discussion_number/comments/:comment_number",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsDeleteDiscussionCommentLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsDeleteDiscussionCommentLegacy(
          input,
          teamsDeleteDiscussionCommentLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsDeleteDiscussionCommentLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsListForTeamDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionCommentLegacyQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForTeamDiscussionCommentLegacy",
    "/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForTeamDiscussionCommentLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForTeamDiscussionCommentLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForTeamDiscussionCommentLegacy(
          input,
          reactionsListForTeamDiscussionCommentLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForTeamDiscussionCommentLegacy.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForTeamDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionCommentLegacyBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionCommentLegacy",
    "/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForTeamDiscussionCommentLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForTeamDiscussionCommentLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForTeamDiscussionCommentLegacy(
          input,
          reactionsCreateForTeamDiscussionCommentLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForTeamDiscussionCommentLegacy.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reactionsListForTeamDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionLegacyQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reactionsListForTeamDiscussionLegacy",
    "/teams/:team_id/discussions/:discussion_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsListForTeamDiscussionLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reactionsListForTeamDiscussionLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reactionsListForTeamDiscussionLegacy(
          input,
          reactionsListForTeamDiscussionLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsListForTeamDiscussionLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reactionsCreateForTeamDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionLegacyBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionLegacy",
    "/teams/:team_id/discussions/:discussion_number/reactions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reactionsCreateForTeamDiscussionLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          reactionsCreateForTeamDiscussionLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reactionsCreateForTeamDiscussionLegacy(
          input,
          reactionsCreateForTeamDiscussionLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reactionsCreateForTeamDiscussionLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListPendingInvitationsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListPendingInvitationsLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListPendingInvitationsLegacy",
    "/teams/:team_id/invitations",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListPendingInvitationsLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListPendingInvitationsLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListPendingInvitationsLegacy(
          input,
          teamsListPendingInvitationsLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListPendingInvitationsLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListMembersLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListMembersLegacyQuerySchema = z.object({
    role: z.enum(["member", "maintainer", "all"]).optional().default("all"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListMembersLegacy",
    "/teams/:team_id/members",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListMembersLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListMembersLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListMembersLegacy(input, teamsListMembersLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListMembersLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsGetMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  router.get(
    "teamsGetMemberLegacy",
    "/teams/:team_id/members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetMemberLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetMemberLegacy(input, teamsGetMemberLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetMemberLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsAddMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  router.put(
    "teamsAddMemberLegacy",
    "/teams/:team_id/members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsAddMemberLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsAddMemberLegacy(input, teamsAddMemberLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsAddMemberLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsRemoveMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  router.delete(
    "teamsRemoveMemberLegacy",
    "/teams/:team_id/members/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsRemoveMemberLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsRemoveMemberLegacy(input, teamsRemoveMemberLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsRemoveMemberLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsGetMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  router.get(
    "teamsGetMembershipForUserLegacy",
    "/teams/:team_id/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsGetMembershipForUserLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsGetMembershipForUserLegacy(
          input,
          teamsGetMembershipForUserLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsGetMembershipForUserLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsAddOrUpdateMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  const teamsAddOrUpdateMembershipForUserLegacyBodySchema = z
    .object({
      role: z.enum(["member", "maintainer"]).optional().default("member"),
    })
    .optional()

  router.put(
    "teamsAddOrUpdateMembershipForUserLegacy",
    "/teams/:team_id/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsAddOrUpdateMembershipForUserLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsAddOrUpdateMembershipForUserLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsAddOrUpdateMembershipForUserLegacy(
          input,
          teamsAddOrUpdateMembershipForUserLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsAddOrUpdateMembershipForUserLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsRemoveMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.string(),
  })

  router.delete(
    "teamsRemoveMembershipForUserLegacy",
    "/teams/:team_id/memberships/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsRemoveMembershipForUserLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsRemoveMembershipForUserLegacy(
          input,
          teamsRemoveMembershipForUserLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsRemoveMembershipForUserLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListProjectsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListProjectsLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListProjectsLegacy",
    "/teams/:team_id/projects",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListProjectsLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListProjectsLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListProjectsLegacy(input, teamsListProjectsLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListProjectsLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCheckPermissionsForProjectLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  router.get(
    "teamsCheckPermissionsForProjectLegacy",
    "/teams/:team_id/projects/:project_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCheckPermissionsForProjectLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsCheckPermissionsForProjectLegacy(
          input,
          teamsCheckPermissionsForProjectLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCheckPermissionsForProjectLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsAddOrUpdateProjectPermissionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  const teamsAddOrUpdateProjectPermissionsLegacyBodySchema = z
    .object({ permission: z.enum(["read", "write", "admin"]).optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateProjectPermissionsLegacy",
    "/teams/:team_id/projects/:project_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsAddOrUpdateProjectPermissionsLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsAddOrUpdateProjectPermissionsLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsAddOrUpdateProjectPermissionsLegacy(
          input,
          teamsAddOrUpdateProjectPermissionsLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsAddOrUpdateProjectPermissionsLegacy.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const teamsRemoveProjectLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  router.delete(
    "teamsRemoveProjectLegacy",
    "/teams/:team_id/projects/:project_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsRemoveProjectLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsRemoveProjectLegacy(
          input,
          teamsRemoveProjectLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsRemoveProjectLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListReposLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListReposLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListReposLegacy",
    "/teams/:team_id/repos",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListReposLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListReposLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListReposLegacy(input, teamsListReposLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListReposLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsCheckPermissionsForRepoLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "teamsCheckPermissionsForRepoLegacy",
    "/teams/:team_id/repos/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsCheckPermissionsForRepoLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsCheckPermissionsForRepoLegacy(
          input,
          teamsCheckPermissionsForRepoLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsCheckPermissionsForRepoLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsAddOrUpdateRepoPermissionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.string(),
    repo: z.string(),
  })

  const teamsAddOrUpdateRepoPermissionsLegacyBodySchema = z
    .object({ permission: z.enum(["pull", "push", "admin"]).optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateRepoPermissionsLegacy",
    "/teams/:team_id/repos/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsAddOrUpdateRepoPermissionsLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          teamsAddOrUpdateRepoPermissionsLegacyBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .teamsAddOrUpdateRepoPermissionsLegacy(
          input,
          teamsAddOrUpdateRepoPermissionsLegacy.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsAddOrUpdateRepoPermissionsLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsRemoveRepoLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "teamsRemoveRepoLegacy",
    "/teams/:team_id/repos/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsRemoveRepoLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsRemoveRepoLegacy(input, teamsRemoveRepoLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsRemoveRepoLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const teamsListChildLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListChildLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListChildLegacy",
    "/teams/:team_id/teams",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          teamsListChildLegacyParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          teamsListChildLegacyQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListChildLegacy(input, teamsListChildLegacy.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListChildLegacy.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get("usersGetAuthenticated", "/user", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .usersGetAuthenticated(input, usersGetAuthenticated.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersGetAuthenticated.validator(status, body)
    ctx.status = status
    return next()
  })

  const usersUpdateAuthenticatedBodySchema = z
    .object({
      name: z.string().optional(),
      email: z.string().optional(),
      blog: z.string().optional(),
      twitter_username: z.string().nullable().optional(),
      company: z.string().optional(),
      location: z.string().optional(),
      hireable: PermissiveBoolean.optional(),
      bio: z.string().optional(),
    })
    .optional()

  router.patch("usersUpdateAuthenticated", "/user", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        usersUpdateAuthenticatedBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const response = await implementation
      .usersUpdateAuthenticated(input, usersUpdateAuthenticated.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersUpdateAuthenticated.validator(status, body)
    ctx.status = status
    return next()
  })

  const usersListBlockedByAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListBlockedByAuthenticatedUser",
    "/user/blocks",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListBlockedByAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListBlockedByAuthenticatedUser(
          input,
          usersListBlockedByAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListBlockedByAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersCheckBlockedParamSchema = z.object({ username: z.string() })

  router.get(
    "usersCheckBlocked",
    "/user/blocks/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersCheckBlockedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersCheckBlocked(input, usersCheckBlocked.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersCheckBlocked.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersBlockParamSchema = z.object({ username: z.string() })

  router.put("usersBlock", "/user/blocks/:username", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        usersBlockParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .usersBlock(input, usersBlock.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersBlock.validator(status, body)
    ctx.status = status
    return next()
  })

  const usersUnblockParamSchema = z.object({ username: z.string() })

  router.delete("usersUnblock", "/user/blocks/:username", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        usersUnblockParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .usersUnblock(input, usersUnblock.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersUnblock.validator(status, body)
    ctx.status = status
    return next()
  })

  const codespacesListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    repository_id: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListForAuthenticatedUser",
    "/user/codespaces",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          codespacesListForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListForAuthenticatedUser(
          input,
          codespacesListForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesListForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesCreateForAuthenticatedUserBodySchema = z.union([
    z.object({
      repository_id: z.coerce.number(),
      ref: z.string().optional(),
      location: z.string().optional(),
      geo: z
        .enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"])
        .optional(),
      client_ip: z.string().optional(),
      machine: z.string().optional(),
      devcontainer_path: z.string().optional(),
      multi_repo_permissions_opt_out: PermissiveBoolean.optional(),
      working_directory: z.string().optional(),
      idle_timeout_minutes: z.coerce.number().optional(),
      display_name: z.string().optional(),
      retention_period_minutes: z.coerce.number().optional(),
    }),
    z.object({
      pull_request: z.object({
        pull_request_number: z.coerce.number(),
        repository_id: z.coerce.number(),
      }),
      location: z.string().optional(),
      geo: z
        .enum(["EuropeWest", "SoutheastAsia", "UsEast", "UsWest"])
        .optional(),
      machine: z.string().optional(),
      devcontainer_path: z.string().optional(),
      working_directory: z.string().optional(),
      idle_timeout_minutes: z.coerce.number().optional(),
    }),
  ])

  router.post(
    "codespacesCreateForAuthenticatedUser",
    "/user/codespaces",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          codespacesCreateForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesCreateForAuthenticatedUser(
          input,
          codespacesCreateForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCreateForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesListSecretsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "codespacesListSecretsForAuthenticatedUser",
    "/user/codespaces/secrets",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          codespacesListSecretsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListSecretsForAuthenticatedUser(
          input,
          codespacesListSecretsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesListSecretsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  router.get(
    "codespacesGetPublicKeyForAuthenticatedUser",
    "/user/codespaces/secrets/public-key",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetPublicKeyForAuthenticatedUser(
          input,
          codespacesGetPublicKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetPublicKeyForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesGetSecretForAuthenticatedUserParamSchema = z.object({
    secret_name: z.string(),
  })

  router.get(
    "codespacesGetSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetSecretForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetSecretForAuthenticatedUser(
          input,
          codespacesGetSecretForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetSecretForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.string() })

  const codespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema = z.object(
    {
      encrypted_value: z
        .string()
        .regex(
          new RegExp(
            "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$",
          ),
        )
        .optional(),
      key_id: z.string(),
      selected_repository_ids: z
        .array(z.union([z.coerce.number(), z.string()]))
        .optional(),
    },
  )

  router.put(
    "codespacesCreateOrUpdateSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesCreateOrUpdateSecretForAuthenticatedUser(
          input,
          codespacesCreateOrUpdateSecretForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCreateOrUpdateSecretForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesDeleteSecretForAuthenticatedUserParamSchema = z.object({
    secret_name: z.string(),
  })

  router.delete(
    "codespacesDeleteSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secret_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesDeleteSecretForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesDeleteSecretForAuthenticatedUser(
          input,
          codespacesDeleteSecretForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesDeleteSecretForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesListRepositoriesForSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.string() })

  router.get(
    "codespacesListRepositoriesForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesListRepositoriesForSecretForAuthenticatedUser(
          input,
          codespacesListRepositoriesForSecretForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        codespacesListRepositoriesForSecretForAuthenticatedUser.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const codespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.string() })

  const codespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema =
    z.object({ selected_repository_ids: z.array(z.coerce.number()) })

  router.put(
    "codespacesSetRepositoriesForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secret_name/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesSetRepositoriesForSecretForAuthenticatedUser(
          input,
          codespacesSetRepositoriesForSecretForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        codespacesSetRepositoriesForSecretForAuthenticatedUser.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const codespacesAddRepositoryForSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.string(), repository_id: z.coerce.number() })

  router.put(
    "codespacesAddRepositoryForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesAddRepositoryForSecretForAuthenticatedUser(
          input,
          codespacesAddRepositoryForSecretForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesAddRepositoryForSecretForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.string(), repository_id: z.coerce.number() })

  router.delete(
    "codespacesRemoveRepositoryForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secret_name/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesRemoveRepositoryForSecretForAuthenticatedUser(
          input,
          codespacesRemoveRepositoryForSecretForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        codespacesRemoveRepositoryForSecretForAuthenticatedUser.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const codespacesGetForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  router.get(
    "codespacesGetForAuthenticatedUser",
    "/user/codespaces/:codespace_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetForAuthenticatedUser(
          input,
          codespacesGetForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesUpdateForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesUpdateForAuthenticatedUserBodySchema = z
    .object({
      machine: z.string().optional(),
      display_name: z.string().optional(),
      recent_folders: z.array(z.string()).optional(),
    })
    .optional()

  router.patch(
    "codespacesUpdateForAuthenticatedUser",
    "/user/codespaces/:codespace_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesUpdateForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesUpdateForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesUpdateForAuthenticatedUser(
          input,
          codespacesUpdateForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesUpdateForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesDeleteForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  router.delete(
    "codespacesDeleteForAuthenticatedUser",
    "/user/codespaces/:codespace_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesDeleteForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesDeleteForAuthenticatedUser(
          input,
          codespacesDeleteForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesDeleteForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesExportForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  router.post(
    "codespacesExportForAuthenticatedUser",
    "/user/codespaces/:codespace_name/exports",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesExportForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesExportForAuthenticatedUser(
          input,
          codespacesExportForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesExportForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesGetExportDetailsForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
    export_id: z.string(),
  })

  router.get(
    "codespacesGetExportDetailsForAuthenticatedUser",
    "/user/codespaces/:codespace_name/exports/:export_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesGetExportDetailsForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesGetExportDetailsForAuthenticatedUser(
          input,
          codespacesGetExportDetailsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesGetExportDetailsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesCodespaceMachinesForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  router.get(
    "codespacesCodespaceMachinesForAuthenticatedUser",
    "/user/codespaces/:codespace_name/machines",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesCodespaceMachinesForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesCodespaceMachinesForAuthenticatedUser(
          input,
          codespacesCodespaceMachinesForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesCodespaceMachinesForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const codespacesPublishForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  const codespacesPublishForAuthenticatedUserBodySchema = z.object({
    name: z.string().optional(),
    private: PermissiveBoolean.optional().default(false),
  })

  router.post(
    "codespacesPublishForAuthenticatedUser",
    "/user/codespaces/:codespace_name/publish",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesPublishForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          codespacesPublishForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .codespacesPublishForAuthenticatedUser(
          input,
          codespacesPublishForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesPublishForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesStartForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  router.post(
    "codespacesStartForAuthenticatedUser",
    "/user/codespaces/:codespace_name/start",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesStartForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesStartForAuthenticatedUser(
          input,
          codespacesStartForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesStartForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const codespacesStopForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.string(),
  })

  router.post(
    "codespacesStopForAuthenticatedUser",
    "/user/codespaces/:codespace_name/stop",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          codespacesStopForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .codespacesStopForAuthenticatedUser(
          input,
          codespacesStopForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = codespacesStopForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get(
    "packagesListDockerMigrationConflictingPackagesForAuthenticatedUser",
    "/user/docker/conflicts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesListDockerMigrationConflictingPackagesForAuthenticatedUser(
          input,
          packagesListDockerMigrationConflictingPackagesForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        packagesListDockerMigrationConflictingPackagesForAuthenticatedUser.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const usersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema = z.object(
    { visibility: z.enum(["public", "private"]) },
  )

  router.patch(
    "usersSetPrimaryEmailVisibilityForAuthenticatedUser",
    "/user/email/visibility",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersSetPrimaryEmailVisibilityForAuthenticatedUser(
          input,
          usersSetPrimaryEmailVisibilityForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersSetPrimaryEmailVisibilityForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersListEmailsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListEmailsForAuthenticatedUser",
    "/user/emails",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListEmailsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListEmailsForAuthenticatedUser(
          input,
          usersListEmailsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListEmailsForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersAddEmailForAuthenticatedUserBodySchema = z
    .union([
      z.object({ emails: z.array(z.string()).min(1) }),
      z.array(z.string()).min(1),
      z.string(),
    ])
    .optional()

  router.post(
    "usersAddEmailForAuthenticatedUser",
    "/user/emails",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersAddEmailForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersAddEmailForAuthenticatedUser(
          input,
          usersAddEmailForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersAddEmailForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersDeleteEmailForAuthenticatedUserBodySchema = z.union([
    z.object({ emails: z.array(z.string()).min(1) }),
    z.array(z.string()).min(1),
    z.string(),
  ])

  router.delete(
    "usersDeleteEmailForAuthenticatedUser",
    "/user/emails",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersDeleteEmailForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersDeleteEmailForAuthenticatedUser(
          input,
          usersDeleteEmailForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersDeleteEmailForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListFollowersForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListFollowersForAuthenticatedUser",
    "/user/followers",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListFollowersForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListFollowersForAuthenticatedUser(
          input,
          usersListFollowersForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListFollowersForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListFollowedByAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListFollowedByAuthenticatedUser",
    "/user/following",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListFollowedByAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListFollowedByAuthenticatedUser(
          input,
          usersListFollowedByAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListFollowedByAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersCheckPersonIsFollowedByAuthenticatedParamSchema = z.object({
    username: z.string(),
  })

  router.get(
    "usersCheckPersonIsFollowedByAuthenticated",
    "/user/following/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersCheckPersonIsFollowedByAuthenticatedParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersCheckPersonIsFollowedByAuthenticated(
          input,
          usersCheckPersonIsFollowedByAuthenticated.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersCheckPersonIsFollowedByAuthenticated.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersFollowParamSchema = z.object({ username: z.string() })

  router.put("usersFollow", "/user/following/:username", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        usersFollowParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .usersFollow(input, usersFollow.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersFollow.validator(status, body)
    ctx.status = status
    return next()
  })

  const usersUnfollowParamSchema = z.object({ username: z.string() })

  router.delete(
    "usersUnfollow",
    "/user/following/:username",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersUnfollowParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersUnfollow(input, usersUnfollow.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersUnfollow.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListGpgKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListGpgKeysForAuthenticatedUser",
    "/user/gpg_keys",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListGpgKeysForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListGpgKeysForAuthenticatedUser(
          input,
          usersListGpgKeysForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListGpgKeysForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersCreateGpgKeyForAuthenticatedUserBodySchema = z.object({
    name: z.string().optional(),
    armored_public_key: z.string(),
  })

  router.post(
    "usersCreateGpgKeyForAuthenticatedUser",
    "/user/gpg_keys",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersCreateGpgKeyForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersCreateGpgKeyForAuthenticatedUser(
          input,
          usersCreateGpgKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersCreateGpgKeyForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersGetGpgKeyForAuthenticatedUserParamSchema = z.object({
    gpg_key_id: z.coerce.number(),
  })

  router.get(
    "usersGetGpgKeyForAuthenticatedUser",
    "/user/gpg_keys/:gpg_key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersGetGpgKeyForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersGetGpgKeyForAuthenticatedUser(
          input,
          usersGetGpgKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersGetGpgKeyForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersDeleteGpgKeyForAuthenticatedUserParamSchema = z.object({
    gpg_key_id: z.coerce.number(),
  })

  router.delete(
    "usersDeleteGpgKeyForAuthenticatedUser",
    "/user/gpg_keys/:gpg_key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersDeleteGpgKeyForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersDeleteGpgKeyForAuthenticatedUser(
          input,
          usersDeleteGpgKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersDeleteGpgKeyForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsListInstallationsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListInstallationsForAuthenticatedUser",
    "/user/installations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListInstallationsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListInstallationsForAuthenticatedUser(
          input,
          appsListInstallationsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListInstallationsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const appsListInstallationReposForAuthenticatedUserParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsListInstallationReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListInstallationReposForAuthenticatedUser",
    "/user/installations/:installation_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsListInstallationReposForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          appsListInstallationReposForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListInstallationReposForAuthenticatedUser(
          input,
          appsListInstallationReposForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListInstallationReposForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const appsAddRepoToInstallationForAuthenticatedUserParamSchema = z.object({
    installation_id: z.coerce.number(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "appsAddRepoToInstallationForAuthenticatedUser",
    "/user/installations/:installation_id/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsAddRepoToInstallationForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsAddRepoToInstallationForAuthenticatedUser(
          input,
          appsAddRepoToInstallationForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsAddRepoToInstallationForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const appsRemoveRepoFromInstallationForAuthenticatedUserParamSchema =
    z.object({
      installation_id: z.coerce.number(),
      repository_id: z.coerce.number(),
    })

  router.delete(
    "appsRemoveRepoFromInstallationForAuthenticatedUser",
    "/user/installations/:installation_id/repositories/:repository_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsRemoveRepoFromInstallationForAuthenticatedUser(
          input,
          appsRemoveRepoFromInstallationForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsRemoveRepoFromInstallationForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  router.get(
    "interactionsGetRestrictionsForAuthenticatedUser",
    "/user/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .interactionsGetRestrictionsForAuthenticatedUser(
          input,
          interactionsGetRestrictionsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsGetRestrictionsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const interactionsSetRestrictionsForAuthenticatedUserBodySchema =
    s_interaction_limit

  router.put(
    "interactionsSetRestrictionsForAuthenticatedUser",
    "/user/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          interactionsSetRestrictionsForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .interactionsSetRestrictionsForAuthenticatedUser(
          input,
          interactionsSetRestrictionsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsSetRestrictionsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  router.delete(
    "interactionsRemoveRestrictionsForAuthenticatedUser",
    "/user/interaction-limits",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .interactionsRemoveRestrictionsForAuthenticatedUser(
          input,
          interactionsRemoveRestrictionsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = interactionsRemoveRestrictionsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const issuesListForAuthenticatedUserQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional()
      .default("assigned"),
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    labels: z.string().optional(),
    sort: z
      .enum(["created", "updated", "comments"])
      .optional()
      .default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "issuesListForAuthenticatedUser",
    "/user/issues",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          issuesListForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .issuesListForAuthenticatedUser(
          input,
          issuesListForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = issuesListForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListPublicSshKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListPublicSshKeysForAuthenticatedUser",
    "/user/keys",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListPublicSshKeysForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListPublicSshKeysForAuthenticatedUser(
          input,
          usersListPublicSshKeysForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListPublicSshKeysForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersCreatePublicSshKeyForAuthenticatedUserBodySchema = z.object({
    title: z.string().optional(),
    key: z
      .string()
      .regex(
        new RegExp("^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) "),
      ),
  })

  router.post(
    "usersCreatePublicSshKeyForAuthenticatedUser",
    "/user/keys",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersCreatePublicSshKeyForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersCreatePublicSshKeyForAuthenticatedUser(
          input,
          usersCreatePublicSshKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersCreatePublicSshKeyForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersGetPublicSshKeyForAuthenticatedUserParamSchema = z.object({
    key_id: z.coerce.number(),
  })

  router.get(
    "usersGetPublicSshKeyForAuthenticatedUser",
    "/user/keys/:key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersGetPublicSshKeyForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersGetPublicSshKeyForAuthenticatedUser(
          input,
          usersGetPublicSshKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersGetPublicSshKeyForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersDeletePublicSshKeyForAuthenticatedUserParamSchema = z.object({
    key_id: z.coerce.number(),
  })

  router.delete(
    "usersDeletePublicSshKeyForAuthenticatedUser",
    "/user/keys/:key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersDeletePublicSshKeyForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersDeletePublicSshKeyForAuthenticatedUser(
          input,
          usersDeletePublicSshKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersDeletePublicSshKeyForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const appsListSubscriptionsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListSubscriptionsForAuthenticatedUser",
    "/user/marketplace_purchases",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListSubscriptionsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListSubscriptionsForAuthenticatedUser(
          input,
          appsListSubscriptionsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListSubscriptionsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const appsListSubscriptionsForAuthenticatedUserStubbedQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "appsListSubscriptionsForAuthenticatedUserStubbed",
    "/user/marketplace_purchases/stubbed",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          appsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsListSubscriptionsForAuthenticatedUserStubbed(
          input,
          appsListSubscriptionsForAuthenticatedUserStubbed.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsListSubscriptionsForAuthenticatedUserStubbed.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const orgsListMembershipsForAuthenticatedUserQuerySchema = z.object({
    state: z.enum(["active", "pending"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListMembershipsForAuthenticatedUser",
    "/user/memberships/orgs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          orgsListMembershipsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListMembershipsForAuthenticatedUser(
          input,
          orgsListMembershipsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListMembershipsForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsGetMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
  })

  router.get(
    "orgsGetMembershipForAuthenticatedUser",
    "/user/memberships/orgs/:org",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsGetMembershipForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsGetMembershipForAuthenticatedUser(
          input,
          orgsGetMembershipForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsGetMembershipForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsUpdateMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.string(),
  })

  const orgsUpdateMembershipForAuthenticatedUserBodySchema = z.object({
    state: z.enum(["active"]),
  })

  router.patch(
    "orgsUpdateMembershipForAuthenticatedUser",
    "/user/memberships/orgs/:org",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          orgsUpdateMembershipForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          orgsUpdateMembershipForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .orgsUpdateMembershipForAuthenticatedUser(
          input,
          orgsUpdateMembershipForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsUpdateMembershipForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const migrationsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "migrationsListForAuthenticatedUser",
    "/user/migrations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          migrationsListForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsListForAuthenticatedUser(
          input,
          migrationsListForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsListForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsStartForAuthenticatedUserBodySchema = z.object({
    lock_repositories: PermissiveBoolean.optional(),
    exclude_metadata: PermissiveBoolean.optional(),
    exclude_git_data: PermissiveBoolean.optional(),
    exclude_attachments: PermissiveBoolean.optional(),
    exclude_releases: PermissiveBoolean.optional(),
    exclude_owner_projects: PermissiveBoolean.optional(),
    org_metadata_only: PermissiveBoolean.optional().default(false),
    exclude: z.array(z.enum(["repositories"])).optional(),
    repositories: z.array(z.string()),
  })

  router.post(
    "migrationsStartForAuthenticatedUser",
    "/user/migrations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          migrationsStartForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .migrationsStartForAuthenticatedUser(
          input,
          migrationsStartForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsStartForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsGetStatusForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsGetStatusForAuthenticatedUserQuerySchema = z.object({
    exclude: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()),
      )
      .optional(),
  })

  router.get(
    "migrationsGetStatusForAuthenticatedUser",
    "/user/migrations/:migration_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsGetStatusForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          migrationsGetStatusForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsGetStatusForAuthenticatedUser(
          input,
          migrationsGetStatusForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsGetStatusForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const migrationsGetArchiveForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  router.get(
    "migrationsGetArchiveForAuthenticatedUser",
    "/user/migrations/:migration_id/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsGetArchiveForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsGetArchiveForAuthenticatedUser(
          input,
          migrationsGetArchiveForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsGetArchiveForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const migrationsDeleteArchiveForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  router.delete(
    "migrationsDeleteArchiveForAuthenticatedUser",
    "/user/migrations/:migration_id/archive",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsDeleteArchiveForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsDeleteArchiveForAuthenticatedUser(
          input,
          migrationsDeleteArchiveForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsDeleteArchiveForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const migrationsUnlockRepoForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
    repo_name: z.string(),
  })

  router.delete(
    "migrationsUnlockRepoForAuthenticatedUser",
    "/user/migrations/:migration_id/repos/:repo_name/lock",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsUnlockRepoForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsUnlockRepoForAuthenticatedUser(
          input,
          migrationsUnlockRepoForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsUnlockRepoForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const migrationsListReposForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsListReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "migrationsListReposForAuthenticatedUser",
    "/user/migrations/:migration_id/repositories",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          migrationsListReposForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          migrationsListReposForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .migrationsListReposForAuthenticatedUser(
          input,
          migrationsListReposForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = migrationsListReposForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "orgsListForAuthenticatedUser",
    "/user/orgs",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          orgsListForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .orgsListForAuthenticatedUser(
          input,
          orgsListForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = orgsListForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesListPackagesForAuthenticatedUserQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "packagesListPackagesForAuthenticatedUser",
    "/user/packages",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          packagesListPackagesForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesListPackagesForAuthenticatedUser(
          input,
          packagesListPackagesForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesListPackagesForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesGetPackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
  })

  router.get(
    "packagesGetPackageForAuthenticatedUser",
    "/user/packages/:package_type/:package_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetPackageForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetPackageForAuthenticatedUser(
          input,
          packagesGetPackageForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetPackageForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesDeletePackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
  })

  router.delete(
    "packagesDeletePackageForAuthenticatedUser",
    "/user/packages/:package_type/:package_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesDeletePackageForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesDeletePackageForAuthenticatedUser(
          input,
          packagesDeletePackageForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesDeletePackageForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesRestorePackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
  })

  const packagesRestorePackageForAuthenticatedUserQuerySchema = z.object({
    token: z.string().optional(),
  })

  router.post(
    "packagesRestorePackageForAuthenticatedUser",
    "/user/packages/:package_type/:package_name/restore",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesRestorePackageForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          packagesRestorePackageForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesRestorePackageForAuthenticatedUser(
          input,
          packagesRestorePackageForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesRestorePackageForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema =
    z.object({
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
    })

  const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema =
    z.object({
      page: z.coerce.number().optional().default(1),
      per_page: z.coerce.number().optional().default(30),
      state: z.enum(["active", "deleted"]).optional().default("active"),
    })

  router.get(
    "packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
    "/user/packages/:package_type/:package_name/versions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
          input,
          packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const packagesGetPackageVersionForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    package_version_id: z.coerce.number(),
  })

  router.get(
    "packagesGetPackageVersionForAuthenticatedUser",
    "/user/packages/:package_type/:package_name/versions/:package_version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetPackageVersionForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetPackageVersionForAuthenticatedUser(
          input,
          packagesGetPackageVersionForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetPackageVersionForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesDeletePackageVersionForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    package_version_id: z.coerce.number(),
  })

  router.delete(
    "packagesDeletePackageVersionForAuthenticatedUser",
    "/user/packages/:package_type/:package_name/versions/:package_version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesDeletePackageVersionForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesDeletePackageVersionForAuthenticatedUser(
          input,
          packagesDeletePackageVersionForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesDeletePackageVersionForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesRestorePackageVersionForAuthenticatedUserParamSchema = z.object(
    {
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
      package_version_id: z.coerce.number(),
    },
  )

  router.post(
    "packagesRestorePackageVersionForAuthenticatedUser",
    "/user/packages/:package_type/:package_name/versions/:package_version_id/restore",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesRestorePackageVersionForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesRestorePackageVersionForAuthenticatedUser(
          input,
          packagesRestorePackageVersionForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesRestorePackageVersionForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const projectsCreateForAuthenticatedUserBodySchema = z.object({
    name: z.string(),
    body: z.string().nullable().optional(),
  })

  router.post(
    "projectsCreateForAuthenticatedUser",
    "/user/projects",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          projectsCreateForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .projectsCreateForAuthenticatedUser(
          input,
          projectsCreateForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsCreateForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListPublicEmailsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListPublicEmailsForAuthenticatedUser",
    "/user/public_emails",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListPublicEmailsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListPublicEmailsForAuthenticatedUser(
          input,
          usersListPublicEmailsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListPublicEmailsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposListForAuthenticatedUserQuerySchema = z.object({
    visibility: z.enum(["all", "public", "private"]).optional().default("all"),
    affiliation: z
      .string()
      .optional()
      .default("owner,collaborator,organization_member"),
    type: z
      .enum(["all", "owner", "public", "private", "member"])
      .optional()
      .default("all"),
    sort: z
      .enum(["created", "updated", "pushed", "full_name"])
      .optional()
      .default("full_name"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
    since: z.string().datetime({ offset: true }).optional(),
    before: z.string().datetime({ offset: true }).optional(),
  })

  router.get(
    "reposListForAuthenticatedUser",
    "/user/repos",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          reposListForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListForAuthenticatedUser(
          input,
          reposListForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposCreateForAuthenticatedUserBodySchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    homepage: z.string().optional(),
    private: PermissiveBoolean.optional().default(false),
    has_issues: PermissiveBoolean.optional().default(true),
    has_projects: PermissiveBoolean.optional().default(true),
    has_wiki: PermissiveBoolean.optional().default(true),
    has_discussions: PermissiveBoolean.optional().default(false),
    team_id: z.coerce.number().optional(),
    auto_init: PermissiveBoolean.optional().default(false),
    gitignore_template: z.string().optional(),
    license_template: z.string().optional(),
    allow_squash_merge: PermissiveBoolean.optional().default(true),
    allow_merge_commit: PermissiveBoolean.optional().default(true),
    allow_rebase_merge: PermissiveBoolean.optional().default(true),
    allow_auto_merge: PermissiveBoolean.optional().default(false),
    delete_branch_on_merge: PermissiveBoolean.optional().default(false),
    squash_merge_commit_title: z
      .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
      .optional(),
    squash_merge_commit_message: z
      .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
      .optional(),
    merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
    merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
    has_downloads: PermissiveBoolean.optional().default(true),
    is_template: PermissiveBoolean.optional().default(false),
  })

  router.post(
    "reposCreateForAuthenticatedUser",
    "/user/repos",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          reposCreateForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .reposCreateForAuthenticatedUser(
          input,
          reposCreateForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposCreateForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListInvitationsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListInvitationsForAuthenticatedUser",
    "/user/repository_invitations",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          reposListInvitationsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListInvitationsForAuthenticatedUser(
          input,
          reposListInvitationsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListInvitationsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposAcceptInvitationForAuthenticatedUserParamSchema = z.object({
    invitation_id: z.coerce.number(),
  })

  router.patch(
    "reposAcceptInvitationForAuthenticatedUser",
    "/user/repository_invitations/:invitation_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposAcceptInvitationForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposAcceptInvitationForAuthenticatedUser(
          input,
          reposAcceptInvitationForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposAcceptInvitationForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const reposDeclineInvitationForAuthenticatedUserParamSchema = z.object({
    invitation_id: z.coerce.number(),
  })

  router.delete(
    "reposDeclineInvitationForAuthenticatedUser",
    "/user/repository_invitations/:invitation_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposDeclineInvitationForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposDeclineInvitationForAuthenticatedUser(
          input,
          reposDeclineInvitationForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposDeclineInvitationForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersListSocialAccountsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListSocialAccountsForAuthenticatedUser",
    "/user/social_accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListSocialAccountsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListSocialAccountsForAuthenticatedUser(
          input,
          usersListSocialAccountsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListSocialAccountsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersAddSocialAccountForAuthenticatedUserBodySchema = z.object({
    account_urls: z.array(z.string()),
  })

  router.post(
    "usersAddSocialAccountForAuthenticatedUser",
    "/user/social_accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersAddSocialAccountForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersAddSocialAccountForAuthenticatedUser(
          input,
          usersAddSocialAccountForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersAddSocialAccountForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersDeleteSocialAccountForAuthenticatedUserBodySchema = z.object({
    account_urls: z.array(z.string()),
  })

  router.delete(
    "usersDeleteSocialAccountForAuthenticatedUser",
    "/user/social_accounts",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersDeleteSocialAccountForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersDeleteSocialAccountForAuthenticatedUser(
          input,
          usersDeleteSocialAccountForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersDeleteSocialAccountForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersListSshSigningKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListSshSigningKeysForAuthenticatedUser",
    "/user/ssh_signing_keys",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          usersListSshSigningKeysForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListSshSigningKeysForAuthenticatedUser(
          input,
          usersListSshSigningKeysForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListSshSigningKeysForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersCreateSshSigningKeyForAuthenticatedUserBodySchema = z.object({
    title: z.string().optional(),
    key: z
      .string()
      .regex(
        new RegExp(
          "^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com ",
        ),
      ),
  })

  router.post(
    "usersCreateSshSigningKeyForAuthenticatedUser",
    "/user/ssh_signing_keys",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          usersCreateSshSigningKeyForAuthenticatedUserBodySchema,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const response = await implementation
        .usersCreateSshSigningKeyForAuthenticatedUser(
          input,
          usersCreateSshSigningKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersCreateSshSigningKeyForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersGetSshSigningKeyForAuthenticatedUserParamSchema = z.object({
    ssh_signing_key_id: z.coerce.number(),
  })

  router.get(
    "usersGetSshSigningKeyForAuthenticatedUser",
    "/user/ssh_signing_keys/:ssh_signing_key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersGetSshSigningKeyForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersGetSshSigningKeyForAuthenticatedUser(
          input,
          usersGetSshSigningKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersGetSshSigningKeyForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const usersDeleteSshSigningKeyForAuthenticatedUserParamSchema = z.object({
    ssh_signing_key_id: z.coerce.number(),
  })

  router.delete(
    "usersDeleteSshSigningKeyForAuthenticatedUser",
    "/user/ssh_signing_keys/:ssh_signing_key_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersDeleteSshSigningKeyForAuthenticatedUser(
          input,
          usersDeleteSshSigningKeyForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersDeleteSshSigningKeyForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const activityListReposStarredByAuthenticatedUserQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListReposStarredByAuthenticatedUser",
    "/user/starred",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          activityListReposStarredByAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListReposStarredByAuthenticatedUser(
          input,
          activityListReposStarredByAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListReposStarredByAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const activityCheckRepoIsStarredByAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.get(
    "activityCheckRepoIsStarredByAuthenticatedUser",
    "/user/starred/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityCheckRepoIsStarredByAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityCheckRepoIsStarredByAuthenticatedUser(
          input,
          activityCheckRepoIsStarredByAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityCheckRepoIsStarredByAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const activityStarRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.put(
    "activityStarRepoForAuthenticatedUser",
    "/user/starred/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityStarRepoForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityStarRepoForAuthenticatedUser(
          input,
          activityStarRepoForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityStarRepoForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityUnstarRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.string(),
    repo: z.string(),
  })

  router.delete(
    "activityUnstarRepoForAuthenticatedUser",
    "/user/starred/:owner/:repo",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityUnstarRepoForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityUnstarRepoForAuthenticatedUser(
          input,
          activityUnstarRepoForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityUnstarRepoForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListWatchedReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListWatchedReposForAuthenticatedUser",
    "/user/subscriptions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          activityListWatchedReposForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListWatchedReposForAuthenticatedUser(
          input,
          activityListWatchedReposForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListWatchedReposForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const teamsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "teamsListForAuthenticatedUser",
    "/user/teams",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          teamsListForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .teamsListForAuthenticatedUser(
          input,
          teamsListForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = teamsListForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersGetByIdParamSchema = z.object({ account_id: z.coerce.number() })

  router.get("usersGetById", "/user/:account_id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        usersGetByIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .usersGetById(input, usersGetById.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersGetById.validator(status, body)
    ctx.status = status
    return next()
  })

  const usersListQuerySchema = z.object({
    since: z.coerce.number().optional(),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get("usersList", "/users", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        usersListQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .usersList(input, usersList.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersList.validator(status, body)
    ctx.status = status
    return next()
  })

  const usersGetByUsernameParamSchema = z.object({ username: z.string() })

  router.get("usersGetByUsername", "/users/:username", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        usersGetByUsernameParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .usersGetByUsername(input, usersGetByUsername.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = usersGetByUsername.validator(status, body)
    ctx.status = status
    return next()
  })

  const usersListAttestationsParamSchema = z.object({
    username: z.string(),
    subject_digest: z.string(),
  })

  const usersListAttestationsQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    before: z.string().optional(),
    after: z.string().optional(),
    predicate_type: z.string().optional(),
  })

  router.get(
    "usersListAttestations",
    "/users/:username/attestations/:subject_digest",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersListAttestationsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersListAttestationsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListAttestations(input, usersListAttestations.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListAttestations.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesListDockerMigrationConflictingPackagesForUserParamSchema =
    z.object({ username: z.string() })

  router.get(
    "packagesListDockerMigrationConflictingPackagesForUser",
    "/users/:username/docker/conflicts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesListDockerMigrationConflictingPackagesForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesListDockerMigrationConflictingPackagesForUser(
          input,
          packagesListDockerMigrationConflictingPackagesForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        packagesListDockerMigrationConflictingPackagesForUser.validator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const activityListEventsForAuthenticatedUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListEventsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListEventsForAuthenticatedUser",
    "/users/:username/events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListEventsForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListEventsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListEventsForAuthenticatedUser(
          input,
          activityListEventsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListEventsForAuthenticatedUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListOrgEventsForAuthenticatedUserParamSchema = z.object({
    username: z.string(),
    org: z.string(),
  })

  const activityListOrgEventsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListOrgEventsForAuthenticatedUser",
    "/users/:username/events/orgs/:org",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListOrgEventsForAuthenticatedUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListOrgEventsForAuthenticatedUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListOrgEventsForAuthenticatedUser(
          input,
          activityListOrgEventsForAuthenticatedUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListOrgEventsForAuthenticatedUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const activityListPublicEventsForUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListPublicEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListPublicEventsForUser",
    "/users/:username/events/public",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListPublicEventsForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListPublicEventsForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListPublicEventsForUser(
          input,
          activityListPublicEventsForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListPublicEventsForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListFollowersForUserParamSchema = z.object({
    username: z.string(),
  })

  const usersListFollowersForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListFollowersForUser",
    "/users/:username/followers",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersListFollowersForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersListFollowersForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListFollowersForUser(
          input,
          usersListFollowersForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListFollowersForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListFollowingForUserParamSchema = z.object({
    username: z.string(),
  })

  const usersListFollowingForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListFollowingForUser",
    "/users/:username/following",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersListFollowingForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersListFollowingForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListFollowingForUser(
          input,
          usersListFollowingForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListFollowingForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersCheckFollowingForUserParamSchema = z.object({
    username: z.string(),
    target_user: z.string(),
  })

  router.get(
    "usersCheckFollowingForUser",
    "/users/:username/following/:target_user",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersCheckFollowingForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersCheckFollowingForUser(
          input,
          usersCheckFollowingForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersCheckFollowingForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const gistsListForUserParamSchema = z.object({ username: z.string() })

  const gistsListForUserQuerySchema = z.object({
    since: z.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "gistsListForUser",
    "/users/:username/gists",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          gistsListForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          gistsListForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .gistsListForUser(input, gistsListForUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = gistsListForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListGpgKeysForUserParamSchema = z.object({ username: z.string() })

  const usersListGpgKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListGpgKeysForUser",
    "/users/:username/gpg_keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersListGpgKeysForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersListGpgKeysForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListGpgKeysForUser(input, usersListGpgKeysForUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListGpgKeysForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersGetContextForUserParamSchema = z.object({ username: z.string() })

  const usersGetContextForUserQuerySchema = z.object({
    subject_type: z
      .enum(["organization", "repository", "issue", "pull_request"])
      .optional(),
    subject_id: z.string().optional(),
  })

  router.get(
    "usersGetContextForUser",
    "/users/:username/hovercard",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersGetContextForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersGetContextForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersGetContextForUser(input, usersGetContextForUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersGetContextForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const appsGetUserInstallationParamSchema = z.object({ username: z.string() })

  router.get(
    "appsGetUserInstallation",
    "/users/:username/installation",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          appsGetUserInstallationParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .appsGetUserInstallation(input, appsGetUserInstallation.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = appsGetUserInstallation.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListPublicKeysForUserParamSchema = z.object({
    username: z.string(),
  })

  const usersListPublicKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListPublicKeysForUser",
    "/users/:username/keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersListPublicKeysForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersListPublicKeysForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListPublicKeysForUser(
          input,
          usersListPublicKeysForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListPublicKeysForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const orgsListForUserParamSchema = z.object({ username: z.string() })

  const orgsListForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get("orgsListForUser", "/users/:username/orgs", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        orgsListForUserParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: parseRequestInput(
        orgsListForUserQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .orgsListForUser(input, orgsListForUser.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = orgsListForUser.validator(status, body)
    ctx.status = status
    return next()
  })

  const packagesListPackagesForUserParamSchema = z.object({
    username: z.string(),
  })

  const packagesListPackagesForUserQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
    page: z.coerce.number().optional().default(1),
    per_page: z.coerce.number().optional().default(30),
  })

  router.get(
    "packagesListPackagesForUser",
    "/users/:username/packages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesListPackagesForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          packagesListPackagesForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesListPackagesForUser(
          input,
          packagesListPackagesForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesListPackagesForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesGetPackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
  })

  router.get(
    "packagesGetPackageForUser",
    "/users/:username/packages/:package_type/:package_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetPackageForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetPackageForUser(
          input,
          packagesGetPackageForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetPackageForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesDeletePackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
  })

  router.delete(
    "packagesDeletePackageForUser",
    "/users/:username/packages/:package_type/:package_name",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesDeletePackageForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesDeletePackageForUser(
          input,
          packagesDeletePackageForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesDeletePackageForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesRestorePackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
  })

  const packagesRestorePackageForUserQuerySchema = z.object({
    token: z.string().optional(),
  })

  router.post(
    "packagesRestorePackageForUser",
    "/users/:username/packages/:package_type/:package_name/restore",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesRestorePackageForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          packagesRestorePackageForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesRestorePackageForUser(
          input,
          packagesRestorePackageForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesRestorePackageForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesGetAllPackageVersionsForPackageOwnedByUserParamSchema =
    z.object({
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.string(),
      username: z.string(),
    })

  router.get(
    "packagesGetAllPackageVersionsForPackageOwnedByUser",
    "/users/:username/packages/:package_type/:package_name/versions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetAllPackageVersionsForPackageOwnedByUser(
          input,
          packagesGetAllPackageVersionsForPackageOwnedByUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetAllPackageVersionsForPackageOwnedByUser.validator(
        status,
        body,
      )
      ctx.status = status
      return next()
    },
  )

  const packagesGetPackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    package_version_id: z.coerce.number(),
    username: z.string(),
  })

  router.get(
    "packagesGetPackageVersionForUser",
    "/users/:username/packages/:package_type/:package_name/versions/:package_version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesGetPackageVersionForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesGetPackageVersionForUser(
          input,
          packagesGetPackageVersionForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesGetPackageVersionForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesDeletePackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
    package_version_id: z.coerce.number(),
  })

  router.delete(
    "packagesDeletePackageVersionForUser",
    "/users/:username/packages/:package_type/:package_name/versions/:package_version_id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesDeletePackageVersionForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesDeletePackageVersionForUser(
          input,
          packagesDeletePackageVersionForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesDeletePackageVersionForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const packagesRestorePackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.string(),
    username: z.string(),
    package_version_id: z.coerce.number(),
  })

  router.post(
    "packagesRestorePackageVersionForUser",
    "/users/:username/packages/:package_type/:package_name/versions/:package_version_id/restore",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          packagesRestorePackageVersionForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .packagesRestorePackageVersionForUser(
          input,
          packagesRestorePackageVersionForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = packagesRestorePackageVersionForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const projectsListForUserParamSchema = z.object({ username: z.string() })

  const projectsListForUserQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional().default("open"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "projectsListForUser",
    "/users/:username/projects",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          projectsListForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          projectsListForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .projectsListForUser(input, projectsListForUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = projectsListForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListReceivedEventsForUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReceivedEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListReceivedEventsForUser",
    "/users/:username/received_events",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListReceivedEventsForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListReceivedEventsForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListReceivedEventsForUser(
          input,
          activityListReceivedEventsForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListReceivedEventsForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListReceivedPublicEventsForUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReceivedPublicEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListReceivedPublicEventsForUser",
    "/users/:username/received_events/public",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListReceivedPublicEventsForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListReceivedPublicEventsForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListReceivedPublicEventsForUser(
          input,
          activityListReceivedPublicEventsForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListReceivedPublicEventsForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const reposListForUserParamSchema = z.object({ username: z.string() })

  const reposListForUserQuerySchema = z.object({
    type: z.enum(["all", "owner", "member"]).optional().default("owner"),
    sort: z
      .enum(["created", "updated", "pushed", "full_name"])
      .optional()
      .default("full_name"),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "reposListForUser",
    "/users/:username/repos",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          reposListForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          reposListForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .reposListForUser(input, reposListForUser.responder, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = reposListForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const billingGetGithubActionsBillingUserParamSchema = z.object({
    username: z.string(),
  })

  router.get(
    "billingGetGithubActionsBillingUser",
    "/users/:username/settings/billing/actions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          billingGetGithubActionsBillingUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .billingGetGithubActionsBillingUser(
          input,
          billingGetGithubActionsBillingUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = billingGetGithubActionsBillingUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const billingGetGithubPackagesBillingUserParamSchema = z.object({
    username: z.string(),
  })

  router.get(
    "billingGetGithubPackagesBillingUser",
    "/users/:username/settings/billing/packages",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          billingGetGithubPackagesBillingUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .billingGetGithubPackagesBillingUser(
          input,
          billingGetGithubPackagesBillingUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = billingGetGithubPackagesBillingUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const billingGetSharedStorageBillingUserParamSchema = z.object({
    username: z.string(),
  })

  router.get(
    "billingGetSharedStorageBillingUser",
    "/users/:username/settings/billing/shared-storage",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          billingGetSharedStorageBillingUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .billingGetSharedStorageBillingUser(
          input,
          billingGetSharedStorageBillingUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = billingGetSharedStorageBillingUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListSocialAccountsForUserParamSchema = z.object({
    username: z.string(),
  })

  const usersListSocialAccountsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListSocialAccountsForUser",
    "/users/:username/social_accounts",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersListSocialAccountsForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersListSocialAccountsForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListSocialAccountsForUser(
          input,
          usersListSocialAccountsForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListSocialAccountsForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const usersListSshSigningKeysForUserParamSchema = z.object({
    username: z.string(),
  })

  const usersListSshSigningKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "usersListSshSigningKeysForUser",
    "/users/:username/ssh_signing_keys",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          usersListSshSigningKeysForUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          usersListSshSigningKeysForUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .usersListSshSigningKeysForUser(
          input,
          usersListSshSigningKeysForUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = usersListSshSigningKeysForUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListReposStarredByUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReposStarredByUserQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional().default("created"),
    direction: z.enum(["asc", "desc"]).optional().default("desc"),
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListReposStarredByUser",
    "/users/:username/starred",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListReposStarredByUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListReposStarredByUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListReposStarredByUser(
          input,
          activityListReposStarredByUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListReposStarredByUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  const activityListReposWatchedByUserParamSchema = z.object({
    username: z.string(),
  })

  const activityListReposWatchedByUserQuerySchema = z.object({
    per_page: z.coerce.number().optional().default(30),
    page: z.coerce.number().optional().default(1),
  })

  router.get(
    "activityListReposWatchedByUser",
    "/users/:username/subscriptions",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          activityListReposWatchedByUserParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          activityListReposWatchedByUserQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const response = await implementation
        .activityListReposWatchedByUser(
          input,
          activityListReposWatchedByUser.responder,
          ctx,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      const { status, body } =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = activityListReposWatchedByUser.validator(status, body)
      ctx.status = status
      return next()
    },
  )

  router.get("metaGetAllVersions", "/versions", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .metaGetAllVersions(input, metaGetAllVersions.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = metaGetAllVersions.validator(status, body)
    ctx.status = status
    return next()
  })

  router.get("metaGetZen", "/zen", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const response = await implementation
      .metaGetZen(input, metaGetZen.responder, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    const { status, body } =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = metaGetZen.validator(status, body)
    ctx.status = status
    return next()
  })

  return router
}

export async function bootstrap(config: ServerConfig) {
  // GitHub v3 REST API
  return startServer(config)
}
