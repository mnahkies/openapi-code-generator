/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import KoaRouter, {type RouterContext} from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  type KoaRuntimeResponder,
  KoaRuntimeResponse,
  type Params,
  type Response,
  type ServerConfig,
  SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod-v4"
import type {Next} from "koa"
import {z} from "zod/v4"
import type {
  t_AddPetBodySchema,
  t_DeletePetParamSchema,
  t_Error,
  t_FindPetByIdParamSchema,
  t_FindPetsQuerySchema,
  t_Pet,
} from "./models"
import {s_Error, s_NewPet, s_Pet} from "./schemas"

export type FindPetsResponder = {
  with200(): KoaRuntimeResponse<t_Pet[]>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type FindPets = (
  params: Params<void, t_FindPetsQuerySchema, void, void>,
  respond: FindPetsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Pet[]>
  | Response<StatusCode, t_Error>
  | typeof SkipResponse
>

export type AddPetResponder = {
  with200(): KoaRuntimeResponse<t_Pet>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type AddPet = (
  params: Params<void, void, t_AddPetBodySchema, void>,
  respond: AddPetResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Pet>
  | Response<StatusCode, t_Error>
  | typeof SkipResponse
>

export type FindPetByIdResponder = {
  with200(): KoaRuntimeResponse<t_Pet>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type FindPetById = (
  params: Params<t_FindPetByIdParamSchema, void, void, void>,
  respond: FindPetByIdResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<200, t_Pet>
  | Response<StatusCode, t_Error>
  | typeof SkipResponse
>

export type DeletePetResponder = {
  with204(): KoaRuntimeResponse<void>
  withDefault(status: StatusCode): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeletePet = (
  params: Params<t_DeletePetParamSchema, void, void, void>,
  respond: DeletePetResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Response<204, void>
  | Response<StatusCode, t_Error>
  | typeof SkipResponse
>

export type Implementation = {
  findPets: FindPets
  addPet: AddPet
  findPetById: FindPetById
  deletePet: DeletePet
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const findPetsQuerySchema = z.object({
    tags: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()),
      )
      .optional(),
    limit: z.coerce.number().optional(),
  })

  const findPetsResponseValidator = responseValidationFactory(
    [["200", z.array(s_Pet)]],
    s_Error,
  )

  router.get("findPets", "/pets", async (ctx, next) => {
    const input = {
      params: undefined,
      query: parseRequestInput(
        findPetsQuerySchema,
        ctx.query,
        RequestInputType.QueryString,
      ),
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Pet[]>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_Error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .findPets(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = findPetsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const addPetBodySchema = s_NewPet

  const addPetResponseValidator = responseValidationFactory(
    [["200", s_Pet]],
    s_Error,
  )

  router.post("addPet", "/pets", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        addPetBodySchema,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Pet>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_Error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .addPet(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = addPetResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const findPetByIdParamSchema = z.object({id: z.coerce.number()})

  const findPetByIdResponseValidator = responseValidationFactory(
    [["200", s_Pet]],
    s_Error,
  )

  router.get("findPetById", "/pets/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        findPetByIdParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Pet>(200)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_Error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .findPetById(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = findPetByIdResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deletePetParamSchema = z.object({id: z.coerce.number()})

  const deletePetResponseValidator = responseValidationFactory(
    [["204", z.undefined()]],
    s_Error,
  )

  router.delete("deletePet", "/pets/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        deletePetParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with204() {
        return new KoaRuntimeResponse<void>(204)
      },
      withDefault(status: StatusCode) {
        return new KoaRuntimeResponse<t_Error>(status)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .deletePet(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = deletePetResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Swagger Petstore
  return startServer(config)
}
