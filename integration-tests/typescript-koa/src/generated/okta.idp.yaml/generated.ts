/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import KoaRouter, {type RouterContext} from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  type KoaRuntimeResponder,
  KoaRuntimeResponse,
  type Params,
  type Res,
  type ServerConfig,
  SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod-v4"
import type {Next} from "koa"
import {z} from "zod/v4"
import type {
  t_AppAuthenticatorEnrollment,
  t_AppAuthenticatorEnrollmentRequest,
  t_Authenticator,
  t_AuthenticatorEnrollment,
  t_CreateEmailRequestBody,
  t_CreatePasswordRequestBody,
  t_CreatePhoneRequestBody,
  t_DeleteAppAuthenticatorEnrollmentParamSchema,
  t_DeleteEmailParamSchema,
  t_DeletePhoneParamSchema,
  t_Email,
  t_Error,
  t_GetAuthenticatorParamSchema,
  t_GetAuthenticatorQuerySchema,
  t_GetEmailParamSchema,
  t_GetEnrollmentParamSchema,
  t_GetPhoneParamSchema,
  t_ListAppAuthenticatorPendingPushNotificationChallengesParamSchema,
  t_ListAuthenticatorsQuerySchema,
  t_ListEnrollmentsParamSchema,
  t_OktaApplication,
  t_Organization,
  t_PasswordResponse,
  t_Phone,
  t_PollChallengeForEmailMagicLinkParamSchema,
  t_Profile,
  t_PushNotificationChallenge,
  t_PushNotificationVerification,
  t_ReplacePasswordRequestBody,
  t_ReplaceProfileRequestBody,
  t_Schema,
  t_SendEmailChallengeParamSchema,
  t_SendEmailChallengeRequestBody,
  t_SendPhoneChallengeParamSchema,
  t_SendPhoneChallengeRequestBody,
  t_UpdateAppAuthenticatorEnrollmentParamSchema,
  t_UpdateAppAuthenticatorEnrollmentRequest,
  t_UpdateAuthenticatorEnrollmentRequest,
  t_UpdateEnrollmentParamSchema,
  t_VerifyAppAuthenticatorPushNotificationChallengeParamSchema,
  t_VerifyEmailOtpParamSchema,
  t_VerifyEmailOtpRequestBody,
  t_VerifyPhoneChallengeParamSchema,
  t_VerifyPhoneChallengeRequestBody,
} from "./models"
import {
  s_AppAuthenticatorEnrollment,
  s_AppAuthenticatorEnrollmentRequest,
  s_Authenticator,
  s_AuthenticatorEnrollment,
  s_CreateEmailRequestBody,
  s_CreatePasswordRequestBody,
  s_CreatePhoneRequestBody,
  s_Email,
  s_Error,
  s_OktaApplication,
  s_Organization,
  s_PasswordResponse,
  s_Phone,
  s_Profile,
  s_PushNotificationChallenge,
  s_PushNotificationVerification,
  s_ReplacePasswordRequestBody,
  s_ReplaceProfileRequestBody,
  s_Schema,
  s_SendEmailChallengeRequestBody,
  s_SendPhoneChallengeRequestBody,
  s_UpdateAppAuthenticatorEnrollmentRequest,
  s_UpdateAuthenticatorEnrollmentRequest,
  s_VerifyEmailOtpRequestBody,
  s_VerifyPhoneChallengeRequestBody,
} from "./schemas"

export type CreateAppAuthenticatorEnrollmentResponder = {
  with200(): KoaRuntimeResponse<t_AppAuthenticatorEnrollment>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type CreateAppAuthenticatorEnrollment = (
  params: Params<void, void, t_AppAuthenticatorEnrollmentRequest, void>,
  respond: CreateAppAuthenticatorEnrollmentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_AppAuthenticatorEnrollment>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type VerifyAppAuthenticatorPushNotificationChallengeResponder = {
  with200(): KoaRuntimeResponse<void>
  with204(): KoaRuntimeResponse<void>
  with400(): KoaRuntimeResponse<void>
} & KoaRuntimeResponder

export type VerifyAppAuthenticatorPushNotificationChallenge = (
  params: Params<
    t_VerifyAppAuthenticatorPushNotificationChallengeParamSchema,
    void,
    t_PushNotificationVerification,
    void
  >,
  respond: VerifyAppAuthenticatorPushNotificationChallengeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, void>
  | Res<204, void>
  | Res<400, void>
  | typeof SkipResponse
>

export type UpdateAppAuthenticatorEnrollmentResponder = {
  with200(): KoaRuntimeResponse<t_AppAuthenticatorEnrollment>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type UpdateAppAuthenticatorEnrollment = (
  params: Params<
    t_UpdateAppAuthenticatorEnrollmentParamSchema,
    void,
    t_UpdateAppAuthenticatorEnrollmentRequest,
    void
  >,
  respond: UpdateAppAuthenticatorEnrollmentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_AppAuthenticatorEnrollment>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type DeleteAppAuthenticatorEnrollmentResponder = {
  with204(): KoaRuntimeResponse<void>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeleteAppAuthenticatorEnrollment = (
  params: Params<
    t_DeleteAppAuthenticatorEnrollmentParamSchema,
    void,
    void,
    void
  >,
  respond: DeleteAppAuthenticatorEnrollmentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<204, void>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type ListAppAuthenticatorPendingPushNotificationChallengesResponder = {
  with200(): KoaRuntimeResponse<t_PushNotificationChallenge[]>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ListAppAuthenticatorPendingPushNotificationChallenges = (
  params: Params<
    t_ListAppAuthenticatorPendingPushNotificationChallengesParamSchema,
    void,
    void,
    void
  >,
  respond: ListAppAuthenticatorPendingPushNotificationChallengesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_PushNotificationChallenge[]>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type ListAuthenticatorsResponder = {
  with200(): KoaRuntimeResponse<t_Authenticator[]>
  with403(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ListAuthenticators = (
  params: Params<void, t_ListAuthenticatorsQuerySchema, void, void>,
  respond: ListAuthenticatorsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Authenticator[]>
  | Res<403, t_Error>
  | Res<429, t_Error>
  | typeof SkipResponse
>

export type GetAuthenticatorResponder = {
  with200(): KoaRuntimeResponse<t_Authenticator>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetAuthenticator = (
  params: Params<
    t_GetAuthenticatorParamSchema,
    t_GetAuthenticatorQuerySchema,
    void,
    void
  >,
  respond: GetAuthenticatorResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Authenticator>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | Res<429, t_Error>
  | typeof SkipResponse
>

export type ListEnrollmentsResponder = {
  with200(): KoaRuntimeResponse<t_AuthenticatorEnrollment[]>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ListEnrollments = (
  params: Params<t_ListEnrollmentsParamSchema, void, void, void>,
  respond: ListEnrollmentsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_AuthenticatorEnrollment[]>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | Res<429, t_Error>
  | typeof SkipResponse
>

export type GetEnrollmentResponder = {
  with200(): KoaRuntimeResponse<t_AuthenticatorEnrollment>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with429(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetEnrollment = (
  params: Params<t_GetEnrollmentParamSchema, void, void, void>,
  respond: GetEnrollmentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_AuthenticatorEnrollment>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | Res<429, t_Error>
  | typeof SkipResponse
>

export type UpdateEnrollmentResponder = {
  with200(): KoaRuntimeResponse<t_AuthenticatorEnrollment>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type UpdateEnrollment = (
  params: Params<
    t_UpdateEnrollmentParamSchema,
    void,
    t_UpdateAuthenticatorEnrollmentRequest,
    void
  >,
  respond: UpdateEnrollmentResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_AuthenticatorEnrollment>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type ListEmailsResponder = {
  with200(): KoaRuntimeResponse<t_Email[]>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ListEmails = (
  params: Params<void, void, void, void>,
  respond: ListEmailsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Email[]>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type CreateEmailResponder = {
  with201(): KoaRuntimeResponse<t_Email>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with409(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type CreateEmail = (
  params: Params<void, void, t_CreateEmailRequestBody, void>,
  respond: CreateEmailResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<201, t_Email>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<409, t_Error>
  | typeof SkipResponse
>

export type GetEmailResponder = {
  with200(): KoaRuntimeResponse<t_Email>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetEmail = (
  params: Params<t_GetEmailParamSchema, void, void, void>,
  respond: GetEmailResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Email>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type DeleteEmailResponder = {
  with204(): KoaRuntimeResponse<void>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeleteEmail = (
  params: Params<t_DeleteEmailParamSchema, void, void, void>,
  respond: DeleteEmailResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<204, void>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type SendEmailChallengeResponder = {
  with201(): KoaRuntimeResponse<{
    _links: {
      poll: {
        hints: {
          allow: "GET"[]
        }
        href: string
      }
      verify: {
        hints: {
          allow: "POST"[]
        }
        href: string
      }
    }
    expiresAt: string
    id: string
    profile: {
      email: string
    }
    status: "VERIFIED" | "UNVERIFIED"
  }>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type SendEmailChallenge = (
  params: Params<
    t_SendEmailChallengeParamSchema,
    void,
    t_SendEmailChallengeRequestBody,
    void
  >,
  respond: SendEmailChallengeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<
      201,
      {
        _links: {
          poll: {
            hints: {
              allow: "GET"[]
            }
            href: string
          }
          verify: {
            hints: {
              allow: "POST"[]
            }
            href: string
          }
        }
        expiresAt: string
        id: string
        profile: {
          email: string
        }
        status: "VERIFIED" | "UNVERIFIED"
      }
    >
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type PollChallengeForEmailMagicLinkResponder = {
  with200(): KoaRuntimeResponse<{
    _links: {
      poll: {
        hints: {
          allow: ("DELETE" | "GET" | "POST" | "PUT")[]
        }
        href: string
      }
      verify: {
        hints: {
          allow: ("DELETE" | "GET" | "POST" | "PUT")[]
        }
        href: string
      }
    }
    expiresAt: string
    id: string
    profile: {
      email: string
    }
    status: "VERIFIED" | "UNVERIFIED"
  }>
  with401(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type PollChallengeForEmailMagicLink = (
  params: Params<t_PollChallengeForEmailMagicLinkParamSchema, void, void, void>,
  respond: PollChallengeForEmailMagicLinkResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<
      200,
      {
        _links: {
          poll: {
            hints: {
              allow: ("DELETE" | "GET" | "POST" | "PUT")[]
            }
            href: string
          }
          verify: {
            hints: {
              allow: ("DELETE" | "GET" | "POST" | "PUT")[]
            }
            href: string
          }
        }
        expiresAt: string
        id: string
        profile: {
          email: string
        }
        status: "VERIFIED" | "UNVERIFIED"
      }
    >
  | Res<401, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type VerifyEmailOtpResponder = {
  with200(): KoaRuntimeResponse<void>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type VerifyEmailOtp = (
  params: Params<
    t_VerifyEmailOtpParamSchema,
    void,
    t_VerifyEmailOtpRequestBody,
    void
  >,
  respond: VerifyEmailOtpResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, void>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type ListOktaApplicationsResponder = {
  with200(): KoaRuntimeResponse<t_OktaApplication[]>
  with400(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ListOktaApplications = (
  params: Params<void, void, void, void>,
  respond: ListOktaApplicationsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_OktaApplication[]>
  | Res<400, t_Error>
  | typeof SkipResponse
>

export type GetOrganizationResponder = {
  with200(): KoaRuntimeResponse<t_Organization>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetOrganization = (
  params: Params<void, void, void, void>,
  respond: GetOrganizationResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Organization>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type GetPasswordResponder = {
  with200(): KoaRuntimeResponse<t_PasswordResponse>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetPassword = (
  params: Params<void, void, void, void>,
  respond: GetPasswordResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_PasswordResponse>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type CreatePasswordResponder = {
  with201(): KoaRuntimeResponse<t_PasswordResponse>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type CreatePassword = (
  params: Params<void, void, t_CreatePasswordRequestBody, void>,
  respond: CreatePasswordResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<201, t_PasswordResponse>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | typeof SkipResponse
>

export type ReplacePasswordResponder = {
  with201(): KoaRuntimeResponse<t_PasswordResponse>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ReplacePassword = (
  params: Params<void, void, t_ReplacePasswordRequestBody, void>,
  respond: ReplacePasswordResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<201, t_PasswordResponse>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | typeof SkipResponse
>

export type DeletePasswordResponder = {
  with204(): KoaRuntimeResponse<void>
  with401(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeletePassword = (
  params: Params<void, void, void, void>,
  respond: DeletePasswordResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<204, void>
  | Res<401, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type ListPhonesResponder = {
  with200(): KoaRuntimeResponse<t_Phone[]>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ListPhones = (
  params: Params<void, void, void, void>,
  respond: ListPhonesResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Phone[]>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type CreatePhoneResponder = {
  with201(): KoaRuntimeResponse<t_Phone>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with409(): KoaRuntimeResponse<t_Error>
  with500(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type CreatePhone = (
  params: Params<void, void, t_CreatePhoneRequestBody, void>,
  respond: CreatePhoneResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<201, t_Phone>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<409, t_Error>
  | Res<500, t_Error>
  | typeof SkipResponse
>

export type GetPhoneResponder = {
  with200(): KoaRuntimeResponse<t_Phone>
  with401(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetPhone = (
  params: Params<t_GetPhoneParamSchema, void, void, void>,
  respond: GetPhoneResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Phone>
  | Res<401, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type DeletePhoneResponder = {
  with204(): KoaRuntimeResponse<void>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeletePhone = (
  params: Params<t_DeletePhoneParamSchema, void, void, void>,
  respond: DeletePhoneResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<204, void>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type SendPhoneChallengeResponder = {
  with200(): KoaRuntimeResponse<{
    _links?: {
      verify?: {
        hints: {
          allow: "GET"[]
        }
        href: string
      }
    }
  }>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with500(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type SendPhoneChallenge = (
  params: Params<
    t_SendPhoneChallengeParamSchema,
    void,
    t_SendPhoneChallengeRequestBody,
    void
  >,
  respond: SendPhoneChallengeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<
      200,
      {
        _links?: {
          verify?: {
            hints: {
              allow: "GET"[]
            }
            href: string
          }
        }
      }
    >
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | Res<500, t_Error>
  | typeof SkipResponse
>

export type VerifyPhoneChallengeResponder = {
  with204(): KoaRuntimeResponse<void>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
  with403(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
  with409(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type VerifyPhoneChallenge = (
  params: Params<
    t_VerifyPhoneChallengeParamSchema,
    void,
    t_VerifyPhoneChallengeRequestBody,
    void
  >,
  respond: VerifyPhoneChallengeResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<204, void>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | Res<403, t_Error>
  | Res<404, t_Error>
  | Res<409, t_Error>
  | typeof SkipResponse
>

export type GetProfileResponder = {
  with200(): KoaRuntimeResponse<t_Profile>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetProfile = (
  params: Params<void, void, void, void>,
  respond: GetProfileResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Profile>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type ReplaceProfileResponder = {
  with200(): KoaRuntimeResponse<t_Profile>
  with400(): KoaRuntimeResponse<t_Error>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type ReplaceProfile = (
  params: Params<void, void, t_ReplaceProfileRequestBody, void>,
  respond: ReplaceProfileResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Profile>
  | Res<400, t_Error>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type GetProfileSchemaResponder = {
  with200(): KoaRuntimeResponse<t_Schema>
  with401(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type GetProfileSchema = (
  params: Params<void, void, void, void>,
  respond: GetProfileSchemaResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<200, t_Schema>
  | Res<401, t_Error>
  | typeof SkipResponse
>

export type DeleteSessionsResponder = {
  with204(): KoaRuntimeResponse<void>
  with401(): KoaRuntimeResponse<t_Error>
  with404(): KoaRuntimeResponse<t_Error>
} & KoaRuntimeResponder

export type DeleteSessions = (
  params: Params<void, void, void, void>,
  respond: DeleteSessionsResponder,
  ctx: RouterContext,
  next: Next,
) => Promise<
  | KoaRuntimeResponse<unknown>
  | Res<204, void>
  | Res<401, t_Error>
  | Res<404, t_Error>
  | typeof SkipResponse
>

export type Implementation = {
  createAppAuthenticatorEnrollment: CreateAppAuthenticatorEnrollment
  verifyAppAuthenticatorPushNotificationChallenge: VerifyAppAuthenticatorPushNotificationChallenge
  updateAppAuthenticatorEnrollment: UpdateAppAuthenticatorEnrollment
  deleteAppAuthenticatorEnrollment: DeleteAppAuthenticatorEnrollment
  listAppAuthenticatorPendingPushNotificationChallenges: ListAppAuthenticatorPendingPushNotificationChallenges
  listAuthenticators: ListAuthenticators
  getAuthenticator: GetAuthenticator
  listEnrollments: ListEnrollments
  getEnrollment: GetEnrollment
  updateEnrollment: UpdateEnrollment
  listEmails: ListEmails
  createEmail: CreateEmail
  getEmail: GetEmail
  deleteEmail: DeleteEmail
  sendEmailChallenge: SendEmailChallenge
  pollChallengeForEmailMagicLink: PollChallengeForEmailMagicLink
  verifyEmailOtp: VerifyEmailOtp
  listOktaApplications: ListOktaApplications
  getOrganization: GetOrganization
  getPassword: GetPassword
  createPassword: CreatePassword
  replacePassword: ReplacePassword
  deletePassword: DeletePassword
  listPhones: ListPhones
  createPhone: CreatePhone
  getPhone: GetPhone
  deletePhone: DeletePhone
  sendPhoneChallenge: SendPhoneChallenge
  verifyPhoneChallenge: VerifyPhoneChallenge
  getProfile: GetProfile
  replaceProfile: ReplaceProfile
  getProfileSchema: GetProfileSchema
  deleteSessions: DeleteSessions
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const createAppAuthenticatorEnrollmentResponseValidator =
    responseValidationFactory(
      [
        ["200", s_AppAuthenticatorEnrollment],
        ["400", s_Error],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.post(
    "createAppAuthenticatorEnrollment",
    "/idp/myaccount/app-authenticators",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          s_AppAuthenticatorEnrollmentRequest,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_AppAuthenticatorEnrollment>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .createAppAuthenticatorEnrollment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = createAppAuthenticatorEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const verifyAppAuthenticatorPushNotificationChallengeParamSchema = z.object({
    challengeId: z.string(),
  })

  const verifyAppAuthenticatorPushNotificationChallengeResponseValidator =
    responseValidationFactory(
      [
        ["200", z.undefined()],
        ["204", z.undefined()],
        ["400", z.undefined()],
      ],
      undefined,
    )

  router.post(
    "verifyAppAuthenticatorPushNotificationChallenge",
    "/idp/myaccount/app-authenticators/challenge/:challengeId/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          verifyAppAuthenticatorPushNotificationChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          s_PushNotificationVerification,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<void>(200)
        },
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with400() {
          return new KoaRuntimeResponse<void>(400)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .verifyAppAuthenticatorPushNotificationChallenge(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        verifyAppAuthenticatorPushNotificationChallengeResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const updateAppAuthenticatorEnrollmentParamSchema = z.object({
    enrollmentId: z.string(),
  })

  const updateAppAuthenticatorEnrollmentResponseValidator =
    responseValidationFactory(
      [
        ["200", s_AppAuthenticatorEnrollment],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.patch(
    "updateAppAuthenticatorEnrollment",
    "/idp/myaccount/app-authenticators/:enrollmentId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          updateAppAuthenticatorEnrollmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          s_UpdateAppAuthenticatorEnrollmentRequest,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_AppAuthenticatorEnrollment>(200)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .updateAppAuthenticatorEnrollment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = updateAppAuthenticatorEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAppAuthenticatorEnrollmentParamSchema = z.object({
    enrollmentId: z.string(),
  })

  const deleteAppAuthenticatorEnrollmentResponseValidator =
    responseValidationFactory(
      [
        ["204", z.undefined()],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.delete(
    "deleteAppAuthenticatorEnrollment",
    "/idp/myaccount/app-authenticators/:enrollmentId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAppAuthenticatorEnrollmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteAppAuthenticatorEnrollment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteAppAuthenticatorEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const listAppAuthenticatorPendingPushNotificationChallengesParamSchema =
    z.object({enrollmentId: z.string()})

  const listAppAuthenticatorPendingPushNotificationChallengesResponseValidator =
    responseValidationFactory(
      [
        ["200", z.array(s_PushNotificationChallenge)],
        ["401", s_Error],
      ],
      undefined,
    )

  router.get(
    "listAppAuthenticatorPendingPushNotificationChallenges",
    "/idp/myaccount/app-authenticators/:enrollmentId/push/notifications",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          listAppAuthenticatorPendingPushNotificationChallengesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_PushNotificationChallenge[]>(200)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .listAppAuthenticatorPendingPushNotificationChallenges(
          input,
          responder,
          ctx,
          next,
        )
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body =
        listAppAuthenticatorPendingPushNotificationChallengesResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const listAuthenticatorsQuerySchema = z.object({
    expand: z.string().optional(),
  })

  const listAuthenticatorsResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_Authenticator)],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get(
    "listAuthenticators",
    "/idp/myaccount/authenticators",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: parseRequestInput(
          listAuthenticatorsQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Authenticator[]>(200)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .listAuthenticators(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = listAuthenticatorsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getAuthenticatorParamSchema = z.object({authenticatorId: z.string()})

  const getAuthenticatorQuerySchema = z.object({expand: z.string().optional()})

  const getAuthenticatorResponseValidator = responseValidationFactory(
    [
      ["200", s_Authenticator],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get(
    "getAuthenticator",
    "/idp/myaccount/authenticators/:authenticatorId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getAuthenticatorParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: parseRequestInput(
          getAuthenticatorQuerySchema,
          ctx.query,
          RequestInputType.QueryString,
        ),
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Authenticator>(200)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getAuthenticator(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getAuthenticatorResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const listEnrollmentsParamSchema = z.object({authenticatorId: z.string()})

  const listEnrollmentsResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_AuthenticatorEnrollment)],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get(
    "listEnrollments",
    "/idp/myaccount/authenticators/:authenticatorId/enrollments",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          listEnrollmentsParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_AuthenticatorEnrollment[]>(200)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .listEnrollments(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = listEnrollmentsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getEnrollmentParamSchema = z.object({
    authenticatorId: z.string(),
    enrollmentId: z.string(),
  })

  const getEnrollmentResponseValidator = responseValidationFactory(
    [
      ["200", s_AuthenticatorEnrollment],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  router.get(
    "getEnrollment",
    "/idp/myaccount/authenticators/:authenticatorId/enrollments/:enrollmentId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          getEnrollmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_AuthenticatorEnrollment>(200)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with429() {
          return new KoaRuntimeResponse<t_Error>(429)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getEnrollment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const updateEnrollmentParamSchema = z.object({
    authenticatorId: z.string(),
    enrollmentId: z.string(),
  })

  const updateEnrollmentResponseValidator = responseValidationFactory(
    [
      ["200", s_AuthenticatorEnrollment],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.patch(
    "updateEnrollment",
    "/idp/myaccount/authenticators/:authenticatorId/enrollments/:enrollmentId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          updateEnrollmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          s_UpdateAuthenticatorEnrollmentRequest,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_AuthenticatorEnrollment>(200)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .updateEnrollment(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = updateEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const listEmailsResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_Email)],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("listEmails", "/idp/myaccount/emails", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Email[]>(200)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .listEmails(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = listEmailsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createEmailResponseValidator = responseValidationFactory(
    [
      ["201", s_Email],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["409", s_Error],
    ],
    undefined,
  )

  router.post("createEmail", "/idp/myaccount/emails", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        s_CreateEmailRequestBody,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with201() {
        return new KoaRuntimeResponse<t_Email>(201)
      },
      with400() {
        return new KoaRuntimeResponse<t_Error>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_Error>(403)
      },
      with409() {
        return new KoaRuntimeResponse<t_Error>(409)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .createEmail(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = createEmailResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getEmailParamSchema = z.object({id: z.string()})

  const getEmailResponseValidator = responseValidationFactory(
    [
      ["200", s_Email],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("getEmail", "/idp/myaccount/emails/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getEmailParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Email>(200)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getEmail(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getEmailResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteEmailParamSchema = z.object({id: z.string()})

  const deleteEmailResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", s_Error],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.delete(
    "deleteEmail",
    "/idp/myaccount/emails/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteEmailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteEmail(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteEmailResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const sendEmailChallengeParamSchema = z.object({id: z.string()})

  const sendEmailChallengeResponseValidator = responseValidationFactory(
    [
      [
        "201",
        z.object({
          id: z.string().min(1),
          status: z.enum(["VERIFIED", "UNVERIFIED"]),
          expiresAt: z.string().min(1),
          profile: z.object({email: z.string().min(1)}),
          _links: z.object({
            verify: z.object({
              href: z.string().min(1),
              hints: z.object({allow: z.array(z.enum(["POST"]))}),
            }),
            poll: z.object({
              href: z.string().min(1),
              hints: z.object({allow: z.array(z.enum(["GET"]))}),
            }),
          }),
        }),
      ],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.post(
    "sendEmailChallenge",
    "/idp/myaccount/emails/:id/challenge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          sendEmailChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          s_SendEmailChallengeRequestBody,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with201() {
          return new KoaRuntimeResponse<{
            _links: {
              poll: {
                hints: {
                  allow: "GET"[]
                }
                href: string
              }
              verify: {
                hints: {
                  allow: "POST"[]
                }
                href: string
              }
            }
            expiresAt: string
            id: string
            profile: {
              email: string
            }
            status: "VERIFIED" | "UNVERIFIED"
          }>(201)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .sendEmailChallenge(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = sendEmailChallengeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pollChallengeForEmailMagicLinkParamSchema = z.object({
    id: z.string(),
    challengeId: z.string(),
  })

  const pollChallengeForEmailMagicLinkResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            id: z.string().min(1),
            status: z.enum(["VERIFIED", "UNVERIFIED"]),
            expiresAt: z.string().min(1),
            profile: z.object({email: z.string().min(1)}),
            _links: z.object({
              verify: z.object({
                href: z.string().min(1),
                hints: z.object({
                  allow: z.array(z.enum(["DELETE", "GET", "POST", "PUT"])),
                }),
              }),
              poll: z.object({
                href: z.string().min(1),
                hints: z.object({
                  allow: z.array(z.enum(["DELETE", "GET", "POST", "PUT"])),
                }),
              }),
            }),
          }),
        ],
        ["401", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.get(
    "pollChallengeForEmailMagicLink",
    "/idp/myaccount/emails/:id/challenge/:challengeId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pollChallengeForEmailMagicLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            _links: {
              poll: {
                hints: {
                  allow: ("DELETE" | "GET" | "POST" | "PUT")[]
                }
                href: string
              }
              verify: {
                hints: {
                  allow: ("DELETE" | "GET" | "POST" | "PUT")[]
                }
                href: string
              }
            }
            expiresAt: string
            id: string
            profile: {
              email: string
            }
            status: "VERIFIED" | "UNVERIFIED"
          }>(200)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .pollChallengeForEmailMagicLink(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = pollChallengeForEmailMagicLinkResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const verifyEmailOtpParamSchema = z.object({
    id: z.string(),
    challengeId: z.string(),
  })

  const verifyEmailOtpResponseValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.post(
    "verifyEmailOtp",
    "/idp/myaccount/emails/:id/challenge/:challengeId/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          verifyEmailOtpParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          s_VerifyEmailOtpRequestBody,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<void>(200)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .verifyEmailOtp(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = verifyEmailOtpResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const listOktaApplicationsResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_OktaApplication)],
      ["400", s_Error],
    ],
    undefined,
  )

  router.get(
    "listOktaApplications",
    "/idp/myaccount/okta-applications",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_OktaApplication[]>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .listOktaApplications(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = listOktaApplicationsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getOrganizationResponseValidator = responseValidationFactory(
    [
      ["200", s_Organization],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get(
    "getOrganization",
    "/idp/myaccount/organization",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Organization>(200)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getOrganization(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getOrganizationResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getPasswordResponseValidator = responseValidationFactory(
    [
      ["200", s_PasswordResponse],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("getPassword", "/idp/myaccount/password", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_PasswordResponse>(200)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPassword(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPasswordResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createPasswordResponseValidator = responseValidationFactory(
    [
      ["201", s_PasswordResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  router.post(
    "createPassword",
    "/idp/myaccount/password",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          s_CreatePasswordRequestBody,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with201() {
          return new KoaRuntimeResponse<t_PasswordResponse>(201)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .createPassword(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = createPasswordResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const replacePasswordResponseValidator = responseValidationFactory(
    [
      ["201", s_PasswordResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  router.put(
    "replacePassword",
    "/idp/myaccount/password",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          s_ReplacePasswordRequestBody,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with201() {
          return new KoaRuntimeResponse<t_PasswordResponse>(201)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .replacePassword(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = replacePasswordResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deletePasswordResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.delete(
    "deletePassword",
    "/idp/myaccount/password",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deletePassword(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deletePasswordResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const listPhonesResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_Phone)],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("listPhones", "/idp/myaccount/phones", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Phone[]>(200)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .listPhones(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = listPhonesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createPhoneResponseValidator = responseValidationFactory(
    [
      ["201", s_Phone],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["409", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  router.post("createPhone", "/idp/myaccount/phones", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        s_CreatePhoneRequestBody,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with201() {
        return new KoaRuntimeResponse<t_Phone>(201)
      },
      with400() {
        return new KoaRuntimeResponse<t_Error>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      with403() {
        return new KoaRuntimeResponse<t_Error>(403)
      },
      with409() {
        return new KoaRuntimeResponse<t_Error>(409)
      },
      with500() {
        return new KoaRuntimeResponse<t_Error>(500)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .createPhone(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = createPhoneResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPhoneParamSchema = z.object({id: z.string()})

  const getPhoneResponseValidator = responseValidationFactory(
    [
      ["200", s_Phone],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.get("getPhone", "/idp/myaccount/phones/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPhoneParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Phone>(200)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      with404() {
        return new KoaRuntimeResponse<t_Error>(404)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getPhone(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getPhoneResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deletePhoneParamSchema = z.object({id: z.string()})

  const deletePhoneResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.delete(
    "deletePhone",
    "/idp/myaccount/phones/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deletePhoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deletePhone(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deletePhoneResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const sendPhoneChallengeParamSchema = z.object({id: z.string()})

  const sendPhoneChallengeResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          _links: z
            .object({
              verify: z
                .object({
                  href: z.string().min(1),
                  hints: z.object({allow: z.array(z.enum(["GET"]))}),
                })
                .optional(),
            })
            .optional(),
        }),
      ],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  router.post(
    "sendPhoneChallenge",
    "/idp/myaccount/phones/:id/challenge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          sendPhoneChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          s_SendPhoneChallengeRequestBody,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<{
            _links?: {
              verify?: {
                hints: {
                  allow: "GET"[]
                }
                href: string
              }
            }
          }>(200)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with500() {
          return new KoaRuntimeResponse<t_Error>(500)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .sendPhoneChallenge(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = sendPhoneChallengeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const verifyPhoneChallengeParamSchema = z.object({id: z.string()})

  const verifyPhoneChallengeResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["409", s_Error],
    ],
    undefined,
  )

  router.post(
    "verifyPhoneChallenge",
    "/idp/myaccount/phones/:id/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          verifyPhoneChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          s_VerifyPhoneChallengeRequestBody,
          Reflect.get(ctx.request, "body"),
          RequestInputType.RequestBody,
        ),
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with400() {
          return new KoaRuntimeResponse<t_Error>(400)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with403() {
          return new KoaRuntimeResponse<t_Error>(403)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        with409() {
          return new KoaRuntimeResponse<t_Error>(409)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .verifyPhoneChallenge(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = verifyPhoneChallengeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getProfileResponseValidator = responseValidationFactory(
    [
      ["200", s_Profile],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("getProfile", "/idp/myaccount/profile", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Profile>(200)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .getProfile(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = getProfileResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const replaceProfileResponseValidator = responseValidationFactory(
    [
      ["200", s_Profile],
      ["400", s_Error],
      ["401", s_Error],
    ],
    undefined,
  )

  router.put("replaceProfile", "/idp/myaccount/profile", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        s_ReplaceProfileRequestBody,
        Reflect.get(ctx.request, "body"),
        RequestInputType.RequestBody,
      ),
      headers: undefined,
    }

    const responder = {
      with200() {
        return new KoaRuntimeResponse<t_Profile>(200)
      },
      with400() {
        return new KoaRuntimeResponse<t_Error>(400)
      },
      with401() {
        return new KoaRuntimeResponse<t_Error>(401)
      },
      withStatus(status: StatusCode) {
        return new KoaRuntimeResponse(status)
      },
    }

    const response = await implementation
      .replaceProfile(input, responder, ctx, next)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    // escape hatch to allow responses to be sent by the implementation handler
    if (response === SkipResponse) {
      return
    }

    const {status, body} =
      response instanceof KoaRuntimeResponse ? response.unpack() : response

    ctx.body = replaceProfileResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getProfileSchemaResponseValidator = responseValidationFactory(
    [
      ["200", s_Schema],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get(
    "getProfileSchema",
    "/idp/myaccount/profile/schema",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with200() {
          return new KoaRuntimeResponse<t_Schema>(200)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .getProfileSchema(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = getProfileSchemaResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteSessionsResponseValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.delete(
    "deleteSessions",
    "/idp/myaccount/sessions",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      }

      const responder = {
        with204() {
          return new KoaRuntimeResponse<void>(204)
        },
        with401() {
          return new KoaRuntimeResponse<t_Error>(401)
        },
        with404() {
          return new KoaRuntimeResponse<t_Error>(404)
        },
        withStatus(status: StatusCode) {
          return new KoaRuntimeResponse(status)
        },
      }

      const response = await implementation
        .deleteSessions(input, responder, ctx, next)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return
      }

      const {status, body} =
        response instanceof KoaRuntimeResponse ? response.unpack() : response

      ctx.body = deleteSessionsResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // MyAccount Management
  return startServer(config)
}
