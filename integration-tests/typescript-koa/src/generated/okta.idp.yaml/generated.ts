/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  EmptyObject,
  t_AppAuthenticatorEnrollment,
  t_AppAuthenticatorMethodCapabilities,
  t_CreateAppAuthenticatorEnrollmentBodySchema,
  t_CreateEmailBodySchema,
  t_CreatePhoneBodySchema,
  t_DeleteAppAuthenticatorEnrollmentParamSchema,
  t_DeleteEmailParamSchema,
  t_DeletePhoneParamSchema,
  t_Email,
  t_Error,
  t_GetEmailParamSchema,
  t_GetPhoneParamSchema,
  t_KeyEC,
  t_KeyObject,
  t_KeyRSA,
  t_ListAppAuthenticatorPendingPushNotificationChallengesParamSchema,
  t_Phone,
  t_PollChallengeForEmailMagicLinkParamSchema,
  t_Profile,
  t_PushNotificationChallenge,
  t_ReplaceProfileBodySchema,
  t_Schema,
  t_SendEmailChallengeBodySchema,
  t_SendEmailChallengeParamSchema,
  t_SendPhoneChallengeBodySchema,
  t_SendPhoneChallengeParamSchema,
  t_UpdateAppAuthenticatorEnrollmentBodySchema,
  t_UpdateAppAuthenticatorEnrollmentParamSchema,
  t_UpdateAppAuthenticatorEnrollmentRequest,
  t_VerifyAppAuthenticatorPushNotificationChallengeBodySchema,
  t_VerifyAppAuthenticatorPushNotificationChallengeParamSchema,
  t_VerifyEmailOtpBodySchema,
  t_VerifyEmailOtpParamSchema,
  t_VerifyPhoneChallengeBodySchema,
  t_VerifyPhoneChallengeParamSchema,
} from "./models"
import {
  s_AppAuthenticatorEnrollment,
  s_AppAuthenticatorEnrollmentRequest,
  s_AppAuthenticatorMethodCapabilities,
  s_Email,
  s_Error,
  s_KeyEC,
  s_KeyObject,
  s_KeyRSA,
  s_Phone,
  s_Profile,
  s_PushNotificationChallenge,
  s_PushNotificationVerification,
  s_Schema,
  s_UpdateAppAuthenticatorEnrollmentRequest,
} from "./schemas"
import KoaRouter from "@koa/router"
import {
  KoaRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-koa-runtime/errors"
import {
  Response,
  ServerConfig,
  StatusCode,
  StatusCode2xx,
  StatusCode3xx,
  StatusCode4xx,
  StatusCode5xx,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  Params,
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod"
import { Context } from "koa"
import koaBody from "koa-body"
import { z } from "zod"

//region safe-edit-region-header

//endregion safe-edit-region-header
export type CreateAppAuthenticatorEnrollment = (
  params: Params<void, void, t_CreateAppAuthenticatorEnrollmentBodySchema>,
  ctx: Context,
) => Promise<
  | Response<200, t_AppAuthenticatorEnrollment>
  | Response<400, t_Error>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
>

export type VerifyAppAuthenticatorPushNotificationChallenge = (
  params: Params<
    t_VerifyAppAuthenticatorPushNotificationChallengeParamSchema,
    void,
    t_VerifyAppAuthenticatorPushNotificationChallengeBodySchema
  >,
  ctx: Context,
) => Promise<Response<200, void> | Response<204, void> | Response<400, void>>

export type UpdateAppAuthenticatorEnrollment = (
  params: Params<
    t_UpdateAppAuthenticatorEnrollmentParamSchema,
    void,
    t_UpdateAppAuthenticatorEnrollmentBodySchema
  >,
  ctx: Context,
) => Promise<
  | Response<200, t_UpdateAppAuthenticatorEnrollmentRequest>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
>

export type DeleteAppAuthenticatorEnrollment = (
  params: Params<t_DeleteAppAuthenticatorEnrollmentParamSchema, void, void>,
  ctx: Context,
) => Promise<
  | Response<204, void>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
>

export type ListAppAuthenticatorPendingPushNotificationChallenges = (
  params: Params<
    t_ListAppAuthenticatorPendingPushNotificationChallengesParamSchema,
    void,
    void
  >,
  ctx: Context,
) => Promise<Response<200, t_PushNotificationChallenge[]>>

export type ListEmails = (
  params: Params<void, void, void>,
  ctx: Context,
) => Promise<Response<200, t_Email[]> | Response<401, t_Error>>

export type CreateEmail = (
  params: Params<void, void, t_CreateEmailBodySchema>,
  ctx: Context,
) => Promise<
  | Response<201, t_Email>
  | Response<400, t_Error>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<409, t_Error>
>

export type GetEmail = (
  params: Params<t_GetEmailParamSchema, void, void>,
  ctx: Context,
) => Promise<Response<200, t_Email> | Response<401, t_Error>>

export type DeleteEmail = (
  params: Params<t_DeleteEmailParamSchema, void, void>,
  ctx: Context,
) => Promise<
  | Response<204, void>
  | Response<400, t_Error>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
>

export type SendEmailChallenge = (
  params: Params<
    t_SendEmailChallengeParamSchema,
    void,
    t_SendEmailChallengeBodySchema
  >,
  ctx: Context,
) => Promise<
  | Response<
      201,
      {
        _links: {
          poll: {
            hints: {
              allow: string[]
            }
            href: string
          }
          verify: {
            hints: {
              allow: string[]
            }
            href: string
          }
        }
        expiresAt: string
        id: string
        profile: {
          email: string
        }
        status: string
      }
    >
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
>

export type PollChallengeForEmailMagicLink = (
  params: Params<t_PollChallengeForEmailMagicLinkParamSchema, void, void>,
  ctx: Context,
) => Promise<
  | Response<
      200,
      {
        _links: {
          poll: {
            hints: {
              allow: string[]
            }
            href: string
          }
          verify: {
            hints: {
              allow: string[]
            }
            href: string
          }
        }
        expiresAt: string
        id: string
        profile: {
          email: string
        }
        status: string
      }
    >
  | Response<401, t_Error>
  | Response<404, t_Error>
>

export type VerifyEmailOtp = (
  params: Params<t_VerifyEmailOtpParamSchema, void, t_VerifyEmailOtpBodySchema>,
  ctx: Context,
) => Promise<
  | Response<200, void>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
>

export type ListPhones = (
  params: Params<void, void, void>,
  ctx: Context,
) => Promise<Response<200, t_Phone[]> | Response<401, t_Error>>

export type CreatePhone = (
  params: Params<void, void, t_CreatePhoneBodySchema>,
  ctx: Context,
) => Promise<
  | Response<201, t_Phone>
  | Response<400, t_Error>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<409, t_Error>
  | Response<500, t_Error>
>

export type GetPhone = (
  params: Params<t_GetPhoneParamSchema, void, void>,
  ctx: Context,
) => Promise<
  Response<200, t_Phone> | Response<401, t_Error> | Response<404, t_Error>
>

export type DeletePhone = (
  params: Params<t_DeletePhoneParamSchema, void, void>,
  ctx: Context,
) => Promise<
  | Response<204, void>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
>

export type SendPhoneChallenge = (
  params: Params<
    t_SendPhoneChallengeParamSchema,
    void,
    t_SendPhoneChallengeBodySchema
  >,
  ctx: Context,
) => Promise<
  | Response<
      200,
      {
        _links?: {
          verify?: {
            hints: {
              allow: string[]
            }
            href: string
          }
        }
      }
    >
  | Response<400, t_Error>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<500, t_Error>
>

export type VerifyPhoneChallenge = (
  params: Params<
    t_VerifyPhoneChallengeParamSchema,
    void,
    t_VerifyPhoneChallengeBodySchema
  >,
  ctx: Context,
) => Promise<
  | Response<204, void>
  | Response<400, t_Error>
  | Response<401, t_Error>
  | Response<403, t_Error>
  | Response<404, t_Error>
  | Response<409, t_Error>
>

export type GetProfile = (
  params: Params<void, void, void>,
  ctx: Context,
) => Promise<Response<200, t_Profile> | Response<401, t_Error>>

export type ReplaceProfile = (
  params: Params<void, void, t_ReplaceProfileBodySchema>,
  ctx: Context,
) => Promise<
  | Response<200, t_Profile>
  | Response<400, t_Error>
  | Response<401, t_Error>
  | Response<403, t_Error>
>

export type GetProfileSchema = (
  params: Params<void, void, void>,
  ctx: Context,
) => Promise<Response<200, t_Schema> | Response<401, t_Error>>

export type Implementation = {
  createAppAuthenticatorEnrollment: CreateAppAuthenticatorEnrollment
  verifyAppAuthenticatorPushNotificationChallenge: VerifyAppAuthenticatorPushNotificationChallenge
  updateAppAuthenticatorEnrollment: UpdateAppAuthenticatorEnrollment
  deleteAppAuthenticatorEnrollment: DeleteAppAuthenticatorEnrollment
  listAppAuthenticatorPendingPushNotificationChallenges: ListAppAuthenticatorPendingPushNotificationChallenges
  listEmails: ListEmails
  createEmail: CreateEmail
  getEmail: GetEmail
  deleteEmail: DeleteEmail
  sendEmailChallenge: SendEmailChallenge
  pollChallengeForEmailMagicLink: PollChallengeForEmailMagicLink
  verifyEmailOtp: VerifyEmailOtp
  listPhones: ListPhones
  createPhone: CreatePhone
  getPhone: GetPhone
  deletePhone: DeletePhone
  sendPhoneChallenge: SendPhoneChallenge
  verifyPhoneChallenge: VerifyPhoneChallenge
  getProfile: GetProfile
  replaceProfile: ReplaceProfile
  getProfileSchema: GetProfileSchema
}

export function createRouter(implementation: Implementation): KoaRouter {
  const router = new KoaRouter()

  const createAppAuthenticatorEnrollmentBodySchema =
    s_AppAuthenticatorEnrollmentRequest

  const createAppAuthenticatorEnrollmentResponseValidator =
    responseValidationFactory(
      [
        ["200", s_AppAuthenticatorEnrollment],
        ["400", s_Error],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.post(
    "createAppAuthenticatorEnrollment",
    "/idp/myaccount/app-authenticators",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(
          createAppAuthenticatorEnrollmentBodySchema,
          ctx.request.body,
          RequestInputType.RequestBody,
        ),
      }

      const { status, body } = await implementation
        .createAppAuthenticatorEnrollment(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = createAppAuthenticatorEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const verifyAppAuthenticatorPushNotificationChallengeParamSchema = z.object({
    challengeId: z.string(),
  })

  const verifyAppAuthenticatorPushNotificationChallengeBodySchema =
    s_PushNotificationVerification

  const verifyAppAuthenticatorPushNotificationChallengeResponseValidator =
    responseValidationFactory(
      [
        ["200", z.void()],
        ["204", z.void()],
        ["400", z.void()],
      ],
      undefined,
    )

  router.post(
    "verifyAppAuthenticatorPushNotificationChallenge",
    "/idp/myaccount/app-authenticators/challenge/:challengeId/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          verifyAppAuthenticatorPushNotificationChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          verifyAppAuthenticatorPushNotificationChallengeBodySchema,
          ctx.request.body,
          RequestInputType.RequestBody,
        ),
      }

      const { status, body } = await implementation
        .verifyAppAuthenticatorPushNotificationChallenge(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body =
        verifyAppAuthenticatorPushNotificationChallengeResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const updateAppAuthenticatorEnrollmentParamSchema = z.object({
    enrollmentId: z.string(),
  })

  const updateAppAuthenticatorEnrollmentBodySchema =
    s_UpdateAppAuthenticatorEnrollmentRequest

  const updateAppAuthenticatorEnrollmentResponseValidator =
    responseValidationFactory(
      [
        ["200", s_UpdateAppAuthenticatorEnrollmentRequest],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.patch(
    "updateAppAuthenticatorEnrollment",
    "/idp/myaccount/app-authenticators/:enrollmentId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          updateAppAuthenticatorEnrollmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          updateAppAuthenticatorEnrollmentBodySchema,
          ctx.request.body,
          RequestInputType.RequestBody,
        ),
      }

      const { status, body } = await implementation
        .updateAppAuthenticatorEnrollment(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = updateAppAuthenticatorEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const deleteAppAuthenticatorEnrollmentParamSchema = z.object({
    enrollmentId: z.string(),
  })

  const deleteAppAuthenticatorEnrollmentResponseValidator =
    responseValidationFactory(
      [
        ["204", z.void()],
        ["401", s_Error],
        ["403", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.delete(
    "deleteAppAuthenticatorEnrollment",
    "/idp/myaccount/app-authenticators/:enrollmentId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteAppAuthenticatorEnrollmentParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
      }

      const { status, body } = await implementation
        .deleteAppAuthenticatorEnrollment(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = deleteAppAuthenticatorEnrollmentResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const listAppAuthenticatorPendingPushNotificationChallengesParamSchema =
    z.object({ enrollmentId: z.string() })

  const listAppAuthenticatorPendingPushNotificationChallengesResponseValidator =
    responseValidationFactory(
      [["200", z.array(s_PushNotificationChallenge)]],
      undefined,
    )

  router.get(
    "listAppAuthenticatorPendingPushNotificationChallenges",
    "/idp/myaccount/app-authenticators/:enrollmentId/push/notifications",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          listAppAuthenticatorPendingPushNotificationChallengesParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
      }

      const { status, body } = await implementation
        .listAppAuthenticatorPendingPushNotificationChallenges(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body =
        listAppAuthenticatorPendingPushNotificationChallengesResponseValidator(
          status,
          body,
        )
      ctx.status = status
      return next()
    },
  )

  const listEmailsResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_Email)],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("listEmails", "/idp/myaccount/emails", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
    }

    const { status, body } = await implementation
      .listEmails(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = listEmailsResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createEmailBodySchema = z.object({
    profile: z.object({ email: z.string().email() }),
    sendEmail: z.coerce.boolean().optional(),
    state: z.string().optional(),
    role: z.enum(["PRIMARY", "SECONDARY"]).optional(),
  })

  const createEmailResponseValidator = responseValidationFactory(
    [
      ["201", s_Email],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["409", s_Error],
    ],
    undefined,
  )

  router.post("createEmail", "/idp/myaccount/emails", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        createEmailBodySchema,
        ctx.request.body,
        RequestInputType.RequestBody,
      ),
    }

    const { status, body } = await implementation
      .createEmail(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = createEmailResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getEmailParamSchema = z.object({ id: z.string() })

  const getEmailResponseValidator = responseValidationFactory(
    [
      ["200", s_Email],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("getEmail", "/idp/myaccount/emails/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getEmailParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
    }

    const { status, body } = await implementation
      .getEmail(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = getEmailResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deleteEmailParamSchema = z.object({ id: z.string() })

  const deleteEmailResponseValidator = responseValidationFactory(
    [
      ["204", z.void()],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.delete(
    "deleteEmail",
    "/idp/myaccount/emails/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deleteEmailParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
      }

      const { status, body } = await implementation
        .deleteEmail(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = deleteEmailResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const sendEmailChallengeParamSchema = z.object({ id: z.string() })

  const sendEmailChallengeBodySchema = z.object({ state: z.string() })

  const sendEmailChallengeResponseValidator = responseValidationFactory(
    [
      [
        "201",
        z.object({
          id: z.string(),
          status: z.string(),
          expiresAt: z.string(),
          profile: z.object({ email: z.string() }),
          _links: z.object({
            verify: z.object({
              href: z.string(),
              hints: z.object({ allow: z.array(z.string()) }),
            }),
            poll: z.object({
              href: z.string(),
              hints: z.object({ allow: z.array(z.string()) }),
            }),
          }),
        }),
      ],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.post(
    "sendEmailChallenge",
    "/idp/myaccount/emails/:id/challenge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          sendEmailChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          sendEmailChallengeBodySchema,
          ctx.request.body,
          RequestInputType.RequestBody,
        ),
      }

      const { status, body } = await implementation
        .sendEmailChallenge(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = sendEmailChallengeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const pollChallengeForEmailMagicLinkParamSchema = z.object({
    id: z.string(),
    challengeId: z.string(),
  })

  const pollChallengeForEmailMagicLinkResponseValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            id: z.string(),
            status: z.string(),
            expiresAt: z.string(),
            profile: z.object({ email: z.string() }),
            _links: z.object({
              verify: z.object({
                href: z.string(),
                hints: z.object({ allow: z.array(z.string()) }),
              }),
              poll: z.object({
                href: z.string(),
                hints: z.object({ allow: z.array(z.string()) }),
              }),
            }),
          }),
        ],
        ["401", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  router.get(
    "pollChallengeForEmailMagicLink",
    "/idp/myaccount/emails/:id/challenge/:challengeId",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          pollChallengeForEmailMagicLinkParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
      }

      const { status, body } = await implementation
        .pollChallengeForEmailMagicLink(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = pollChallengeForEmailMagicLinkResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const verifyEmailOtpParamSchema = z.object({
    id: z.string(),
    challengeId: z.string(),
  })

  const verifyEmailOtpBodySchema = z.object({ verificationCode: z.string() })

  const verifyEmailOtpResponseValidator = responseValidationFactory(
    [
      ["200", z.void()],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.post(
    "verifyEmailOtp",
    "/idp/myaccount/emails/:id/challenge/:challengeId/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          verifyEmailOtpParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          verifyEmailOtpBodySchema,
          ctx.request.body,
          RequestInputType.RequestBody,
        ),
      }

      const { status, body } = await implementation
        .verifyEmailOtp(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = verifyEmailOtpResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const listPhonesResponseValidator = responseValidationFactory(
    [
      ["200", z.array(s_Phone)],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("listPhones", "/idp/myaccount/phones", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
    }

    const { status, body } = await implementation
      .listPhones(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = listPhonesResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const createPhoneBodySchema = z.object({
    profile: z.object({ phoneNumber: z.string().optional() }).optional(),
    sendCode: z.coerce.boolean().optional(),
    method: z.enum(["SMS", "CALL"]).optional(),
  })

  const createPhoneResponseValidator = responseValidationFactory(
    [
      ["201", s_Phone],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["409", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  router.post("createPhone", "/idp/myaccount/phones", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        createPhoneBodySchema,
        ctx.request.body,
        RequestInputType.RequestBody,
      ),
    }

    const { status, body } = await implementation
      .createPhone(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = createPhoneResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getPhoneParamSchema = z.object({ id: z.string() })

  const getPhoneResponseValidator = responseValidationFactory(
    [
      ["200", s_Phone],
      ["401", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.get("getPhone", "/idp/myaccount/phones/:id", async (ctx, next) => {
    const input = {
      params: parseRequestInput(
        getPhoneParamSchema,
        ctx.params,
        RequestInputType.RouteParam,
      ),
      query: undefined,
      body: undefined,
    }

    const { status, body } = await implementation
      .getPhone(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = getPhoneResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const deletePhoneParamSchema = z.object({ id: z.string() })

  const deletePhoneResponseValidator = responseValidationFactory(
    [
      ["204", z.void()],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
    ],
    undefined,
  )

  router.delete(
    "deletePhone",
    "/idp/myaccount/phones/:id",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          deletePhoneParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: undefined,
      }

      const { status, body } = await implementation
        .deletePhone(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = deletePhoneResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const sendPhoneChallengeParamSchema = z.object({ id: z.string() })

  const sendPhoneChallengeBodySchema = z.object({
    method: z.enum(["SMS", "CALL"]),
    retry: z.coerce.boolean().optional(),
  })

  const sendPhoneChallengeResponseValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          _links: z
            .object({
              verify: z
                .object({
                  href: z.string(),
                  hints: z.object({ allow: z.array(z.string()) }),
                })
                .optional(),
            })
            .optional(),
        }),
      ],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  router.post(
    "sendPhoneChallenge",
    "/idp/myaccount/phones/:id/challenge",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          sendPhoneChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          sendPhoneChallengeBodySchema,
          ctx.request.body,
          RequestInputType.RequestBody,
        ),
      }

      const { status, body } = await implementation
        .sendPhoneChallenge(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = sendPhoneChallengeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const verifyPhoneChallengeParamSchema = z.object({ id: z.string() })

  const verifyPhoneChallengeBodySchema = z.object({
    verificationCode: z.string(),
  })

  const verifyPhoneChallengeResponseValidator = responseValidationFactory(
    [
      ["204", z.void()],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["409", s_Error],
    ],
    undefined,
  )

  router.post(
    "verifyPhoneChallenge",
    "/idp/myaccount/phones/:id/verify",
    async (ctx, next) => {
      const input = {
        params: parseRequestInput(
          verifyPhoneChallengeParamSchema,
          ctx.params,
          RequestInputType.RouteParam,
        ),
        query: undefined,
        body: parseRequestInput(
          verifyPhoneChallengeBodySchema,
          ctx.request.body,
          RequestInputType.RequestBody,
        ),
      }

      const { status, body } = await implementation
        .verifyPhoneChallenge(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = verifyPhoneChallengeResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  const getProfileResponseValidator = responseValidationFactory(
    [
      ["200", s_Profile],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get("getProfile", "/idp/myaccount/profile", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: undefined,
    }

    const { status, body } = await implementation
      .getProfile(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = getProfileResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const replaceProfileBodySchema = z.object({
    profile: z.object({}).optional(),
  })

  const replaceProfileResponseValidator = responseValidationFactory(
    [
      ["200", s_Profile],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  router.put("replaceProfile", "/idp/myaccount/profile", async (ctx, next) => {
    const input = {
      params: undefined,
      query: undefined,
      body: parseRequestInput(
        replaceProfileBodySchema,
        ctx.request.body,
        RequestInputType.RequestBody,
      ),
    }

    const { status, body } = await implementation
      .replaceProfile(input, ctx)
      .catch((err) => {
        throw KoaRuntimeError.HandlerError(err)
      })

    ctx.body = replaceProfileResponseValidator(status, body)
    ctx.status = status
    return next()
  })

  const getProfileSchemaResponseValidator = responseValidationFactory(
    [
      ["200", s_Schema],
      ["401", s_Error],
    ],
    undefined,
  )

  router.get(
    "getProfileSchema",
    "/idp/myaccount/profile/schema",
    async (ctx, next) => {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
      }

      const { status, body } = await implementation
        .getProfileSchema(input, ctx)
        .catch((err) => {
          throw KoaRuntimeError.HandlerError(err)
        })

      ctx.body = getProfileSchemaResponseValidator(status, body)
      ctx.status = status
      return next()
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // ApiClient
  return startServer(config)
}
