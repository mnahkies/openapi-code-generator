/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint:disable */

import {
  t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema,
  t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
  t_ActionsAddSelectedRepoToOrgSecretParamSchema,
  t_ActionsAddSelectedRepoToOrgVariableParamSchema,
  t_ActionsAddSelectedRepoToRequiredWorkflowParamSchema,
  t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema,
  t_ActionsApproveWorkflowRunParamSchema,
  t_ActionsCancelWorkflowRunParamSchema,
  t_ActionsCreateEnvironmentVariableBodySchema,
  t_ActionsCreateEnvironmentVariableParamSchema,
  t_ActionsCreateOrUpdateEnvironmentSecretBodySchema,
  t_ActionsCreateOrUpdateEnvironmentSecretParamSchema,
  t_ActionsCreateOrUpdateOrgSecretBodySchema,
  t_ActionsCreateOrUpdateOrgSecretParamSchema,
  t_ActionsCreateOrUpdateRepoSecretBodySchema,
  t_ActionsCreateOrUpdateRepoSecretParamSchema,
  t_ActionsCreateOrgVariableBodySchema,
  t_ActionsCreateOrgVariableParamSchema,
  t_ActionsCreateRegistrationTokenForOrgParamSchema,
  t_ActionsCreateRegistrationTokenForRepoParamSchema,
  t_ActionsCreateRemoveTokenForOrgParamSchema,
  t_ActionsCreateRemoveTokenForRepoParamSchema,
  t_ActionsCreateRepoVariableBodySchema,
  t_ActionsCreateRepoVariableParamSchema,
  t_ActionsCreateRequiredWorkflowBodySchema,
  t_ActionsCreateRequiredWorkflowParamSchema,
  t_ActionsCreateSelfHostedRunnerGroupForOrgBodySchema,
  t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema,
  t_ActionsCreateWorkflowDispatchBodySchema,
  t_ActionsCreateWorkflowDispatchParamSchema,
  t_ActionsDeleteActionsCacheByIdParamSchema,
  t_ActionsDeleteActionsCacheByKeyParamSchema,
  t_ActionsDeleteActionsCacheByKeyQuerySchema,
  t_ActionsDeleteArtifactParamSchema,
  t_ActionsDeleteEnvironmentSecretParamSchema,
  t_ActionsDeleteEnvironmentVariableParamSchema,
  t_ActionsDeleteOrgSecretParamSchema,
  t_ActionsDeleteOrgVariableParamSchema,
  t_ActionsDeleteRepoSecretParamSchema,
  t_ActionsDeleteRepoVariableParamSchema,
  t_ActionsDeleteRequiredWorkflowParamSchema,
  t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema,
  t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema,
  t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
  t_ActionsDeleteWorkflowRunLogsParamSchema,
  t_ActionsDeleteWorkflowRunParamSchema,
  t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
  t_ActionsDisableWorkflowParamSchema,
  t_ActionsDownloadArtifactParamSchema,
  t_ActionsDownloadJobLogsForWorkflowRunParamSchema,
  t_ActionsDownloadWorkflowRunAttemptLogsParamSchema,
  t_ActionsDownloadWorkflowRunLogsParamSchema,
  t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
  t_ActionsEnableWorkflowParamSchema,
  t_ActionsGetActionsCacheListParamSchema,
  t_ActionsGetActionsCacheListQuerySchema,
  t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema,
  t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema,
  t_ActionsGetActionsCacheUsageForOrgParamSchema,
  t_ActionsGetActionsCacheUsageParamSchema,
  t_ActionsGetAllowedActionsOrganizationParamSchema,
  t_ActionsGetAllowedActionsRepositoryParamSchema,
  t_ActionsGetArtifactParamSchema,
  t_ActionsGetCustomOidcSubClaimForRepoParamSchema,
  t_ActionsGetEnvironmentPublicKeyParamSchema,
  t_ActionsGetEnvironmentSecretParamSchema,
  t_ActionsGetEnvironmentVariableParamSchema,
  t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
  t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
  t_ActionsGetGithubActionsPermissionsOrganizationParamSchema,
  t_ActionsGetGithubActionsPermissionsRepositoryParamSchema,
  t_ActionsGetJobForWorkflowRunParamSchema,
  t_ActionsGetOrgPublicKeyParamSchema,
  t_ActionsGetOrgSecretParamSchema,
  t_ActionsGetOrgVariableParamSchema,
  t_ActionsGetPendingDeploymentsForRunParamSchema,
  t_ActionsGetRepoPublicKeyParamSchema,
  t_ActionsGetRepoRequiredWorkflowParamSchema,
  t_ActionsGetRepoRequiredWorkflowUsageParamSchema,
  t_ActionsGetRepoSecretParamSchema,
  t_ActionsGetRepoVariableParamSchema,
  t_ActionsGetRequiredWorkflowParamSchema,
  t_ActionsGetReviewsForRunParamSchema,
  t_ActionsGetSelfHostedRunnerForOrgParamSchema,
  t_ActionsGetSelfHostedRunnerForRepoParamSchema,
  t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema,
  t_ActionsGetWorkflowAccessToRepositoryParamSchema,
  t_ActionsGetWorkflowParamSchema,
  t_ActionsGetWorkflowRunAttemptParamSchema,
  t_ActionsGetWorkflowRunAttemptQuerySchema,
  t_ActionsGetWorkflowRunParamSchema,
  t_ActionsGetWorkflowRunQuerySchema,
  t_ActionsGetWorkflowRunUsageParamSchema,
  t_ActionsGetWorkflowUsageParamSchema,
  t_ActionsListArtifactsForRepoParamSchema,
  t_ActionsListArtifactsForRepoQuerySchema,
  t_ActionsListEnvironmentSecretsParamSchema,
  t_ActionsListEnvironmentSecretsQuerySchema,
  t_ActionsListEnvironmentVariablesParamSchema,
  t_ActionsListEnvironmentVariablesQuerySchema,
  t_ActionsListJobsForWorkflowRunAttemptParamSchema,
  t_ActionsListJobsForWorkflowRunAttemptQuerySchema,
  t_ActionsListJobsForWorkflowRunParamSchema,
  t_ActionsListJobsForWorkflowRunQuerySchema,
  t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema,
  t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema,
  t_ActionsListOrgSecretsParamSchema,
  t_ActionsListOrgSecretsQuerySchema,
  t_ActionsListOrgVariablesParamSchema,
  t_ActionsListOrgVariablesQuerySchema,
  t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
  t_ActionsListRepoRequiredWorkflowsParamSchema,
  t_ActionsListRepoRequiredWorkflowsQuerySchema,
  t_ActionsListRepoSecretsParamSchema,
  t_ActionsListRepoSecretsQuerySchema,
  t_ActionsListRepoVariablesParamSchema,
  t_ActionsListRepoVariablesQuerySchema,
  t_ActionsListRepoWorkflowsParamSchema,
  t_ActionsListRepoWorkflowsQuerySchema,
  t_ActionsListRequiredWorkflowRunsParamSchema,
  t_ActionsListRequiredWorkflowRunsQuerySchema,
  t_ActionsListRequiredWorkflowsParamSchema,
  t_ActionsListRequiredWorkflowsQuerySchema,
  t_ActionsListRunnerApplicationsForOrgParamSchema,
  t_ActionsListRunnerApplicationsForRepoParamSchema,
  t_ActionsListSelectedReposForOrgSecretParamSchema,
  t_ActionsListSelectedReposForOrgSecretQuerySchema,
  t_ActionsListSelectedReposForOrgVariableParamSchema,
  t_ActionsListSelectedReposForOrgVariableQuerySchema,
  t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
  t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
  t_ActionsListSelectedRepositoriesRequiredWorkflowParamSchema,
  t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema,
  t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema,
  t_ActionsListSelfHostedRunnersForOrgParamSchema,
  t_ActionsListSelfHostedRunnersForOrgQuerySchema,
  t_ActionsListSelfHostedRunnersForRepoParamSchema,
  t_ActionsListSelfHostedRunnersForRepoQuerySchema,
  t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema,
  t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema,
  t_ActionsListWorkflowRunArtifactsParamSchema,
  t_ActionsListWorkflowRunArtifactsQuerySchema,
  t_ActionsListWorkflowRunsForRepoParamSchema,
  t_ActionsListWorkflowRunsForRepoQuerySchema,
  t_ActionsListWorkflowRunsParamSchema,
  t_ActionsListWorkflowRunsQuerySchema,
  t_ActionsReRunJobForWorkflowRunBodySchema,
  t_ActionsReRunJobForWorkflowRunParamSchema,
  t_ActionsReRunWorkflowBodySchema,
  t_ActionsReRunWorkflowFailedJobsBodySchema,
  t_ActionsReRunWorkflowFailedJobsParamSchema,
  t_ActionsReRunWorkflowParamSchema,
  t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
  t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
  t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
  t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
  t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema,
  t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema,
  t_ActionsRemoveSelectedRepoFromRequiredWorkflowParamSchema,
  t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
  t_ActionsReviewPendingDeploymentsForRunBodySchema,
  t_ActionsReviewPendingDeploymentsForRunParamSchema,
  t_ActionsSetAllowedActionsOrganizationBodySchema,
  t_ActionsSetAllowedActionsOrganizationParamSchema,
  t_ActionsSetAllowedActionsRepositoryBodySchema,
  t_ActionsSetAllowedActionsRepositoryParamSchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema,
  t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
  t_ActionsSetCustomOidcSubClaimForRepoBodySchema,
  t_ActionsSetCustomOidcSubClaimForRepoParamSchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema,
  t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
  t_ActionsSetGithubActionsPermissionsOrganizationBodySchema,
  t_ActionsSetGithubActionsPermissionsOrganizationParamSchema,
  t_ActionsSetGithubActionsPermissionsRepositoryBodySchema,
  t_ActionsSetGithubActionsPermissionsRepositoryParamSchema,
  t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema,
  t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
  t_ActionsSetSelectedReposForOrgSecretBodySchema,
  t_ActionsSetSelectedReposForOrgSecretParamSchema,
  t_ActionsSetSelectedReposForOrgVariableBodySchema,
  t_ActionsSetSelectedReposForOrgVariableParamSchema,
  t_ActionsSetSelectedReposToRequiredWorkflowBodySchema,
  t_ActionsSetSelectedReposToRequiredWorkflowParamSchema,
  t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema,
  t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
  t_ActionsSetSelfHostedRunnersInGroupForOrgBodySchema,
  t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema,
  t_ActionsSetWorkflowAccessToRepositoryBodySchema,
  t_ActionsSetWorkflowAccessToRepositoryParamSchema,
  t_ActionsUpdateEnvironmentVariableBodySchema,
  t_ActionsUpdateEnvironmentVariableParamSchema,
  t_ActionsUpdateOrgVariableBodySchema,
  t_ActionsUpdateOrgVariableParamSchema,
  t_ActionsUpdateRepoVariableBodySchema,
  t_ActionsUpdateRepoVariableParamSchema,
  t_ActionsUpdateRequiredWorkflowBodySchema,
  t_ActionsUpdateRequiredWorkflowParamSchema,
  t_ActionsUpdateSelfHostedRunnerGroupForOrgBodySchema,
  t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
  t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema,
  t_ActivityDeleteRepoSubscriptionParamSchema,
  t_ActivityDeleteThreadSubscriptionParamSchema,
  t_ActivityGetRepoSubscriptionParamSchema,
  t_ActivityGetThreadParamSchema,
  t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema,
  t_ActivityListEventsForAuthenticatedUserParamSchema,
  t_ActivityListEventsForAuthenticatedUserQuerySchema,
  t_ActivityListNotificationsForAuthenticatedUserQuerySchema,
  t_ActivityListOrgEventsForAuthenticatedUserParamSchema,
  t_ActivityListOrgEventsForAuthenticatedUserQuerySchema,
  t_ActivityListPublicEventsForRepoNetworkParamSchema,
  t_ActivityListPublicEventsForRepoNetworkQuerySchema,
  t_ActivityListPublicEventsForUserParamSchema,
  t_ActivityListPublicEventsForUserQuerySchema,
  t_ActivityListPublicEventsQuerySchema,
  t_ActivityListPublicOrgEventsParamSchema,
  t_ActivityListPublicOrgEventsQuerySchema,
  t_ActivityListReceivedEventsForUserParamSchema,
  t_ActivityListReceivedEventsForUserQuerySchema,
  t_ActivityListReceivedPublicEventsForUserParamSchema,
  t_ActivityListReceivedPublicEventsForUserQuerySchema,
  t_ActivityListRepoEventsParamSchema,
  t_ActivityListRepoEventsQuerySchema,
  t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema,
  t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema,
  t_ActivityListReposStarredByAuthenticatedUserQuerySchema,
  t_ActivityListReposStarredByUserParamSchema,
  t_ActivityListReposStarredByUserQuerySchema,
  t_ActivityListReposWatchedByUserParamSchema,
  t_ActivityListReposWatchedByUserQuerySchema,
  t_ActivityListStargazersForRepoParamSchema,
  t_ActivityListStargazersForRepoQuerySchema,
  t_ActivityListWatchedReposForAuthenticatedUserQuerySchema,
  t_ActivityListWatchersForRepoParamSchema,
  t_ActivityListWatchersForRepoQuerySchema,
  t_ActivityMarkNotificationsAsReadBodySchema,
  t_ActivityMarkRepoNotificationsAsReadBodySchema,
  t_ActivityMarkRepoNotificationsAsReadParamSchema,
  t_ActivityMarkThreadAsReadParamSchema,
  t_ActivitySetRepoSubscriptionBodySchema,
  t_ActivitySetRepoSubscriptionParamSchema,
  t_ActivitySetThreadSubscriptionBodySchema,
  t_ActivitySetThreadSubscriptionParamSchema,
  t_ActivityStarRepoForAuthenticatedUserParamSchema,
  t_ActivityUnstarRepoForAuthenticatedUserParamSchema,
  t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema,
  t_AppsCheckTokenBodySchema,
  t_AppsCheckTokenParamSchema,
  t_AppsCreateFromManifestParamSchema,
  t_AppsCreateInstallationAccessTokenBodySchema,
  t_AppsCreateInstallationAccessTokenParamSchema,
  t_AppsDeleteAuthorizationBodySchema,
  t_AppsDeleteAuthorizationParamSchema,
  t_AppsDeleteInstallationParamSchema,
  t_AppsDeleteTokenBodySchema,
  t_AppsDeleteTokenParamSchema,
  t_AppsGetBySlugParamSchema,
  t_AppsGetInstallationParamSchema,
  t_AppsGetOrgInstallationParamSchema,
  t_AppsGetRepoInstallationParamSchema,
  t_AppsGetSubscriptionPlanForAccountParamSchema,
  t_AppsGetSubscriptionPlanForAccountStubbedParamSchema,
  t_AppsGetUserInstallationParamSchema,
  t_AppsGetWebhookDeliveryParamSchema,
  t_AppsListAccountsForPlanParamSchema,
  t_AppsListAccountsForPlanQuerySchema,
  t_AppsListAccountsForPlanStubbedParamSchema,
  t_AppsListAccountsForPlanStubbedQuerySchema,
  t_AppsListInstallationReposForAuthenticatedUserParamSchema,
  t_AppsListInstallationReposForAuthenticatedUserQuerySchema,
  t_AppsListInstallationsForAuthenticatedUserQuerySchema,
  t_AppsListInstallationsQuerySchema,
  t_AppsListPlansQuerySchema,
  t_AppsListPlansStubbedQuerySchema,
  t_AppsListReposAccessibleToInstallationQuerySchema,
  t_AppsListSubscriptionsForAuthenticatedUserQuerySchema,
  t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
  t_AppsListWebhookDeliveriesQuerySchema,
  t_AppsRedeliverWebhookDeliveryParamSchema,
  t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
  t_AppsResetTokenBodySchema,
  t_AppsResetTokenParamSchema,
  t_AppsScopeTokenBodySchema,
  t_AppsScopeTokenParamSchema,
  t_AppsSuspendInstallationParamSchema,
  t_AppsUnsuspendInstallationParamSchema,
  t_AppsUpdateWebhookConfigForAppBodySchema,
  t_BillingGetGithubActionsBillingOrgParamSchema,
  t_BillingGetGithubActionsBillingUserParamSchema,
  t_BillingGetGithubPackagesBillingOrgParamSchema,
  t_BillingGetGithubPackagesBillingUserParamSchema,
  t_BillingGetSharedStorageBillingOrgParamSchema,
  t_BillingGetSharedStorageBillingUserParamSchema,
  t_ChecksCreateBodySchema,
  t_ChecksCreateParamSchema,
  t_ChecksCreateSuiteBodySchema,
  t_ChecksCreateSuiteParamSchema,
  t_ChecksGetParamSchema,
  t_ChecksGetSuiteParamSchema,
  t_ChecksListAnnotationsParamSchema,
  t_ChecksListAnnotationsQuerySchema,
  t_ChecksListForRefParamSchema,
  t_ChecksListForRefQuerySchema,
  t_ChecksListForSuiteParamSchema,
  t_ChecksListForSuiteQuerySchema,
  t_ChecksListSuitesForRefParamSchema,
  t_ChecksListSuitesForRefQuerySchema,
  t_ChecksRerequestRunParamSchema,
  t_ChecksRerequestSuiteParamSchema,
  t_ChecksSetSuitesPreferencesBodySchema,
  t_ChecksSetSuitesPreferencesParamSchema,
  t_ChecksUpdateBodySchema,
  t_ChecksUpdateParamSchema,
  t_CodeScanningDeleteAnalysisParamSchema,
  t_CodeScanningDeleteAnalysisQuerySchema,
  t_CodeScanningGetAlertParamSchema,
  t_CodeScanningGetAnalysisParamSchema,
  t_CodeScanningGetCodeqlDatabaseParamSchema,
  t_CodeScanningGetSarifParamSchema,
  t_CodeScanningListAlertInstancesParamSchema,
  t_CodeScanningListAlertInstancesQuerySchema,
  t_CodeScanningListAlertsForOrgParamSchema,
  t_CodeScanningListAlertsForOrgQuerySchema,
  t_CodeScanningListAlertsForRepoParamSchema,
  t_CodeScanningListAlertsForRepoQuerySchema,
  t_CodeScanningListCodeqlDatabasesParamSchema,
  t_CodeScanningListRecentAnalysesParamSchema,
  t_CodeScanningListRecentAnalysesQuerySchema,
  t_CodeScanningUpdateAlertBodySchema,
  t_CodeScanningUpdateAlertParamSchema,
  t_CodeScanningUploadSarifBodySchema,
  t_CodeScanningUploadSarifParamSchema,
  t_CodesOfConductGetConductCodeParamSchema,
  t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
  t_CodespacesAddSelectedRepoToOrgSecretParamSchema,
  t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema,
  t_CodespacesCreateForAuthenticatedUserBodySchema,
  t_CodespacesCreateOrUpdateOrgSecretBodySchema,
  t_CodespacesCreateOrUpdateOrgSecretParamSchema,
  t_CodespacesCreateOrUpdateRepoSecretBodySchema,
  t_CodespacesCreateOrUpdateRepoSecretParamSchema,
  t_CodespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema,
  t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
  t_CodespacesCreateWithPrForAuthenticatedUserBodySchema,
  t_CodespacesCreateWithPrForAuthenticatedUserParamSchema,
  t_CodespacesCreateWithRepoForAuthenticatedUserBodySchema,
  t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema,
  t_CodespacesDeleteForAuthenticatedUserParamSchema,
  t_CodespacesDeleteFromOrganizationParamSchema,
  t_CodespacesDeleteOrgSecretParamSchema,
  t_CodespacesDeleteRepoSecretParamSchema,
  t_CodespacesDeleteSecretForAuthenticatedUserParamSchema,
  t_CodespacesExportForAuthenticatedUserParamSchema,
  t_CodespacesGetCodespacesForUserInOrgParamSchema,
  t_CodespacesGetCodespacesForUserInOrgQuerySchema,
  t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema,
  t_CodespacesGetForAuthenticatedUserParamSchema,
  t_CodespacesGetOrgPublicKeyParamSchema,
  t_CodespacesGetOrgSecretParamSchema,
  t_CodespacesGetRepoPublicKeyParamSchema,
  t_CodespacesGetRepoSecretParamSchema,
  t_CodespacesGetSecretForAuthenticatedUserParamSchema,
  t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
  t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
  t_CodespacesListForAuthenticatedUserQuerySchema,
  t_CodespacesListInOrganizationParamSchema,
  t_CodespacesListInOrganizationQuerySchema,
  t_CodespacesListInRepositoryForAuthenticatedUserParamSchema,
  t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema,
  t_CodespacesListOrgSecretsParamSchema,
  t_CodespacesListOrgSecretsQuerySchema,
  t_CodespacesListRepoSecretsParamSchema,
  t_CodespacesListRepoSecretsQuerySchema,
  t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
  t_CodespacesListSecretsForAuthenticatedUserQuerySchema,
  t_CodespacesListSelectedReposForOrgSecretParamSchema,
  t_CodespacesListSelectedReposForOrgSecretQuerySchema,
  t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
  t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
  t_CodespacesPublishForAuthenticatedUserBodySchema,
  t_CodespacesPublishForAuthenticatedUserParamSchema,
  t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
  t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema,
  t_CodespacesRepoMachinesForAuthenticatedUserParamSchema,
  t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema,
  t_CodespacesSetCodespacesBillingBodySchema,
  t_CodespacesSetCodespacesBillingParamSchema,
  t_CodespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema,
  t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
  t_CodespacesSetSelectedReposForOrgSecretBodySchema,
  t_CodespacesSetSelectedReposForOrgSecretParamSchema,
  t_CodespacesStartForAuthenticatedUserParamSchema,
  t_CodespacesStopForAuthenticatedUserParamSchema,
  t_CodespacesStopInOrganizationParamSchema,
  t_CodespacesUpdateForAuthenticatedUserBodySchema,
  t_CodespacesUpdateForAuthenticatedUserParamSchema,
  t_DependabotAddSelectedRepoToOrgSecretParamSchema,
  t_DependabotCreateOrUpdateOrgSecretBodySchema,
  t_DependabotCreateOrUpdateOrgSecretParamSchema,
  t_DependabotCreateOrUpdateRepoSecretBodySchema,
  t_DependabotCreateOrUpdateRepoSecretParamSchema,
  t_DependabotDeleteOrgSecretParamSchema,
  t_DependabotDeleteRepoSecretParamSchema,
  t_DependabotGetAlertParamSchema,
  t_DependabotGetOrgPublicKeyParamSchema,
  t_DependabotGetOrgSecretParamSchema,
  t_DependabotGetRepoPublicKeyParamSchema,
  t_DependabotGetRepoSecretParamSchema,
  t_DependabotListAlertsForEnterpriseParamSchema,
  t_DependabotListAlertsForEnterpriseQuerySchema,
  t_DependabotListAlertsForOrgParamSchema,
  t_DependabotListAlertsForOrgQuerySchema,
  t_DependabotListAlertsForRepoParamSchema,
  t_DependabotListAlertsForRepoQuerySchema,
  t_DependabotListOrgSecretsParamSchema,
  t_DependabotListOrgSecretsQuerySchema,
  t_DependabotListRepoSecretsParamSchema,
  t_DependabotListRepoSecretsQuerySchema,
  t_DependabotListSelectedReposForOrgSecretParamSchema,
  t_DependabotListSelectedReposForOrgSecretQuerySchema,
  t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema,
  t_DependabotSetSelectedReposForOrgSecretBodySchema,
  t_DependabotSetSelectedReposForOrgSecretParamSchema,
  t_DependabotUpdateAlertBodySchema,
  t_DependabotUpdateAlertParamSchema,
  t_DependencyGraphCreateRepositorySnapshotBodySchema,
  t_DependencyGraphCreateRepositorySnapshotParamSchema,
  t_DependencyGraphDiffRangeParamSchema,
  t_DependencyGraphDiffRangeQuerySchema,
  t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseBodySchema,
  t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseParamSchema,
  t_EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParamSchema,
  t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseBodySchema,
  t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParamSchema,
  t_EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParamSchema,
  t_EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParamSchema,
  t_EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParamSchema,
  t_EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseParamSchema,
  t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParamSchema,
  t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseQuerySchema,
  t_EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParamSchema,
  t_GistsCheckIsStarredParamSchema,
  t_GistsCreateBodySchema,
  t_GistsCreateCommentBodySchema,
  t_GistsCreateCommentParamSchema,
  t_GistsDeleteCommentParamSchema,
  t_GistsDeleteParamSchema,
  t_GistsForkParamSchema,
  t_GistsGetCommentParamSchema,
  t_GistsGetParamSchema,
  t_GistsGetRevisionParamSchema,
  t_GistsListCommentsParamSchema,
  t_GistsListCommentsQuerySchema,
  t_GistsListCommitsParamSchema,
  t_GistsListCommitsQuerySchema,
  t_GistsListForUserParamSchema,
  t_GistsListForUserQuerySchema,
  t_GistsListForksParamSchema,
  t_GistsListForksQuerySchema,
  t_GistsListPublicQuerySchema,
  t_GistsListQuerySchema,
  t_GistsListStarredQuerySchema,
  t_GistsStarParamSchema,
  t_GistsUnstarParamSchema,
  t_GistsUpdateBodySchema,
  t_GistsUpdateCommentBodySchema,
  t_GistsUpdateCommentParamSchema,
  t_GistsUpdateParamSchema,
  t_GitCreateBlobBodySchema,
  t_GitCreateBlobParamSchema,
  t_GitCreateCommitBodySchema,
  t_GitCreateCommitParamSchema,
  t_GitCreateRefBodySchema,
  t_GitCreateRefParamSchema,
  t_GitCreateTagBodySchema,
  t_GitCreateTagParamSchema,
  t_GitCreateTreeBodySchema,
  t_GitCreateTreeParamSchema,
  t_GitDeleteRefParamSchema,
  t_GitGetBlobParamSchema,
  t_GitGetCommitParamSchema,
  t_GitGetRefParamSchema,
  t_GitGetTagParamSchema,
  t_GitGetTreeParamSchema,
  t_GitGetTreeQuerySchema,
  t_GitListMatchingRefsParamSchema,
  t_GitUpdateRefBodySchema,
  t_GitUpdateRefParamSchema,
  t_GitignoreGetTemplateParamSchema,
  t_InteractionsGetRestrictionsForOrgParamSchema,
  t_InteractionsGetRestrictionsForRepoParamSchema,
  t_InteractionsRemoveRestrictionsForOrgParamSchema,
  t_InteractionsRemoveRestrictionsForRepoParamSchema,
  t_InteractionsSetRestrictionsForAuthenticatedUserBodySchema,
  t_InteractionsSetRestrictionsForOrgBodySchema,
  t_InteractionsSetRestrictionsForOrgParamSchema,
  t_InteractionsSetRestrictionsForRepoBodySchema,
  t_InteractionsSetRestrictionsForRepoParamSchema,
  t_IssuesAddAssigneesBodySchema,
  t_IssuesAddAssigneesParamSchema,
  t_IssuesAddLabelsBodySchema,
  t_IssuesAddLabelsParamSchema,
  t_IssuesCheckUserCanBeAssignedParamSchema,
  t_IssuesCheckUserCanBeAssignedToIssueParamSchema,
  t_IssuesCreateBodySchema,
  t_IssuesCreateCommentBodySchema,
  t_IssuesCreateCommentParamSchema,
  t_IssuesCreateLabelBodySchema,
  t_IssuesCreateLabelParamSchema,
  t_IssuesCreateMilestoneBodySchema,
  t_IssuesCreateMilestoneParamSchema,
  t_IssuesCreateParamSchema,
  t_IssuesDeleteCommentParamSchema,
  t_IssuesDeleteLabelParamSchema,
  t_IssuesDeleteMilestoneParamSchema,
  t_IssuesGetCommentParamSchema,
  t_IssuesGetEventParamSchema,
  t_IssuesGetLabelParamSchema,
  t_IssuesGetMilestoneParamSchema,
  t_IssuesGetParamSchema,
  t_IssuesListAssigneesParamSchema,
  t_IssuesListAssigneesQuerySchema,
  t_IssuesListCommentsForRepoParamSchema,
  t_IssuesListCommentsForRepoQuerySchema,
  t_IssuesListCommentsParamSchema,
  t_IssuesListCommentsQuerySchema,
  t_IssuesListEventsForRepoParamSchema,
  t_IssuesListEventsForRepoQuerySchema,
  t_IssuesListEventsForTimelineParamSchema,
  t_IssuesListEventsForTimelineQuerySchema,
  t_IssuesListEventsParamSchema,
  t_IssuesListEventsQuerySchema,
  t_IssuesListForAuthenticatedUserQuerySchema,
  t_IssuesListForOrgParamSchema,
  t_IssuesListForOrgQuerySchema,
  t_IssuesListForRepoParamSchema,
  t_IssuesListForRepoQuerySchema,
  t_IssuesListLabelsForMilestoneParamSchema,
  t_IssuesListLabelsForMilestoneQuerySchema,
  t_IssuesListLabelsForRepoParamSchema,
  t_IssuesListLabelsForRepoQuerySchema,
  t_IssuesListLabelsOnIssueParamSchema,
  t_IssuesListLabelsOnIssueQuerySchema,
  t_IssuesListMilestonesParamSchema,
  t_IssuesListMilestonesQuerySchema,
  t_IssuesListQuerySchema,
  t_IssuesLockBodySchema,
  t_IssuesLockParamSchema,
  t_IssuesRemoveAllLabelsParamSchema,
  t_IssuesRemoveAssigneesBodySchema,
  t_IssuesRemoveAssigneesParamSchema,
  t_IssuesRemoveLabelParamSchema,
  t_IssuesSetLabelsBodySchema,
  t_IssuesSetLabelsParamSchema,
  t_IssuesUnlockParamSchema,
  t_IssuesUpdateBodySchema,
  t_IssuesUpdateCommentBodySchema,
  t_IssuesUpdateCommentParamSchema,
  t_IssuesUpdateLabelBodySchema,
  t_IssuesUpdateLabelParamSchema,
  t_IssuesUpdateMilestoneBodySchema,
  t_IssuesUpdateMilestoneParamSchema,
  t_IssuesUpdateParamSchema,
  t_LicensesGetAllCommonlyUsedQuerySchema,
  t_LicensesGetForRepoParamSchema,
  t_LicensesGetParamSchema,
  t_MarkdownRenderBodySchema,
  t_MarkdownRenderRawBodySchema,
  t_MetaGetOctocatQuerySchema,
  t_MigrationsCancelImportParamSchema,
  t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema,
  t_MigrationsDeleteArchiveForOrgParamSchema,
  t_MigrationsDownloadArchiveForOrgParamSchema,
  t_MigrationsGetArchiveForAuthenticatedUserParamSchema,
  t_MigrationsGetCommitAuthorsParamSchema,
  t_MigrationsGetCommitAuthorsQuerySchema,
  t_MigrationsGetImportStatusParamSchema,
  t_MigrationsGetLargeFilesParamSchema,
  t_MigrationsGetStatusForAuthenticatedUserParamSchema,
  t_MigrationsGetStatusForAuthenticatedUserQuerySchema,
  t_MigrationsGetStatusForOrgParamSchema,
  t_MigrationsGetStatusForOrgQuerySchema,
  t_MigrationsListForAuthenticatedUserQuerySchema,
  t_MigrationsListForOrgParamSchema,
  t_MigrationsListForOrgQuerySchema,
  t_MigrationsListReposForAuthenticatedUserParamSchema,
  t_MigrationsListReposForAuthenticatedUserQuerySchema,
  t_MigrationsListReposForOrgParamSchema,
  t_MigrationsListReposForOrgQuerySchema,
  t_MigrationsMapCommitAuthorBodySchema,
  t_MigrationsMapCommitAuthorParamSchema,
  t_MigrationsSetLfsPreferenceBodySchema,
  t_MigrationsSetLfsPreferenceParamSchema,
  t_MigrationsStartForAuthenticatedUserBodySchema,
  t_MigrationsStartForOrgBodySchema,
  t_MigrationsStartForOrgParamSchema,
  t_MigrationsStartImportBodySchema,
  t_MigrationsStartImportParamSchema,
  t_MigrationsUnlockRepoForAuthenticatedUserParamSchema,
  t_MigrationsUnlockRepoForOrgParamSchema,
  t_MigrationsUpdateImportBodySchema,
  t_MigrationsUpdateImportParamSchema,
  t_OidcGetOidcCustomSubTemplateForOrgParamSchema,
  t_OidcUpdateOidcCustomSubTemplateForOrgBodySchema,
  t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema,
  t_OrgsAddSecurityManagerTeamParamSchema,
  t_OrgsBlockUserParamSchema,
  t_OrgsCancelInvitationParamSchema,
  t_OrgsCheckBlockedUserParamSchema,
  t_OrgsCheckMembershipForUserParamSchema,
  t_OrgsCheckPublicMembershipForUserParamSchema,
  t_OrgsConvertMemberToOutsideCollaboratorBodySchema,
  t_OrgsConvertMemberToOutsideCollaboratorParamSchema,
  t_OrgsCreateInvitationBodySchema,
  t_OrgsCreateInvitationParamSchema,
  t_OrgsCreateWebhookBodySchema,
  t_OrgsCreateWebhookParamSchema,
  t_OrgsDeleteWebhookParamSchema,
  t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
  t_OrgsGetMembershipForAuthenticatedUserParamSchema,
  t_OrgsGetMembershipForUserParamSchema,
  t_OrgsGetParamSchema,
  t_OrgsGetWebhookConfigForOrgParamSchema,
  t_OrgsGetWebhookDeliveryParamSchema,
  t_OrgsGetWebhookParamSchema,
  t_OrgsListAppInstallationsParamSchema,
  t_OrgsListAppInstallationsQuerySchema,
  t_OrgsListBlockedUsersParamSchema,
  t_OrgsListBlockedUsersQuerySchema,
  t_OrgsListFailedInvitationsParamSchema,
  t_OrgsListFailedInvitationsQuerySchema,
  t_OrgsListForAuthenticatedUserQuerySchema,
  t_OrgsListForUserParamSchema,
  t_OrgsListForUserQuerySchema,
  t_OrgsListInvitationTeamsParamSchema,
  t_OrgsListInvitationTeamsQuerySchema,
  t_OrgsListMembersParamSchema,
  t_OrgsListMembersQuerySchema,
  t_OrgsListMembershipsForAuthenticatedUserQuerySchema,
  t_OrgsListOutsideCollaboratorsParamSchema,
  t_OrgsListOutsideCollaboratorsQuerySchema,
  t_OrgsListPendingInvitationsParamSchema,
  t_OrgsListPendingInvitationsQuerySchema,
  t_OrgsListPublicMembersParamSchema,
  t_OrgsListPublicMembersQuerySchema,
  t_OrgsListQuerySchema,
  t_OrgsListSecurityManagerTeamsParamSchema,
  t_OrgsListWebhookDeliveriesParamSchema,
  t_OrgsListWebhookDeliveriesQuerySchema,
  t_OrgsListWebhooksParamSchema,
  t_OrgsListWebhooksQuerySchema,
  t_OrgsPingWebhookParamSchema,
  t_OrgsRedeliverWebhookDeliveryParamSchema,
  t_OrgsRemoveMemberParamSchema,
  t_OrgsRemoveMembershipForUserParamSchema,
  t_OrgsRemoveOutsideCollaboratorParamSchema,
  t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema,
  t_OrgsRemoveSecurityManagerTeamParamSchema,
  t_OrgsSetMembershipForUserBodySchema,
  t_OrgsSetMembershipForUserParamSchema,
  t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema,
  t_OrgsUnblockUserParamSchema,
  t_OrgsUpdateBodySchema,
  t_OrgsUpdateMembershipForAuthenticatedUserBodySchema,
  t_OrgsUpdateMembershipForAuthenticatedUserParamSchema,
  t_OrgsUpdateParamSchema,
  t_OrgsUpdateWebhookBodySchema,
  t_OrgsUpdateWebhookConfigForOrgBodySchema,
  t_OrgsUpdateWebhookConfigForOrgParamSchema,
  t_OrgsUpdateWebhookParamSchema,
  t_PackagesDeletePackageForAuthenticatedUserParamSchema,
  t_PackagesDeletePackageForOrgParamSchema,
  t_PackagesDeletePackageForUserParamSchema,
  t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema,
  t_PackagesDeletePackageVersionForOrgParamSchema,
  t_PackagesDeletePackageVersionForUserParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
  t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
  t_PackagesGetPackageForAuthenticatedUserParamSchema,
  t_PackagesGetPackageForOrganizationParamSchema,
  t_PackagesGetPackageForUserParamSchema,
  t_PackagesGetPackageVersionForAuthenticatedUserParamSchema,
  t_PackagesGetPackageVersionForOrganizationParamSchema,
  t_PackagesGetPackageVersionForUserParamSchema,
  t_PackagesListPackagesForAuthenticatedUserQuerySchema,
  t_PackagesListPackagesForOrganizationParamSchema,
  t_PackagesListPackagesForOrganizationQuerySchema,
  t_PackagesListPackagesForUserParamSchema,
  t_PackagesListPackagesForUserQuerySchema,
  t_PackagesRestorePackageForAuthenticatedUserParamSchema,
  t_PackagesRestorePackageForAuthenticatedUserQuerySchema,
  t_PackagesRestorePackageForOrgParamSchema,
  t_PackagesRestorePackageForOrgQuerySchema,
  t_PackagesRestorePackageForUserParamSchema,
  t_PackagesRestorePackageForUserQuerySchema,
  t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema,
  t_PackagesRestorePackageVersionForOrgParamSchema,
  t_PackagesRestorePackageVersionForUserParamSchema,
  t_ProjectsAddCollaboratorBodySchema,
  t_ProjectsAddCollaboratorParamSchema,
  t_ProjectsCreateCardBodySchema,
  t_ProjectsCreateCardParamSchema,
  t_ProjectsCreateColumnBodySchema,
  t_ProjectsCreateColumnParamSchema,
  t_ProjectsCreateForAuthenticatedUserBodySchema,
  t_ProjectsCreateForOrgBodySchema,
  t_ProjectsCreateForOrgParamSchema,
  t_ProjectsCreateForRepoBodySchema,
  t_ProjectsCreateForRepoParamSchema,
  t_ProjectsDeleteCardParamSchema,
  t_ProjectsDeleteColumnParamSchema,
  t_ProjectsDeleteParamSchema,
  t_ProjectsGetCardParamSchema,
  t_ProjectsGetColumnParamSchema,
  t_ProjectsGetParamSchema,
  t_ProjectsGetPermissionForUserParamSchema,
  t_ProjectsListCardsParamSchema,
  t_ProjectsListCardsQuerySchema,
  t_ProjectsListCollaboratorsParamSchema,
  t_ProjectsListCollaboratorsQuerySchema,
  t_ProjectsListColumnsParamSchema,
  t_ProjectsListColumnsQuerySchema,
  t_ProjectsListForOrgParamSchema,
  t_ProjectsListForOrgQuerySchema,
  t_ProjectsListForRepoParamSchema,
  t_ProjectsListForRepoQuerySchema,
  t_ProjectsListForUserParamSchema,
  t_ProjectsListForUserQuerySchema,
  t_ProjectsMoveCardBodySchema,
  t_ProjectsMoveCardParamSchema,
  t_ProjectsMoveColumnBodySchema,
  t_ProjectsMoveColumnParamSchema,
  t_ProjectsRemoveCollaboratorParamSchema,
  t_ProjectsUpdateBodySchema,
  t_ProjectsUpdateCardBodySchema,
  t_ProjectsUpdateCardParamSchema,
  t_ProjectsUpdateColumnBodySchema,
  t_ProjectsUpdateColumnParamSchema,
  t_ProjectsUpdateParamSchema,
  t_PullsCheckIfMergedParamSchema,
  t_PullsCreateBodySchema,
  t_PullsCreateParamSchema,
  t_PullsCreateReplyForReviewCommentBodySchema,
  t_PullsCreateReplyForReviewCommentParamSchema,
  t_PullsCreateReviewBodySchema,
  t_PullsCreateReviewCommentBodySchema,
  t_PullsCreateReviewCommentParamSchema,
  t_PullsCreateReviewParamSchema,
  t_PullsDeletePendingReviewParamSchema,
  t_PullsDeleteReviewCommentParamSchema,
  t_PullsDismissReviewBodySchema,
  t_PullsDismissReviewParamSchema,
  t_PullsGetParamSchema,
  t_PullsGetReviewCommentParamSchema,
  t_PullsGetReviewParamSchema,
  t_PullsListCommentsForReviewParamSchema,
  t_PullsListCommentsForReviewQuerySchema,
  t_PullsListCommitsParamSchema,
  t_PullsListCommitsQuerySchema,
  t_PullsListFilesParamSchema,
  t_PullsListFilesQuerySchema,
  t_PullsListParamSchema,
  t_PullsListQuerySchema,
  t_PullsListRequestedReviewersParamSchema,
  t_PullsListReviewCommentsForRepoParamSchema,
  t_PullsListReviewCommentsForRepoQuerySchema,
  t_PullsListReviewCommentsParamSchema,
  t_PullsListReviewCommentsQuerySchema,
  t_PullsListReviewsParamSchema,
  t_PullsListReviewsQuerySchema,
  t_PullsMergeBodySchema,
  t_PullsMergeParamSchema,
  t_PullsRemoveRequestedReviewersBodySchema,
  t_PullsRemoveRequestedReviewersParamSchema,
  t_PullsRequestReviewersBodySchema,
  t_PullsRequestReviewersParamSchema,
  t_PullsSubmitReviewBodySchema,
  t_PullsSubmitReviewParamSchema,
  t_PullsUpdateBodySchema,
  t_PullsUpdateBranchBodySchema,
  t_PullsUpdateBranchParamSchema,
  t_PullsUpdateParamSchema,
  t_PullsUpdateReviewBodySchema,
  t_PullsUpdateReviewCommentBodySchema,
  t_PullsUpdateReviewCommentParamSchema,
  t_PullsUpdateReviewParamSchema,
  t_ReactionsCreateForCommitCommentBodySchema,
  t_ReactionsCreateForCommitCommentParamSchema,
  t_ReactionsCreateForIssueBodySchema,
  t_ReactionsCreateForIssueCommentBodySchema,
  t_ReactionsCreateForIssueCommentParamSchema,
  t_ReactionsCreateForIssueParamSchema,
  t_ReactionsCreateForPullRequestReviewCommentBodySchema,
  t_ReactionsCreateForPullRequestReviewCommentParamSchema,
  t_ReactionsCreateForReleaseBodySchema,
  t_ReactionsCreateForReleaseParamSchema,
  t_ReactionsCreateForTeamDiscussionCommentInOrgBodySchema,
  t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema,
  t_ReactionsCreateForTeamDiscussionCommentLegacyBodySchema,
  t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema,
  t_ReactionsCreateForTeamDiscussionInOrgBodySchema,
  t_ReactionsCreateForTeamDiscussionInOrgParamSchema,
  t_ReactionsCreateForTeamDiscussionLegacyBodySchema,
  t_ReactionsCreateForTeamDiscussionLegacyParamSchema,
  t_ReactionsDeleteForCommitCommentParamSchema,
  t_ReactionsDeleteForIssueCommentParamSchema,
  t_ReactionsDeleteForIssueParamSchema,
  t_ReactionsDeleteForPullRequestCommentParamSchema,
  t_ReactionsDeleteForReleaseParamSchema,
  t_ReactionsDeleteForTeamDiscussionCommentParamSchema,
  t_ReactionsDeleteForTeamDiscussionParamSchema,
  t_ReactionsListForCommitCommentParamSchema,
  t_ReactionsListForCommitCommentQuerySchema,
  t_ReactionsListForIssueCommentParamSchema,
  t_ReactionsListForIssueCommentQuerySchema,
  t_ReactionsListForIssueParamSchema,
  t_ReactionsListForIssueQuerySchema,
  t_ReactionsListForPullRequestReviewCommentParamSchema,
  t_ReactionsListForPullRequestReviewCommentQuerySchema,
  t_ReactionsListForReleaseParamSchema,
  t_ReactionsListForReleaseQuerySchema,
  t_ReactionsListForTeamDiscussionCommentInOrgParamSchema,
  t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema,
  t_ReactionsListForTeamDiscussionCommentLegacyParamSchema,
  t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema,
  t_ReactionsListForTeamDiscussionInOrgParamSchema,
  t_ReactionsListForTeamDiscussionInOrgQuerySchema,
  t_ReactionsListForTeamDiscussionLegacyParamSchema,
  t_ReactionsListForTeamDiscussionLegacyQuerySchema,
  t_ReposAcceptInvitationForAuthenticatedUserParamSchema,
  t_ReposAddAppAccessRestrictionsBodySchema,
  t_ReposAddAppAccessRestrictionsParamSchema,
  t_ReposAddCollaboratorBodySchema,
  t_ReposAddCollaboratorParamSchema,
  t_ReposAddStatusCheckContextsBodySchema,
  t_ReposAddStatusCheckContextsParamSchema,
  t_ReposAddTeamAccessRestrictionsBodySchema,
  t_ReposAddTeamAccessRestrictionsParamSchema,
  t_ReposAddUserAccessRestrictionsBodySchema,
  t_ReposAddUserAccessRestrictionsParamSchema,
  t_ReposCheckCollaboratorParamSchema,
  t_ReposCheckVulnerabilityAlertsParamSchema,
  t_ReposCodeownersErrorsParamSchema,
  t_ReposCodeownersErrorsQuerySchema,
  t_ReposCompareCommitsParamSchema,
  t_ReposCompareCommitsQuerySchema,
  t_ReposCreateAutolinkBodySchema,
  t_ReposCreateAutolinkParamSchema,
  t_ReposCreateCommitCommentBodySchema,
  t_ReposCreateCommitCommentParamSchema,
  t_ReposCreateCommitSignatureProtectionParamSchema,
  t_ReposCreateCommitStatusBodySchema,
  t_ReposCreateCommitStatusParamSchema,
  t_ReposCreateDeployKeyBodySchema,
  t_ReposCreateDeployKeyParamSchema,
  t_ReposCreateDeploymentBodySchema,
  t_ReposCreateDeploymentBranchPolicyBodySchema,
  t_ReposCreateDeploymentBranchPolicyParamSchema,
  t_ReposCreateDeploymentParamSchema,
  t_ReposCreateDeploymentStatusBodySchema,
  t_ReposCreateDeploymentStatusParamSchema,
  t_ReposCreateDispatchEventBodySchema,
  t_ReposCreateDispatchEventParamSchema,
  t_ReposCreateForAuthenticatedUserBodySchema,
  t_ReposCreateForkBodySchema,
  t_ReposCreateForkParamSchema,
  t_ReposCreateInOrgBodySchema,
  t_ReposCreateInOrgParamSchema,
  t_ReposCreateOrUpdateEnvironmentBodySchema,
  t_ReposCreateOrUpdateEnvironmentParamSchema,
  t_ReposCreateOrUpdateFileContentsBodySchema,
  t_ReposCreateOrUpdateFileContentsParamSchema,
  t_ReposCreatePagesDeploymentBodySchema,
  t_ReposCreatePagesDeploymentParamSchema,
  t_ReposCreatePagesSiteBodySchema,
  t_ReposCreatePagesSiteParamSchema,
  t_ReposCreateReleaseBodySchema,
  t_ReposCreateReleaseParamSchema,
  t_ReposCreateTagProtectionBodySchema,
  t_ReposCreateTagProtectionParamSchema,
  t_ReposCreateUsingTemplateBodySchema,
  t_ReposCreateUsingTemplateParamSchema,
  t_ReposCreateWebhookBodySchema,
  t_ReposCreateWebhookParamSchema,
  t_ReposDeclineInvitationForAuthenticatedUserParamSchema,
  t_ReposDeleteAccessRestrictionsParamSchema,
  t_ReposDeleteAdminBranchProtectionParamSchema,
  t_ReposDeleteAnEnvironmentParamSchema,
  t_ReposDeleteAutolinkParamSchema,
  t_ReposDeleteBranchProtectionParamSchema,
  t_ReposDeleteCommitCommentParamSchema,
  t_ReposDeleteCommitSignatureProtectionParamSchema,
  t_ReposDeleteDeployKeyParamSchema,
  t_ReposDeleteDeploymentBranchPolicyParamSchema,
  t_ReposDeleteDeploymentParamSchema,
  t_ReposDeleteFileBodySchema,
  t_ReposDeleteFileParamSchema,
  t_ReposDeleteInvitationParamSchema,
  t_ReposDeletePagesSiteParamSchema,
  t_ReposDeleteParamSchema,
  t_ReposDeletePullRequestReviewProtectionParamSchema,
  t_ReposDeleteReleaseAssetParamSchema,
  t_ReposDeleteReleaseParamSchema,
  t_ReposDeleteTagProtectionParamSchema,
  t_ReposDeleteWebhookParamSchema,
  t_ReposDisableAutomatedSecurityFixesParamSchema,
  t_ReposDisableLfsForRepoParamSchema,
  t_ReposDisableVulnerabilityAlertsParamSchema,
  t_ReposDownloadTarballArchiveParamSchema,
  t_ReposDownloadZipballArchiveParamSchema,
  t_ReposEnableAutomatedSecurityFixesParamSchema,
  t_ReposEnableLfsForRepoParamSchema,
  t_ReposEnableVulnerabilityAlertsParamSchema,
  t_ReposGenerateReleaseNotesBodySchema,
  t_ReposGenerateReleaseNotesParamSchema,
  t_ReposGetAccessRestrictionsParamSchema,
  t_ReposGetAdminBranchProtectionParamSchema,
  t_ReposGetAllEnvironmentsParamSchema,
  t_ReposGetAllEnvironmentsQuerySchema,
  t_ReposGetAllStatusCheckContextsParamSchema,
  t_ReposGetAllTopicsParamSchema,
  t_ReposGetAllTopicsQuerySchema,
  t_ReposGetAppsWithAccessToProtectedBranchParamSchema,
  t_ReposGetAutolinkParamSchema,
  t_ReposGetBranchParamSchema,
  t_ReposGetBranchProtectionParamSchema,
  t_ReposGetClonesParamSchema,
  t_ReposGetClonesQuerySchema,
  t_ReposGetCodeFrequencyStatsParamSchema,
  t_ReposGetCollaboratorPermissionLevelParamSchema,
  t_ReposGetCombinedStatusForRefParamSchema,
  t_ReposGetCombinedStatusForRefQuerySchema,
  t_ReposGetCommitActivityStatsParamSchema,
  t_ReposGetCommitCommentParamSchema,
  t_ReposGetCommitParamSchema,
  t_ReposGetCommitQuerySchema,
  t_ReposGetCommitSignatureProtectionParamSchema,
  t_ReposGetCommunityProfileMetricsParamSchema,
  t_ReposGetContentParamSchema,
  t_ReposGetContentQuerySchema,
  t_ReposGetContributorsStatsParamSchema,
  t_ReposGetDeployKeyParamSchema,
  t_ReposGetDeploymentBranchPolicyParamSchema,
  t_ReposGetDeploymentParamSchema,
  t_ReposGetDeploymentStatusParamSchema,
  t_ReposGetEnvironmentParamSchema,
  t_ReposGetLatestPagesBuildParamSchema,
  t_ReposGetLatestReleaseParamSchema,
  t_ReposGetPagesBuildParamSchema,
  t_ReposGetPagesHealthCheckParamSchema,
  t_ReposGetPagesParamSchema,
  t_ReposGetParamSchema,
  t_ReposGetParticipationStatsParamSchema,
  t_ReposGetPullRequestReviewProtectionParamSchema,
  t_ReposGetPunchCardStatsParamSchema,
  t_ReposGetReadmeInDirectoryParamSchema,
  t_ReposGetReadmeInDirectoryQuerySchema,
  t_ReposGetReadmeParamSchema,
  t_ReposGetReadmeQuerySchema,
  t_ReposGetReleaseAssetParamSchema,
  t_ReposGetReleaseByTagParamSchema,
  t_ReposGetReleaseParamSchema,
  t_ReposGetStatusChecksProtectionParamSchema,
  t_ReposGetTeamsWithAccessToProtectedBranchParamSchema,
  t_ReposGetTopPathsParamSchema,
  t_ReposGetTopReferrersParamSchema,
  t_ReposGetUsersWithAccessToProtectedBranchParamSchema,
  t_ReposGetViewsParamSchema,
  t_ReposGetViewsQuerySchema,
  t_ReposGetWebhookConfigForRepoParamSchema,
  t_ReposGetWebhookDeliveryParamSchema,
  t_ReposGetWebhookParamSchema,
  t_ReposListAutolinksParamSchema,
  t_ReposListAutolinksQuerySchema,
  t_ReposListBranchesForHeadCommitParamSchema,
  t_ReposListBranchesParamSchema,
  t_ReposListBranchesQuerySchema,
  t_ReposListCollaboratorsParamSchema,
  t_ReposListCollaboratorsQuerySchema,
  t_ReposListCommentsForCommitParamSchema,
  t_ReposListCommentsForCommitQuerySchema,
  t_ReposListCommitCommentsForRepoParamSchema,
  t_ReposListCommitCommentsForRepoQuerySchema,
  t_ReposListCommitStatusesForRefParamSchema,
  t_ReposListCommitStatusesForRefQuerySchema,
  t_ReposListCommitsParamSchema,
  t_ReposListCommitsQuerySchema,
  t_ReposListContributorsParamSchema,
  t_ReposListContributorsQuerySchema,
  t_ReposListDeployKeysParamSchema,
  t_ReposListDeployKeysQuerySchema,
  t_ReposListDeploymentBranchPoliciesParamSchema,
  t_ReposListDeploymentBranchPoliciesQuerySchema,
  t_ReposListDeploymentStatusesParamSchema,
  t_ReposListDeploymentStatusesQuerySchema,
  t_ReposListDeploymentsParamSchema,
  t_ReposListDeploymentsQuerySchema,
  t_ReposListForAuthenticatedUserQuerySchema,
  t_ReposListForOrgParamSchema,
  t_ReposListForOrgQuerySchema,
  t_ReposListForUserParamSchema,
  t_ReposListForUserQuerySchema,
  t_ReposListForksParamSchema,
  t_ReposListForksQuerySchema,
  t_ReposListInvitationsForAuthenticatedUserQuerySchema,
  t_ReposListInvitationsParamSchema,
  t_ReposListInvitationsQuerySchema,
  t_ReposListLanguagesParamSchema,
  t_ReposListPagesBuildsParamSchema,
  t_ReposListPagesBuildsQuerySchema,
  t_ReposListPublicQuerySchema,
  t_ReposListPullRequestsAssociatedWithCommitParamSchema,
  t_ReposListPullRequestsAssociatedWithCommitQuerySchema,
  t_ReposListReleaseAssetsParamSchema,
  t_ReposListReleaseAssetsQuerySchema,
  t_ReposListReleasesParamSchema,
  t_ReposListReleasesQuerySchema,
  t_ReposListTagProtectionParamSchema,
  t_ReposListTagsParamSchema,
  t_ReposListTagsQuerySchema,
  t_ReposListTeamsParamSchema,
  t_ReposListTeamsQuerySchema,
  t_ReposListWebhookDeliveriesParamSchema,
  t_ReposListWebhookDeliveriesQuerySchema,
  t_ReposListWebhooksParamSchema,
  t_ReposListWebhooksQuerySchema,
  t_ReposMergeBodySchema,
  t_ReposMergeParamSchema,
  t_ReposMergeUpstreamBodySchema,
  t_ReposMergeUpstreamParamSchema,
  t_ReposPingWebhookParamSchema,
  t_ReposRedeliverWebhookDeliveryParamSchema,
  t_ReposRemoveAppAccessRestrictionsBodySchema,
  t_ReposRemoveAppAccessRestrictionsParamSchema,
  t_ReposRemoveCollaboratorParamSchema,
  t_ReposRemoveStatusCheckContextsBodySchema,
  t_ReposRemoveStatusCheckContextsParamSchema,
  t_ReposRemoveStatusCheckProtectionParamSchema,
  t_ReposRemoveTeamAccessRestrictionsBodySchema,
  t_ReposRemoveTeamAccessRestrictionsParamSchema,
  t_ReposRemoveUserAccessRestrictionsBodySchema,
  t_ReposRemoveUserAccessRestrictionsParamSchema,
  t_ReposRenameBranchBodySchema,
  t_ReposRenameBranchParamSchema,
  t_ReposReplaceAllTopicsBodySchema,
  t_ReposReplaceAllTopicsParamSchema,
  t_ReposRequestPagesBuildParamSchema,
  t_ReposSetAdminBranchProtectionParamSchema,
  t_ReposSetAppAccessRestrictionsBodySchema,
  t_ReposSetAppAccessRestrictionsParamSchema,
  t_ReposSetStatusCheckContextsBodySchema,
  t_ReposSetStatusCheckContextsParamSchema,
  t_ReposSetTeamAccessRestrictionsBodySchema,
  t_ReposSetTeamAccessRestrictionsParamSchema,
  t_ReposSetUserAccessRestrictionsBodySchema,
  t_ReposSetUserAccessRestrictionsParamSchema,
  t_ReposTestPushWebhookParamSchema,
  t_ReposTransferBodySchema,
  t_ReposTransferParamSchema,
  t_ReposUpdateBodySchema,
  t_ReposUpdateBranchProtectionBodySchema,
  t_ReposUpdateBranchProtectionParamSchema,
  t_ReposUpdateCommitCommentBodySchema,
  t_ReposUpdateCommitCommentParamSchema,
  t_ReposUpdateDeploymentBranchPolicyBodySchema,
  t_ReposUpdateDeploymentBranchPolicyParamSchema,
  t_ReposUpdateInformationAboutPagesSiteBodySchema,
  t_ReposUpdateInformationAboutPagesSiteParamSchema,
  t_ReposUpdateInvitationBodySchema,
  t_ReposUpdateInvitationParamSchema,
  t_ReposUpdateParamSchema,
  t_ReposUpdatePullRequestReviewProtectionBodySchema,
  t_ReposUpdatePullRequestReviewProtectionParamSchema,
  t_ReposUpdateReleaseAssetBodySchema,
  t_ReposUpdateReleaseAssetParamSchema,
  t_ReposUpdateReleaseBodySchema,
  t_ReposUpdateReleaseParamSchema,
  t_ReposUpdateStatusCheckProtectionBodySchema,
  t_ReposUpdateStatusCheckProtectionParamSchema,
  t_ReposUpdateWebhookBodySchema,
  t_ReposUpdateWebhookConfigForRepoBodySchema,
  t_ReposUpdateWebhookConfigForRepoParamSchema,
  t_ReposUpdateWebhookParamSchema,
  t_ReposUploadReleaseAssetBodySchema,
  t_ReposUploadReleaseAssetParamSchema,
  t_ReposUploadReleaseAssetQuerySchema,
  t_SearchCodeQuerySchema,
  t_SearchCommitsQuerySchema,
  t_SearchIssuesAndPullRequestsQuerySchema,
  t_SearchLabelsQuerySchema,
  t_SearchReposQuerySchema,
  t_SearchTopicsQuerySchema,
  t_SearchUsersQuerySchema,
  t_SecretScanningGetAlertParamSchema,
  t_SecretScanningGetSecurityAnalysisSettingsForEnterpriseParamSchema,
  t_SecretScanningListAlertsForEnterpriseParamSchema,
  t_SecretScanningListAlertsForEnterpriseQuerySchema,
  t_SecretScanningListAlertsForOrgParamSchema,
  t_SecretScanningListAlertsForOrgQuerySchema,
  t_SecretScanningListAlertsForRepoParamSchema,
  t_SecretScanningListAlertsForRepoQuerySchema,
  t_SecretScanningListLocationsForAlertParamSchema,
  t_SecretScanningListLocationsForAlertQuerySchema,
  t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseBodySchema,
  t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseParamSchema,
  t_SecretScanningPostSecurityProductEnablementForEnterpriseParamSchema,
  t_SecretScanningUpdateAlertBodySchema,
  t_SecretScanningUpdateAlertParamSchema,
  t_TeamsAddMemberLegacyParamSchema,
  t_TeamsAddOrUpdateMembershipForUserInOrgBodySchema,
  t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema,
  t_TeamsAddOrUpdateMembershipForUserLegacyBodySchema,
  t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema,
  t_TeamsAddOrUpdateProjectPermissionsInOrgBodySchema,
  t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema,
  t_TeamsAddOrUpdateProjectPermissionsLegacyBodySchema,
  t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema,
  t_TeamsAddOrUpdateRepoPermissionsInOrgBodySchema,
  t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema,
  t_TeamsAddOrUpdateRepoPermissionsLegacyBodySchema,
  t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema,
  t_TeamsCheckPermissionsForProjectInOrgParamSchema,
  t_TeamsCheckPermissionsForProjectLegacyParamSchema,
  t_TeamsCheckPermissionsForRepoInOrgParamSchema,
  t_TeamsCheckPermissionsForRepoLegacyParamSchema,
  t_TeamsCreateBodySchema,
  t_TeamsCreateDiscussionCommentInOrgBodySchema,
  t_TeamsCreateDiscussionCommentInOrgParamSchema,
  t_TeamsCreateDiscussionCommentLegacyBodySchema,
  t_TeamsCreateDiscussionCommentLegacyParamSchema,
  t_TeamsCreateDiscussionInOrgBodySchema,
  t_TeamsCreateDiscussionInOrgParamSchema,
  t_TeamsCreateDiscussionLegacyBodySchema,
  t_TeamsCreateDiscussionLegacyParamSchema,
  t_TeamsCreateParamSchema,
  t_TeamsDeleteDiscussionCommentInOrgParamSchema,
  t_TeamsDeleteDiscussionCommentLegacyParamSchema,
  t_TeamsDeleteDiscussionInOrgParamSchema,
  t_TeamsDeleteDiscussionLegacyParamSchema,
  t_TeamsDeleteInOrgParamSchema,
  t_TeamsDeleteLegacyParamSchema,
  t_TeamsGetByNameParamSchema,
  t_TeamsGetDiscussionCommentInOrgParamSchema,
  t_TeamsGetDiscussionCommentLegacyParamSchema,
  t_TeamsGetDiscussionInOrgParamSchema,
  t_TeamsGetDiscussionLegacyParamSchema,
  t_TeamsGetLegacyParamSchema,
  t_TeamsGetMemberLegacyParamSchema,
  t_TeamsGetMembershipForUserInOrgParamSchema,
  t_TeamsGetMembershipForUserLegacyParamSchema,
  t_TeamsListChildInOrgParamSchema,
  t_TeamsListChildInOrgQuerySchema,
  t_TeamsListChildLegacyParamSchema,
  t_TeamsListChildLegacyQuerySchema,
  t_TeamsListDiscussionCommentsInOrgParamSchema,
  t_TeamsListDiscussionCommentsInOrgQuerySchema,
  t_TeamsListDiscussionCommentsLegacyParamSchema,
  t_TeamsListDiscussionCommentsLegacyQuerySchema,
  t_TeamsListDiscussionsInOrgParamSchema,
  t_TeamsListDiscussionsInOrgQuerySchema,
  t_TeamsListDiscussionsLegacyParamSchema,
  t_TeamsListDiscussionsLegacyQuerySchema,
  t_TeamsListForAuthenticatedUserQuerySchema,
  t_TeamsListMembersInOrgParamSchema,
  t_TeamsListMembersInOrgQuerySchema,
  t_TeamsListMembersLegacyParamSchema,
  t_TeamsListMembersLegacyQuerySchema,
  t_TeamsListParamSchema,
  t_TeamsListPendingInvitationsInOrgParamSchema,
  t_TeamsListPendingInvitationsInOrgQuerySchema,
  t_TeamsListPendingInvitationsLegacyParamSchema,
  t_TeamsListPendingInvitationsLegacyQuerySchema,
  t_TeamsListProjectsInOrgParamSchema,
  t_TeamsListProjectsInOrgQuerySchema,
  t_TeamsListProjectsLegacyParamSchema,
  t_TeamsListProjectsLegacyQuerySchema,
  t_TeamsListQuerySchema,
  t_TeamsListReposInOrgParamSchema,
  t_TeamsListReposInOrgQuerySchema,
  t_TeamsListReposLegacyParamSchema,
  t_TeamsListReposLegacyQuerySchema,
  t_TeamsRemoveMemberLegacyParamSchema,
  t_TeamsRemoveMembershipForUserInOrgParamSchema,
  t_TeamsRemoveMembershipForUserLegacyParamSchema,
  t_TeamsRemoveProjectInOrgParamSchema,
  t_TeamsRemoveProjectLegacyParamSchema,
  t_TeamsRemoveRepoInOrgParamSchema,
  t_TeamsRemoveRepoLegacyParamSchema,
  t_TeamsUpdateDiscussionCommentInOrgBodySchema,
  t_TeamsUpdateDiscussionCommentInOrgParamSchema,
  t_TeamsUpdateDiscussionCommentLegacyBodySchema,
  t_TeamsUpdateDiscussionCommentLegacyParamSchema,
  t_TeamsUpdateDiscussionInOrgBodySchema,
  t_TeamsUpdateDiscussionInOrgParamSchema,
  t_TeamsUpdateDiscussionLegacyBodySchema,
  t_TeamsUpdateDiscussionLegacyParamSchema,
  t_TeamsUpdateInOrgBodySchema,
  t_TeamsUpdateInOrgParamSchema,
  t_TeamsUpdateLegacyBodySchema,
  t_TeamsUpdateLegacyParamSchema,
  t_UsersAddEmailForAuthenticatedUserBodySchema,
  t_UsersBlockParamSchema,
  t_UsersCheckBlockedParamSchema,
  t_UsersCheckFollowingForUserParamSchema,
  t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema,
  t_UsersCreateGpgKeyForAuthenticatedUserBodySchema,
  t_UsersCreatePublicSshKeyForAuthenticatedUserBodySchema,
  t_UsersCreateSshSigningKeyForAuthenticatedUserBodySchema,
  t_UsersDeleteEmailForAuthenticatedUserBodySchema,
  t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema,
  t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema,
  t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
  t_UsersFollowParamSchema,
  t_UsersGetByUsernameParamSchema,
  t_UsersGetContextForUserParamSchema,
  t_UsersGetContextForUserQuerySchema,
  t_UsersGetGpgKeyForAuthenticatedUserParamSchema,
  t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema,
  t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema,
  t_UsersListBlockedByAuthenticatedUserQuerySchema,
  t_UsersListEmailsForAuthenticatedUserQuerySchema,
  t_UsersListFollowedByAuthenticatedUserQuerySchema,
  t_UsersListFollowersForAuthenticatedUserQuerySchema,
  t_UsersListFollowersForUserParamSchema,
  t_UsersListFollowersForUserQuerySchema,
  t_UsersListFollowingForUserParamSchema,
  t_UsersListFollowingForUserQuerySchema,
  t_UsersListGpgKeysForAuthenticatedUserQuerySchema,
  t_UsersListGpgKeysForUserParamSchema,
  t_UsersListGpgKeysForUserQuerySchema,
  t_UsersListPublicEmailsForAuthenticatedUserQuerySchema,
  t_UsersListPublicKeysForUserParamSchema,
  t_UsersListPublicKeysForUserQuerySchema,
  t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema,
  t_UsersListQuerySchema,
  t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema,
  t_UsersListSshSigningKeysForUserParamSchema,
  t_UsersListSshSigningKeysForUserQuerySchema,
  t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema,
  t_UsersUnblockParamSchema,
  t_UsersUnfollowParamSchema,
  t_UsersUpdateAuthenticatedBodySchema,
} from "./models"
import KoaRouter from "@koa/router"
import {
  ServerConfig,
  startServer,
} from "@nahkies/typescript-koa-runtime/server"
import {
  bodyValidationFactory,
  paramValidationFactory,
  queryValidationFactory,
} from "@nahkies/typescript-koa-runtime/zod"
import { Context, Next } from "koa"
import { z } from "zod"

//region safe-edit-region-header
//endregion safe-edit-region-header

type Params<Params, Query, Body> = { params: Params; query: Query; body: Body }

interface ValidatedCtx<Params, Query, Body> extends Context {
  state: { params: Params; query: Query; body: Body }
}

export type MetaRoot = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetAuthenticated = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsCreateFromManifest = (
  params: Params<t_AppsCreateFromManifestParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetWebhookConfigForApp = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsUpdateWebhookConfigForApp = (
  params: Params<void, void, t_AppsUpdateWebhookConfigForAppBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListWebhookDeliveries = (
  params: Params<void, t_AppsListWebhookDeliveriesQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetWebhookDelivery = (
  params: Params<t_AppsGetWebhookDeliveryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsRedeliverWebhookDelivery = (
  params: Params<t_AppsRedeliverWebhookDeliveryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListInstallations = (
  params: Params<void, t_AppsListInstallationsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetInstallation = (
  params: Params<t_AppsGetInstallationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsDeleteInstallation = (
  params: Params<t_AppsDeleteInstallationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsCreateInstallationAccessToken = (
  params: Params<
    t_AppsCreateInstallationAccessTokenParamSchema,
    void,
    t_AppsCreateInstallationAccessTokenBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsSuspendInstallation = (
  params: Params<t_AppsSuspendInstallationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsUnsuspendInstallation = (
  params: Params<t_AppsUnsuspendInstallationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsDeleteAuthorization = (
  params: Params<
    t_AppsDeleteAuthorizationParamSchema,
    void,
    t_AppsDeleteAuthorizationBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsCheckToken = (
  params: Params<t_AppsCheckTokenParamSchema, void, t_AppsCheckTokenBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsResetToken = (
  params: Params<t_AppsResetTokenParamSchema, void, t_AppsResetTokenBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsDeleteToken = (
  params: Params<
    t_AppsDeleteTokenParamSchema,
    void,
    t_AppsDeleteTokenBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsScopeToken = (
  params: Params<t_AppsScopeTokenParamSchema, void, t_AppsScopeTokenBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetBySlug = (
  params: Params<t_AppsGetBySlugParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodesOfConductGetAllCodesOfConduct = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodesOfConductGetConductCode = (
  params: Params<t_CodesOfConductGetConductCodeParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EmojisGet = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise = (
  params: Params<
    t_EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise = (
  params: Params<
    t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParamSchema,
    t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise = (
  params: Params<
    t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParamSchema,
    void,
    t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise = (
  params: Params<
    t_EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise = (
  params: Params<
    t_EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise = (
  params: Params<
    t_EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise = (
  params: Params<
    t_EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise = (
  params: Params<
    t_EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise = (
  params: Params<
    t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseParamSchema,
    void,
    t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningGetSecurityAnalysisSettingsForEnterprise = (
  params: Params<
    t_SecretScanningGetSecurityAnalysisSettingsForEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningPatchSecurityAnalysisSettingsForEnterprise = (
  params: Params<
    t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseParamSchema,
    void,
    | t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseBodySchema
    | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotListAlertsForEnterprise = (
  params: Params<
    t_DependabotListAlertsForEnterpriseParamSchema,
    t_DependabotListAlertsForEnterpriseQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningListAlertsForEnterprise = (
  params: Params<
    t_SecretScanningListAlertsForEnterpriseParamSchema,
    t_SecretScanningListAlertsForEnterpriseQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningPostSecurityProductEnablementForEnterprise = (
  params: Params<
    t_SecretScanningPostSecurityProductEnablementForEnterpriseParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListPublicEvents = (
  params: Params<void, t_ActivityListPublicEventsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityGetFeeds = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsList = (
  params: Params<void, t_GistsListQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsCreate = (
  params: Params<void, void, t_GistsCreateBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsListPublic = (
  params: Params<void, t_GistsListPublicQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsListStarred = (
  params: Params<void, t_GistsListStarredQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsGet = (
  params: Params<t_GistsGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsUpdate = (
  params: Params<t_GistsUpdateParamSchema, void, t_GistsUpdateBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsDelete = (
  params: Params<t_GistsDeleteParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsListComments = (
  params: Params<
    t_GistsListCommentsParamSchema,
    t_GistsListCommentsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsCreateComment = (
  params: Params<
    t_GistsCreateCommentParamSchema,
    void,
    t_GistsCreateCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsGetComment = (
  params: Params<t_GistsGetCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsUpdateComment = (
  params: Params<
    t_GistsUpdateCommentParamSchema,
    void,
    t_GistsUpdateCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsDeleteComment = (
  params: Params<t_GistsDeleteCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsListCommits = (
  params: Params<
    t_GistsListCommitsParamSchema,
    t_GistsListCommitsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsListForks = (
  params: Params<
    t_GistsListForksParamSchema,
    t_GistsListForksQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsFork = (
  params: Params<t_GistsForkParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsCheckIsStarred = (
  params: Params<t_GistsCheckIsStarredParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsStar = (
  params: Params<t_GistsStarParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsUnstar = (
  params: Params<t_GistsUnstarParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsGetRevision = (
  params: Params<t_GistsGetRevisionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitignoreGetAllTemplates = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitignoreGetTemplate = (
  params: Params<t_GitignoreGetTemplateParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListReposAccessibleToInstallation = (
  params: Params<
    void,
    t_AppsListReposAccessibleToInstallationQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsRevokeInstallationAccessToken = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesList = (
  params: Params<void, t_IssuesListQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type LicensesGetAllCommonlyUsed = (
  params: Params<void, t_LicensesGetAllCommonlyUsedQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type LicensesGet = (
  params: Params<t_LicensesGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MarkdownRender = (
  params: Params<void, void, t_MarkdownRenderBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MarkdownRenderRaw = (
  params: Params<void, void, t_MarkdownRenderRawBodySchema | undefined>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetSubscriptionPlanForAccount = (
  params: Params<t_AppsGetSubscriptionPlanForAccountParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListPlans = (
  params: Params<void, t_AppsListPlansQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListAccountsForPlan = (
  params: Params<
    t_AppsListAccountsForPlanParamSchema,
    t_AppsListAccountsForPlanQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetSubscriptionPlanForAccountStubbed = (
  params: Params<
    t_AppsGetSubscriptionPlanForAccountStubbedParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListPlansStubbed = (
  params: Params<void, t_AppsListPlansStubbedQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListAccountsForPlanStubbed = (
  params: Params<
    t_AppsListAccountsForPlanStubbedParamSchema,
    t_AppsListAccountsForPlanStubbedQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MetaGet = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListPublicEventsForRepoNetwork = (
  params: Params<
    t_ActivityListPublicEventsForRepoNetworkParamSchema,
    t_ActivityListPublicEventsForRepoNetworkQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListNotificationsForAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListNotificationsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityMarkNotificationsAsRead = (
  params: Params<
    void,
    void,
    t_ActivityMarkNotificationsAsReadBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityGetThread = (
  params: Params<t_ActivityGetThreadParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityMarkThreadAsRead = (
  params: Params<t_ActivityMarkThreadAsReadParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityGetThreadSubscriptionForAuthenticatedUser = (
  params: Params<
    t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivitySetThreadSubscription = (
  params: Params<
    t_ActivitySetThreadSubscriptionParamSchema,
    void,
    t_ActivitySetThreadSubscriptionBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityDeleteThreadSubscription = (
  params: Params<t_ActivityDeleteThreadSubscriptionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MetaGetOctocat = (
  params: Params<void, t_MetaGetOctocatQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsList = (
  params: Params<void, t_OrgsListQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsGet = (
  params: Params<t_OrgsGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsUpdate = (
  params: Params<
    t_OrgsUpdateParamSchema,
    void,
    t_OrgsUpdateBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetActionsCacheUsageForOrg = (
  params: Params<t_ActionsGetActionsCacheUsageForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetActionsCacheUsageByRepoForOrg = (
  params: Params<
    t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema,
    t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OidcGetOidcCustomSubTemplateForOrg = (
  params: Params<t_OidcGetOidcCustomSubTemplateForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OidcUpdateOidcCustomSubTemplateForOrg = (
  params: Params<
    t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema,
    void,
    t_OidcUpdateOidcCustomSubTemplateForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetGithubActionsPermissionsOrganization = (
  params: Params<
    t_ActionsGetGithubActionsPermissionsOrganizationParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetGithubActionsPermissionsOrganization = (
  params: Params<
    t_ActionsSetGithubActionsPermissionsOrganizationParamSchema,
    void,
    t_ActionsSetGithubActionsPermissionsOrganizationBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganization = (
  params: Params<
    t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
    t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization = (
  params: Params<
    t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
    void,
    t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsEnableSelectedRepositoryGithubActionsOrganization = (
  params: Params<
    t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDisableSelectedRepositoryGithubActionsOrganization = (
  params: Params<
    t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetAllowedActionsOrganization = (
  params: Params<t_ActionsGetAllowedActionsOrganizationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetAllowedActionsOrganization = (
  params: Params<
    t_ActionsSetAllowedActionsOrganizationParamSchema,
    void,
    t_ActionsSetAllowedActionsOrganizationBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization = (
  params: Params<
    t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization = (
  params: Params<
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
    void,
    | t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema
    | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRequiredWorkflows = (
  params: Params<
    t_ActionsListRequiredWorkflowsParamSchema,
    t_ActionsListRequiredWorkflowsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateRequiredWorkflow = (
  params: Params<
    t_ActionsCreateRequiredWorkflowParamSchema,
    void,
    t_ActionsCreateRequiredWorkflowBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetRequiredWorkflow = (
  params: Params<t_ActionsGetRequiredWorkflowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsUpdateRequiredWorkflow = (
  params: Params<
    t_ActionsUpdateRequiredWorkflowParamSchema,
    void,
    t_ActionsUpdateRequiredWorkflowBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteRequiredWorkflow = (
  params: Params<t_ActionsDeleteRequiredWorkflowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelectedRepositoriesRequiredWorkflow = (
  params: Params<
    t_ActionsListSelectedRepositoriesRequiredWorkflowParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetSelectedReposToRequiredWorkflow = (
  params: Params<
    t_ActionsSetSelectedReposToRequiredWorkflowParamSchema,
    void,
    t_ActionsSetSelectedReposToRequiredWorkflowBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsAddSelectedRepoToRequiredWorkflow = (
  params: Params<
    t_ActionsAddSelectedRepoToRequiredWorkflowParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveSelectedRepoFromRequiredWorkflow = (
  params: Params<
    t_ActionsRemoveSelectedRepoFromRequiredWorkflowParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelfHostedRunnerGroupsForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema,
    t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema,
    void,
    t_ActionsCreateSelfHostedRunnerGroupForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsUpdateSelfHostedRunnerGroupForOrg = (
  params: Params<
    t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
    void,
    t_ActionsUpdateSelfHostedRunnerGroupForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteSelfHostedRunnerGroupFromOrg = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg = (
  params: Params<
    t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelfHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema,
    t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetSelfHostedRunnersInGroupForOrg = (
  params: Params<
    t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema,
    void,
    t_ActionsSetSelfHostedRunnersInGroupForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsAddSelfHostedRunnerToGroupForOrg = (
  params: Params<
    t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveSelfHostedRunnerFromGroupForOrg = (
  params: Params<
    t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelfHostedRunnersForOrg = (
  params: Params<
    t_ActionsListSelfHostedRunnersForOrgParamSchema,
    t_ActionsListSelfHostedRunnersForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRunnerApplicationsForOrg = (
  params: Params<t_ActionsListRunnerApplicationsForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateRegistrationTokenForOrg = (
  params: Params<t_ActionsCreateRegistrationTokenForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateRemoveTokenForOrg = (
  params: Params<t_ActionsCreateRemoveTokenForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetSelfHostedRunnerForOrg = (
  params: Params<t_ActionsGetSelfHostedRunnerForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteSelfHostedRunnerFromOrg = (
  params: Params<t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListLabelsForSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
    void,
    t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
    void,
    t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg = (
  params: Params<
    t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListOrgSecrets = (
  params: Params<
    t_ActionsListOrgSecretsParamSchema,
    t_ActionsListOrgSecretsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetOrgPublicKey = (
  params: Params<t_ActionsGetOrgPublicKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetOrgSecret = (
  params: Params<t_ActionsGetOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateOrUpdateOrgSecret = (
  params: Params<
    t_ActionsCreateOrUpdateOrgSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateOrgSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteOrgSecret = (
  params: Params<t_ActionsDeleteOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelectedReposForOrgSecret = (
  params: Params<
    t_ActionsListSelectedReposForOrgSecretParamSchema,
    t_ActionsListSelectedReposForOrgSecretQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetSelectedReposForOrgSecret = (
  params: Params<
    t_ActionsSetSelectedReposForOrgSecretParamSchema,
    void,
    t_ActionsSetSelectedReposForOrgSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsAddSelectedRepoToOrgSecret = (
  params: Params<t_ActionsAddSelectedRepoToOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListOrgVariables = (
  params: Params<
    t_ActionsListOrgVariablesParamSchema,
    t_ActionsListOrgVariablesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateOrgVariable = (
  params: Params<
    t_ActionsCreateOrgVariableParamSchema,
    void,
    t_ActionsCreateOrgVariableBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetOrgVariable = (
  params: Params<t_ActionsGetOrgVariableParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsUpdateOrgVariable = (
  params: Params<
    t_ActionsUpdateOrgVariableParamSchema,
    void,
    t_ActionsUpdateOrgVariableBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteOrgVariable = (
  params: Params<t_ActionsDeleteOrgVariableParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelectedReposForOrgVariable = (
  params: Params<
    t_ActionsListSelectedReposForOrgVariableParamSchema,
    t_ActionsListSelectedReposForOrgVariableQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetSelectedReposForOrgVariable = (
  params: Params<
    t_ActionsSetSelectedReposForOrgVariableParamSchema,
    void,
    t_ActionsSetSelectedReposForOrgVariableBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsAddSelectedRepoToOrgVariable = (
  params: Params<t_ActionsAddSelectedRepoToOrgVariableParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveSelectedRepoFromOrgVariable = (
  params: Params<
    t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListBlockedUsers = (
  params: Params<
    t_OrgsListBlockedUsersParamSchema,
    t_OrgsListBlockedUsersQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsCheckBlockedUser = (
  params: Params<t_OrgsCheckBlockedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsBlockUser = (
  params: Params<t_OrgsBlockUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsUnblockUser = (
  params: Params<t_OrgsUnblockUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningListAlertsForOrg = (
  params: Params<
    t_CodeScanningListAlertsForOrgParamSchema,
    t_CodeScanningListAlertsForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListInOrganization = (
  params: Params<
    t_CodespacesListInOrganizationParamSchema,
    t_CodespacesListInOrganizationQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesSetCodespacesBilling = (
  params: Params<
    t_CodespacesSetCodespacesBillingParamSchema,
    void,
    t_CodespacesSetCodespacesBillingBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListOrgSecrets = (
  params: Params<
    t_CodespacesListOrgSecretsParamSchema,
    t_CodespacesListOrgSecretsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetOrgPublicKey = (
  params: Params<t_CodespacesGetOrgPublicKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetOrgSecret = (
  params: Params<t_CodespacesGetOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesCreateOrUpdateOrgSecret = (
  params: Params<
    t_CodespacesCreateOrUpdateOrgSecretParamSchema,
    void,
    t_CodespacesCreateOrUpdateOrgSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesDeleteOrgSecret = (
  params: Params<t_CodespacesDeleteOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListSelectedReposForOrgSecret = (
  params: Params<
    t_CodespacesListSelectedReposForOrgSecretParamSchema,
    t_CodespacesListSelectedReposForOrgSecretQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesSetSelectedReposForOrgSecret = (
  params: Params<
    t_CodespacesSetSelectedReposForOrgSecretParamSchema,
    void,
    t_CodespacesSetSelectedReposForOrgSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesAddSelectedRepoToOrgSecret = (
  params: Params<t_CodespacesAddSelectedRepoToOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotListAlertsForOrg = (
  params: Params<
    t_DependabotListAlertsForOrgParamSchema,
    t_DependabotListAlertsForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotListOrgSecrets = (
  params: Params<
    t_DependabotListOrgSecretsParamSchema,
    t_DependabotListOrgSecretsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotGetOrgPublicKey = (
  params: Params<t_DependabotGetOrgPublicKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotGetOrgSecret = (
  params: Params<t_DependabotGetOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotCreateOrUpdateOrgSecret = (
  params: Params<
    t_DependabotCreateOrUpdateOrgSecretParamSchema,
    void,
    t_DependabotCreateOrUpdateOrgSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotDeleteOrgSecret = (
  params: Params<t_DependabotDeleteOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotListSelectedReposForOrgSecret = (
  params: Params<
    t_DependabotListSelectedReposForOrgSecretParamSchema,
    t_DependabotListSelectedReposForOrgSecretQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotSetSelectedReposForOrgSecret = (
  params: Params<
    t_DependabotSetSelectedReposForOrgSecretParamSchema,
    void,
    t_DependabotSetSelectedReposForOrgSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotAddSelectedRepoToOrgSecret = (
  params: Params<t_DependabotAddSelectedRepoToOrgSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotRemoveSelectedRepoFromOrgSecret = (
  params: Params<
    t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListPublicOrgEvents = (
  params: Params<
    t_ActivityListPublicOrgEventsParamSchema,
    t_ActivityListPublicOrgEventsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListFailedInvitations = (
  params: Params<
    t_OrgsListFailedInvitationsParamSchema,
    t_OrgsListFailedInvitationsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListWebhooks = (
  params: Params<
    t_OrgsListWebhooksParamSchema,
    t_OrgsListWebhooksQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsCreateWebhook = (
  params: Params<
    t_OrgsCreateWebhookParamSchema,
    void,
    t_OrgsCreateWebhookBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsGetWebhook = (
  params: Params<t_OrgsGetWebhookParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsUpdateWebhook = (
  params: Params<
    t_OrgsUpdateWebhookParamSchema,
    void,
    t_OrgsUpdateWebhookBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsDeleteWebhook = (
  params: Params<t_OrgsDeleteWebhookParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsGetWebhookConfigForOrg = (
  params: Params<t_OrgsGetWebhookConfigForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsUpdateWebhookConfigForOrg = (
  params: Params<
    t_OrgsUpdateWebhookConfigForOrgParamSchema,
    void,
    t_OrgsUpdateWebhookConfigForOrgBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListWebhookDeliveries = (
  params: Params<
    t_OrgsListWebhookDeliveriesParamSchema,
    t_OrgsListWebhookDeliveriesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsGetWebhookDelivery = (
  params: Params<t_OrgsGetWebhookDeliveryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsRedeliverWebhookDelivery = (
  params: Params<t_OrgsRedeliverWebhookDeliveryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsPingWebhook = (
  params: Params<t_OrgsPingWebhookParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetOrgInstallation = (
  params: Params<t_AppsGetOrgInstallationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListAppInstallations = (
  params: Params<
    t_OrgsListAppInstallationsParamSchema,
    t_OrgsListAppInstallationsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsGetRestrictionsForOrg = (
  params: Params<t_InteractionsGetRestrictionsForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsSetRestrictionsForOrg = (
  params: Params<
    t_InteractionsSetRestrictionsForOrgParamSchema,
    void,
    t_InteractionsSetRestrictionsForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsRemoveRestrictionsForOrg = (
  params: Params<t_InteractionsRemoveRestrictionsForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListPendingInvitations = (
  params: Params<
    t_OrgsListPendingInvitationsParamSchema,
    t_OrgsListPendingInvitationsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsCreateInvitation = (
  params: Params<
    t_OrgsCreateInvitationParamSchema,
    void,
    t_OrgsCreateInvitationBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsCancelInvitation = (
  params: Params<t_OrgsCancelInvitationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListInvitationTeams = (
  params: Params<
    t_OrgsListInvitationTeamsParamSchema,
    t_OrgsListInvitationTeamsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListForOrg = (
  params: Params<
    t_IssuesListForOrgParamSchema,
    t_IssuesListForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListMembers = (
  params: Params<
    t_OrgsListMembersParamSchema,
    t_OrgsListMembersQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsCheckMembershipForUser = (
  params: Params<t_OrgsCheckMembershipForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsRemoveMember = (
  params: Params<t_OrgsRemoveMemberParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetCodespacesForUserInOrg = (
  params: Params<
    t_CodespacesGetCodespacesForUserInOrgParamSchema,
    t_CodespacesGetCodespacesForUserInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesDeleteFromOrganization = (
  params: Params<t_CodespacesDeleteFromOrganizationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesStopInOrganization = (
  params: Params<t_CodespacesStopInOrganizationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsGetMembershipForUser = (
  params: Params<t_OrgsGetMembershipForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsSetMembershipForUser = (
  params: Params<
    t_OrgsSetMembershipForUserParamSchema,
    void,
    t_OrgsSetMembershipForUserBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsRemoveMembershipForUser = (
  params: Params<t_OrgsRemoveMembershipForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsListForOrg = (
  params: Params<
    t_MigrationsListForOrgParamSchema,
    t_MigrationsListForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsStartForOrg = (
  params: Params<
    t_MigrationsStartForOrgParamSchema,
    void,
    t_MigrationsStartForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsGetStatusForOrg = (
  params: Params<
    t_MigrationsGetStatusForOrgParamSchema,
    t_MigrationsGetStatusForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsDownloadArchiveForOrg = (
  params: Params<t_MigrationsDownloadArchiveForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsDeleteArchiveForOrg = (
  params: Params<t_MigrationsDeleteArchiveForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsUnlockRepoForOrg = (
  params: Params<t_MigrationsUnlockRepoForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsListReposForOrg = (
  params: Params<
    t_MigrationsListReposForOrgParamSchema,
    t_MigrationsListReposForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListOutsideCollaborators = (
  params: Params<
    t_OrgsListOutsideCollaboratorsParamSchema,
    t_OrgsListOutsideCollaboratorsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsConvertMemberToOutsideCollaborator = (
  params: Params<
    t_OrgsConvertMemberToOutsideCollaboratorParamSchema,
    void,
    t_OrgsConvertMemberToOutsideCollaboratorBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsRemoveOutsideCollaborator = (
  params: Params<t_OrgsRemoveOutsideCollaboratorParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesListPackagesForOrganization = (
  params: Params<
    t_PackagesListPackagesForOrganizationParamSchema,
    t_PackagesListPackagesForOrganizationQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetPackageForOrganization = (
  params: Params<t_PackagesGetPackageForOrganizationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesDeletePackageForOrg = (
  params: Params<t_PackagesDeletePackageForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesRestorePackageForOrg = (
  params: Params<
    t_PackagesRestorePackageForOrgParamSchema,
    t_PackagesRestorePackageForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
    t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetPackageVersionForOrganization = (
  params: Params<
    t_PackagesGetPackageVersionForOrganizationParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesDeletePackageVersionForOrg = (
  params: Params<t_PackagesDeletePackageVersionForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesRestorePackageVersionForOrg = (
  params: Params<t_PackagesRestorePackageVersionForOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsListForOrg = (
  params: Params<
    t_ProjectsListForOrgParamSchema,
    t_ProjectsListForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsCreateForOrg = (
  params: Params<
    t_ProjectsCreateForOrgParamSchema,
    void,
    t_ProjectsCreateForOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListPublicMembers = (
  params: Params<
    t_OrgsListPublicMembersParamSchema,
    t_OrgsListPublicMembersQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsCheckPublicMembershipForUser = (
  params: Params<t_OrgsCheckPublicMembershipForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsSetPublicMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsRemovePublicMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListForOrg = (
  params: Params<
    t_ReposListForOrgParamSchema,
    t_ReposListForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateInOrg = (
  params: Params<
    t_ReposCreateInOrgParamSchema,
    void,
    t_ReposCreateInOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningListAlertsForOrg = (
  params: Params<
    t_SecretScanningListAlertsForOrgParamSchema,
    t_SecretScanningListAlertsForOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListSecurityManagerTeams = (
  params: Params<t_OrgsListSecurityManagerTeamsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsAddSecurityManagerTeam = (
  params: Params<t_OrgsAddSecurityManagerTeamParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsRemoveSecurityManagerTeam = (
  params: Params<t_OrgsRemoveSecurityManagerTeamParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type BillingGetGithubActionsBillingOrg = (
  params: Params<t_BillingGetGithubActionsBillingOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type BillingGetGithubPackagesBillingOrg = (
  params: Params<t_BillingGetGithubPackagesBillingOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type BillingGetSharedStorageBillingOrg = (
  params: Params<t_BillingGetSharedStorageBillingOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsList = (
  params: Params<t_TeamsListParamSchema, t_TeamsListQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCreate = (
  params: Params<t_TeamsCreateParamSchema, void, t_TeamsCreateBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetByName = (
  params: Params<t_TeamsGetByNameParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsUpdateInOrg = (
  params: Params<
    t_TeamsUpdateInOrgParamSchema,
    void,
    t_TeamsUpdateInOrgBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsDeleteInOrg = (
  params: Params<t_TeamsDeleteInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListDiscussionsInOrg = (
  params: Params<
    t_TeamsListDiscussionsInOrgParamSchema,
    t_TeamsListDiscussionsInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCreateDiscussionInOrg = (
  params: Params<
    t_TeamsCreateDiscussionInOrgParamSchema,
    void,
    t_TeamsCreateDiscussionInOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetDiscussionInOrg = (
  params: Params<t_TeamsGetDiscussionInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsUpdateDiscussionInOrg = (
  params: Params<
    t_TeamsUpdateDiscussionInOrgParamSchema,
    void,
    t_TeamsUpdateDiscussionInOrgBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsDeleteDiscussionInOrg = (
  params: Params<t_TeamsDeleteDiscussionInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListDiscussionCommentsInOrg = (
  params: Params<
    t_TeamsListDiscussionCommentsInOrgParamSchema,
    t_TeamsListDiscussionCommentsInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCreateDiscussionCommentInOrg = (
  params: Params<
    t_TeamsCreateDiscussionCommentInOrgParamSchema,
    void,
    t_TeamsCreateDiscussionCommentInOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetDiscussionCommentInOrg = (
  params: Params<t_TeamsGetDiscussionCommentInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsUpdateDiscussionCommentInOrg = (
  params: Params<
    t_TeamsUpdateDiscussionCommentInOrgParamSchema,
    void,
    t_TeamsUpdateDiscussionCommentInOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsDeleteDiscussionCommentInOrg = (
  params: Params<t_TeamsDeleteDiscussionCommentInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForTeamDiscussionCommentInOrg = (
  params: Params<
    t_ReactionsListForTeamDiscussionCommentInOrgParamSchema,
    t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForTeamDiscussionCommentInOrg = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionCommentInOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsDeleteForTeamDiscussionComment = (
  params: Params<
    t_ReactionsDeleteForTeamDiscussionCommentParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForTeamDiscussionInOrg = (
  params: Params<
    t_ReactionsListForTeamDiscussionInOrgParamSchema,
    t_ReactionsListForTeamDiscussionInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForTeamDiscussionInOrg = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionInOrgParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionInOrgBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsDeleteForTeamDiscussion = (
  params: Params<t_ReactionsDeleteForTeamDiscussionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListPendingInvitationsInOrg = (
  params: Params<
    t_TeamsListPendingInvitationsInOrgParamSchema,
    t_TeamsListPendingInvitationsInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListMembersInOrg = (
  params: Params<
    t_TeamsListMembersInOrgParamSchema,
    t_TeamsListMembersInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetMembershipForUserInOrg = (
  params: Params<t_TeamsGetMembershipForUserInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsAddOrUpdateMembershipForUserInOrg = (
  params: Params<
    t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateMembershipForUserInOrgBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsRemoveMembershipForUserInOrg = (
  params: Params<t_TeamsRemoveMembershipForUserInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListProjectsInOrg = (
  params: Params<
    t_TeamsListProjectsInOrgParamSchema,
    t_TeamsListProjectsInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCheckPermissionsForProjectInOrg = (
  params: Params<t_TeamsCheckPermissionsForProjectInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsAddOrUpdateProjectPermissionsInOrg = (
  params: Params<
    t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateProjectPermissionsInOrgBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsRemoveProjectInOrg = (
  params: Params<t_TeamsRemoveProjectInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListReposInOrg = (
  params: Params<
    t_TeamsListReposInOrgParamSchema,
    t_TeamsListReposInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCheckPermissionsForRepoInOrg = (
  params: Params<t_TeamsCheckPermissionsForRepoInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsAddOrUpdateRepoPermissionsInOrg = (
  params: Params<
    t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema,
    void,
    t_TeamsAddOrUpdateRepoPermissionsInOrgBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsRemoveRepoInOrg = (
  params: Params<t_TeamsRemoveRepoInOrgParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListChildInOrg = (
  params: Params<
    t_TeamsListChildInOrgParamSchema,
    t_TeamsListChildInOrgQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsEnableOrDisableSecurityProductOnAllOrgRepos = (
  params: Params<
    t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsGetCard = (
  params: Params<t_ProjectsGetCardParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsUpdateCard = (
  params: Params<
    t_ProjectsUpdateCardParamSchema,
    void,
    t_ProjectsUpdateCardBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsDeleteCard = (
  params: Params<t_ProjectsDeleteCardParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsMoveCard = (
  params: Params<
    t_ProjectsMoveCardParamSchema,
    void,
    t_ProjectsMoveCardBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsGetColumn = (
  params: Params<t_ProjectsGetColumnParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsUpdateColumn = (
  params: Params<
    t_ProjectsUpdateColumnParamSchema,
    void,
    t_ProjectsUpdateColumnBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsDeleteColumn = (
  params: Params<t_ProjectsDeleteColumnParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsListCards = (
  params: Params<
    t_ProjectsListCardsParamSchema,
    t_ProjectsListCardsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsCreateCard = (
  params: Params<
    t_ProjectsCreateCardParamSchema,
    void,
    t_ProjectsCreateCardBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsMoveColumn = (
  params: Params<
    t_ProjectsMoveColumnParamSchema,
    void,
    t_ProjectsMoveColumnBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsGet = (
  params: Params<t_ProjectsGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsUpdate = (
  params: Params<
    t_ProjectsUpdateParamSchema,
    void,
    t_ProjectsUpdateBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsDelete = (
  params: Params<t_ProjectsDeleteParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsListCollaborators = (
  params: Params<
    t_ProjectsListCollaboratorsParamSchema,
    t_ProjectsListCollaboratorsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsAddCollaborator = (
  params: Params<
    t_ProjectsAddCollaboratorParamSchema,
    void,
    t_ProjectsAddCollaboratorBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsRemoveCollaborator = (
  params: Params<t_ProjectsRemoveCollaboratorParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsGetPermissionForUser = (
  params: Params<t_ProjectsGetPermissionForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsListColumns = (
  params: Params<
    t_ProjectsListColumnsParamSchema,
    t_ProjectsListColumnsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsCreateColumn = (
  params: Params<
    t_ProjectsCreateColumnParamSchema,
    void,
    t_ProjectsCreateColumnBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type RateLimitGet = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRepoRequiredWorkflows = (
  params: Params<
    t_ActionsListRepoRequiredWorkflowsParamSchema,
    t_ActionsListRepoRequiredWorkflowsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetRepoRequiredWorkflow = (
  params: Params<t_ActionsGetRepoRequiredWorkflowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetRepoRequiredWorkflowUsage = (
  params: Params<t_ActionsGetRepoRequiredWorkflowUsageParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGet = (
  params: Params<t_ReposGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdate = (
  params: Params<
    t_ReposUpdateParamSchema,
    void,
    t_ReposUpdateBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDelete = (
  params: Params<t_ReposDeleteParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListArtifactsForRepo = (
  params: Params<
    t_ActionsListArtifactsForRepoParamSchema,
    t_ActionsListArtifactsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetArtifact = (
  params: Params<t_ActionsGetArtifactParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteArtifact = (
  params: Params<t_ActionsDeleteArtifactParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDownloadArtifact = (
  params: Params<t_ActionsDownloadArtifactParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetActionsCacheUsage = (
  params: Params<t_ActionsGetActionsCacheUsageParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetActionsCacheList = (
  params: Params<
    t_ActionsGetActionsCacheListParamSchema,
    t_ActionsGetActionsCacheListQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteActionsCacheByKey = (
  params: Params<
    t_ActionsDeleteActionsCacheByKeyParamSchema,
    t_ActionsDeleteActionsCacheByKeyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteActionsCacheById = (
  params: Params<t_ActionsDeleteActionsCacheByIdParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetJobForWorkflowRun = (
  params: Params<t_ActionsGetJobForWorkflowRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDownloadJobLogsForWorkflowRun = (
  params: Params<t_ActionsDownloadJobLogsForWorkflowRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsReRunJobForWorkflowRun = (
  params: Params<
    t_ActionsReRunJobForWorkflowRunParamSchema,
    void,
    t_ActionsReRunJobForWorkflowRunBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetCustomOidcSubClaimForRepo = (
  params: Params<t_ActionsGetCustomOidcSubClaimForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetCustomOidcSubClaimForRepo = (
  params: Params<
    t_ActionsSetCustomOidcSubClaimForRepoParamSchema,
    void,
    t_ActionsSetCustomOidcSubClaimForRepoBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetGithubActionsPermissionsRepository = (
  params: Params<
    t_ActionsGetGithubActionsPermissionsRepositoryParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetGithubActionsPermissionsRepository = (
  params: Params<
    t_ActionsSetGithubActionsPermissionsRepositoryParamSchema,
    void,
    t_ActionsSetGithubActionsPermissionsRepositoryBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetWorkflowAccessToRepository = (
  params: Params<t_ActionsGetWorkflowAccessToRepositoryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetWorkflowAccessToRepository = (
  params: Params<
    t_ActionsSetWorkflowAccessToRepositoryParamSchema,
    void,
    t_ActionsSetWorkflowAccessToRepositoryBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetAllowedActionsRepository = (
  params: Params<t_ActionsGetAllowedActionsRepositoryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetAllowedActionsRepository = (
  params: Params<
    t_ActionsSetAllowedActionsRepositoryParamSchema,
    void,
    t_ActionsSetAllowedActionsRepositoryBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepository = (
  params: Params<
    t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepository = (
  params: Params<
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
    void,
    t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRequiredWorkflowRuns = (
  params: Params<
    t_ActionsListRequiredWorkflowRunsParamSchema,
    t_ActionsListRequiredWorkflowRunsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListSelfHostedRunnersForRepo = (
  params: Params<
    t_ActionsListSelfHostedRunnersForRepoParamSchema,
    t_ActionsListSelfHostedRunnersForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRunnerApplicationsForRepo = (
  params: Params<t_ActionsListRunnerApplicationsForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateRegistrationTokenForRepo = (
  params: Params<
    t_ActionsCreateRegistrationTokenForRepoParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateRemoveTokenForRepo = (
  params: Params<t_ActionsCreateRemoveTokenForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetSelfHostedRunnerForRepo = (
  params: Params<t_ActionsGetSelfHostedRunnerForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteSelfHostedRunnerFromRepo = (
  params: Params<
    t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListLabelsForSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
    void,
    t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
    void,
    t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo = (
  params: Params<
    t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListWorkflowRunsForRepo = (
  params: Params<
    t_ActionsListWorkflowRunsForRepoParamSchema,
    t_ActionsListWorkflowRunsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetWorkflowRun = (
  params: Params<
    t_ActionsGetWorkflowRunParamSchema,
    t_ActionsGetWorkflowRunQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteWorkflowRun = (
  params: Params<t_ActionsDeleteWorkflowRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetReviewsForRun = (
  params: Params<t_ActionsGetReviewsForRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsApproveWorkflowRun = (
  params: Params<t_ActionsApproveWorkflowRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListWorkflowRunArtifacts = (
  params: Params<
    t_ActionsListWorkflowRunArtifactsParamSchema,
    t_ActionsListWorkflowRunArtifactsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetWorkflowRunAttempt = (
  params: Params<
    t_ActionsGetWorkflowRunAttemptParamSchema,
    t_ActionsGetWorkflowRunAttemptQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListJobsForWorkflowRunAttempt = (
  params: Params<
    t_ActionsListJobsForWorkflowRunAttemptParamSchema,
    t_ActionsListJobsForWorkflowRunAttemptQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDownloadWorkflowRunAttemptLogs = (
  params: Params<
    t_ActionsDownloadWorkflowRunAttemptLogsParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCancelWorkflowRun = (
  params: Params<t_ActionsCancelWorkflowRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListJobsForWorkflowRun = (
  params: Params<
    t_ActionsListJobsForWorkflowRunParamSchema,
    t_ActionsListJobsForWorkflowRunQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDownloadWorkflowRunLogs = (
  params: Params<t_ActionsDownloadWorkflowRunLogsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteWorkflowRunLogs = (
  params: Params<t_ActionsDeleteWorkflowRunLogsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetPendingDeploymentsForRun = (
  params: Params<t_ActionsGetPendingDeploymentsForRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsReviewPendingDeploymentsForRun = (
  params: Params<
    t_ActionsReviewPendingDeploymentsForRunParamSchema,
    void,
    t_ActionsReviewPendingDeploymentsForRunBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsReRunWorkflow = (
  params: Params<
    t_ActionsReRunWorkflowParamSchema,
    void,
    t_ActionsReRunWorkflowBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsReRunWorkflowFailedJobs = (
  params: Params<
    t_ActionsReRunWorkflowFailedJobsParamSchema,
    void,
    t_ActionsReRunWorkflowFailedJobsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetWorkflowRunUsage = (
  params: Params<t_ActionsGetWorkflowRunUsageParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRepoSecrets = (
  params: Params<
    t_ActionsListRepoSecretsParamSchema,
    t_ActionsListRepoSecretsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetRepoPublicKey = (
  params: Params<t_ActionsGetRepoPublicKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetRepoSecret = (
  params: Params<t_ActionsGetRepoSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateOrUpdateRepoSecret = (
  params: Params<
    t_ActionsCreateOrUpdateRepoSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateRepoSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteRepoSecret = (
  params: Params<t_ActionsDeleteRepoSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRepoVariables = (
  params: Params<
    t_ActionsListRepoVariablesParamSchema,
    t_ActionsListRepoVariablesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateRepoVariable = (
  params: Params<
    t_ActionsCreateRepoVariableParamSchema,
    void,
    t_ActionsCreateRepoVariableBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetRepoVariable = (
  params: Params<t_ActionsGetRepoVariableParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsUpdateRepoVariable = (
  params: Params<
    t_ActionsUpdateRepoVariableParamSchema,
    void,
    t_ActionsUpdateRepoVariableBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteRepoVariable = (
  params: Params<t_ActionsDeleteRepoVariableParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListRepoWorkflows = (
  params: Params<
    t_ActionsListRepoWorkflowsParamSchema,
    t_ActionsListRepoWorkflowsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetWorkflow = (
  params: Params<t_ActionsGetWorkflowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDisableWorkflow = (
  params: Params<t_ActionsDisableWorkflowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateWorkflowDispatch = (
  params: Params<
    t_ActionsCreateWorkflowDispatchParamSchema,
    void,
    t_ActionsCreateWorkflowDispatchBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsEnableWorkflow = (
  params: Params<t_ActionsEnableWorkflowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListWorkflowRuns = (
  params: Params<
    t_ActionsListWorkflowRunsParamSchema,
    t_ActionsListWorkflowRunsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetWorkflowUsage = (
  params: Params<t_ActionsGetWorkflowUsageParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListAssignees = (
  params: Params<
    t_IssuesListAssigneesParamSchema,
    t_IssuesListAssigneesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesCheckUserCanBeAssigned = (
  params: Params<t_IssuesCheckUserCanBeAssignedParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListAutolinks = (
  params: Params<
    t_ReposListAutolinksParamSchema,
    t_ReposListAutolinksQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateAutolink = (
  params: Params<
    t_ReposCreateAutolinkParamSchema,
    void,
    t_ReposCreateAutolinkBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetAutolink = (
  params: Params<t_ReposGetAutolinkParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteAutolink = (
  params: Params<t_ReposDeleteAutolinkParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposEnableAutomatedSecurityFixes = (
  params: Params<t_ReposEnableAutomatedSecurityFixesParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDisableAutomatedSecurityFixes = (
  params: Params<t_ReposDisableAutomatedSecurityFixesParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListBranches = (
  params: Params<
    t_ReposListBranchesParamSchema,
    t_ReposListBranchesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetBranch = (
  params: Params<t_ReposGetBranchParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetBranchProtection = (
  params: Params<t_ReposGetBranchProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateBranchProtection = (
  params: Params<
    t_ReposUpdateBranchProtectionParamSchema,
    void,
    t_ReposUpdateBranchProtectionBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteBranchProtection = (
  params: Params<t_ReposDeleteBranchProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetAdminBranchProtection = (
  params: Params<t_ReposGetAdminBranchProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposSetAdminBranchProtection = (
  params: Params<t_ReposSetAdminBranchProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteAdminBranchProtection = (
  params: Params<t_ReposDeleteAdminBranchProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetPullRequestReviewProtection = (
  params: Params<t_ReposGetPullRequestReviewProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdatePullRequestReviewProtection = (
  params: Params<
    t_ReposUpdatePullRequestReviewProtectionParamSchema,
    void,
    t_ReposUpdatePullRequestReviewProtectionBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeletePullRequestReviewProtection = (
  params: Params<
    t_ReposDeletePullRequestReviewProtectionParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCommitSignatureProtection = (
  params: Params<t_ReposGetCommitSignatureProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateCommitSignatureProtection = (
  params: Params<t_ReposCreateCommitSignatureProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteCommitSignatureProtection = (
  params: Params<t_ReposDeleteCommitSignatureProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetStatusChecksProtection = (
  params: Params<t_ReposGetStatusChecksProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateStatusCheckProtection = (
  params: Params<
    t_ReposUpdateStatusCheckProtectionParamSchema,
    void,
    t_ReposUpdateStatusCheckProtectionBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRemoveStatusCheckProtection = (
  params: Params<t_ReposRemoveStatusCheckProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetAllStatusCheckContexts = (
  params: Params<t_ReposGetAllStatusCheckContextsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposAddStatusCheckContexts = (
  params: Params<
    t_ReposAddStatusCheckContextsParamSchema,
    void,
    t_ReposAddStatusCheckContextsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposSetStatusCheckContexts = (
  params: Params<
    t_ReposSetStatusCheckContextsParamSchema,
    void,
    t_ReposSetStatusCheckContextsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRemoveStatusCheckContexts = (
  params: Params<
    t_ReposRemoveStatusCheckContextsParamSchema,
    void,
    t_ReposRemoveStatusCheckContextsBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetAccessRestrictions = (
  params: Params<t_ReposGetAccessRestrictionsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteAccessRestrictions = (
  params: Params<t_ReposDeleteAccessRestrictionsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetAppsWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetAppsWithAccessToProtectedBranchParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposAddAppAccessRestrictions = (
  params: Params<
    t_ReposAddAppAccessRestrictionsParamSchema,
    void,
    t_ReposAddAppAccessRestrictionsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposSetAppAccessRestrictions = (
  params: Params<
    t_ReposSetAppAccessRestrictionsParamSchema,
    void,
    t_ReposSetAppAccessRestrictionsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRemoveAppAccessRestrictions = (
  params: Params<
    t_ReposRemoveAppAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveAppAccessRestrictionsBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetTeamsWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetTeamsWithAccessToProtectedBranchParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposAddTeamAccessRestrictions = (
  params: Params<
    t_ReposAddTeamAccessRestrictionsParamSchema,
    void,
    t_ReposAddTeamAccessRestrictionsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposSetTeamAccessRestrictions = (
  params: Params<
    t_ReposSetTeamAccessRestrictionsParamSchema,
    void,
    t_ReposSetTeamAccessRestrictionsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRemoveTeamAccessRestrictions = (
  params: Params<
    t_ReposRemoveTeamAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveTeamAccessRestrictionsBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetUsersWithAccessToProtectedBranch = (
  params: Params<
    t_ReposGetUsersWithAccessToProtectedBranchParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposAddUserAccessRestrictions = (
  params: Params<
    t_ReposAddUserAccessRestrictionsParamSchema,
    void,
    t_ReposAddUserAccessRestrictionsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposSetUserAccessRestrictions = (
  params: Params<
    t_ReposSetUserAccessRestrictionsParamSchema,
    void,
    t_ReposSetUserAccessRestrictionsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRemoveUserAccessRestrictions = (
  params: Params<
    t_ReposRemoveUserAccessRestrictionsParamSchema,
    void,
    t_ReposRemoveUserAccessRestrictionsBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRenameBranch = (
  params: Params<
    t_ReposRenameBranchParamSchema,
    void,
    t_ReposRenameBranchBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksCreate = (
  params: Params<t_ChecksCreateParamSchema, void, t_ChecksCreateBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksGet = (
  params: Params<t_ChecksGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksUpdate = (
  params: Params<t_ChecksUpdateParamSchema, void, t_ChecksUpdateBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksListAnnotations = (
  params: Params<
    t_ChecksListAnnotationsParamSchema,
    t_ChecksListAnnotationsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksRerequestRun = (
  params: Params<t_ChecksRerequestRunParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksCreateSuite = (
  params: Params<
    t_ChecksCreateSuiteParamSchema,
    void,
    t_ChecksCreateSuiteBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksSetSuitesPreferences = (
  params: Params<
    t_ChecksSetSuitesPreferencesParamSchema,
    void,
    t_ChecksSetSuitesPreferencesBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksGetSuite = (
  params: Params<t_ChecksGetSuiteParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksListForSuite = (
  params: Params<
    t_ChecksListForSuiteParamSchema,
    t_ChecksListForSuiteQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksRerequestSuite = (
  params: Params<t_ChecksRerequestSuiteParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningListAlertsForRepo = (
  params: Params<
    t_CodeScanningListAlertsForRepoParamSchema,
    t_CodeScanningListAlertsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningGetAlert = (
  params: Params<t_CodeScanningGetAlertParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningUpdateAlert = (
  params: Params<
    t_CodeScanningUpdateAlertParamSchema,
    void,
    t_CodeScanningUpdateAlertBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningListAlertInstances = (
  params: Params<
    t_CodeScanningListAlertInstancesParamSchema,
    t_CodeScanningListAlertInstancesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningListRecentAnalyses = (
  params: Params<
    t_CodeScanningListRecentAnalysesParamSchema,
    t_CodeScanningListRecentAnalysesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningGetAnalysis = (
  params: Params<t_CodeScanningGetAnalysisParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningDeleteAnalysis = (
  params: Params<
    t_CodeScanningDeleteAnalysisParamSchema,
    t_CodeScanningDeleteAnalysisQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningListCodeqlDatabases = (
  params: Params<t_CodeScanningListCodeqlDatabasesParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningGetCodeqlDatabase = (
  params: Params<t_CodeScanningGetCodeqlDatabaseParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningUploadSarif = (
  params: Params<
    t_CodeScanningUploadSarifParamSchema,
    void,
    t_CodeScanningUploadSarifBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodeScanningGetSarif = (
  params: Params<t_CodeScanningGetSarifParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCodeownersErrors = (
  params: Params<
    t_ReposCodeownersErrorsParamSchema,
    t_ReposCodeownersErrorsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListInRepositoryForAuthenticatedUser = (
  params: Params<
    t_CodespacesListInRepositoryForAuthenticatedUserParamSchema,
    t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesCreateWithRepoForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateWithRepoForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser = (
  params: Params<
    t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
    t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesRepoMachinesForAuthenticatedUser = (
  params: Params<
    t_CodespacesRepoMachinesForAuthenticatedUserParamSchema,
    t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesPreFlightWithRepoForAuthenticatedUser = (
  params: Params<
    t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
    t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListRepoSecrets = (
  params: Params<
    t_CodespacesListRepoSecretsParamSchema,
    t_CodespacesListRepoSecretsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetRepoPublicKey = (
  params: Params<t_CodespacesGetRepoPublicKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetRepoSecret = (
  params: Params<t_CodespacesGetRepoSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesCreateOrUpdateRepoSecret = (
  params: Params<
    t_CodespacesCreateOrUpdateRepoSecretParamSchema,
    void,
    t_CodespacesCreateOrUpdateRepoSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesDeleteRepoSecret = (
  params: Params<t_CodespacesDeleteRepoSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListCollaborators = (
  params: Params<
    t_ReposListCollaboratorsParamSchema,
    t_ReposListCollaboratorsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCheckCollaborator = (
  params: Params<t_ReposCheckCollaboratorParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposAddCollaborator = (
  params: Params<
    t_ReposAddCollaboratorParamSchema,
    void,
    t_ReposAddCollaboratorBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRemoveCollaborator = (
  params: Params<t_ReposRemoveCollaboratorParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCollaboratorPermissionLevel = (
  params: Params<t_ReposGetCollaboratorPermissionLevelParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListCommitCommentsForRepo = (
  params: Params<
    t_ReposListCommitCommentsForRepoParamSchema,
    t_ReposListCommitCommentsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCommitComment = (
  params: Params<t_ReposGetCommitCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateCommitComment = (
  params: Params<
    t_ReposUpdateCommitCommentParamSchema,
    void,
    t_ReposUpdateCommitCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteCommitComment = (
  params: Params<t_ReposDeleteCommitCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForCommitComment = (
  params: Params<
    t_ReactionsListForCommitCommentParamSchema,
    t_ReactionsListForCommitCommentQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForCommitComment = (
  params: Params<
    t_ReactionsCreateForCommitCommentParamSchema,
    void,
    t_ReactionsCreateForCommitCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsDeleteForCommitComment = (
  params: Params<t_ReactionsDeleteForCommitCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListCommits = (
  params: Params<
    t_ReposListCommitsParamSchema,
    t_ReposListCommitsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListBranchesForHeadCommit = (
  params: Params<t_ReposListBranchesForHeadCommitParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListCommentsForCommit = (
  params: Params<
    t_ReposListCommentsForCommitParamSchema,
    t_ReposListCommentsForCommitQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateCommitComment = (
  params: Params<
    t_ReposCreateCommitCommentParamSchema,
    void,
    t_ReposCreateCommitCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListPullRequestsAssociatedWithCommit = (
  params: Params<
    t_ReposListPullRequestsAssociatedWithCommitParamSchema,
    t_ReposListPullRequestsAssociatedWithCommitQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCommit = (
  params: Params<
    t_ReposGetCommitParamSchema,
    t_ReposGetCommitQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksListForRef = (
  params: Params<
    t_ChecksListForRefParamSchema,
    t_ChecksListForRefQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ChecksListSuitesForRef = (
  params: Params<
    t_ChecksListSuitesForRefParamSchema,
    t_ChecksListSuitesForRefQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCombinedStatusForRef = (
  params: Params<
    t_ReposGetCombinedStatusForRefParamSchema,
    t_ReposGetCombinedStatusForRefQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListCommitStatusesForRef = (
  params: Params<
    t_ReposListCommitStatusesForRefParamSchema,
    t_ReposListCommitStatusesForRefQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCommunityProfileMetrics = (
  params: Params<t_ReposGetCommunityProfileMetricsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCompareCommits = (
  params: Params<
    t_ReposCompareCommitsParamSchema,
    t_ReposCompareCommitsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetContent = (
  params: Params<
    t_ReposGetContentParamSchema,
    t_ReposGetContentQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateOrUpdateFileContents = (
  params: Params<
    t_ReposCreateOrUpdateFileContentsParamSchema,
    void,
    t_ReposCreateOrUpdateFileContentsBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteFile = (
  params: Params<
    t_ReposDeleteFileParamSchema,
    void,
    t_ReposDeleteFileBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListContributors = (
  params: Params<
    t_ReposListContributorsParamSchema,
    t_ReposListContributorsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotListAlertsForRepo = (
  params: Params<
    t_DependabotListAlertsForRepoParamSchema,
    t_DependabotListAlertsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotGetAlert = (
  params: Params<t_DependabotGetAlertParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotUpdateAlert = (
  params: Params<
    t_DependabotUpdateAlertParamSchema,
    void,
    t_DependabotUpdateAlertBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotListRepoSecrets = (
  params: Params<
    t_DependabotListRepoSecretsParamSchema,
    t_DependabotListRepoSecretsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotGetRepoPublicKey = (
  params: Params<t_DependabotGetRepoPublicKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotGetRepoSecret = (
  params: Params<t_DependabotGetRepoSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotCreateOrUpdateRepoSecret = (
  params: Params<
    t_DependabotCreateOrUpdateRepoSecretParamSchema,
    void,
    t_DependabotCreateOrUpdateRepoSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependabotDeleteRepoSecret = (
  params: Params<t_DependabotDeleteRepoSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependencyGraphDiffRange = (
  params: Params<
    t_DependencyGraphDiffRangeParamSchema,
    t_DependencyGraphDiffRangeQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type DependencyGraphCreateRepositorySnapshot = (
  params: Params<
    t_DependencyGraphCreateRepositorySnapshotParamSchema,
    void,
    t_DependencyGraphCreateRepositorySnapshotBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListDeployments = (
  params: Params<
    t_ReposListDeploymentsParamSchema,
    t_ReposListDeploymentsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateDeployment = (
  params: Params<
    t_ReposCreateDeploymentParamSchema,
    void,
    t_ReposCreateDeploymentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetDeployment = (
  params: Params<t_ReposGetDeploymentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteDeployment = (
  params: Params<t_ReposDeleteDeploymentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListDeploymentStatuses = (
  params: Params<
    t_ReposListDeploymentStatusesParamSchema,
    t_ReposListDeploymentStatusesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateDeploymentStatus = (
  params: Params<
    t_ReposCreateDeploymentStatusParamSchema,
    void,
    t_ReposCreateDeploymentStatusBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetDeploymentStatus = (
  params: Params<t_ReposGetDeploymentStatusParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateDispatchEvent = (
  params: Params<
    t_ReposCreateDispatchEventParamSchema,
    void,
    t_ReposCreateDispatchEventBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetAllEnvironments = (
  params: Params<
    t_ReposGetAllEnvironmentsParamSchema,
    t_ReposGetAllEnvironmentsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetEnvironment = (
  params: Params<t_ReposGetEnvironmentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateOrUpdateEnvironment = (
  params: Params<
    t_ReposCreateOrUpdateEnvironmentParamSchema,
    void,
    t_ReposCreateOrUpdateEnvironmentBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteAnEnvironment = (
  params: Params<t_ReposDeleteAnEnvironmentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListDeploymentBranchPolicies = (
  params: Params<
    t_ReposListDeploymentBranchPoliciesParamSchema,
    t_ReposListDeploymentBranchPoliciesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateDeploymentBranchPolicy = (
  params: Params<
    t_ReposCreateDeploymentBranchPolicyParamSchema,
    void,
    t_ReposCreateDeploymentBranchPolicyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetDeploymentBranchPolicy = (
  params: Params<t_ReposGetDeploymentBranchPolicyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateDeploymentBranchPolicy = (
  params: Params<
    t_ReposUpdateDeploymentBranchPolicyParamSchema,
    void,
    t_ReposUpdateDeploymentBranchPolicyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteDeploymentBranchPolicy = (
  params: Params<t_ReposDeleteDeploymentBranchPolicyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListRepoEvents = (
  params: Params<
    t_ActivityListRepoEventsParamSchema,
    t_ActivityListRepoEventsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListForks = (
  params: Params<
    t_ReposListForksParamSchema,
    t_ReposListForksQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateFork = (
  params: Params<
    t_ReposCreateForkParamSchema,
    void,
    t_ReposCreateForkBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitCreateBlob = (
  params: Params<t_GitCreateBlobParamSchema, void, t_GitCreateBlobBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitGetBlob = (
  params: Params<t_GitGetBlobParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitCreateCommit = (
  params: Params<
    t_GitCreateCommitParamSchema,
    void,
    t_GitCreateCommitBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitGetCommit = (
  params: Params<t_GitGetCommitParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitListMatchingRefs = (
  params: Params<t_GitListMatchingRefsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitGetRef = (
  params: Params<t_GitGetRefParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitCreateRef = (
  params: Params<t_GitCreateRefParamSchema, void, t_GitCreateRefBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitUpdateRef = (
  params: Params<t_GitUpdateRefParamSchema, void, t_GitUpdateRefBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitDeleteRef = (
  params: Params<t_GitDeleteRefParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitCreateTag = (
  params: Params<t_GitCreateTagParamSchema, void, t_GitCreateTagBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitGetTag = (
  params: Params<t_GitGetTagParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitCreateTree = (
  params: Params<t_GitCreateTreeParamSchema, void, t_GitCreateTreeBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GitGetTree = (
  params: Params<t_GitGetTreeParamSchema, t_GitGetTreeQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListWebhooks = (
  params: Params<
    t_ReposListWebhooksParamSchema,
    t_ReposListWebhooksQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateWebhook = (
  params: Params<
    t_ReposCreateWebhookParamSchema,
    void,
    t_ReposCreateWebhookBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetWebhook = (
  params: Params<t_ReposGetWebhookParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateWebhook = (
  params: Params<
    t_ReposUpdateWebhookParamSchema,
    void,
    t_ReposUpdateWebhookBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteWebhook = (
  params: Params<t_ReposDeleteWebhookParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetWebhookConfigForRepo = (
  params: Params<t_ReposGetWebhookConfigForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateWebhookConfigForRepo = (
  params: Params<
    t_ReposUpdateWebhookConfigForRepoParamSchema,
    void,
    t_ReposUpdateWebhookConfigForRepoBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListWebhookDeliveries = (
  params: Params<
    t_ReposListWebhookDeliveriesParamSchema,
    t_ReposListWebhookDeliveriesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetWebhookDelivery = (
  params: Params<t_ReposGetWebhookDeliveryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRedeliverWebhookDelivery = (
  params: Params<t_ReposRedeliverWebhookDeliveryParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposPingWebhook = (
  params: Params<t_ReposPingWebhookParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposTestPushWebhook = (
  params: Params<t_ReposTestPushWebhookParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsGetImportStatus = (
  params: Params<t_MigrationsGetImportStatusParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsStartImport = (
  params: Params<
    t_MigrationsStartImportParamSchema,
    void,
    t_MigrationsStartImportBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsUpdateImport = (
  params: Params<
    t_MigrationsUpdateImportParamSchema,
    void,
    t_MigrationsUpdateImportBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsCancelImport = (
  params: Params<t_MigrationsCancelImportParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsGetCommitAuthors = (
  params: Params<
    t_MigrationsGetCommitAuthorsParamSchema,
    t_MigrationsGetCommitAuthorsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsMapCommitAuthor = (
  params: Params<
    t_MigrationsMapCommitAuthorParamSchema,
    void,
    t_MigrationsMapCommitAuthorBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsGetLargeFiles = (
  params: Params<t_MigrationsGetLargeFilesParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsSetLfsPreference = (
  params: Params<
    t_MigrationsSetLfsPreferenceParamSchema,
    void,
    t_MigrationsSetLfsPreferenceBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetRepoInstallation = (
  params: Params<t_AppsGetRepoInstallationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsGetRestrictionsForRepo = (
  params: Params<t_InteractionsGetRestrictionsForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsSetRestrictionsForRepo = (
  params: Params<
    t_InteractionsSetRestrictionsForRepoParamSchema,
    void,
    t_InteractionsSetRestrictionsForRepoBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsRemoveRestrictionsForRepo = (
  params: Params<
    t_InteractionsRemoveRestrictionsForRepoParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListInvitations = (
  params: Params<
    t_ReposListInvitationsParamSchema,
    t_ReposListInvitationsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateInvitation = (
  params: Params<
    t_ReposUpdateInvitationParamSchema,
    void,
    t_ReposUpdateInvitationBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteInvitation = (
  params: Params<t_ReposDeleteInvitationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListForRepo = (
  params: Params<
    t_IssuesListForRepoParamSchema,
    t_IssuesListForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesCreate = (
  params: Params<t_IssuesCreateParamSchema, void, t_IssuesCreateBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListCommentsForRepo = (
  params: Params<
    t_IssuesListCommentsForRepoParamSchema,
    t_IssuesListCommentsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesGetComment = (
  params: Params<t_IssuesGetCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesUpdateComment = (
  params: Params<
    t_IssuesUpdateCommentParamSchema,
    void,
    t_IssuesUpdateCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesDeleteComment = (
  params: Params<t_IssuesDeleteCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForIssueComment = (
  params: Params<
    t_ReactionsListForIssueCommentParamSchema,
    t_ReactionsListForIssueCommentQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForIssueComment = (
  params: Params<
    t_ReactionsCreateForIssueCommentParamSchema,
    void,
    t_ReactionsCreateForIssueCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsDeleteForIssueComment = (
  params: Params<t_ReactionsDeleteForIssueCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListEventsForRepo = (
  params: Params<
    t_IssuesListEventsForRepoParamSchema,
    t_IssuesListEventsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesGetEvent = (
  params: Params<t_IssuesGetEventParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesGet = (
  params: Params<t_IssuesGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesUpdate = (
  params: Params<
    t_IssuesUpdateParamSchema,
    void,
    t_IssuesUpdateBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesAddAssignees = (
  params: Params<
    t_IssuesAddAssigneesParamSchema,
    void,
    t_IssuesAddAssigneesBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesRemoveAssignees = (
  params: Params<
    t_IssuesRemoveAssigneesParamSchema,
    void,
    t_IssuesRemoveAssigneesBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesCheckUserCanBeAssignedToIssue = (
  params: Params<t_IssuesCheckUserCanBeAssignedToIssueParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListComments = (
  params: Params<
    t_IssuesListCommentsParamSchema,
    t_IssuesListCommentsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesCreateComment = (
  params: Params<
    t_IssuesCreateCommentParamSchema,
    void,
    t_IssuesCreateCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListEvents = (
  params: Params<
    t_IssuesListEventsParamSchema,
    t_IssuesListEventsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListLabelsOnIssue = (
  params: Params<
    t_IssuesListLabelsOnIssueParamSchema,
    t_IssuesListLabelsOnIssueQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesAddLabels = (
  params: Params<
    t_IssuesAddLabelsParamSchema,
    void,
    t_IssuesAddLabelsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesSetLabels = (
  params: Params<
    t_IssuesSetLabelsParamSchema,
    void,
    t_IssuesSetLabelsBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesRemoveAllLabels = (
  params: Params<t_IssuesRemoveAllLabelsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesRemoveLabel = (
  params: Params<t_IssuesRemoveLabelParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesLock = (
  params: Params<
    t_IssuesLockParamSchema,
    void,
    t_IssuesLockBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesUnlock = (
  params: Params<t_IssuesUnlockParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForIssue = (
  params: Params<
    t_ReactionsListForIssueParamSchema,
    t_ReactionsListForIssueQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForIssue = (
  params: Params<
    t_ReactionsCreateForIssueParamSchema,
    void,
    t_ReactionsCreateForIssueBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsDeleteForIssue = (
  params: Params<t_ReactionsDeleteForIssueParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListEventsForTimeline = (
  params: Params<
    t_IssuesListEventsForTimelineParamSchema,
    t_IssuesListEventsForTimelineQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListDeployKeys = (
  params: Params<
    t_ReposListDeployKeysParamSchema,
    t_ReposListDeployKeysQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateDeployKey = (
  params: Params<
    t_ReposCreateDeployKeyParamSchema,
    void,
    t_ReposCreateDeployKeyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetDeployKey = (
  params: Params<t_ReposGetDeployKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteDeployKey = (
  params: Params<t_ReposDeleteDeployKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListLabelsForRepo = (
  params: Params<
    t_IssuesListLabelsForRepoParamSchema,
    t_IssuesListLabelsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesCreateLabel = (
  params: Params<
    t_IssuesCreateLabelParamSchema,
    void,
    t_IssuesCreateLabelBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesGetLabel = (
  params: Params<t_IssuesGetLabelParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesUpdateLabel = (
  params: Params<
    t_IssuesUpdateLabelParamSchema,
    void,
    t_IssuesUpdateLabelBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesDeleteLabel = (
  params: Params<t_IssuesDeleteLabelParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListLanguages = (
  params: Params<t_ReposListLanguagesParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposEnableLfsForRepo = (
  params: Params<t_ReposEnableLfsForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDisableLfsForRepo = (
  params: Params<t_ReposDisableLfsForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type LicensesGetForRepo = (
  params: Params<t_LicensesGetForRepoParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposMergeUpstream = (
  params: Params<
    t_ReposMergeUpstreamParamSchema,
    void,
    t_ReposMergeUpstreamBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposMerge = (
  params: Params<t_ReposMergeParamSchema, void, t_ReposMergeBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListMilestones = (
  params: Params<
    t_IssuesListMilestonesParamSchema,
    t_IssuesListMilestonesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesCreateMilestone = (
  params: Params<
    t_IssuesCreateMilestoneParamSchema,
    void,
    t_IssuesCreateMilestoneBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesGetMilestone = (
  params: Params<t_IssuesGetMilestoneParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesUpdateMilestone = (
  params: Params<
    t_IssuesUpdateMilestoneParamSchema,
    void,
    t_IssuesUpdateMilestoneBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesDeleteMilestone = (
  params: Params<t_IssuesDeleteMilestoneParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListLabelsForMilestone = (
  params: Params<
    t_IssuesListLabelsForMilestoneParamSchema,
    t_IssuesListLabelsForMilestoneQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListRepoNotificationsForAuthenticatedUser = (
  params: Params<
    t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema,
    t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityMarkRepoNotificationsAsRead = (
  params: Params<
    t_ActivityMarkRepoNotificationsAsReadParamSchema,
    void,
    t_ActivityMarkRepoNotificationsAsReadBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetPages = (
  params: Params<t_ReposGetPagesParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreatePagesSite = (
  params: Params<
    t_ReposCreatePagesSiteParamSchema,
    void,
    t_ReposCreatePagesSiteBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateInformationAboutPagesSite = (
  params: Params<
    t_ReposUpdateInformationAboutPagesSiteParamSchema,
    void,
    t_ReposUpdateInformationAboutPagesSiteBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeletePagesSite = (
  params: Params<t_ReposDeletePagesSiteParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListPagesBuilds = (
  params: Params<
    t_ReposListPagesBuildsParamSchema,
    t_ReposListPagesBuildsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposRequestPagesBuild = (
  params: Params<t_ReposRequestPagesBuildParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetLatestPagesBuild = (
  params: Params<t_ReposGetLatestPagesBuildParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetPagesBuild = (
  params: Params<t_ReposGetPagesBuildParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreatePagesDeployment = (
  params: Params<
    t_ReposCreatePagesDeploymentParamSchema,
    void,
    t_ReposCreatePagesDeploymentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetPagesHealthCheck = (
  params: Params<t_ReposGetPagesHealthCheckParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsListForRepo = (
  params: Params<
    t_ProjectsListForRepoParamSchema,
    t_ProjectsListForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsCreateForRepo = (
  params: Params<
    t_ProjectsCreateForRepoParamSchema,
    void,
    t_ProjectsCreateForRepoBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsList = (
  params: Params<t_PullsListParamSchema, t_PullsListQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsCreate = (
  params: Params<t_PullsCreateParamSchema, void, t_PullsCreateBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsListReviewCommentsForRepo = (
  params: Params<
    t_PullsListReviewCommentsForRepoParamSchema,
    t_PullsListReviewCommentsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsGetReviewComment = (
  params: Params<t_PullsGetReviewCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsUpdateReviewComment = (
  params: Params<
    t_PullsUpdateReviewCommentParamSchema,
    void,
    t_PullsUpdateReviewCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsDeleteReviewComment = (
  params: Params<t_PullsDeleteReviewCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForPullRequestReviewComment = (
  params: Params<
    t_ReactionsListForPullRequestReviewCommentParamSchema,
    t_ReactionsListForPullRequestReviewCommentQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForPullRequestReviewComment = (
  params: Params<
    t_ReactionsCreateForPullRequestReviewCommentParamSchema,
    void,
    t_ReactionsCreateForPullRequestReviewCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsDeleteForPullRequestComment = (
  params: Params<t_ReactionsDeleteForPullRequestCommentParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsGet = (
  params: Params<t_PullsGetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsUpdate = (
  params: Params<
    t_PullsUpdateParamSchema,
    void,
    t_PullsUpdateBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesCreateWithPrForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateWithPrForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateWithPrForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsListReviewComments = (
  params: Params<
    t_PullsListReviewCommentsParamSchema,
    t_PullsListReviewCommentsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsCreateReviewComment = (
  params: Params<
    t_PullsCreateReviewCommentParamSchema,
    void,
    t_PullsCreateReviewCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsCreateReplyForReviewComment = (
  params: Params<
    t_PullsCreateReplyForReviewCommentParamSchema,
    void,
    t_PullsCreateReplyForReviewCommentBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsListCommits = (
  params: Params<
    t_PullsListCommitsParamSchema,
    t_PullsListCommitsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsListFiles = (
  params: Params<
    t_PullsListFilesParamSchema,
    t_PullsListFilesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsCheckIfMerged = (
  params: Params<t_PullsCheckIfMergedParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsMerge = (
  params: Params<
    t_PullsMergeParamSchema,
    void,
    t_PullsMergeBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsListRequestedReviewers = (
  params: Params<t_PullsListRequestedReviewersParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsRequestReviewers = (
  params: Params<
    t_PullsRequestReviewersParamSchema,
    void,
    t_PullsRequestReviewersBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsRemoveRequestedReviewers = (
  params: Params<
    t_PullsRemoveRequestedReviewersParamSchema,
    void,
    t_PullsRemoveRequestedReviewersBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsListReviews = (
  params: Params<
    t_PullsListReviewsParamSchema,
    t_PullsListReviewsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsCreateReview = (
  params: Params<
    t_PullsCreateReviewParamSchema,
    void,
    t_PullsCreateReviewBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsGetReview = (
  params: Params<t_PullsGetReviewParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsUpdateReview = (
  params: Params<
    t_PullsUpdateReviewParamSchema,
    void,
    t_PullsUpdateReviewBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsDeletePendingReview = (
  params: Params<t_PullsDeletePendingReviewParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsListCommentsForReview = (
  params: Params<
    t_PullsListCommentsForReviewParamSchema,
    t_PullsListCommentsForReviewQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsDismissReview = (
  params: Params<
    t_PullsDismissReviewParamSchema,
    void,
    t_PullsDismissReviewBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsSubmitReview = (
  params: Params<
    t_PullsSubmitReviewParamSchema,
    void,
    t_PullsSubmitReviewBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PullsUpdateBranch = (
  params: Params<
    t_PullsUpdateBranchParamSchema,
    void,
    t_PullsUpdateBranchBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetReadme = (
  params: Params<
    t_ReposGetReadmeParamSchema,
    t_ReposGetReadmeQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetReadmeInDirectory = (
  params: Params<
    t_ReposGetReadmeInDirectoryParamSchema,
    t_ReposGetReadmeInDirectoryQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListReleases = (
  params: Params<
    t_ReposListReleasesParamSchema,
    t_ReposListReleasesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateRelease = (
  params: Params<
    t_ReposCreateReleaseParamSchema,
    void,
    t_ReposCreateReleaseBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetReleaseAsset = (
  params: Params<t_ReposGetReleaseAssetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateReleaseAsset = (
  params: Params<
    t_ReposUpdateReleaseAssetParamSchema,
    void,
    t_ReposUpdateReleaseAssetBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteReleaseAsset = (
  params: Params<t_ReposDeleteReleaseAssetParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGenerateReleaseNotes = (
  params: Params<
    t_ReposGenerateReleaseNotesParamSchema,
    void,
    t_ReposGenerateReleaseNotesBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetLatestRelease = (
  params: Params<t_ReposGetLatestReleaseParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetReleaseByTag = (
  params: Params<t_ReposGetReleaseByTagParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetRelease = (
  params: Params<t_ReposGetReleaseParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUpdateRelease = (
  params: Params<
    t_ReposUpdateReleaseParamSchema,
    void,
    t_ReposUpdateReleaseBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteRelease = (
  params: Params<t_ReposDeleteReleaseParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListReleaseAssets = (
  params: Params<
    t_ReposListReleaseAssetsParamSchema,
    t_ReposListReleaseAssetsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposUploadReleaseAsset = (
  params: Params<
    t_ReposUploadReleaseAssetParamSchema,
    t_ReposUploadReleaseAssetQuerySchema,
    t_ReposUploadReleaseAssetBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForRelease = (
  params: Params<
    t_ReactionsListForReleaseParamSchema,
    t_ReactionsListForReleaseQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForRelease = (
  params: Params<
    t_ReactionsCreateForReleaseParamSchema,
    void,
    t_ReactionsCreateForReleaseBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsDeleteForRelease = (
  params: Params<t_ReactionsDeleteForReleaseParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningListAlertsForRepo = (
  params: Params<
    t_SecretScanningListAlertsForRepoParamSchema,
    t_SecretScanningListAlertsForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningGetAlert = (
  params: Params<t_SecretScanningGetAlertParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningUpdateAlert = (
  params: Params<
    t_SecretScanningUpdateAlertParamSchema,
    void,
    t_SecretScanningUpdateAlertBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SecretScanningListLocationsForAlert = (
  params: Params<
    t_SecretScanningListLocationsForAlertParamSchema,
    t_SecretScanningListLocationsForAlertQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListStargazersForRepo = (
  params: Params<
    t_ActivityListStargazersForRepoParamSchema,
    t_ActivityListStargazersForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCodeFrequencyStats = (
  params: Params<t_ReposGetCodeFrequencyStatsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetCommitActivityStats = (
  params: Params<t_ReposGetCommitActivityStatsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetContributorsStats = (
  params: Params<t_ReposGetContributorsStatsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetParticipationStats = (
  params: Params<t_ReposGetParticipationStatsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetPunchCardStats = (
  params: Params<t_ReposGetPunchCardStatsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateCommitStatus = (
  params: Params<
    t_ReposCreateCommitStatusParamSchema,
    void,
    t_ReposCreateCommitStatusBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListWatchersForRepo = (
  params: Params<
    t_ActivityListWatchersForRepoParamSchema,
    t_ActivityListWatchersForRepoQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityGetRepoSubscription = (
  params: Params<t_ActivityGetRepoSubscriptionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivitySetRepoSubscription = (
  params: Params<
    t_ActivitySetRepoSubscriptionParamSchema,
    void,
    t_ActivitySetRepoSubscriptionBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityDeleteRepoSubscription = (
  params: Params<t_ActivityDeleteRepoSubscriptionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListTags = (
  params: Params<t_ReposListTagsParamSchema, t_ReposListTagsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListTagProtection = (
  params: Params<t_ReposListTagProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateTagProtection = (
  params: Params<
    t_ReposCreateTagProtectionParamSchema,
    void,
    t_ReposCreateTagProtectionBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeleteTagProtection = (
  params: Params<t_ReposDeleteTagProtectionParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDownloadTarballArchive = (
  params: Params<t_ReposDownloadTarballArchiveParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListTeams = (
  params: Params<
    t_ReposListTeamsParamSchema,
    t_ReposListTeamsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetAllTopics = (
  params: Params<
    t_ReposGetAllTopicsParamSchema,
    t_ReposGetAllTopicsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposReplaceAllTopics = (
  params: Params<
    t_ReposReplaceAllTopicsParamSchema,
    void,
    t_ReposReplaceAllTopicsBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetClones = (
  params: Params<
    t_ReposGetClonesParamSchema,
    t_ReposGetClonesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetTopPaths = (
  params: Params<t_ReposGetTopPathsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetTopReferrers = (
  params: Params<t_ReposGetTopReferrersParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposGetViews = (
  params: Params<t_ReposGetViewsParamSchema, t_ReposGetViewsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposTransfer = (
  params: Params<t_ReposTransferParamSchema, void, t_ReposTransferBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCheckVulnerabilityAlerts = (
  params: Params<t_ReposCheckVulnerabilityAlertsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposEnableVulnerabilityAlerts = (
  params: Params<t_ReposEnableVulnerabilityAlertsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDisableVulnerabilityAlerts = (
  params: Params<t_ReposDisableVulnerabilityAlertsParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDownloadZipballArchive = (
  params: Params<t_ReposDownloadZipballArchiveParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateUsingTemplate = (
  params: Params<
    t_ReposCreateUsingTemplateParamSchema,
    void,
    t_ReposCreateUsingTemplateBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListPublic = (
  params: Params<void, t_ReposListPublicQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListEnvironmentSecrets = (
  params: Params<
    t_ActionsListEnvironmentSecretsParamSchema,
    t_ActionsListEnvironmentSecretsQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetEnvironmentPublicKey = (
  params: Params<t_ActionsGetEnvironmentPublicKeyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetEnvironmentSecret = (
  params: Params<t_ActionsGetEnvironmentSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateOrUpdateEnvironmentSecret = (
  params: Params<
    t_ActionsCreateOrUpdateEnvironmentSecretParamSchema,
    void,
    t_ActionsCreateOrUpdateEnvironmentSecretBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteEnvironmentSecret = (
  params: Params<t_ActionsDeleteEnvironmentSecretParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsListEnvironmentVariables = (
  params: Params<
    t_ActionsListEnvironmentVariablesParamSchema,
    t_ActionsListEnvironmentVariablesQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsCreateEnvironmentVariable = (
  params: Params<
    t_ActionsCreateEnvironmentVariableParamSchema,
    void,
    t_ActionsCreateEnvironmentVariableBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsGetEnvironmentVariable = (
  params: Params<t_ActionsGetEnvironmentVariableParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsUpdateEnvironmentVariable = (
  params: Params<
    t_ActionsUpdateEnvironmentVariableParamSchema,
    void,
    t_ActionsUpdateEnvironmentVariableBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActionsDeleteEnvironmentVariable = (
  params: Params<t_ActionsDeleteEnvironmentVariableParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SearchCode = (
  params: Params<void, t_SearchCodeQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SearchCommits = (
  params: Params<void, t_SearchCommitsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SearchIssuesAndPullRequests = (
  params: Params<void, t_SearchIssuesAndPullRequestsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SearchLabels = (
  params: Params<void, t_SearchLabelsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SearchRepos = (
  params: Params<void, t_SearchReposQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SearchTopics = (
  params: Params<void, t_SearchTopicsQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type SearchUsers = (
  params: Params<void, t_SearchUsersQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetLegacy = (
  params: Params<t_TeamsGetLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsUpdateLegacy = (
  params: Params<
    t_TeamsUpdateLegacyParamSchema,
    void,
    t_TeamsUpdateLegacyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsDeleteLegacy = (
  params: Params<t_TeamsDeleteLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListDiscussionsLegacy = (
  params: Params<
    t_TeamsListDiscussionsLegacyParamSchema,
    t_TeamsListDiscussionsLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCreateDiscussionLegacy = (
  params: Params<
    t_TeamsCreateDiscussionLegacyParamSchema,
    void,
    t_TeamsCreateDiscussionLegacyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetDiscussionLegacy = (
  params: Params<t_TeamsGetDiscussionLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsUpdateDiscussionLegacy = (
  params: Params<
    t_TeamsUpdateDiscussionLegacyParamSchema,
    void,
    t_TeamsUpdateDiscussionLegacyBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsDeleteDiscussionLegacy = (
  params: Params<t_TeamsDeleteDiscussionLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListDiscussionCommentsLegacy = (
  params: Params<
    t_TeamsListDiscussionCommentsLegacyParamSchema,
    t_TeamsListDiscussionCommentsLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCreateDiscussionCommentLegacy = (
  params: Params<
    t_TeamsCreateDiscussionCommentLegacyParamSchema,
    void,
    t_TeamsCreateDiscussionCommentLegacyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetDiscussionCommentLegacy = (
  params: Params<t_TeamsGetDiscussionCommentLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsUpdateDiscussionCommentLegacy = (
  params: Params<
    t_TeamsUpdateDiscussionCommentLegacyParamSchema,
    void,
    t_TeamsUpdateDiscussionCommentLegacyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsDeleteDiscussionCommentLegacy = (
  params: Params<t_TeamsDeleteDiscussionCommentLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForTeamDiscussionCommentLegacy = (
  params: Params<
    t_ReactionsListForTeamDiscussionCommentLegacyParamSchema,
    t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForTeamDiscussionCommentLegacy = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionCommentLegacyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsListForTeamDiscussionLegacy = (
  params: Params<
    t_ReactionsListForTeamDiscussionLegacyParamSchema,
    t_ReactionsListForTeamDiscussionLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReactionsCreateForTeamDiscussionLegacy = (
  params: Params<
    t_ReactionsCreateForTeamDiscussionLegacyParamSchema,
    void,
    t_ReactionsCreateForTeamDiscussionLegacyBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListPendingInvitationsLegacy = (
  params: Params<
    t_TeamsListPendingInvitationsLegacyParamSchema,
    t_TeamsListPendingInvitationsLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListMembersLegacy = (
  params: Params<
    t_TeamsListMembersLegacyParamSchema,
    t_TeamsListMembersLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetMemberLegacy = (
  params: Params<t_TeamsGetMemberLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsAddMemberLegacy = (
  params: Params<t_TeamsAddMemberLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsRemoveMemberLegacy = (
  params: Params<t_TeamsRemoveMemberLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsGetMembershipForUserLegacy = (
  params: Params<t_TeamsGetMembershipForUserLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsAddOrUpdateMembershipForUserLegacy = (
  params: Params<
    t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateMembershipForUserLegacyBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsRemoveMembershipForUserLegacy = (
  params: Params<t_TeamsRemoveMembershipForUserLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListProjectsLegacy = (
  params: Params<
    t_TeamsListProjectsLegacyParamSchema,
    t_TeamsListProjectsLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCheckPermissionsForProjectLegacy = (
  params: Params<
    t_TeamsCheckPermissionsForProjectLegacyParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsAddOrUpdateProjectPermissionsLegacy = (
  params: Params<
    t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateProjectPermissionsLegacyBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsRemoveProjectLegacy = (
  params: Params<t_TeamsRemoveProjectLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListReposLegacy = (
  params: Params<
    t_TeamsListReposLegacyParamSchema,
    t_TeamsListReposLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsCheckPermissionsForRepoLegacy = (
  params: Params<t_TeamsCheckPermissionsForRepoLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsAddOrUpdateRepoPermissionsLegacy = (
  params: Params<
    t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema,
    void,
    t_TeamsAddOrUpdateRepoPermissionsLegacyBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsRemoveRepoLegacy = (
  params: Params<t_TeamsRemoveRepoLegacyParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListChildLegacy = (
  params: Params<
    t_TeamsListChildLegacyParamSchema,
    t_TeamsListChildLegacyQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersGetAuthenticated = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersUpdateAuthenticated = (
  params: Params<void, void, t_UsersUpdateAuthenticatedBodySchema | undefined>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListBlockedByAuthenticatedUser = (
  params: Params<void, t_UsersListBlockedByAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersCheckBlocked = (
  params: Params<t_UsersCheckBlockedParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersBlock = (
  params: Params<t_UsersBlockParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersUnblock = (
  params: Params<t_UsersUnblockParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListForAuthenticatedUser = (
  params: Params<void, t_CodespacesListForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesCreateForAuthenticatedUser = (
  params: Params<void, void, t_CodespacesCreateForAuthenticatedUserBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListSecretsForAuthenticatedUser = (
  params: Params<
    void,
    t_CodespacesListSecretsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetPublicKeyForAuthenticatedUser = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetSecretForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
    void,
    t_CodespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesDeleteSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesDeleteSecretForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesListRepositoriesForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
    void,
    t_CodespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesAddRepositoryForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser = (
  params: Params<
    t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetForAuthenticatedUser = (
  params: Params<t_CodespacesGetForAuthenticatedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesUpdateForAuthenticatedUser = (
  params: Params<
    t_CodespacesUpdateForAuthenticatedUserParamSchema,
    void,
    t_CodespacesUpdateForAuthenticatedUserBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesDeleteForAuthenticatedUser = (
  params: Params<t_CodespacesDeleteForAuthenticatedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesExportForAuthenticatedUser = (
  params: Params<t_CodespacesExportForAuthenticatedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesGetExportDetailsForAuthenticatedUser = (
  params: Params<
    t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesCodespaceMachinesForAuthenticatedUser = (
  params: Params<
    t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesPublishForAuthenticatedUser = (
  params: Params<
    t_CodespacesPublishForAuthenticatedUserParamSchema,
    void,
    t_CodespacesPublishForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesStartForAuthenticatedUser = (
  params: Params<t_CodespacesStartForAuthenticatedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type CodespacesStopForAuthenticatedUser = (
  params: Params<t_CodespacesStopForAuthenticatedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListEmailsForAuthenticatedUser = (
  params: Params<void, t_UsersListEmailsForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersAddEmailForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersAddEmailForAuthenticatedUserBodySchema | undefined
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersDeleteEmailForAuthenticatedUser = (
  params: Params<void, void, t_UsersDeleteEmailForAuthenticatedUserBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListFollowersForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListFollowersForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListFollowedByAuthenticatedUser = (
  params: Params<void, t_UsersListFollowedByAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersCheckPersonIsFollowedByAuthenticated = (
  params: Params<
    t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersFollow = (
  params: Params<t_UsersFollowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersUnfollow = (
  params: Params<t_UsersUnfollowParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListGpgKeysForAuthenticatedUser = (
  params: Params<void, t_UsersListGpgKeysForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersCreateGpgKeyForAuthenticatedUser = (
  params: Params<void, void, t_UsersCreateGpgKeyForAuthenticatedUserBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersGetGpgKeyForAuthenticatedUser = (
  params: Params<t_UsersGetGpgKeyForAuthenticatedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersDeleteGpgKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListInstallationsForAuthenticatedUser = (
  params: Params<
    void,
    t_AppsListInstallationsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListInstallationReposForAuthenticatedUser = (
  params: Params<
    t_AppsListInstallationReposForAuthenticatedUserParamSchema,
    t_AppsListInstallationReposForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsAddRepoToInstallationForAuthenticatedUser = (
  params: Params<
    t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsRemoveRepoFromInstallationForAuthenticatedUser = (
  params: Params<
    t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsGetRestrictionsForAuthenticatedUser = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsSetRestrictionsForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_InteractionsSetRestrictionsForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type InteractionsRemoveRestrictionsForAuthenticatedUser = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type IssuesListForAuthenticatedUser = (
  params: Params<void, t_IssuesListForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListPublicSshKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersCreatePublicSshKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreatePublicSshKeyForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersGetPublicSshKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersDeletePublicSshKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListSubscriptionsForAuthenticatedUser = (
  params: Params<
    void,
    t_AppsListSubscriptionsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsListSubscriptionsForAuthenticatedUserStubbed = (
  params: Params<
    void,
    t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListMembershipsForAuthenticatedUser = (
  params: Params<
    void,
    t_OrgsListMembershipsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsGetMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsGetMembershipForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsUpdateMembershipForAuthenticatedUser = (
  params: Params<
    t_OrgsUpdateMembershipForAuthenticatedUserParamSchema,
    void,
    t_OrgsUpdateMembershipForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsListForAuthenticatedUser = (
  params: Params<void, t_MigrationsListForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsStartForAuthenticatedUser = (
  params: Params<void, void, t_MigrationsStartForAuthenticatedUserBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsGetStatusForAuthenticatedUser = (
  params: Params<
    t_MigrationsGetStatusForAuthenticatedUserParamSchema,
    t_MigrationsGetStatusForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsGetArchiveForAuthenticatedUser = (
  params: Params<
    t_MigrationsGetArchiveForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsDeleteArchiveForAuthenticatedUser = (
  params: Params<
    t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsUnlockRepoForAuthenticatedUser = (
  params: Params<
    t_MigrationsUnlockRepoForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MigrationsListReposForAuthenticatedUser = (
  params: Params<
    t_MigrationsListReposForAuthenticatedUserParamSchema,
    t_MigrationsListReposForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListForAuthenticatedUser = (
  params: Params<void, t_OrgsListForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesListPackagesForAuthenticatedUser = (
  params: Params<
    void,
    t_PackagesListPackagesForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetPackageForAuthenticatedUser = (
  params: Params<
    t_PackagesGetPackageForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesDeletePackageForAuthenticatedUser = (
  params: Params<
    t_PackagesDeletePackageForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesRestorePackageForAuthenticatedUser = (
  params: Params<
    t_PackagesRestorePackageForAuthenticatedUserParamSchema,
    t_PackagesRestorePackageForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
    t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetPackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesGetPackageVersionForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesDeletePackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesRestorePackageVersionForAuthenticatedUser = (
  params: Params<
    t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsCreateForAuthenticatedUser = (
  params: Params<void, void, t_ProjectsCreateForAuthenticatedUserBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListPublicEmailsForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListPublicEmailsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListForAuthenticatedUser = (
  params: Params<void, t_ReposListForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposCreateForAuthenticatedUser = (
  params: Params<void, void, t_ReposCreateForAuthenticatedUserBodySchema>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListInvitationsForAuthenticatedUser = (
  params: Params<
    void,
    t_ReposListInvitationsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposAcceptInvitationForAuthenticatedUser = (
  params: Params<
    t_ReposAcceptInvitationForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposDeclineInvitationForAuthenticatedUser = (
  params: Params<
    t_ReposDeclineInvitationForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListSshSigningKeysForAuthenticatedUser = (
  params: Params<
    void,
    t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersCreateSshSigningKeyForAuthenticatedUser = (
  params: Params<
    void,
    void,
    t_UsersCreateSshSigningKeyForAuthenticatedUserBodySchema
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersGetSshSigningKeyForAuthenticatedUser = (
  params: Params<
    t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersDeleteSshSigningKeyForAuthenticatedUser = (
  params: Params<
    t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListReposStarredByAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListReposStarredByAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityCheckRepoIsStarredByAuthenticatedUser = (
  params: Params<
    t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityStarRepoForAuthenticatedUser = (
  params: Params<t_ActivityStarRepoForAuthenticatedUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityUnstarRepoForAuthenticatedUser = (
  params: Params<
    t_ActivityUnstarRepoForAuthenticatedUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListWatchedReposForAuthenticatedUser = (
  params: Params<
    void,
    t_ActivityListWatchedReposForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type TeamsListForAuthenticatedUser = (
  params: Params<void, t_TeamsListForAuthenticatedUserQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersList = (
  params: Params<void, t_UsersListQuerySchema, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersGetByUsername = (
  params: Params<t_UsersGetByUsernameParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListEventsForAuthenticatedUser = (
  params: Params<
    t_ActivityListEventsForAuthenticatedUserParamSchema,
    t_ActivityListEventsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListOrgEventsForAuthenticatedUser = (
  params: Params<
    t_ActivityListOrgEventsForAuthenticatedUserParamSchema,
    t_ActivityListOrgEventsForAuthenticatedUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListPublicEventsForUser = (
  params: Params<
    t_ActivityListPublicEventsForUserParamSchema,
    t_ActivityListPublicEventsForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListFollowersForUser = (
  params: Params<
    t_UsersListFollowersForUserParamSchema,
    t_UsersListFollowersForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListFollowingForUser = (
  params: Params<
    t_UsersListFollowingForUserParamSchema,
    t_UsersListFollowingForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersCheckFollowingForUser = (
  params: Params<t_UsersCheckFollowingForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type GistsListForUser = (
  params: Params<
    t_GistsListForUserParamSchema,
    t_GistsListForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListGpgKeysForUser = (
  params: Params<
    t_UsersListGpgKeysForUserParamSchema,
    t_UsersListGpgKeysForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersGetContextForUser = (
  params: Params<
    t_UsersGetContextForUserParamSchema,
    t_UsersGetContextForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type AppsGetUserInstallation = (
  params: Params<t_AppsGetUserInstallationParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListPublicKeysForUser = (
  params: Params<
    t_UsersListPublicKeysForUserParamSchema,
    t_UsersListPublicKeysForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type OrgsListForUser = (
  params: Params<
    t_OrgsListForUserParamSchema,
    t_OrgsListForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesListPackagesForUser = (
  params: Params<
    t_PackagesListPackagesForUserParamSchema,
    t_PackagesListPackagesForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetPackageForUser = (
  params: Params<t_PackagesGetPackageForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesDeletePackageForUser = (
  params: Params<t_PackagesDeletePackageForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesRestorePackageForUser = (
  params: Params<
    t_PackagesRestorePackageForUserParamSchema,
    t_PackagesRestorePackageForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetAllPackageVersionsForPackageOwnedByUser = (
  params: Params<
    t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
    void,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesGetPackageVersionForUser = (
  params: Params<t_PackagesGetPackageVersionForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesDeletePackageVersionForUser = (
  params: Params<t_PackagesDeletePackageVersionForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type PackagesRestorePackageVersionForUser = (
  params: Params<t_PackagesRestorePackageVersionForUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ProjectsListForUser = (
  params: Params<
    t_ProjectsListForUserParamSchema,
    t_ProjectsListForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListReceivedEventsForUser = (
  params: Params<
    t_ActivityListReceivedEventsForUserParamSchema,
    t_ActivityListReceivedEventsForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListReceivedPublicEventsForUser = (
  params: Params<
    t_ActivityListReceivedPublicEventsForUserParamSchema,
    t_ActivityListReceivedPublicEventsForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ReposListForUser = (
  params: Params<
    t_ReposListForUserParamSchema,
    t_ReposListForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type BillingGetGithubActionsBillingUser = (
  params: Params<t_BillingGetGithubActionsBillingUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type BillingGetGithubPackagesBillingUser = (
  params: Params<t_BillingGetGithubPackagesBillingUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type BillingGetSharedStorageBillingUser = (
  params: Params<t_BillingGetSharedStorageBillingUserParamSchema, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type UsersListSshSigningKeysForUser = (
  params: Params<
    t_UsersListSshSigningKeysForUserParamSchema,
    t_UsersListSshSigningKeysForUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListReposStarredByUser = (
  params: Params<
    t_ActivityListReposStarredByUserParamSchema,
    t_ActivityListReposStarredByUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type ActivityListReposWatchedByUser = (
  params: Params<
    t_ActivityListReposWatchedByUserParamSchema,
    t_ActivityListReposWatchedByUserQuerySchema,
    void
  >,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MetaGetAllVersions = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type MetaGetZen = (
  params: Params<void, void, void>,
  ctx: Context
) => Promise<{ status: number; body: any }>

export type Implementation = {
  metaRoot: MetaRoot
  appsGetAuthenticated: AppsGetAuthenticated
  appsCreateFromManifest: AppsCreateFromManifest
  appsGetWebhookConfigForApp: AppsGetWebhookConfigForApp
  appsUpdateWebhookConfigForApp: AppsUpdateWebhookConfigForApp
  appsListWebhookDeliveries: AppsListWebhookDeliveries
  appsGetWebhookDelivery: AppsGetWebhookDelivery
  appsRedeliverWebhookDelivery: AppsRedeliverWebhookDelivery
  appsListInstallations: AppsListInstallations
  appsGetInstallation: AppsGetInstallation
  appsDeleteInstallation: AppsDeleteInstallation
  appsCreateInstallationAccessToken: AppsCreateInstallationAccessToken
  appsSuspendInstallation: AppsSuspendInstallation
  appsUnsuspendInstallation: AppsUnsuspendInstallation
  appsDeleteAuthorization: AppsDeleteAuthorization
  appsCheckToken: AppsCheckToken
  appsResetToken: AppsResetToken
  appsDeleteToken: AppsDeleteToken
  appsScopeToken: AppsScopeToken
  appsGetBySlug: AppsGetBySlug
  codesOfConductGetAllCodesOfConduct: CodesOfConductGetAllCodesOfConduct
  codesOfConductGetConductCode: CodesOfConductGetConductCode
  emojisGet: EmojisGet
  enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise
  enterpriseAdminListSelfHostedRunnerGroupsForEnterprise: EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise
  enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise
  enterpriseAdminGetSelfHostedRunnerGroupForEnterprise: EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise
  enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise
  enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise
  enterpriseAdminDeleteSelfHostedRunnerFromEnterprise: EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise
  enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise: EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise
  enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise: EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise
  secretScanningGetSecurityAnalysisSettingsForEnterprise: SecretScanningGetSecurityAnalysisSettingsForEnterprise
  secretScanningPatchSecurityAnalysisSettingsForEnterprise: SecretScanningPatchSecurityAnalysisSettingsForEnterprise
  dependabotListAlertsForEnterprise: DependabotListAlertsForEnterprise
  secretScanningListAlertsForEnterprise: SecretScanningListAlertsForEnterprise
  secretScanningPostSecurityProductEnablementForEnterprise: SecretScanningPostSecurityProductEnablementForEnterprise
  activityListPublicEvents: ActivityListPublicEvents
  activityGetFeeds: ActivityGetFeeds
  gistsList: GistsList
  gistsCreate: GistsCreate
  gistsListPublic: GistsListPublic
  gistsListStarred: GistsListStarred
  gistsGet: GistsGet
  gistsUpdate: GistsUpdate
  gistsDelete: GistsDelete
  gistsListComments: GistsListComments
  gistsCreateComment: GistsCreateComment
  gistsGetComment: GistsGetComment
  gistsUpdateComment: GistsUpdateComment
  gistsDeleteComment: GistsDeleteComment
  gistsListCommits: GistsListCommits
  gistsListForks: GistsListForks
  gistsFork: GistsFork
  gistsCheckIsStarred: GistsCheckIsStarred
  gistsStar: GistsStar
  gistsUnstar: GistsUnstar
  gistsGetRevision: GistsGetRevision
  gitignoreGetAllTemplates: GitignoreGetAllTemplates
  gitignoreGetTemplate: GitignoreGetTemplate
  appsListReposAccessibleToInstallation: AppsListReposAccessibleToInstallation
  appsRevokeInstallationAccessToken: AppsRevokeInstallationAccessToken
  issuesList: IssuesList
  licensesGetAllCommonlyUsed: LicensesGetAllCommonlyUsed
  licensesGet: LicensesGet
  markdownRender: MarkdownRender
  markdownRenderRaw: MarkdownRenderRaw
  appsGetSubscriptionPlanForAccount: AppsGetSubscriptionPlanForAccount
  appsListPlans: AppsListPlans
  appsListAccountsForPlan: AppsListAccountsForPlan
  appsGetSubscriptionPlanForAccountStubbed: AppsGetSubscriptionPlanForAccountStubbed
  appsListPlansStubbed: AppsListPlansStubbed
  appsListAccountsForPlanStubbed: AppsListAccountsForPlanStubbed
  metaGet: MetaGet
  activityListPublicEventsForRepoNetwork: ActivityListPublicEventsForRepoNetwork
  activityListNotificationsForAuthenticatedUser: ActivityListNotificationsForAuthenticatedUser
  activityMarkNotificationsAsRead: ActivityMarkNotificationsAsRead
  activityGetThread: ActivityGetThread
  activityMarkThreadAsRead: ActivityMarkThreadAsRead
  activityGetThreadSubscriptionForAuthenticatedUser: ActivityGetThreadSubscriptionForAuthenticatedUser
  activitySetThreadSubscription: ActivitySetThreadSubscription
  activityDeleteThreadSubscription: ActivityDeleteThreadSubscription
  metaGetOctocat: MetaGetOctocat
  orgsList: OrgsList
  orgsGet: OrgsGet
  orgsUpdate: OrgsUpdate
  actionsGetActionsCacheUsageForOrg: ActionsGetActionsCacheUsageForOrg
  actionsGetActionsCacheUsageByRepoForOrg: ActionsGetActionsCacheUsageByRepoForOrg
  oidcGetOidcCustomSubTemplateForOrg: OidcGetOidcCustomSubTemplateForOrg
  oidcUpdateOidcCustomSubTemplateForOrg: OidcUpdateOidcCustomSubTemplateForOrg
  actionsGetGithubActionsPermissionsOrganization: ActionsGetGithubActionsPermissionsOrganization
  actionsSetGithubActionsPermissionsOrganization: ActionsSetGithubActionsPermissionsOrganization
  actionsListSelectedRepositoriesEnabledGithubActionsOrganization: ActionsListSelectedRepositoriesEnabledGithubActionsOrganization
  actionsSetSelectedRepositoriesEnabledGithubActionsOrganization: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization
  actionsEnableSelectedRepositoryGithubActionsOrganization: ActionsEnableSelectedRepositoryGithubActionsOrganization
  actionsDisableSelectedRepositoryGithubActionsOrganization: ActionsDisableSelectedRepositoryGithubActionsOrganization
  actionsGetAllowedActionsOrganization: ActionsGetAllowedActionsOrganization
  actionsSetAllowedActionsOrganization: ActionsSetAllowedActionsOrganization
  actionsGetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization
  actionsSetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization
  actionsListRequiredWorkflows: ActionsListRequiredWorkflows
  actionsCreateRequiredWorkflow: ActionsCreateRequiredWorkflow
  actionsGetRequiredWorkflow: ActionsGetRequiredWorkflow
  actionsUpdateRequiredWorkflow: ActionsUpdateRequiredWorkflow
  actionsDeleteRequiredWorkflow: ActionsDeleteRequiredWorkflow
  actionsListSelectedRepositoriesRequiredWorkflow: ActionsListSelectedRepositoriesRequiredWorkflow
  actionsSetSelectedReposToRequiredWorkflow: ActionsSetSelectedReposToRequiredWorkflow
  actionsAddSelectedRepoToRequiredWorkflow: ActionsAddSelectedRepoToRequiredWorkflow
  actionsRemoveSelectedRepoFromRequiredWorkflow: ActionsRemoveSelectedRepoFromRequiredWorkflow
  actionsListSelfHostedRunnerGroupsForOrg: ActionsListSelfHostedRunnerGroupsForOrg
  actionsCreateSelfHostedRunnerGroupForOrg: ActionsCreateSelfHostedRunnerGroupForOrg
  actionsGetSelfHostedRunnerGroupForOrg: ActionsGetSelfHostedRunnerGroupForOrg
  actionsUpdateSelfHostedRunnerGroupForOrg: ActionsUpdateSelfHostedRunnerGroupForOrg
  actionsDeleteSelfHostedRunnerGroupFromOrg: ActionsDeleteSelfHostedRunnerGroupFromOrg
  actionsListRepoAccessToSelfHostedRunnerGroupInOrg: ActionsListRepoAccessToSelfHostedRunnerGroupInOrg
  actionsSetRepoAccessToSelfHostedRunnerGroupInOrg: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg
  actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
  actionsListSelfHostedRunnersInGroupForOrg: ActionsListSelfHostedRunnersInGroupForOrg
  actionsSetSelfHostedRunnersInGroupForOrg: ActionsSetSelfHostedRunnersInGroupForOrg
  actionsAddSelfHostedRunnerToGroupForOrg: ActionsAddSelfHostedRunnerToGroupForOrg
  actionsRemoveSelfHostedRunnerFromGroupForOrg: ActionsRemoveSelfHostedRunnerFromGroupForOrg
  actionsListSelfHostedRunnersForOrg: ActionsListSelfHostedRunnersForOrg
  actionsListRunnerApplicationsForOrg: ActionsListRunnerApplicationsForOrg
  actionsCreateRegistrationTokenForOrg: ActionsCreateRegistrationTokenForOrg
  actionsCreateRemoveTokenForOrg: ActionsCreateRemoveTokenForOrg
  actionsGetSelfHostedRunnerForOrg: ActionsGetSelfHostedRunnerForOrg
  actionsDeleteSelfHostedRunnerFromOrg: ActionsDeleteSelfHostedRunnerFromOrg
  actionsListLabelsForSelfHostedRunnerForOrg: ActionsListLabelsForSelfHostedRunnerForOrg
  actionsAddCustomLabelsToSelfHostedRunnerForOrg: ActionsAddCustomLabelsToSelfHostedRunnerForOrg
  actionsSetCustomLabelsForSelfHostedRunnerForOrg: ActionsSetCustomLabelsForSelfHostedRunnerForOrg
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg
  actionsRemoveCustomLabelFromSelfHostedRunnerForOrg: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg
  actionsListOrgSecrets: ActionsListOrgSecrets
  actionsGetOrgPublicKey: ActionsGetOrgPublicKey
  actionsGetOrgSecret: ActionsGetOrgSecret
  actionsCreateOrUpdateOrgSecret: ActionsCreateOrUpdateOrgSecret
  actionsDeleteOrgSecret: ActionsDeleteOrgSecret
  actionsListSelectedReposForOrgSecret: ActionsListSelectedReposForOrgSecret
  actionsSetSelectedReposForOrgSecret: ActionsSetSelectedReposForOrgSecret
  actionsAddSelectedRepoToOrgSecret: ActionsAddSelectedRepoToOrgSecret
  actionsRemoveSelectedRepoFromOrgSecret: ActionsRemoveSelectedRepoFromOrgSecret
  actionsListOrgVariables: ActionsListOrgVariables
  actionsCreateOrgVariable: ActionsCreateOrgVariable
  actionsGetOrgVariable: ActionsGetOrgVariable
  actionsUpdateOrgVariable: ActionsUpdateOrgVariable
  actionsDeleteOrgVariable: ActionsDeleteOrgVariable
  actionsListSelectedReposForOrgVariable: ActionsListSelectedReposForOrgVariable
  actionsSetSelectedReposForOrgVariable: ActionsSetSelectedReposForOrgVariable
  actionsAddSelectedRepoToOrgVariable: ActionsAddSelectedRepoToOrgVariable
  actionsRemoveSelectedRepoFromOrgVariable: ActionsRemoveSelectedRepoFromOrgVariable
  orgsListBlockedUsers: OrgsListBlockedUsers
  orgsCheckBlockedUser: OrgsCheckBlockedUser
  orgsBlockUser: OrgsBlockUser
  orgsUnblockUser: OrgsUnblockUser
  codeScanningListAlertsForOrg: CodeScanningListAlertsForOrg
  codespacesListInOrganization: CodespacesListInOrganization
  codespacesSetCodespacesBilling: CodespacesSetCodespacesBilling
  codespacesListOrgSecrets: CodespacesListOrgSecrets
  codespacesGetOrgPublicKey: CodespacesGetOrgPublicKey
  codespacesGetOrgSecret: CodespacesGetOrgSecret
  codespacesCreateOrUpdateOrgSecret: CodespacesCreateOrUpdateOrgSecret
  codespacesDeleteOrgSecret: CodespacesDeleteOrgSecret
  codespacesListSelectedReposForOrgSecret: CodespacesListSelectedReposForOrgSecret
  codespacesSetSelectedReposForOrgSecret: CodespacesSetSelectedReposForOrgSecret
  codespacesAddSelectedRepoToOrgSecret: CodespacesAddSelectedRepoToOrgSecret
  codespacesRemoveSelectedRepoFromOrgSecret: CodespacesRemoveSelectedRepoFromOrgSecret
  dependabotListAlertsForOrg: DependabotListAlertsForOrg
  dependabotListOrgSecrets: DependabotListOrgSecrets
  dependabotGetOrgPublicKey: DependabotGetOrgPublicKey
  dependabotGetOrgSecret: DependabotGetOrgSecret
  dependabotCreateOrUpdateOrgSecret: DependabotCreateOrUpdateOrgSecret
  dependabotDeleteOrgSecret: DependabotDeleteOrgSecret
  dependabotListSelectedReposForOrgSecret: DependabotListSelectedReposForOrgSecret
  dependabotSetSelectedReposForOrgSecret: DependabotSetSelectedReposForOrgSecret
  dependabotAddSelectedRepoToOrgSecret: DependabotAddSelectedRepoToOrgSecret
  dependabotRemoveSelectedRepoFromOrgSecret: DependabotRemoveSelectedRepoFromOrgSecret
  activityListPublicOrgEvents: ActivityListPublicOrgEvents
  orgsListFailedInvitations: OrgsListFailedInvitations
  orgsListWebhooks: OrgsListWebhooks
  orgsCreateWebhook: OrgsCreateWebhook
  orgsGetWebhook: OrgsGetWebhook
  orgsUpdateWebhook: OrgsUpdateWebhook
  orgsDeleteWebhook: OrgsDeleteWebhook
  orgsGetWebhookConfigForOrg: OrgsGetWebhookConfigForOrg
  orgsUpdateWebhookConfigForOrg: OrgsUpdateWebhookConfigForOrg
  orgsListWebhookDeliveries: OrgsListWebhookDeliveries
  orgsGetWebhookDelivery: OrgsGetWebhookDelivery
  orgsRedeliverWebhookDelivery: OrgsRedeliverWebhookDelivery
  orgsPingWebhook: OrgsPingWebhook
  appsGetOrgInstallation: AppsGetOrgInstallation
  orgsListAppInstallations: OrgsListAppInstallations
  interactionsGetRestrictionsForOrg: InteractionsGetRestrictionsForOrg
  interactionsSetRestrictionsForOrg: InteractionsSetRestrictionsForOrg
  interactionsRemoveRestrictionsForOrg: InteractionsRemoveRestrictionsForOrg
  orgsListPendingInvitations: OrgsListPendingInvitations
  orgsCreateInvitation: OrgsCreateInvitation
  orgsCancelInvitation: OrgsCancelInvitation
  orgsListInvitationTeams: OrgsListInvitationTeams
  issuesListForOrg: IssuesListForOrg
  orgsListMembers: OrgsListMembers
  orgsCheckMembershipForUser: OrgsCheckMembershipForUser
  orgsRemoveMember: OrgsRemoveMember
  codespacesGetCodespacesForUserInOrg: CodespacesGetCodespacesForUserInOrg
  codespacesDeleteFromOrganization: CodespacesDeleteFromOrganization
  codespacesStopInOrganization: CodespacesStopInOrganization
  orgsGetMembershipForUser: OrgsGetMembershipForUser
  orgsSetMembershipForUser: OrgsSetMembershipForUser
  orgsRemoveMembershipForUser: OrgsRemoveMembershipForUser
  migrationsListForOrg: MigrationsListForOrg
  migrationsStartForOrg: MigrationsStartForOrg
  migrationsGetStatusForOrg: MigrationsGetStatusForOrg
  migrationsDownloadArchiveForOrg: MigrationsDownloadArchiveForOrg
  migrationsDeleteArchiveForOrg: MigrationsDeleteArchiveForOrg
  migrationsUnlockRepoForOrg: MigrationsUnlockRepoForOrg
  migrationsListReposForOrg: MigrationsListReposForOrg
  orgsListOutsideCollaborators: OrgsListOutsideCollaborators
  orgsConvertMemberToOutsideCollaborator: OrgsConvertMemberToOutsideCollaborator
  orgsRemoveOutsideCollaborator: OrgsRemoveOutsideCollaborator
  packagesListPackagesForOrganization: PackagesListPackagesForOrganization
  packagesGetPackageForOrganization: PackagesGetPackageForOrganization
  packagesDeletePackageForOrg: PackagesDeletePackageForOrg
  packagesRestorePackageForOrg: PackagesRestorePackageForOrg
  packagesGetAllPackageVersionsForPackageOwnedByOrg: PackagesGetAllPackageVersionsForPackageOwnedByOrg
  packagesGetPackageVersionForOrganization: PackagesGetPackageVersionForOrganization
  packagesDeletePackageVersionForOrg: PackagesDeletePackageVersionForOrg
  packagesRestorePackageVersionForOrg: PackagesRestorePackageVersionForOrg
  projectsListForOrg: ProjectsListForOrg
  projectsCreateForOrg: ProjectsCreateForOrg
  orgsListPublicMembers: OrgsListPublicMembers
  orgsCheckPublicMembershipForUser: OrgsCheckPublicMembershipForUser
  orgsSetPublicMembershipForAuthenticatedUser: OrgsSetPublicMembershipForAuthenticatedUser
  orgsRemovePublicMembershipForAuthenticatedUser: OrgsRemovePublicMembershipForAuthenticatedUser
  reposListForOrg: ReposListForOrg
  reposCreateInOrg: ReposCreateInOrg
  secretScanningListAlertsForOrg: SecretScanningListAlertsForOrg
  orgsListSecurityManagerTeams: OrgsListSecurityManagerTeams
  orgsAddSecurityManagerTeam: OrgsAddSecurityManagerTeam
  orgsRemoveSecurityManagerTeam: OrgsRemoveSecurityManagerTeam
  billingGetGithubActionsBillingOrg: BillingGetGithubActionsBillingOrg
  billingGetGithubPackagesBillingOrg: BillingGetGithubPackagesBillingOrg
  billingGetSharedStorageBillingOrg: BillingGetSharedStorageBillingOrg
  teamsList: TeamsList
  teamsCreate: TeamsCreate
  teamsGetByName: TeamsGetByName
  teamsUpdateInOrg: TeamsUpdateInOrg
  teamsDeleteInOrg: TeamsDeleteInOrg
  teamsListDiscussionsInOrg: TeamsListDiscussionsInOrg
  teamsCreateDiscussionInOrg: TeamsCreateDiscussionInOrg
  teamsGetDiscussionInOrg: TeamsGetDiscussionInOrg
  teamsUpdateDiscussionInOrg: TeamsUpdateDiscussionInOrg
  teamsDeleteDiscussionInOrg: TeamsDeleteDiscussionInOrg
  teamsListDiscussionCommentsInOrg: TeamsListDiscussionCommentsInOrg
  teamsCreateDiscussionCommentInOrg: TeamsCreateDiscussionCommentInOrg
  teamsGetDiscussionCommentInOrg: TeamsGetDiscussionCommentInOrg
  teamsUpdateDiscussionCommentInOrg: TeamsUpdateDiscussionCommentInOrg
  teamsDeleteDiscussionCommentInOrg: TeamsDeleteDiscussionCommentInOrg
  reactionsListForTeamDiscussionCommentInOrg: ReactionsListForTeamDiscussionCommentInOrg
  reactionsCreateForTeamDiscussionCommentInOrg: ReactionsCreateForTeamDiscussionCommentInOrg
  reactionsDeleteForTeamDiscussionComment: ReactionsDeleteForTeamDiscussionComment
  reactionsListForTeamDiscussionInOrg: ReactionsListForTeamDiscussionInOrg
  reactionsCreateForTeamDiscussionInOrg: ReactionsCreateForTeamDiscussionInOrg
  reactionsDeleteForTeamDiscussion: ReactionsDeleteForTeamDiscussion
  teamsListPendingInvitationsInOrg: TeamsListPendingInvitationsInOrg
  teamsListMembersInOrg: TeamsListMembersInOrg
  teamsGetMembershipForUserInOrg: TeamsGetMembershipForUserInOrg
  teamsAddOrUpdateMembershipForUserInOrg: TeamsAddOrUpdateMembershipForUserInOrg
  teamsRemoveMembershipForUserInOrg: TeamsRemoveMembershipForUserInOrg
  teamsListProjectsInOrg: TeamsListProjectsInOrg
  teamsCheckPermissionsForProjectInOrg: TeamsCheckPermissionsForProjectInOrg
  teamsAddOrUpdateProjectPermissionsInOrg: TeamsAddOrUpdateProjectPermissionsInOrg
  teamsRemoveProjectInOrg: TeamsRemoveProjectInOrg
  teamsListReposInOrg: TeamsListReposInOrg
  teamsCheckPermissionsForRepoInOrg: TeamsCheckPermissionsForRepoInOrg
  teamsAddOrUpdateRepoPermissionsInOrg: TeamsAddOrUpdateRepoPermissionsInOrg
  teamsRemoveRepoInOrg: TeamsRemoveRepoInOrg
  teamsListChildInOrg: TeamsListChildInOrg
  orgsEnableOrDisableSecurityProductOnAllOrgRepos: OrgsEnableOrDisableSecurityProductOnAllOrgRepos
  projectsGetCard: ProjectsGetCard
  projectsUpdateCard: ProjectsUpdateCard
  projectsDeleteCard: ProjectsDeleteCard
  projectsMoveCard: ProjectsMoveCard
  projectsGetColumn: ProjectsGetColumn
  projectsUpdateColumn: ProjectsUpdateColumn
  projectsDeleteColumn: ProjectsDeleteColumn
  projectsListCards: ProjectsListCards
  projectsCreateCard: ProjectsCreateCard
  projectsMoveColumn: ProjectsMoveColumn
  projectsGet: ProjectsGet
  projectsUpdate: ProjectsUpdate
  projectsDelete: ProjectsDelete
  projectsListCollaborators: ProjectsListCollaborators
  projectsAddCollaborator: ProjectsAddCollaborator
  projectsRemoveCollaborator: ProjectsRemoveCollaborator
  projectsGetPermissionForUser: ProjectsGetPermissionForUser
  projectsListColumns: ProjectsListColumns
  projectsCreateColumn: ProjectsCreateColumn
  rateLimitGet: RateLimitGet
  actionsListRepoRequiredWorkflows: ActionsListRepoRequiredWorkflows
  actionsGetRepoRequiredWorkflow: ActionsGetRepoRequiredWorkflow
  actionsGetRepoRequiredWorkflowUsage: ActionsGetRepoRequiredWorkflowUsage
  reposGet: ReposGet
  reposUpdate: ReposUpdate
  reposDelete: ReposDelete
  actionsListArtifactsForRepo: ActionsListArtifactsForRepo
  actionsGetArtifact: ActionsGetArtifact
  actionsDeleteArtifact: ActionsDeleteArtifact
  actionsDownloadArtifact: ActionsDownloadArtifact
  actionsGetActionsCacheUsage: ActionsGetActionsCacheUsage
  actionsGetActionsCacheList: ActionsGetActionsCacheList
  actionsDeleteActionsCacheByKey: ActionsDeleteActionsCacheByKey
  actionsDeleteActionsCacheById: ActionsDeleteActionsCacheById
  actionsGetJobForWorkflowRun: ActionsGetJobForWorkflowRun
  actionsDownloadJobLogsForWorkflowRun: ActionsDownloadJobLogsForWorkflowRun
  actionsReRunJobForWorkflowRun: ActionsReRunJobForWorkflowRun
  actionsGetCustomOidcSubClaimForRepo: ActionsGetCustomOidcSubClaimForRepo
  actionsSetCustomOidcSubClaimForRepo: ActionsSetCustomOidcSubClaimForRepo
  actionsGetGithubActionsPermissionsRepository: ActionsGetGithubActionsPermissionsRepository
  actionsSetGithubActionsPermissionsRepository: ActionsSetGithubActionsPermissionsRepository
  actionsGetWorkflowAccessToRepository: ActionsGetWorkflowAccessToRepository
  actionsSetWorkflowAccessToRepository: ActionsSetWorkflowAccessToRepository
  actionsGetAllowedActionsRepository: ActionsGetAllowedActionsRepository
  actionsSetAllowedActionsRepository: ActionsSetAllowedActionsRepository
  actionsGetGithubActionsDefaultWorkflowPermissionsRepository: ActionsGetGithubActionsDefaultWorkflowPermissionsRepository
  actionsSetGithubActionsDefaultWorkflowPermissionsRepository: ActionsSetGithubActionsDefaultWorkflowPermissionsRepository
  actionsListRequiredWorkflowRuns: ActionsListRequiredWorkflowRuns
  actionsListSelfHostedRunnersForRepo: ActionsListSelfHostedRunnersForRepo
  actionsListRunnerApplicationsForRepo: ActionsListRunnerApplicationsForRepo
  actionsCreateRegistrationTokenForRepo: ActionsCreateRegistrationTokenForRepo
  actionsCreateRemoveTokenForRepo: ActionsCreateRemoveTokenForRepo
  actionsGetSelfHostedRunnerForRepo: ActionsGetSelfHostedRunnerForRepo
  actionsDeleteSelfHostedRunnerFromRepo: ActionsDeleteSelfHostedRunnerFromRepo
  actionsListLabelsForSelfHostedRunnerForRepo: ActionsListLabelsForSelfHostedRunnerForRepo
  actionsAddCustomLabelsToSelfHostedRunnerForRepo: ActionsAddCustomLabelsToSelfHostedRunnerForRepo
  actionsSetCustomLabelsForSelfHostedRunnerForRepo: ActionsSetCustomLabelsForSelfHostedRunnerForRepo
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo
  actionsRemoveCustomLabelFromSelfHostedRunnerForRepo: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo
  actionsListWorkflowRunsForRepo: ActionsListWorkflowRunsForRepo
  actionsGetWorkflowRun: ActionsGetWorkflowRun
  actionsDeleteWorkflowRun: ActionsDeleteWorkflowRun
  actionsGetReviewsForRun: ActionsGetReviewsForRun
  actionsApproveWorkflowRun: ActionsApproveWorkflowRun
  actionsListWorkflowRunArtifacts: ActionsListWorkflowRunArtifacts
  actionsGetWorkflowRunAttempt: ActionsGetWorkflowRunAttempt
  actionsListJobsForWorkflowRunAttempt: ActionsListJobsForWorkflowRunAttempt
  actionsDownloadWorkflowRunAttemptLogs: ActionsDownloadWorkflowRunAttemptLogs
  actionsCancelWorkflowRun: ActionsCancelWorkflowRun
  actionsListJobsForWorkflowRun: ActionsListJobsForWorkflowRun
  actionsDownloadWorkflowRunLogs: ActionsDownloadWorkflowRunLogs
  actionsDeleteWorkflowRunLogs: ActionsDeleteWorkflowRunLogs
  actionsGetPendingDeploymentsForRun: ActionsGetPendingDeploymentsForRun
  actionsReviewPendingDeploymentsForRun: ActionsReviewPendingDeploymentsForRun
  actionsReRunWorkflow: ActionsReRunWorkflow
  actionsReRunWorkflowFailedJobs: ActionsReRunWorkflowFailedJobs
  actionsGetWorkflowRunUsage: ActionsGetWorkflowRunUsage
  actionsListRepoSecrets: ActionsListRepoSecrets
  actionsGetRepoPublicKey: ActionsGetRepoPublicKey
  actionsGetRepoSecret: ActionsGetRepoSecret
  actionsCreateOrUpdateRepoSecret: ActionsCreateOrUpdateRepoSecret
  actionsDeleteRepoSecret: ActionsDeleteRepoSecret
  actionsListRepoVariables: ActionsListRepoVariables
  actionsCreateRepoVariable: ActionsCreateRepoVariable
  actionsGetRepoVariable: ActionsGetRepoVariable
  actionsUpdateRepoVariable: ActionsUpdateRepoVariable
  actionsDeleteRepoVariable: ActionsDeleteRepoVariable
  actionsListRepoWorkflows: ActionsListRepoWorkflows
  actionsGetWorkflow: ActionsGetWorkflow
  actionsDisableWorkflow: ActionsDisableWorkflow
  actionsCreateWorkflowDispatch: ActionsCreateWorkflowDispatch
  actionsEnableWorkflow: ActionsEnableWorkflow
  actionsListWorkflowRuns: ActionsListWorkflowRuns
  actionsGetWorkflowUsage: ActionsGetWorkflowUsage
  issuesListAssignees: IssuesListAssignees
  issuesCheckUserCanBeAssigned: IssuesCheckUserCanBeAssigned
  reposListAutolinks: ReposListAutolinks
  reposCreateAutolink: ReposCreateAutolink
  reposGetAutolink: ReposGetAutolink
  reposDeleteAutolink: ReposDeleteAutolink
  reposEnableAutomatedSecurityFixes: ReposEnableAutomatedSecurityFixes
  reposDisableAutomatedSecurityFixes: ReposDisableAutomatedSecurityFixes
  reposListBranches: ReposListBranches
  reposGetBranch: ReposGetBranch
  reposGetBranchProtection: ReposGetBranchProtection
  reposUpdateBranchProtection: ReposUpdateBranchProtection
  reposDeleteBranchProtection: ReposDeleteBranchProtection
  reposGetAdminBranchProtection: ReposGetAdminBranchProtection
  reposSetAdminBranchProtection: ReposSetAdminBranchProtection
  reposDeleteAdminBranchProtection: ReposDeleteAdminBranchProtection
  reposGetPullRequestReviewProtection: ReposGetPullRequestReviewProtection
  reposUpdatePullRequestReviewProtection: ReposUpdatePullRequestReviewProtection
  reposDeletePullRequestReviewProtection: ReposDeletePullRequestReviewProtection
  reposGetCommitSignatureProtection: ReposGetCommitSignatureProtection
  reposCreateCommitSignatureProtection: ReposCreateCommitSignatureProtection
  reposDeleteCommitSignatureProtection: ReposDeleteCommitSignatureProtection
  reposGetStatusChecksProtection: ReposGetStatusChecksProtection
  reposUpdateStatusCheckProtection: ReposUpdateStatusCheckProtection
  reposRemoveStatusCheckProtection: ReposRemoveStatusCheckProtection
  reposGetAllStatusCheckContexts: ReposGetAllStatusCheckContexts
  reposAddStatusCheckContexts: ReposAddStatusCheckContexts
  reposSetStatusCheckContexts: ReposSetStatusCheckContexts
  reposRemoveStatusCheckContexts: ReposRemoveStatusCheckContexts
  reposGetAccessRestrictions: ReposGetAccessRestrictions
  reposDeleteAccessRestrictions: ReposDeleteAccessRestrictions
  reposGetAppsWithAccessToProtectedBranch: ReposGetAppsWithAccessToProtectedBranch
  reposAddAppAccessRestrictions: ReposAddAppAccessRestrictions
  reposSetAppAccessRestrictions: ReposSetAppAccessRestrictions
  reposRemoveAppAccessRestrictions: ReposRemoveAppAccessRestrictions
  reposGetTeamsWithAccessToProtectedBranch: ReposGetTeamsWithAccessToProtectedBranch
  reposAddTeamAccessRestrictions: ReposAddTeamAccessRestrictions
  reposSetTeamAccessRestrictions: ReposSetTeamAccessRestrictions
  reposRemoveTeamAccessRestrictions: ReposRemoveTeamAccessRestrictions
  reposGetUsersWithAccessToProtectedBranch: ReposGetUsersWithAccessToProtectedBranch
  reposAddUserAccessRestrictions: ReposAddUserAccessRestrictions
  reposSetUserAccessRestrictions: ReposSetUserAccessRestrictions
  reposRemoveUserAccessRestrictions: ReposRemoveUserAccessRestrictions
  reposRenameBranch: ReposRenameBranch
  checksCreate: ChecksCreate
  checksGet: ChecksGet
  checksUpdate: ChecksUpdate
  checksListAnnotations: ChecksListAnnotations
  checksRerequestRun: ChecksRerequestRun
  checksCreateSuite: ChecksCreateSuite
  checksSetSuitesPreferences: ChecksSetSuitesPreferences
  checksGetSuite: ChecksGetSuite
  checksListForSuite: ChecksListForSuite
  checksRerequestSuite: ChecksRerequestSuite
  codeScanningListAlertsForRepo: CodeScanningListAlertsForRepo
  codeScanningGetAlert: CodeScanningGetAlert
  codeScanningUpdateAlert: CodeScanningUpdateAlert
  codeScanningListAlertInstances: CodeScanningListAlertInstances
  codeScanningListRecentAnalyses: CodeScanningListRecentAnalyses
  codeScanningGetAnalysis: CodeScanningGetAnalysis
  codeScanningDeleteAnalysis: CodeScanningDeleteAnalysis
  codeScanningListCodeqlDatabases: CodeScanningListCodeqlDatabases
  codeScanningGetCodeqlDatabase: CodeScanningGetCodeqlDatabase
  codeScanningUploadSarif: CodeScanningUploadSarif
  codeScanningGetSarif: CodeScanningGetSarif
  reposCodeownersErrors: ReposCodeownersErrors
  codespacesListInRepositoryForAuthenticatedUser: CodespacesListInRepositoryForAuthenticatedUser
  codespacesCreateWithRepoForAuthenticatedUser: CodespacesCreateWithRepoForAuthenticatedUser
  codespacesListDevcontainersInRepositoryForAuthenticatedUser: CodespacesListDevcontainersInRepositoryForAuthenticatedUser
  codespacesRepoMachinesForAuthenticatedUser: CodespacesRepoMachinesForAuthenticatedUser
  codespacesPreFlightWithRepoForAuthenticatedUser: CodespacesPreFlightWithRepoForAuthenticatedUser
  codespacesListRepoSecrets: CodespacesListRepoSecrets
  codespacesGetRepoPublicKey: CodespacesGetRepoPublicKey
  codespacesGetRepoSecret: CodespacesGetRepoSecret
  codespacesCreateOrUpdateRepoSecret: CodespacesCreateOrUpdateRepoSecret
  codespacesDeleteRepoSecret: CodespacesDeleteRepoSecret
  reposListCollaborators: ReposListCollaborators
  reposCheckCollaborator: ReposCheckCollaborator
  reposAddCollaborator: ReposAddCollaborator
  reposRemoveCollaborator: ReposRemoveCollaborator
  reposGetCollaboratorPermissionLevel: ReposGetCollaboratorPermissionLevel
  reposListCommitCommentsForRepo: ReposListCommitCommentsForRepo
  reposGetCommitComment: ReposGetCommitComment
  reposUpdateCommitComment: ReposUpdateCommitComment
  reposDeleteCommitComment: ReposDeleteCommitComment
  reactionsListForCommitComment: ReactionsListForCommitComment
  reactionsCreateForCommitComment: ReactionsCreateForCommitComment
  reactionsDeleteForCommitComment: ReactionsDeleteForCommitComment
  reposListCommits: ReposListCommits
  reposListBranchesForHeadCommit: ReposListBranchesForHeadCommit
  reposListCommentsForCommit: ReposListCommentsForCommit
  reposCreateCommitComment: ReposCreateCommitComment
  reposListPullRequestsAssociatedWithCommit: ReposListPullRequestsAssociatedWithCommit
  reposGetCommit: ReposGetCommit
  checksListForRef: ChecksListForRef
  checksListSuitesForRef: ChecksListSuitesForRef
  reposGetCombinedStatusForRef: ReposGetCombinedStatusForRef
  reposListCommitStatusesForRef: ReposListCommitStatusesForRef
  reposGetCommunityProfileMetrics: ReposGetCommunityProfileMetrics
  reposCompareCommits: ReposCompareCommits
  reposGetContent: ReposGetContent
  reposCreateOrUpdateFileContents: ReposCreateOrUpdateFileContents
  reposDeleteFile: ReposDeleteFile
  reposListContributors: ReposListContributors
  dependabotListAlertsForRepo: DependabotListAlertsForRepo
  dependabotGetAlert: DependabotGetAlert
  dependabotUpdateAlert: DependabotUpdateAlert
  dependabotListRepoSecrets: DependabotListRepoSecrets
  dependabotGetRepoPublicKey: DependabotGetRepoPublicKey
  dependabotGetRepoSecret: DependabotGetRepoSecret
  dependabotCreateOrUpdateRepoSecret: DependabotCreateOrUpdateRepoSecret
  dependabotDeleteRepoSecret: DependabotDeleteRepoSecret
  dependencyGraphDiffRange: DependencyGraphDiffRange
  dependencyGraphCreateRepositorySnapshot: DependencyGraphCreateRepositorySnapshot
  reposListDeployments: ReposListDeployments
  reposCreateDeployment: ReposCreateDeployment
  reposGetDeployment: ReposGetDeployment
  reposDeleteDeployment: ReposDeleteDeployment
  reposListDeploymentStatuses: ReposListDeploymentStatuses
  reposCreateDeploymentStatus: ReposCreateDeploymentStatus
  reposGetDeploymentStatus: ReposGetDeploymentStatus
  reposCreateDispatchEvent: ReposCreateDispatchEvent
  reposGetAllEnvironments: ReposGetAllEnvironments
  reposGetEnvironment: ReposGetEnvironment
  reposCreateOrUpdateEnvironment: ReposCreateOrUpdateEnvironment
  reposDeleteAnEnvironment: ReposDeleteAnEnvironment
  reposListDeploymentBranchPolicies: ReposListDeploymentBranchPolicies
  reposCreateDeploymentBranchPolicy: ReposCreateDeploymentBranchPolicy
  reposGetDeploymentBranchPolicy: ReposGetDeploymentBranchPolicy
  reposUpdateDeploymentBranchPolicy: ReposUpdateDeploymentBranchPolicy
  reposDeleteDeploymentBranchPolicy: ReposDeleteDeploymentBranchPolicy
  activityListRepoEvents: ActivityListRepoEvents
  reposListForks: ReposListForks
  reposCreateFork: ReposCreateFork
  gitCreateBlob: GitCreateBlob
  gitGetBlob: GitGetBlob
  gitCreateCommit: GitCreateCommit
  gitGetCommit: GitGetCommit
  gitListMatchingRefs: GitListMatchingRefs
  gitGetRef: GitGetRef
  gitCreateRef: GitCreateRef
  gitUpdateRef: GitUpdateRef
  gitDeleteRef: GitDeleteRef
  gitCreateTag: GitCreateTag
  gitGetTag: GitGetTag
  gitCreateTree: GitCreateTree
  gitGetTree: GitGetTree
  reposListWebhooks: ReposListWebhooks
  reposCreateWebhook: ReposCreateWebhook
  reposGetWebhook: ReposGetWebhook
  reposUpdateWebhook: ReposUpdateWebhook
  reposDeleteWebhook: ReposDeleteWebhook
  reposGetWebhookConfigForRepo: ReposGetWebhookConfigForRepo
  reposUpdateWebhookConfigForRepo: ReposUpdateWebhookConfigForRepo
  reposListWebhookDeliveries: ReposListWebhookDeliveries
  reposGetWebhookDelivery: ReposGetWebhookDelivery
  reposRedeliverWebhookDelivery: ReposRedeliverWebhookDelivery
  reposPingWebhook: ReposPingWebhook
  reposTestPushWebhook: ReposTestPushWebhook
  migrationsGetImportStatus: MigrationsGetImportStatus
  migrationsStartImport: MigrationsStartImport
  migrationsUpdateImport: MigrationsUpdateImport
  migrationsCancelImport: MigrationsCancelImport
  migrationsGetCommitAuthors: MigrationsGetCommitAuthors
  migrationsMapCommitAuthor: MigrationsMapCommitAuthor
  migrationsGetLargeFiles: MigrationsGetLargeFiles
  migrationsSetLfsPreference: MigrationsSetLfsPreference
  appsGetRepoInstallation: AppsGetRepoInstallation
  interactionsGetRestrictionsForRepo: InteractionsGetRestrictionsForRepo
  interactionsSetRestrictionsForRepo: InteractionsSetRestrictionsForRepo
  interactionsRemoveRestrictionsForRepo: InteractionsRemoveRestrictionsForRepo
  reposListInvitations: ReposListInvitations
  reposUpdateInvitation: ReposUpdateInvitation
  reposDeleteInvitation: ReposDeleteInvitation
  issuesListForRepo: IssuesListForRepo
  issuesCreate: IssuesCreate
  issuesListCommentsForRepo: IssuesListCommentsForRepo
  issuesGetComment: IssuesGetComment
  issuesUpdateComment: IssuesUpdateComment
  issuesDeleteComment: IssuesDeleteComment
  reactionsListForIssueComment: ReactionsListForIssueComment
  reactionsCreateForIssueComment: ReactionsCreateForIssueComment
  reactionsDeleteForIssueComment: ReactionsDeleteForIssueComment
  issuesListEventsForRepo: IssuesListEventsForRepo
  issuesGetEvent: IssuesGetEvent
  issuesGet: IssuesGet
  issuesUpdate: IssuesUpdate
  issuesAddAssignees: IssuesAddAssignees
  issuesRemoveAssignees: IssuesRemoveAssignees
  issuesCheckUserCanBeAssignedToIssue: IssuesCheckUserCanBeAssignedToIssue
  issuesListComments: IssuesListComments
  issuesCreateComment: IssuesCreateComment
  issuesListEvents: IssuesListEvents
  issuesListLabelsOnIssue: IssuesListLabelsOnIssue
  issuesAddLabels: IssuesAddLabels
  issuesSetLabels: IssuesSetLabels
  issuesRemoveAllLabels: IssuesRemoveAllLabels
  issuesRemoveLabel: IssuesRemoveLabel
  issuesLock: IssuesLock
  issuesUnlock: IssuesUnlock
  reactionsListForIssue: ReactionsListForIssue
  reactionsCreateForIssue: ReactionsCreateForIssue
  reactionsDeleteForIssue: ReactionsDeleteForIssue
  issuesListEventsForTimeline: IssuesListEventsForTimeline
  reposListDeployKeys: ReposListDeployKeys
  reposCreateDeployKey: ReposCreateDeployKey
  reposGetDeployKey: ReposGetDeployKey
  reposDeleteDeployKey: ReposDeleteDeployKey
  issuesListLabelsForRepo: IssuesListLabelsForRepo
  issuesCreateLabel: IssuesCreateLabel
  issuesGetLabel: IssuesGetLabel
  issuesUpdateLabel: IssuesUpdateLabel
  issuesDeleteLabel: IssuesDeleteLabel
  reposListLanguages: ReposListLanguages
  reposEnableLfsForRepo: ReposEnableLfsForRepo
  reposDisableLfsForRepo: ReposDisableLfsForRepo
  licensesGetForRepo: LicensesGetForRepo
  reposMergeUpstream: ReposMergeUpstream
  reposMerge: ReposMerge
  issuesListMilestones: IssuesListMilestones
  issuesCreateMilestone: IssuesCreateMilestone
  issuesGetMilestone: IssuesGetMilestone
  issuesUpdateMilestone: IssuesUpdateMilestone
  issuesDeleteMilestone: IssuesDeleteMilestone
  issuesListLabelsForMilestone: IssuesListLabelsForMilestone
  activityListRepoNotificationsForAuthenticatedUser: ActivityListRepoNotificationsForAuthenticatedUser
  activityMarkRepoNotificationsAsRead: ActivityMarkRepoNotificationsAsRead
  reposGetPages: ReposGetPages
  reposCreatePagesSite: ReposCreatePagesSite
  reposUpdateInformationAboutPagesSite: ReposUpdateInformationAboutPagesSite
  reposDeletePagesSite: ReposDeletePagesSite
  reposListPagesBuilds: ReposListPagesBuilds
  reposRequestPagesBuild: ReposRequestPagesBuild
  reposGetLatestPagesBuild: ReposGetLatestPagesBuild
  reposGetPagesBuild: ReposGetPagesBuild
  reposCreatePagesDeployment: ReposCreatePagesDeployment
  reposGetPagesHealthCheck: ReposGetPagesHealthCheck
  projectsListForRepo: ProjectsListForRepo
  projectsCreateForRepo: ProjectsCreateForRepo
  pullsList: PullsList
  pullsCreate: PullsCreate
  pullsListReviewCommentsForRepo: PullsListReviewCommentsForRepo
  pullsGetReviewComment: PullsGetReviewComment
  pullsUpdateReviewComment: PullsUpdateReviewComment
  pullsDeleteReviewComment: PullsDeleteReviewComment
  reactionsListForPullRequestReviewComment: ReactionsListForPullRequestReviewComment
  reactionsCreateForPullRequestReviewComment: ReactionsCreateForPullRequestReviewComment
  reactionsDeleteForPullRequestComment: ReactionsDeleteForPullRequestComment
  pullsGet: PullsGet
  pullsUpdate: PullsUpdate
  codespacesCreateWithPrForAuthenticatedUser: CodespacesCreateWithPrForAuthenticatedUser
  pullsListReviewComments: PullsListReviewComments
  pullsCreateReviewComment: PullsCreateReviewComment
  pullsCreateReplyForReviewComment: PullsCreateReplyForReviewComment
  pullsListCommits: PullsListCommits
  pullsListFiles: PullsListFiles
  pullsCheckIfMerged: PullsCheckIfMerged
  pullsMerge: PullsMerge
  pullsListRequestedReviewers: PullsListRequestedReviewers
  pullsRequestReviewers: PullsRequestReviewers
  pullsRemoveRequestedReviewers: PullsRemoveRequestedReviewers
  pullsListReviews: PullsListReviews
  pullsCreateReview: PullsCreateReview
  pullsGetReview: PullsGetReview
  pullsUpdateReview: PullsUpdateReview
  pullsDeletePendingReview: PullsDeletePendingReview
  pullsListCommentsForReview: PullsListCommentsForReview
  pullsDismissReview: PullsDismissReview
  pullsSubmitReview: PullsSubmitReview
  pullsUpdateBranch: PullsUpdateBranch
  reposGetReadme: ReposGetReadme
  reposGetReadmeInDirectory: ReposGetReadmeInDirectory
  reposListReleases: ReposListReleases
  reposCreateRelease: ReposCreateRelease
  reposGetReleaseAsset: ReposGetReleaseAsset
  reposUpdateReleaseAsset: ReposUpdateReleaseAsset
  reposDeleteReleaseAsset: ReposDeleteReleaseAsset
  reposGenerateReleaseNotes: ReposGenerateReleaseNotes
  reposGetLatestRelease: ReposGetLatestRelease
  reposGetReleaseByTag: ReposGetReleaseByTag
  reposGetRelease: ReposGetRelease
  reposUpdateRelease: ReposUpdateRelease
  reposDeleteRelease: ReposDeleteRelease
  reposListReleaseAssets: ReposListReleaseAssets
  reposUploadReleaseAsset: ReposUploadReleaseAsset
  reactionsListForRelease: ReactionsListForRelease
  reactionsCreateForRelease: ReactionsCreateForRelease
  reactionsDeleteForRelease: ReactionsDeleteForRelease
  secretScanningListAlertsForRepo: SecretScanningListAlertsForRepo
  secretScanningGetAlert: SecretScanningGetAlert
  secretScanningUpdateAlert: SecretScanningUpdateAlert
  secretScanningListLocationsForAlert: SecretScanningListLocationsForAlert
  activityListStargazersForRepo: ActivityListStargazersForRepo
  reposGetCodeFrequencyStats: ReposGetCodeFrequencyStats
  reposGetCommitActivityStats: ReposGetCommitActivityStats
  reposGetContributorsStats: ReposGetContributorsStats
  reposGetParticipationStats: ReposGetParticipationStats
  reposGetPunchCardStats: ReposGetPunchCardStats
  reposCreateCommitStatus: ReposCreateCommitStatus
  activityListWatchersForRepo: ActivityListWatchersForRepo
  activityGetRepoSubscription: ActivityGetRepoSubscription
  activitySetRepoSubscription: ActivitySetRepoSubscription
  activityDeleteRepoSubscription: ActivityDeleteRepoSubscription
  reposListTags: ReposListTags
  reposListTagProtection: ReposListTagProtection
  reposCreateTagProtection: ReposCreateTagProtection
  reposDeleteTagProtection: ReposDeleteTagProtection
  reposDownloadTarballArchive: ReposDownloadTarballArchive
  reposListTeams: ReposListTeams
  reposGetAllTopics: ReposGetAllTopics
  reposReplaceAllTopics: ReposReplaceAllTopics
  reposGetClones: ReposGetClones
  reposGetTopPaths: ReposGetTopPaths
  reposGetTopReferrers: ReposGetTopReferrers
  reposGetViews: ReposGetViews
  reposTransfer: ReposTransfer
  reposCheckVulnerabilityAlerts: ReposCheckVulnerabilityAlerts
  reposEnableVulnerabilityAlerts: ReposEnableVulnerabilityAlerts
  reposDisableVulnerabilityAlerts: ReposDisableVulnerabilityAlerts
  reposDownloadZipballArchive: ReposDownloadZipballArchive
  reposCreateUsingTemplate: ReposCreateUsingTemplate
  reposListPublic: ReposListPublic
  actionsListEnvironmentSecrets: ActionsListEnvironmentSecrets
  actionsGetEnvironmentPublicKey: ActionsGetEnvironmentPublicKey
  actionsGetEnvironmentSecret: ActionsGetEnvironmentSecret
  actionsCreateOrUpdateEnvironmentSecret: ActionsCreateOrUpdateEnvironmentSecret
  actionsDeleteEnvironmentSecret: ActionsDeleteEnvironmentSecret
  actionsListEnvironmentVariables: ActionsListEnvironmentVariables
  actionsCreateEnvironmentVariable: ActionsCreateEnvironmentVariable
  actionsGetEnvironmentVariable: ActionsGetEnvironmentVariable
  actionsUpdateEnvironmentVariable: ActionsUpdateEnvironmentVariable
  actionsDeleteEnvironmentVariable: ActionsDeleteEnvironmentVariable
  searchCode: SearchCode
  searchCommits: SearchCommits
  searchIssuesAndPullRequests: SearchIssuesAndPullRequests
  searchLabels: SearchLabels
  searchRepos: SearchRepos
  searchTopics: SearchTopics
  searchUsers: SearchUsers
  teamsGetLegacy: TeamsGetLegacy
  teamsUpdateLegacy: TeamsUpdateLegacy
  teamsDeleteLegacy: TeamsDeleteLegacy
  teamsListDiscussionsLegacy: TeamsListDiscussionsLegacy
  teamsCreateDiscussionLegacy: TeamsCreateDiscussionLegacy
  teamsGetDiscussionLegacy: TeamsGetDiscussionLegacy
  teamsUpdateDiscussionLegacy: TeamsUpdateDiscussionLegacy
  teamsDeleteDiscussionLegacy: TeamsDeleteDiscussionLegacy
  teamsListDiscussionCommentsLegacy: TeamsListDiscussionCommentsLegacy
  teamsCreateDiscussionCommentLegacy: TeamsCreateDiscussionCommentLegacy
  teamsGetDiscussionCommentLegacy: TeamsGetDiscussionCommentLegacy
  teamsUpdateDiscussionCommentLegacy: TeamsUpdateDiscussionCommentLegacy
  teamsDeleteDiscussionCommentLegacy: TeamsDeleteDiscussionCommentLegacy
  reactionsListForTeamDiscussionCommentLegacy: ReactionsListForTeamDiscussionCommentLegacy
  reactionsCreateForTeamDiscussionCommentLegacy: ReactionsCreateForTeamDiscussionCommentLegacy
  reactionsListForTeamDiscussionLegacy: ReactionsListForTeamDiscussionLegacy
  reactionsCreateForTeamDiscussionLegacy: ReactionsCreateForTeamDiscussionLegacy
  teamsListPendingInvitationsLegacy: TeamsListPendingInvitationsLegacy
  teamsListMembersLegacy: TeamsListMembersLegacy
  teamsGetMemberLegacy: TeamsGetMemberLegacy
  teamsAddMemberLegacy: TeamsAddMemberLegacy
  teamsRemoveMemberLegacy: TeamsRemoveMemberLegacy
  teamsGetMembershipForUserLegacy: TeamsGetMembershipForUserLegacy
  teamsAddOrUpdateMembershipForUserLegacy: TeamsAddOrUpdateMembershipForUserLegacy
  teamsRemoveMembershipForUserLegacy: TeamsRemoveMembershipForUserLegacy
  teamsListProjectsLegacy: TeamsListProjectsLegacy
  teamsCheckPermissionsForProjectLegacy: TeamsCheckPermissionsForProjectLegacy
  teamsAddOrUpdateProjectPermissionsLegacy: TeamsAddOrUpdateProjectPermissionsLegacy
  teamsRemoveProjectLegacy: TeamsRemoveProjectLegacy
  teamsListReposLegacy: TeamsListReposLegacy
  teamsCheckPermissionsForRepoLegacy: TeamsCheckPermissionsForRepoLegacy
  teamsAddOrUpdateRepoPermissionsLegacy: TeamsAddOrUpdateRepoPermissionsLegacy
  teamsRemoveRepoLegacy: TeamsRemoveRepoLegacy
  teamsListChildLegacy: TeamsListChildLegacy
  usersGetAuthenticated: UsersGetAuthenticated
  usersUpdateAuthenticated: UsersUpdateAuthenticated
  usersListBlockedByAuthenticatedUser: UsersListBlockedByAuthenticatedUser
  usersCheckBlocked: UsersCheckBlocked
  usersBlock: UsersBlock
  usersUnblock: UsersUnblock
  codespacesListForAuthenticatedUser: CodespacesListForAuthenticatedUser
  codespacesCreateForAuthenticatedUser: CodespacesCreateForAuthenticatedUser
  codespacesListSecretsForAuthenticatedUser: CodespacesListSecretsForAuthenticatedUser
  codespacesGetPublicKeyForAuthenticatedUser: CodespacesGetPublicKeyForAuthenticatedUser
  codespacesGetSecretForAuthenticatedUser: CodespacesGetSecretForAuthenticatedUser
  codespacesCreateOrUpdateSecretForAuthenticatedUser: CodespacesCreateOrUpdateSecretForAuthenticatedUser
  codespacesDeleteSecretForAuthenticatedUser: CodespacesDeleteSecretForAuthenticatedUser
  codespacesListRepositoriesForSecretForAuthenticatedUser: CodespacesListRepositoriesForSecretForAuthenticatedUser
  codespacesSetRepositoriesForSecretForAuthenticatedUser: CodespacesSetRepositoriesForSecretForAuthenticatedUser
  codespacesAddRepositoryForSecretForAuthenticatedUser: CodespacesAddRepositoryForSecretForAuthenticatedUser
  codespacesRemoveRepositoryForSecretForAuthenticatedUser: CodespacesRemoveRepositoryForSecretForAuthenticatedUser
  codespacesGetForAuthenticatedUser: CodespacesGetForAuthenticatedUser
  codespacesUpdateForAuthenticatedUser: CodespacesUpdateForAuthenticatedUser
  codespacesDeleteForAuthenticatedUser: CodespacesDeleteForAuthenticatedUser
  codespacesExportForAuthenticatedUser: CodespacesExportForAuthenticatedUser
  codespacesGetExportDetailsForAuthenticatedUser: CodespacesGetExportDetailsForAuthenticatedUser
  codespacesCodespaceMachinesForAuthenticatedUser: CodespacesCodespaceMachinesForAuthenticatedUser
  codespacesPublishForAuthenticatedUser: CodespacesPublishForAuthenticatedUser
  codespacesStartForAuthenticatedUser: CodespacesStartForAuthenticatedUser
  codespacesStopForAuthenticatedUser: CodespacesStopForAuthenticatedUser
  usersSetPrimaryEmailVisibilityForAuthenticatedUser: UsersSetPrimaryEmailVisibilityForAuthenticatedUser
  usersListEmailsForAuthenticatedUser: UsersListEmailsForAuthenticatedUser
  usersAddEmailForAuthenticatedUser: UsersAddEmailForAuthenticatedUser
  usersDeleteEmailForAuthenticatedUser: UsersDeleteEmailForAuthenticatedUser
  usersListFollowersForAuthenticatedUser: UsersListFollowersForAuthenticatedUser
  usersListFollowedByAuthenticatedUser: UsersListFollowedByAuthenticatedUser
  usersCheckPersonIsFollowedByAuthenticated: UsersCheckPersonIsFollowedByAuthenticated
  usersFollow: UsersFollow
  usersUnfollow: UsersUnfollow
  usersListGpgKeysForAuthenticatedUser: UsersListGpgKeysForAuthenticatedUser
  usersCreateGpgKeyForAuthenticatedUser: UsersCreateGpgKeyForAuthenticatedUser
  usersGetGpgKeyForAuthenticatedUser: UsersGetGpgKeyForAuthenticatedUser
  usersDeleteGpgKeyForAuthenticatedUser: UsersDeleteGpgKeyForAuthenticatedUser
  appsListInstallationsForAuthenticatedUser: AppsListInstallationsForAuthenticatedUser
  appsListInstallationReposForAuthenticatedUser: AppsListInstallationReposForAuthenticatedUser
  appsAddRepoToInstallationForAuthenticatedUser: AppsAddRepoToInstallationForAuthenticatedUser
  appsRemoveRepoFromInstallationForAuthenticatedUser: AppsRemoveRepoFromInstallationForAuthenticatedUser
  interactionsGetRestrictionsForAuthenticatedUser: InteractionsGetRestrictionsForAuthenticatedUser
  interactionsSetRestrictionsForAuthenticatedUser: InteractionsSetRestrictionsForAuthenticatedUser
  interactionsRemoveRestrictionsForAuthenticatedUser: InteractionsRemoveRestrictionsForAuthenticatedUser
  issuesListForAuthenticatedUser: IssuesListForAuthenticatedUser
  usersListPublicSshKeysForAuthenticatedUser: UsersListPublicSshKeysForAuthenticatedUser
  usersCreatePublicSshKeyForAuthenticatedUser: UsersCreatePublicSshKeyForAuthenticatedUser
  usersGetPublicSshKeyForAuthenticatedUser: UsersGetPublicSshKeyForAuthenticatedUser
  usersDeletePublicSshKeyForAuthenticatedUser: UsersDeletePublicSshKeyForAuthenticatedUser
  appsListSubscriptionsForAuthenticatedUser: AppsListSubscriptionsForAuthenticatedUser
  appsListSubscriptionsForAuthenticatedUserStubbed: AppsListSubscriptionsForAuthenticatedUserStubbed
  orgsListMembershipsForAuthenticatedUser: OrgsListMembershipsForAuthenticatedUser
  orgsGetMembershipForAuthenticatedUser: OrgsGetMembershipForAuthenticatedUser
  orgsUpdateMembershipForAuthenticatedUser: OrgsUpdateMembershipForAuthenticatedUser
  migrationsListForAuthenticatedUser: MigrationsListForAuthenticatedUser
  migrationsStartForAuthenticatedUser: MigrationsStartForAuthenticatedUser
  migrationsGetStatusForAuthenticatedUser: MigrationsGetStatusForAuthenticatedUser
  migrationsGetArchiveForAuthenticatedUser: MigrationsGetArchiveForAuthenticatedUser
  migrationsDeleteArchiveForAuthenticatedUser: MigrationsDeleteArchiveForAuthenticatedUser
  migrationsUnlockRepoForAuthenticatedUser: MigrationsUnlockRepoForAuthenticatedUser
  migrationsListReposForAuthenticatedUser: MigrationsListReposForAuthenticatedUser
  orgsListForAuthenticatedUser: OrgsListForAuthenticatedUser
  packagesListPackagesForAuthenticatedUser: PackagesListPackagesForAuthenticatedUser
  packagesGetPackageForAuthenticatedUser: PackagesGetPackageForAuthenticatedUser
  packagesDeletePackageForAuthenticatedUser: PackagesDeletePackageForAuthenticatedUser
  packagesRestorePackageForAuthenticatedUser: PackagesRestorePackageForAuthenticatedUser
  packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser
  packagesGetPackageVersionForAuthenticatedUser: PackagesGetPackageVersionForAuthenticatedUser
  packagesDeletePackageVersionForAuthenticatedUser: PackagesDeletePackageVersionForAuthenticatedUser
  packagesRestorePackageVersionForAuthenticatedUser: PackagesRestorePackageVersionForAuthenticatedUser
  projectsCreateForAuthenticatedUser: ProjectsCreateForAuthenticatedUser
  usersListPublicEmailsForAuthenticatedUser: UsersListPublicEmailsForAuthenticatedUser
  reposListForAuthenticatedUser: ReposListForAuthenticatedUser
  reposCreateForAuthenticatedUser: ReposCreateForAuthenticatedUser
  reposListInvitationsForAuthenticatedUser: ReposListInvitationsForAuthenticatedUser
  reposAcceptInvitationForAuthenticatedUser: ReposAcceptInvitationForAuthenticatedUser
  reposDeclineInvitationForAuthenticatedUser: ReposDeclineInvitationForAuthenticatedUser
  usersListSshSigningKeysForAuthenticatedUser: UsersListSshSigningKeysForAuthenticatedUser
  usersCreateSshSigningKeyForAuthenticatedUser: UsersCreateSshSigningKeyForAuthenticatedUser
  usersGetSshSigningKeyForAuthenticatedUser: UsersGetSshSigningKeyForAuthenticatedUser
  usersDeleteSshSigningKeyForAuthenticatedUser: UsersDeleteSshSigningKeyForAuthenticatedUser
  activityListReposStarredByAuthenticatedUser: ActivityListReposStarredByAuthenticatedUser
  activityCheckRepoIsStarredByAuthenticatedUser: ActivityCheckRepoIsStarredByAuthenticatedUser
  activityStarRepoForAuthenticatedUser: ActivityStarRepoForAuthenticatedUser
  activityUnstarRepoForAuthenticatedUser: ActivityUnstarRepoForAuthenticatedUser
  activityListWatchedReposForAuthenticatedUser: ActivityListWatchedReposForAuthenticatedUser
  teamsListForAuthenticatedUser: TeamsListForAuthenticatedUser
  usersList: UsersList
  usersGetByUsername: UsersGetByUsername
  activityListEventsForAuthenticatedUser: ActivityListEventsForAuthenticatedUser
  activityListOrgEventsForAuthenticatedUser: ActivityListOrgEventsForAuthenticatedUser
  activityListPublicEventsForUser: ActivityListPublicEventsForUser
  usersListFollowersForUser: UsersListFollowersForUser
  usersListFollowingForUser: UsersListFollowingForUser
  usersCheckFollowingForUser: UsersCheckFollowingForUser
  gistsListForUser: GistsListForUser
  usersListGpgKeysForUser: UsersListGpgKeysForUser
  usersGetContextForUser: UsersGetContextForUser
  appsGetUserInstallation: AppsGetUserInstallation
  usersListPublicKeysForUser: UsersListPublicKeysForUser
  orgsListForUser: OrgsListForUser
  packagesListPackagesForUser: PackagesListPackagesForUser
  packagesGetPackageForUser: PackagesGetPackageForUser
  packagesDeletePackageForUser: PackagesDeletePackageForUser
  packagesRestorePackageForUser: PackagesRestorePackageForUser
  packagesGetAllPackageVersionsForPackageOwnedByUser: PackagesGetAllPackageVersionsForPackageOwnedByUser
  packagesGetPackageVersionForUser: PackagesGetPackageVersionForUser
  packagesDeletePackageVersionForUser: PackagesDeletePackageVersionForUser
  packagesRestorePackageVersionForUser: PackagesRestorePackageVersionForUser
  projectsListForUser: ProjectsListForUser
  activityListReceivedEventsForUser: ActivityListReceivedEventsForUser
  activityListReceivedPublicEventsForUser: ActivityListReceivedPublicEventsForUser
  reposListForUser: ReposListForUser
  billingGetGithubActionsBillingUser: BillingGetGithubActionsBillingUser
  billingGetGithubPackagesBillingUser: BillingGetGithubPackagesBillingUser
  billingGetSharedStorageBillingUser: BillingGetSharedStorageBillingUser
  usersListSshSigningKeysForUser: UsersListSshSigningKeysForUser
  activityListReposStarredByUser: ActivityListReposStarredByUser
  activityListReposWatchedByUser: ActivityListReposWatchedByUser
  metaGetAllVersions: MetaGetAllVersions
  metaGetZen: MetaGetZen
}

export function bootstrap(
  implementation: Implementation,
  config: Omit<ServerConfig, "router">
) {
  // ApiClient
  const router = new KoaRouter()

  router.get(
    "metaRoot",
    "/",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.metaRoot(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "appsGetAuthenticated",
    "/app",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.appsGetAuthenticated(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsCreateFromManifestParamSchema = z.object({
    code: z.coerce.string(),
  })

  router.post(
    "appsCreateFromManifest",
    "/app-manifests/:code/conversions",
    paramValidationFactory<t_AppsCreateFromManifestParamSchema>(
      appsCreateFromManifestParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsCreateFromManifestParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsCreateFromManifest(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "appsGetWebhookConfigForApp",
    "/app/hook/config",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.appsGetWebhookConfigForApp(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsUpdateWebhookConfigForAppBodySchema = z.object({
    url: z.coerce.string().optional(),
    content_type: z.coerce.string().optional(),
    secret: z.coerce.string().optional(),
    insecure_ssl: z.union([z.coerce.string(), z.coerce.number()]),
  })

  router.patch(
    "appsUpdateWebhookConfigForApp",
    "/app/hook/config",
    bodyValidationFactory<t_AppsUpdateWebhookConfigForAppBodySchema>(
      appsUpdateWebhookConfigForAppBodySchema
    ),
    async (
      ctx: ValidatedCtx<void, void, t_AppsUpdateWebhookConfigForAppBodySchema>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsUpdateWebhookConfigForApp(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    cursor: z.coerce.string().optional(),
    redelivery: z.coerce.boolean().optional(),
  })

  router.get(
    "appsListWebhookDeliveries",
    "/app/hook/deliveries",
    queryValidationFactory<t_AppsListWebhookDeliveriesQuerySchema>(
      appsListWebhookDeliveriesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_AppsListWebhookDeliveriesQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsListWebhookDeliveries(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetWebhookDeliveryParamSchema = z.object({
    delivery_id: z.coerce.number(),
  })

  router.get(
    "appsGetWebhookDelivery",
    "/app/hook/deliveries/:deliveryId",
    paramValidationFactory<t_AppsGetWebhookDeliveryParamSchema>(
      appsGetWebhookDeliveryParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsGetWebhookDeliveryParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsGetWebhookDelivery(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsRedeliverWebhookDeliveryParamSchema = z.object({
    delivery_id: z.coerce.number(),
  })

  router.post(
    "appsRedeliverWebhookDelivery",
    "/app/hook/deliveries/:deliveryId/attempts",
    paramValidationFactory<t_AppsRedeliverWebhookDeliveryParamSchema>(
      appsRedeliverWebhookDeliveryParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsRedeliverWebhookDeliveryParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsRedeliverWebhookDelivery(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListInstallationsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    outdated: z.coerce.string().optional(),
  })

  router.get(
    "appsListInstallations",
    "/app/installations",
    queryValidationFactory<t_AppsListInstallationsQuerySchema>(
      appsListInstallationsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_AppsListInstallationsQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsListInstallations(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.get(
    "appsGetInstallation",
    "/app/installations/:installationId",
    paramValidationFactory<t_AppsGetInstallationParamSchema>(
      appsGetInstallationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsGetInstallationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsGetInstallation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsDeleteInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.delete(
    "appsDeleteInstallation",
    "/app/installations/:installationId",
    paramValidationFactory<t_AppsDeleteInstallationParamSchema>(
      appsDeleteInstallationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsDeleteInstallationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsDeleteInstallation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsCreateInstallationAccessTokenParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsCreateInstallationAccessTokenBodySchema = z
    .object({
      repositories: z.array(z.coerce.string()).optional(),
      repository_ids: z.array(z.coerce.number()).optional(),
      permissions: z
        .object({
          actions: z.enum(["read", "write"]).optional(),
          administration: z.enum(["read", "write"]).optional(),
          checks: z.enum(["read", "write"]).optional(),
          contents: z.enum(["read", "write"]).optional(),
          deployments: z.enum(["read", "write"]).optional(),
          environments: z.enum(["read", "write"]).optional(),
          issues: z.enum(["read", "write"]).optional(),
          metadata: z.enum(["read", "write"]).optional(),
          packages: z.enum(["read", "write"]).optional(),
          pages: z.enum(["read", "write"]).optional(),
          pull_requests: z.enum(["read", "write"]).optional(),
          repository_announcement_banners: z.enum(["read", "write"]).optional(),
          repository_hooks: z.enum(["read", "write"]).optional(),
          repository_projects: z.enum(["read", "write", "admin"]).optional(),
          secret_scanning_alerts: z.enum(["read", "write"]).optional(),
          secrets: z.enum(["read", "write"]).optional(),
          security_events: z.enum(["read", "write"]).optional(),
          single_file: z.enum(["read", "write"]).optional(),
          statuses: z.enum(["read", "write"]).optional(),
          vulnerability_alerts: z.enum(["read", "write"]).optional(),
          workflows: z.enum(["write"]).optional(),
          members: z.enum(["read", "write"]).optional(),
          organization_administration: z.enum(["read", "write"]).optional(),
          organization_custom_roles: z.enum(["read", "write"]).optional(),
          organization_announcement_banners: z
            .enum(["read", "write"])
            .optional(),
          organization_hooks: z.enum(["read", "write"]).optional(),
          organization_plan: z.enum(["read"]).optional(),
          organization_projects: z.enum(["read", "write", "admin"]).optional(),
          organization_packages: z.enum(["read", "write"]).optional(),
          organization_secrets: z.enum(["read", "write"]).optional(),
          organization_self_hosted_runners: z
            .enum(["read", "write"])
            .optional(),
          organization_user_blocking: z.enum(["read", "write"]).optional(),
          team_discussions: z.enum(["read", "write"]).optional(),
        })
        .optional(),
    })
    .optional()

  router.post(
    "appsCreateInstallationAccessToken",
    "/app/installations/:installationId/access_tokens",
    paramValidationFactory<t_AppsCreateInstallationAccessTokenParamSchema>(
      appsCreateInstallationAccessTokenParamSchema
    ),
    bodyValidationFactory<t_AppsCreateInstallationAccessTokenBodySchema>(
      appsCreateInstallationAccessTokenBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsCreateInstallationAccessTokenParamSchema,
        void,
        t_AppsCreateInstallationAccessTokenBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsCreateInstallationAccessToken(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsSuspendInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.put(
    "appsSuspendInstallation",
    "/app/installations/:installationId/suspended",
    paramValidationFactory<t_AppsSuspendInstallationParamSchema>(
      appsSuspendInstallationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsSuspendInstallationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsSuspendInstallation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsUnsuspendInstallationParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  router.delete(
    "appsUnsuspendInstallation",
    "/app/installations/:installationId/suspended",
    paramValidationFactory<t_AppsUnsuspendInstallationParamSchema>(
      appsUnsuspendInstallationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsUnsuspendInstallationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsUnsuspendInstallation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsDeleteAuthorizationParamSchema = z.object({
    client_id: z.coerce.string(),
  })

  const appsDeleteAuthorizationBodySchema = z.object({
    access_token: z.coerce.string(),
  })

  router.delete(
    "appsDeleteAuthorization",
    "/applications/:clientId/grant",
    paramValidationFactory<t_AppsDeleteAuthorizationParamSchema>(
      appsDeleteAuthorizationParamSchema
    ),
    bodyValidationFactory<t_AppsDeleteAuthorizationBodySchema>(
      appsDeleteAuthorizationBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsDeleteAuthorizationParamSchema,
        void,
        t_AppsDeleteAuthorizationBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.appsDeleteAuthorization(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsCheckTokenParamSchema = z.object({ client_id: z.coerce.string() })

  const appsCheckTokenBodySchema = z.object({ access_token: z.coerce.string() })

  router.post(
    "appsCheckToken",
    "/applications/:clientId/token",
    paramValidationFactory<t_AppsCheckTokenParamSchema>(
      appsCheckTokenParamSchema
    ),
    bodyValidationFactory<t_AppsCheckTokenBodySchema>(appsCheckTokenBodySchema),
    async (
      ctx: ValidatedCtx<
        t_AppsCheckTokenParamSchema,
        void,
        t_AppsCheckTokenBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.appsCheckToken(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsResetTokenParamSchema = z.object({ client_id: z.coerce.string() })

  const appsResetTokenBodySchema = z.object({ access_token: z.coerce.string() })

  router.patch(
    "appsResetToken",
    "/applications/:clientId/token",
    paramValidationFactory<t_AppsResetTokenParamSchema>(
      appsResetTokenParamSchema
    ),
    bodyValidationFactory<t_AppsResetTokenBodySchema>(appsResetTokenBodySchema),
    async (
      ctx: ValidatedCtx<
        t_AppsResetTokenParamSchema,
        void,
        t_AppsResetTokenBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.appsResetToken(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsDeleteTokenParamSchema = z.object({ client_id: z.coerce.string() })

  const appsDeleteTokenBodySchema = z.object({
    access_token: z.coerce.string(),
  })

  router.delete(
    "appsDeleteToken",
    "/applications/:clientId/token",
    paramValidationFactory<t_AppsDeleteTokenParamSchema>(
      appsDeleteTokenParamSchema
    ),
    bodyValidationFactory<t_AppsDeleteTokenBodySchema>(
      appsDeleteTokenBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsDeleteTokenParamSchema,
        void,
        t_AppsDeleteTokenBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.appsDeleteToken(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsScopeTokenParamSchema = z.object({ client_id: z.coerce.string() })

  const appsScopeTokenBodySchema = z.object({
    access_token: z.coerce.string(),
    target: z.coerce.string().optional(),
    target_id: z.coerce.number().optional(),
    repositories: z.array(z.coerce.string()).optional(),
    repository_ids: z.array(z.coerce.number()).optional(),
    permissions: z
      .object({
        actions: z.enum(["read", "write"]).optional(),
        administration: z.enum(["read", "write"]).optional(),
        checks: z.enum(["read", "write"]).optional(),
        contents: z.enum(["read", "write"]).optional(),
        deployments: z.enum(["read", "write"]).optional(),
        environments: z.enum(["read", "write"]).optional(),
        issues: z.enum(["read", "write"]).optional(),
        metadata: z.enum(["read", "write"]).optional(),
        packages: z.enum(["read", "write"]).optional(),
        pages: z.enum(["read", "write"]).optional(),
        pull_requests: z.enum(["read", "write"]).optional(),
        repository_announcement_banners: z.enum(["read", "write"]).optional(),
        repository_hooks: z.enum(["read", "write"]).optional(),
        repository_projects: z.enum(["read", "write", "admin"]).optional(),
        secret_scanning_alerts: z.enum(["read", "write"]).optional(),
        secrets: z.enum(["read", "write"]).optional(),
        security_events: z.enum(["read", "write"]).optional(),
        single_file: z.enum(["read", "write"]).optional(),
        statuses: z.enum(["read", "write"]).optional(),
        vulnerability_alerts: z.enum(["read", "write"]).optional(),
        workflows: z.enum(["write"]).optional(),
        members: z.enum(["read", "write"]).optional(),
        organization_administration: z.enum(["read", "write"]).optional(),
        organization_custom_roles: z.enum(["read", "write"]).optional(),
        organization_announcement_banners: z.enum(["read", "write"]).optional(),
        organization_hooks: z.enum(["read", "write"]).optional(),
        organization_plan: z.enum(["read"]).optional(),
        organization_projects: z.enum(["read", "write", "admin"]).optional(),
        organization_packages: z.enum(["read", "write"]).optional(),
        organization_secrets: z.enum(["read", "write"]).optional(),
        organization_self_hosted_runners: z.enum(["read", "write"]).optional(),
        organization_user_blocking: z.enum(["read", "write"]).optional(),
        team_discussions: z.enum(["read", "write"]).optional(),
      })
      .optional(),
  })

  router.post(
    "appsScopeToken",
    "/applications/:clientId/token/scoped",
    paramValidationFactory<t_AppsScopeTokenParamSchema>(
      appsScopeTokenParamSchema
    ),
    bodyValidationFactory<t_AppsScopeTokenBodySchema>(appsScopeTokenBodySchema),
    async (
      ctx: ValidatedCtx<
        t_AppsScopeTokenParamSchema,
        void,
        t_AppsScopeTokenBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.appsScopeToken(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetBySlugParamSchema = z.object({ app_slug: z.coerce.string() })

  router.get(
    "appsGetBySlug",
    "/apps/:appSlug",
    paramValidationFactory<t_AppsGetBySlugParamSchema>(
      appsGetBySlugParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsGetBySlugParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsGetBySlug(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "codesOfConductGetAllCodesOfConduct",
    "/codes_of_conduct",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } =
        await implementation.codesOfConductGetAllCodesOfConduct(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codesOfConductGetConductCodeParamSchema = z.object({
    key: z.coerce.string(),
  })

  router.get(
    "codesOfConductGetConductCode",
    "/codes_of_conduct/:key",
    paramValidationFactory<t_CodesOfConductGetConductCodeParamSchema>(
      codesOfConductGetConductCodeParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodesOfConductGetConductCodeParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codesOfConductGetConductCode(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "emojisGet",
    "/emojis",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.emojisGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string(), org_id: z.coerce.number() })

  router.put(
    "enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
    "/enterprises/:enterprise/actions/permissions/organizations/:orgId",
    paramValidationFactory<t_EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParamSchema>(
      enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string() })

  const enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseQuerySchema =
    z.object({
      per_page: z.coerce.number().optional(),
      page: z.coerce.number().optional(),
      visible_to_organization: z.coerce.string().optional(),
    })

  router.get(
    "enterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
    "/enterprises/:enterprise/actions/runner-groups",
    paramValidationFactory<t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParamSchema>(
      enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParamSchema
    ),
    queryValidationFactory<t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseQuerySchema>(
      enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParamSchema,
        t_EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminListSelfHostedRunnerGroupsForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string() })

  const enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseBodySchema =
    z.object({
      name: z.coerce.string(),
      visibility: z.enum(["selected", "all"]).optional(),
      selected_organization_ids: z.array(z.coerce.number()).optional(),
      runners: z.array(z.coerce.number()).optional(),
      allows_public_repositories: z.coerce.boolean().optional(),
      restricted_to_workflows: z.coerce.boolean().optional(),
      selected_workflows: z.array(z.coerce.string()).optional(),
    })

  router.post(
    "enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
    "/enterprises/:enterprise/actions/runner-groups",
    paramValidationFactory<t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParamSchema>(
      enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParamSchema
    ),
    bodyValidationFactory<t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseBodySchema>(
      enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParamSchema,
        void,
        t_EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParamSchema =
    z.object({
      enterprise: z.coerce.string(),
      runner_group_id: z.coerce.number(),
    })

  router.get(
    "enterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
    "/enterprises/:enterprise/actions/runner-groups/:runnerGroupId",
    paramValidationFactory<t_EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParamSchema>(
      enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminGetSelfHostedRunnerGroupForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParamSchema =
    z.object({
      enterprise: z.coerce.string(),
      runner_group_id: z.coerce.number(),
      org_id: z.coerce.number(),
    })

  router.put(
    "enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
    "/enterprises/:enterprise/actions/runner-groups/:runnerGroupId/organizations/:orgId",
    paramValidationFactory<t_EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParamSchema>(
      enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParamSchema =
    z.object({
      enterprise: z.coerce.string(),
      runner_group_id: z.coerce.number(),
      runner_id: z.coerce.number(),
    })

  router.delete(
    "enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
    "/enterprises/:enterprise/actions/runner-groups/:runnerGroupId/runners/:runnerId",
    paramValidationFactory<t_EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParamSchema>(
      enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string(), runner_id: z.coerce.number() })

  router.delete(
    "enterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
    "/enterprises/:enterprise/actions/runners/:runnerId",
    paramValidationFactory<t_EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParamSchema>(
      enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminDeleteSelfHostedRunnerFromEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string(), runner_id: z.coerce.number() })

  router.get(
    "enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise",
    "/enterprises/:enterprise/actions/runners/:runnerId/labels",
    paramValidationFactory<t_EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseParamSchema>(
      enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string(), runner_id: z.coerce.number() })

  const enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseBodySchema =
    z.object({ labels: z.array(z.coerce.string()) })

  router.post(
    "enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise",
    "/enterprises/:enterprise/actions/runners/:runnerId/labels",
    paramValidationFactory<t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseParamSchema>(
      enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseParamSchema
    ),
    bodyValidationFactory<t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseBodySchema>(
      enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseParamSchema,
        void,
        t_EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningGetSecurityAnalysisSettingsForEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string() })

  router.get(
    "secretScanningGetSecurityAnalysisSettingsForEnterprise",
    "/enterprises/:enterprise/code_security_and_analysis",
    paramValidationFactory<t_SecretScanningGetSecurityAnalysisSettingsForEnterpriseParamSchema>(
      secretScanningGetSecurityAnalysisSettingsForEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningGetSecurityAnalysisSettingsForEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.secretScanningGetSecurityAnalysisSettingsForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningPatchSecurityAnalysisSettingsForEnterpriseParamSchema =
    z.object({ enterprise: z.coerce.string() })

  const secretScanningPatchSecurityAnalysisSettingsForEnterpriseBodySchema = z
    .object({
      advanced_security_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      secret_scanning_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      secret_scanning_push_protection_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      secret_scanning_push_protection_custom_link: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "secretScanningPatchSecurityAnalysisSettingsForEnterprise",
    "/enterprises/:enterprise/code_security_and_analysis",
    paramValidationFactory<t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseParamSchema>(
      secretScanningPatchSecurityAnalysisSettingsForEnterpriseParamSchema
    ),
    bodyValidationFactory<t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseBodySchema>(
      secretScanningPatchSecurityAnalysisSettingsForEnterpriseBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseParamSchema,
        void,
        t_SecretScanningPatchSecurityAnalysisSettingsForEnterpriseBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.secretScanningPatchSecurityAnalysisSettingsForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotListAlertsForEnterpriseParamSchema = z.object({
    enterprise: z.coerce.string(),
  })

  const dependabotListAlertsForEnterpriseQuerySchema = z.object({
    state: z.coerce.string().optional(),
    severity: z.coerce.string().optional(),
    ecosystem: z.coerce.string().optional(),
    package: z.coerce.string().optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    before: z.coerce.string().optional(),
    after: z.coerce.string().optional(),
    first: z.coerce.number().optional(),
    last: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "dependabotListAlertsForEnterprise",
    "/enterprises/:enterprise/dependabot/alerts",
    paramValidationFactory<t_DependabotListAlertsForEnterpriseParamSchema>(
      dependabotListAlertsForEnterpriseParamSchema
    ),
    queryValidationFactory<t_DependabotListAlertsForEnterpriseQuerySchema>(
      dependabotListAlertsForEnterpriseQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotListAlertsForEnterpriseParamSchema,
        t_DependabotListAlertsForEnterpriseQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependabotListAlertsForEnterprise(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningListAlertsForEnterpriseParamSchema = z.object({
    enterprise: z.coerce.string(),
  })

  const secretScanningListAlertsForEnterpriseQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.coerce.string().optional(),
    resolution: z.coerce.string().optional(),
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    before: z.coerce.string().optional(),
    after: z.coerce.string().optional(),
  })

  router.get(
    "secretScanningListAlertsForEnterprise",
    "/enterprises/:enterprise/secret-scanning/alerts",
    paramValidationFactory<t_SecretScanningListAlertsForEnterpriseParamSchema>(
      secretScanningListAlertsForEnterpriseParamSchema
    ),
    queryValidationFactory<t_SecretScanningListAlertsForEnterpriseQuerySchema>(
      secretScanningListAlertsForEnterpriseQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningListAlertsForEnterpriseParamSchema,
        t_SecretScanningListAlertsForEnterpriseQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.secretScanningListAlertsForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningPostSecurityProductEnablementForEnterpriseParamSchema =
    z.object({
      enterprise: z.coerce.string(),
      security_product: z.enum([
        "advanced_security",
        "secret_scanning",
        "secret_scanning_push_protection",
      ]),
      enablement: z.enum(["enable_all", "disable_all"]),
    })

  router.post(
    "secretScanningPostSecurityProductEnablementForEnterprise",
    "/enterprises/:enterprise/:securityProduct/:enablement",
    paramValidationFactory<t_SecretScanningPostSecurityProductEnablementForEnterpriseParamSchema>(
      secretScanningPostSecurityProductEnablementForEnterpriseParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningPostSecurityProductEnablementForEnterpriseParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.secretScanningPostSecurityProductEnablementForEnterprise(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListPublicEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListPublicEvents",
    "/events",
    queryValidationFactory<t_ActivityListPublicEventsQuerySchema>(
      activityListPublicEventsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_ActivityListPublicEventsQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.activityListPublicEvents(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "activityGetFeeds",
    "/feeds",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.activityGetFeeds(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsListQuerySchema = z.object({
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "gistsList",
    "/gists",
    queryValidationFactory<t_GistsListQuerySchema>(gistsListQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_GistsListQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsList(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsCreateBodySchema = z.object({
    description: z.coerce.string().optional(),
    files: z.object({}),
    public: z.union([z.coerce.boolean(), z.enum(["true", "false"])]),
  })

  router.post(
    "gistsCreate",
    "/gists",
    bodyValidationFactory<t_GistsCreateBodySchema>(gistsCreateBodySchema),
    async (
      ctx: ValidatedCtx<void, void, t_GistsCreateBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsCreate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsListPublicQuerySchema = z.object({
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "gistsListPublic",
    "/gists/public",
    queryValidationFactory<t_GistsListPublicQuerySchema>(
      gistsListPublicQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_GistsListPublicQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsListPublic(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsListStarredQuerySchema = z.object({
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "gistsListStarred",
    "/gists/starred",
    queryValidationFactory<t_GistsListStarredQuerySchema>(
      gistsListStarredQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_GistsListStarredQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsListStarred(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsGetParamSchema = z.object({ gist_id: z.coerce.string() })

  router.get(
    "gistsGet",
    "/gists/:gistId",
    paramValidationFactory<t_GistsGetParamSchema>(gistsGetParamSchema),
    async (
      ctx: ValidatedCtx<t_GistsGetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsUpdateParamSchema = z.object({ gist_id: z.coerce.string() })

  const gistsUpdateBodySchema = z.object({
    description: z.coerce.string().optional(),
    files: z.object({}).optional(),
  })

  router.patch(
    "gistsUpdate",
    "/gists/:gistId",
    paramValidationFactory<t_GistsUpdateParamSchema>(gistsUpdateParamSchema),
    bodyValidationFactory<t_GistsUpdateBodySchema>(gistsUpdateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_GistsUpdateParamSchema,
        void,
        t_GistsUpdateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsUpdate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsDeleteParamSchema = z.object({ gist_id: z.coerce.string() })

  router.delete(
    "gistsDelete",
    "/gists/:gistId",
    paramValidationFactory<t_GistsDeleteParamSchema>(gistsDeleteParamSchema),
    async (
      ctx: ValidatedCtx<t_GistsDeleteParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsDelete(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsListCommentsParamSchema = z.object({ gist_id: z.coerce.string() })

  const gistsListCommentsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "gistsListComments",
    "/gists/:gistId/comments",
    paramValidationFactory<t_GistsListCommentsParamSchema>(
      gistsListCommentsParamSchema
    ),
    queryValidationFactory<t_GistsListCommentsQuerySchema>(
      gistsListCommentsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_GistsListCommentsParamSchema,
        t_GistsListCommentsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsListComments(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsCreateCommentParamSchema = z.object({ gist_id: z.coerce.string() })

  const gistsCreateCommentBodySchema = z.object({ body: z.coerce.string() })

  router.post(
    "gistsCreateComment",
    "/gists/:gistId/comments",
    paramValidationFactory<t_GistsCreateCommentParamSchema>(
      gistsCreateCommentParamSchema
    ),
    bodyValidationFactory<t_GistsCreateCommentBodySchema>(
      gistsCreateCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_GistsCreateCommentParamSchema,
        void,
        t_GistsCreateCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsCreateComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsGetCommentParamSchema = z.object({
    gist_id: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "gistsGetComment",
    "/gists/:gistId/comments/:commentId",
    paramValidationFactory<t_GistsGetCommentParamSchema>(
      gistsGetCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_GistsGetCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsGetComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsUpdateCommentParamSchema = z.object({
    gist_id: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const gistsUpdateCommentBodySchema = z.object({ body: z.coerce.string() })

  router.patch(
    "gistsUpdateComment",
    "/gists/:gistId/comments/:commentId",
    paramValidationFactory<t_GistsUpdateCommentParamSchema>(
      gistsUpdateCommentParamSchema
    ),
    bodyValidationFactory<t_GistsUpdateCommentBodySchema>(
      gistsUpdateCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_GistsUpdateCommentParamSchema,
        void,
        t_GistsUpdateCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsUpdateComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsDeleteCommentParamSchema = z.object({
    gist_id: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "gistsDeleteComment",
    "/gists/:gistId/comments/:commentId",
    paramValidationFactory<t_GistsDeleteCommentParamSchema>(
      gistsDeleteCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_GistsDeleteCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsDeleteComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsListCommitsParamSchema = z.object({ gist_id: z.coerce.string() })

  const gistsListCommitsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "gistsListCommits",
    "/gists/:gistId/commits",
    paramValidationFactory<t_GistsListCommitsParamSchema>(
      gistsListCommitsParamSchema
    ),
    queryValidationFactory<t_GistsListCommitsQuerySchema>(
      gistsListCommitsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_GistsListCommitsParamSchema,
        t_GistsListCommitsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsListCommits(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsListForksParamSchema = z.object({ gist_id: z.coerce.string() })

  const gistsListForksQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "gistsListForks",
    "/gists/:gistId/forks",
    paramValidationFactory<t_GistsListForksParamSchema>(
      gistsListForksParamSchema
    ),
    queryValidationFactory<t_GistsListForksQuerySchema>(
      gistsListForksQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_GistsListForksParamSchema,
        t_GistsListForksQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsListForks(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsForkParamSchema = z.object({ gist_id: z.coerce.string() })

  router.post(
    "gistsFork",
    "/gists/:gistId/forks",
    paramValidationFactory<t_GistsForkParamSchema>(gistsForkParamSchema),
    async (
      ctx: ValidatedCtx<t_GistsForkParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsFork(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsCheckIsStarredParamSchema = z.object({
    gist_id: z.coerce.string(),
  })

  router.get(
    "gistsCheckIsStarred",
    "/gists/:gistId/star",
    paramValidationFactory<t_GistsCheckIsStarredParamSchema>(
      gistsCheckIsStarredParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_GistsCheckIsStarredParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsCheckIsStarred(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsStarParamSchema = z.object({ gist_id: z.coerce.string() })

  router.put(
    "gistsStar",
    "/gists/:gistId/star",
    paramValidationFactory<t_GistsStarParamSchema>(gistsStarParamSchema),
    async (
      ctx: ValidatedCtx<t_GistsStarParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsStar(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsUnstarParamSchema = z.object({ gist_id: z.coerce.string() })

  router.delete(
    "gistsUnstar",
    "/gists/:gistId/star",
    paramValidationFactory<t_GistsUnstarParamSchema>(gistsUnstarParamSchema),
    async (
      ctx: ValidatedCtx<t_GistsUnstarParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsUnstar(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsGetRevisionParamSchema = z.object({
    gist_id: z.coerce.string(),
    sha: z.coerce.string(),
  })

  router.get(
    "gistsGetRevision",
    "/gists/:gistId/:sha",
    paramValidationFactory<t_GistsGetRevisionParamSchema>(
      gistsGetRevisionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_GistsGetRevisionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsGetRevision(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "gitignoreGetAllTemplates",
    "/gitignore/templates",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.gitignoreGetAllTemplates(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitignoreGetTemplateParamSchema = z.object({ name: z.coerce.string() })

  router.get(
    "gitignoreGetTemplate",
    "/gitignore/templates/:name",
    paramValidationFactory<t_GitignoreGetTemplateParamSchema>(
      gitignoreGetTemplateParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_GitignoreGetTemplateParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitignoreGetTemplate(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListReposAccessibleToInstallationQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListReposAccessibleToInstallation",
    "/installation/repositories",
    queryValidationFactory<t_AppsListReposAccessibleToInstallationQuerySchema>(
      appsListReposAccessibleToInstallationQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_AppsListReposAccessibleToInstallationQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsListReposAccessibleToInstallation(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.delete(
    "appsRevokeInstallationAccessToken",
    "/installation/token",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } =
        await implementation.appsRevokeInstallationAccessToken(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional(),
    state: z.enum(["open", "closed", "all"]).optional(),
    labels: z.coerce.string().optional(),
    sort: z.enum(["created", "updated", "comments"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    collab: z.coerce.boolean().optional(),
    orgs: z.coerce.boolean().optional(),
    owned: z.coerce.boolean().optional(),
    pulls: z.coerce.boolean().optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesList",
    "/issues",
    queryValidationFactory<t_IssuesListQuerySchema>(issuesListQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_IssuesListQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesList(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const licensesGetAllCommonlyUsedQuerySchema = z.object({
    featured: z.coerce.boolean().optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "licensesGetAllCommonlyUsed",
    "/licenses",
    queryValidationFactory<t_LicensesGetAllCommonlyUsedQuerySchema>(
      licensesGetAllCommonlyUsedQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_LicensesGetAllCommonlyUsedQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.licensesGetAllCommonlyUsed(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const licensesGetParamSchema = z.object({ license: z.coerce.string() })

  router.get(
    "licensesGet",
    "/licenses/:license",
    paramValidationFactory<t_LicensesGetParamSchema>(licensesGetParamSchema),
    async (
      ctx: ValidatedCtx<t_LicensesGetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.licensesGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const markdownRenderBodySchema = z.object({
    text: z.coerce.string(),
    mode: z.enum(["markdown", "gfm"]).optional(),
    context: z.coerce.string().optional(),
  })

  router.post(
    "markdownRender",
    "/markdown",
    bodyValidationFactory<t_MarkdownRenderBodySchema>(markdownRenderBodySchema),
    async (
      ctx: ValidatedCtx<void, void, t_MarkdownRenderBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.markdownRender(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const markdownRenderRawBodySchema = z.coerce.string().optional()

  router.post(
    "markdownRenderRaw",
    "/markdown/raw",
    bodyValidationFactory<t_MarkdownRenderRawBodySchema>(
      markdownRenderRawBodySchema
    ),
    async (
      ctx: ValidatedCtx<void, void, t_MarkdownRenderRawBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.markdownRenderRaw(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetSubscriptionPlanForAccountParamSchema = z.object({
    account_id: z.coerce.number(),
  })

  router.get(
    "appsGetSubscriptionPlanForAccount",
    "/marketplace_listing/accounts/:accountId",
    paramValidationFactory<t_AppsGetSubscriptionPlanForAccountParamSchema>(
      appsGetSubscriptionPlanForAccountParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsGetSubscriptionPlanForAccountParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsGetSubscriptionPlanForAccount(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListPlansQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListPlans",
    "/marketplace_listing/plans",
    queryValidationFactory<t_AppsListPlansQuerySchema>(
      appsListPlansQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_AppsListPlansQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsListPlans(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListAccountsForPlanParamSchema = z.object({
    plan_id: z.coerce.number(),
  })

  const appsListAccountsForPlanQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListAccountsForPlan",
    "/marketplace_listing/plans/:planId/accounts",
    paramValidationFactory<t_AppsListAccountsForPlanParamSchema>(
      appsListAccountsForPlanParamSchema
    ),
    queryValidationFactory<t_AppsListAccountsForPlanQuerySchema>(
      appsListAccountsForPlanQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsListAccountsForPlanParamSchema,
        t_AppsListAccountsForPlanQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.appsListAccountsForPlan(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetSubscriptionPlanForAccountStubbedParamSchema = z.object({
    account_id: z.coerce.number(),
  })

  router.get(
    "appsGetSubscriptionPlanForAccountStubbed",
    "/marketplace_listing/stubbed/accounts/:accountId",
    paramValidationFactory<t_AppsGetSubscriptionPlanForAccountStubbedParamSchema>(
      appsGetSubscriptionPlanForAccountStubbedParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsGetSubscriptionPlanForAccountStubbedParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsGetSubscriptionPlanForAccountStubbed(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListPlansStubbedQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListPlansStubbed",
    "/marketplace_listing/stubbed/plans",
    queryValidationFactory<t_AppsListPlansStubbedQuerySchema>(
      appsListPlansStubbedQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_AppsListPlansStubbedQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsListPlansStubbed(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListAccountsForPlanStubbedParamSchema = z.object({
    plan_id: z.coerce.number(),
  })

  const appsListAccountsForPlanStubbedQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListAccountsForPlanStubbed",
    "/marketplace_listing/stubbed/plans/:planId/accounts",
    paramValidationFactory<t_AppsListAccountsForPlanStubbedParamSchema>(
      appsListAccountsForPlanStubbedParamSchema
    ),
    queryValidationFactory<t_AppsListAccountsForPlanStubbedQuerySchema>(
      appsListAccountsForPlanStubbedQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsListAccountsForPlanStubbedParamSchema,
        t_AppsListAccountsForPlanStubbedQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsListAccountsForPlanStubbed(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "metaGet",
    "/meta",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.metaGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListPublicEventsForRepoNetworkParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const activityListPublicEventsForRepoNetworkQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListPublicEventsForRepoNetwork",
    "/networks/:owner/:repo/events",
    paramValidationFactory<t_ActivityListPublicEventsForRepoNetworkParamSchema>(
      activityListPublicEventsForRepoNetworkParamSchema
    ),
    queryValidationFactory<t_ActivityListPublicEventsForRepoNetworkQuerySchema>(
      activityListPublicEventsForRepoNetworkQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListPublicEventsForRepoNetworkParamSchema,
        t_ActivityListPublicEventsForRepoNetworkQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListPublicEventsForRepoNetwork(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListNotificationsForAuthenticatedUserQuerySchema = z.object({
    all: z.coerce.boolean().optional(),
    participating: z.coerce.boolean().optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    before: z.coerce.string().datetime({ offset: true }).optional(),
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "activityListNotificationsForAuthenticatedUser",
    "/notifications",
    queryValidationFactory<t_ActivityListNotificationsForAuthenticatedUserQuerySchema>(
      activityListNotificationsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_ActivityListNotificationsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListNotificationsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityMarkNotificationsAsReadBodySchema = z
    .object({
      last_read_at: z.coerce.string().datetime({ offset: true }).optional(),
      read: z.coerce.boolean().optional(),
    })
    .optional()

  router.put(
    "activityMarkNotificationsAsRead",
    "/notifications",
    bodyValidationFactory<t_ActivityMarkNotificationsAsReadBodySchema>(
      activityMarkNotificationsAsReadBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_ActivityMarkNotificationsAsReadBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityMarkNotificationsAsRead(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityGetThreadParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  router.get(
    "activityGetThread",
    "/notifications/threads/:threadId",
    paramValidationFactory<t_ActivityGetThreadParamSchema>(
      activityGetThreadParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActivityGetThreadParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.activityGetThread(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityMarkThreadAsReadParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  router.patch(
    "activityMarkThreadAsRead",
    "/notifications/threads/:threadId",
    paramValidationFactory<t_ActivityMarkThreadAsReadParamSchema>(
      activityMarkThreadAsReadParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActivityMarkThreadAsReadParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.activityMarkThreadAsRead(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityGetThreadSubscriptionForAuthenticatedUserParamSchema = z.object(
    { thread_id: z.coerce.number() }
  )

  router.get(
    "activityGetThreadSubscriptionForAuthenticatedUser",
    "/notifications/threads/:threadId/subscription",
    paramValidationFactory<t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema>(
      activityGetThreadSubscriptionForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityGetThreadSubscriptionForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityGetThreadSubscriptionForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activitySetThreadSubscriptionParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  const activitySetThreadSubscriptionBodySchema = z
    .object({ ignored: z.coerce.boolean().optional() })
    .optional()

  router.put(
    "activitySetThreadSubscription",
    "/notifications/threads/:threadId/subscription",
    paramValidationFactory<t_ActivitySetThreadSubscriptionParamSchema>(
      activitySetThreadSubscriptionParamSchema
    ),
    bodyValidationFactory<t_ActivitySetThreadSubscriptionBodySchema>(
      activitySetThreadSubscriptionBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivitySetThreadSubscriptionParamSchema,
        void,
        t_ActivitySetThreadSubscriptionBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activitySetThreadSubscription(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityDeleteThreadSubscriptionParamSchema = z.object({
    thread_id: z.coerce.number(),
  })

  router.delete(
    "activityDeleteThreadSubscription",
    "/notifications/threads/:threadId/subscription",
    paramValidationFactory<t_ActivityDeleteThreadSubscriptionParamSchema>(
      activityDeleteThreadSubscriptionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityDeleteThreadSubscriptionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityDeleteThreadSubscription(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const metaGetOctocatQuerySchema = z.object({
    s: z.coerce.string().optional(),
  })

  router.get(
    "metaGetOctocat",
    "/octocat",
    queryValidationFactory<t_MetaGetOctocatQuerySchema>(
      metaGetOctocatQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_MetaGetOctocatQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.metaGetOctocat(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListQuerySchema = z.object({
    since: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "orgsList",
    "/organizations",
    queryValidationFactory<t_OrgsListQuerySchema>(orgsListQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_OrgsListQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsList(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsGetParamSchema = z.object({ org: z.coerce.string() })

  router.get(
    "orgsGet",
    "/orgs/:org",
    paramValidationFactory<t_OrgsGetParamSchema>(orgsGetParamSchema),
    async (ctx: ValidatedCtx<t_OrgsGetParamSchema, void, void>, next: Next) => {
      const { status, body } = await implementation.orgsGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsUpdateParamSchema = z.object({ org: z.coerce.string() })

  const orgsUpdateBodySchema = z
    .object({
      billing_email: z.coerce.string().optional(),
      company: z.coerce.string().optional(),
      email: z.coerce.string().optional(),
      twitter_username: z.coerce.string().optional(),
      location: z.coerce.string().optional(),
      name: z.coerce.string().optional(),
      description: z.coerce.string().optional(),
      has_organization_projects: z.coerce.boolean().optional(),
      has_repository_projects: z.coerce.boolean().optional(),
      default_repository_permission: z
        .enum(["read", "write", "admin", "none"])
        .optional(),
      members_can_create_repositories: z.coerce.boolean().optional(),
      members_can_create_internal_repositories: z.coerce.boolean().optional(),
      members_can_create_private_repositories: z.coerce.boolean().optional(),
      members_can_create_public_repositories: z.coerce.boolean().optional(),
      members_allowed_repository_creation_type: z
        .enum(["all", "private", "none"])
        .optional(),
      members_can_create_pages: z.coerce.boolean().optional(),
      members_can_create_public_pages: z.coerce.boolean().optional(),
      members_can_create_private_pages: z.coerce.boolean().optional(),
      members_can_fork_private_repositories: z.coerce.boolean().optional(),
      web_commit_signoff_required: z.coerce.boolean().optional(),
      blog: z.coerce.string().optional(),
      advanced_security_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      dependabot_alerts_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      dependabot_security_updates_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      dependency_graph_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      secret_scanning_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      secret_scanning_push_protection_enabled_for_new_repositories: z.coerce
        .boolean()
        .optional(),
      secret_scanning_push_protection_custom_link_enabled: z.coerce
        .boolean()
        .optional(),
      secret_scanning_push_protection_custom_link: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "orgsUpdate",
    "/orgs/:org",
    paramValidationFactory<t_OrgsUpdateParamSchema>(orgsUpdateParamSchema),
    bodyValidationFactory<t_OrgsUpdateBodySchema>(orgsUpdateBodySchema),
    async (
      ctx: ValidatedCtx<t_OrgsUpdateParamSchema, void, t_OrgsUpdateBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsUpdate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetActionsCacheUsageForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "actionsGetActionsCacheUsageForOrg",
    "/orgs/:org/actions/cache/usage",
    paramValidationFactory<t_ActionsGetActionsCacheUsageForOrgParamSchema>(
      actionsGetActionsCacheUsageForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetActionsCacheUsageForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetActionsCacheUsageForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetActionsCacheUsageByRepoForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsGetActionsCacheUsageByRepoForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsGetActionsCacheUsageByRepoForOrg",
    "/orgs/:org/actions/cache/usage-by-repository",
    paramValidationFactory<t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema>(
      actionsGetActionsCacheUsageByRepoForOrgParamSchema
    ),
    queryValidationFactory<t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema>(
      actionsGetActionsCacheUsageByRepoForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetActionsCacheUsageByRepoForOrgParamSchema,
        t_ActionsGetActionsCacheUsageByRepoForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetActionsCacheUsageByRepoForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const oidcGetOidcCustomSubTemplateForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "oidcGetOidcCustomSubTemplateForOrg",
    "/orgs/:org/actions/oidc/customization/sub",
    paramValidationFactory<t_OidcGetOidcCustomSubTemplateForOrgParamSchema>(
      oidcGetOidcCustomSubTemplateForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OidcGetOidcCustomSubTemplateForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.oidcGetOidcCustomSubTemplateForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const oidcUpdateOidcCustomSubTemplateForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const oidcUpdateOidcCustomSubTemplateForOrgBodySchema = z.object({
    include_claim_keys: z.array(z.coerce.string()),
  })

  router.put(
    "oidcUpdateOidcCustomSubTemplateForOrg",
    "/orgs/:org/actions/oidc/customization/sub",
    paramValidationFactory<t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema>(
      oidcUpdateOidcCustomSubTemplateForOrgParamSchema
    ),
    bodyValidationFactory<t_OidcUpdateOidcCustomSubTemplateForOrgBodySchema>(
      oidcUpdateOidcCustomSubTemplateForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OidcUpdateOidcCustomSubTemplateForOrgParamSchema,
        void,
        t_OidcUpdateOidcCustomSubTemplateForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.oidcUpdateOidcCustomSubTemplateForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetGithubActionsPermissionsOrganizationParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "actionsGetGithubActionsPermissionsOrganization",
    "/orgs/:org/actions/permissions",
    paramValidationFactory<t_ActionsGetGithubActionsPermissionsOrganizationParamSchema>(
      actionsGetGithubActionsPermissionsOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetGithubActionsPermissionsOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetGithubActionsPermissionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetGithubActionsPermissionsOrganizationParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsSetGithubActionsPermissionsOrganizationBodySchema = z.object({
    enabled_repositories: z.enum(["all", "none", "selected"]),
    allowed_actions: z.enum(["all", "local_only", "selected"]).optional(),
  })

  router.put(
    "actionsSetGithubActionsPermissionsOrganization",
    "/orgs/:org/actions/permissions",
    paramValidationFactory<t_ActionsSetGithubActionsPermissionsOrganizationParamSchema>(
      actionsSetGithubActionsPermissionsOrganizationParamSchema
    ),
    bodyValidationFactory<t_ActionsSetGithubActionsPermissionsOrganizationBodySchema>(
      actionsSetGithubActionsPermissionsOrganizationBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetGithubActionsPermissionsOrganizationParamSchema,
        void,
        t_ActionsSetGithubActionsPermissionsOrganizationBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetGithubActionsPermissionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema =
    z.object({ org: z.coerce.string() })

  const actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema =
    z.object({
      per_page: z.coerce.number().optional(),
      page: z.coerce.number().optional(),
    })

  router.get(
    "actionsListSelectedRepositoriesEnabledGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories",
    paramValidationFactory<t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema>(
      actionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema
    ),
    queryValidationFactory<t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema>(
      actionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
        t_ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema =
    z.object({ org: z.coerce.string() })

  const actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema =
    z.object({ selected_repository_ids: z.array(z.coerce.number()) })

  router.put(
    "actionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories",
    paramValidationFactory<t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema>(
      actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema
    ),
    bodyValidationFactory<t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema>(
      actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParamSchema,
        void,
        t_ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema =
    z.object({ org: z.coerce.string(), repository_id: z.coerce.number() })

  router.put(
    "actionsEnableSelectedRepositoryGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories/:repositoryId",
    paramValidationFactory<t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema>(
      actionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsEnableSelectedRepositoryGithubActionsOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsEnableSelectedRepositoryGithubActionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema =
    z.object({ org: z.coerce.string(), repository_id: z.coerce.number() })

  router.delete(
    "actionsDisableSelectedRepositoryGithubActionsOrganization",
    "/orgs/:org/actions/permissions/repositories/:repositoryId",
    paramValidationFactory<t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema>(
      actionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDisableSelectedRepositoryGithubActionsOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDisableSelectedRepositoryGithubActionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetAllowedActionsOrganizationParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "actionsGetAllowedActionsOrganization",
    "/orgs/:org/actions/permissions/selected-actions",
    paramValidationFactory<t_ActionsGetAllowedActionsOrganizationParamSchema>(
      actionsGetAllowedActionsOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetAllowedActionsOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetAllowedActionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetAllowedActionsOrganizationParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsSetAllowedActionsOrganizationBodySchema = z
    .object({
      github_owned_allowed: z.coerce.boolean().optional(),
      verified_allowed: z.coerce.boolean().optional(),
      patterns_allowed: z.array(z.coerce.string()).optional(),
    })
    .optional()

  router.put(
    "actionsSetAllowedActionsOrganization",
    "/orgs/:org/actions/permissions/selected-actions",
    paramValidationFactory<t_ActionsSetAllowedActionsOrganizationParamSchema>(
      actionsSetAllowedActionsOrganizationParamSchema
    ),
    bodyValidationFactory<t_ActionsSetAllowedActionsOrganizationBodySchema>(
      actionsSetAllowedActionsOrganizationBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetAllowedActionsOrganizationParamSchema,
        void,
        t_ActionsSetAllowedActionsOrganizationBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetAllowedActionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema =
    z.object({ org: z.coerce.string() })

  router.get(
    "actionsGetGithubActionsDefaultWorkflowPermissionsOrganization",
    "/orgs/:org/actions/permissions/workflow",
    paramValidationFactory<t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema>(
      actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema =
    z.object({ org: z.coerce.string() })

  const actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema =
    z
      .object({
        default_workflow_permissions: z.enum(["read", "write"]).optional(),
        can_approve_pull_request_reviews: z.coerce.boolean().optional(),
      })
      .optional()

  router.put(
    "actionsSetGithubActionsDefaultWorkflowPermissionsOrganization",
    "/orgs/:org/actions/permissions/workflow",
    paramValidationFactory<t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema>(
      actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema
    ),
    bodyValidationFactory<t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema>(
      actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationParamSchema,
        void,
        t_ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRequiredWorkflowsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsListRequiredWorkflowsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListRequiredWorkflows",
    "/orgs/:org/actions/required_workflows",
    paramValidationFactory<t_ActionsListRequiredWorkflowsParamSchema>(
      actionsListRequiredWorkflowsParamSchema
    ),
    queryValidationFactory<t_ActionsListRequiredWorkflowsQuerySchema>(
      actionsListRequiredWorkflowsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRequiredWorkflowsParamSchema,
        t_ActionsListRequiredWorkflowsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListRequiredWorkflows(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsCreateRequiredWorkflowBodySchema = z.object({
    workflow_file_path: z.coerce.string(),
    repository_id: z.coerce.string(),
    scope: z.enum(["selected", "all"]).optional(),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.post(
    "actionsCreateRequiredWorkflow",
    "/orgs/:org/actions/required_workflows",
    paramValidationFactory<t_ActionsCreateRequiredWorkflowParamSchema>(
      actionsCreateRequiredWorkflowParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateRequiredWorkflowBodySchema>(
      actionsCreateRequiredWorkflowBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateRequiredWorkflowParamSchema,
        void,
        t_ActionsCreateRequiredWorkflowBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateRequiredWorkflow(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    required_workflow_id: z.coerce.number(),
  })

  router.get(
    "actionsGetRequiredWorkflow",
    "/orgs/:org/actions/required_workflows/:requiredWorkflowId",
    paramValidationFactory<t_ActionsGetRequiredWorkflowParamSchema>(
      actionsGetRequiredWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetRequiredWorkflowParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetRequiredWorkflow(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsUpdateRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    required_workflow_id: z.coerce.number(),
  })

  const actionsUpdateRequiredWorkflowBodySchema = z.object({
    workflow_file_path: z.coerce.string().optional(),
    repository_id: z.coerce.string().optional(),
    scope: z.enum(["selected", "all"]).optional(),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.patch(
    "actionsUpdateRequiredWorkflow",
    "/orgs/:org/actions/required_workflows/:requiredWorkflowId",
    paramValidationFactory<t_ActionsUpdateRequiredWorkflowParamSchema>(
      actionsUpdateRequiredWorkflowParamSchema
    ),
    bodyValidationFactory<t_ActionsUpdateRequiredWorkflowBodySchema>(
      actionsUpdateRequiredWorkflowBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsUpdateRequiredWorkflowParamSchema,
        void,
        t_ActionsUpdateRequiredWorkflowBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsUpdateRequiredWorkflow(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    required_workflow_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteRequiredWorkflow",
    "/orgs/:org/actions/required_workflows/:requiredWorkflowId",
    paramValidationFactory<t_ActionsDeleteRequiredWorkflowParamSchema>(
      actionsDeleteRequiredWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteRequiredWorkflowParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteRequiredWorkflow(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelectedRepositoriesRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    required_workflow_id: z.coerce.number(),
  })

  router.get(
    "actionsListSelectedRepositoriesRequiredWorkflow",
    "/orgs/:org/actions/required_workflows/:requiredWorkflowId/repositories",
    paramValidationFactory<t_ActionsListSelectedRepositoriesRequiredWorkflowParamSchema>(
      actionsListSelectedRepositoriesRequiredWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelectedRepositoriesRequiredWorkflowParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelectedRepositoriesRequiredWorkflow(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetSelectedReposToRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    required_workflow_id: z.coerce.number(),
  })

  const actionsSetSelectedReposToRequiredWorkflowBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetSelectedReposToRequiredWorkflow",
    "/orgs/:org/actions/required_workflows/:requiredWorkflowId/repositories",
    paramValidationFactory<t_ActionsSetSelectedReposToRequiredWorkflowParamSchema>(
      actionsSetSelectedReposToRequiredWorkflowParamSchema
    ),
    bodyValidationFactory<t_ActionsSetSelectedReposToRequiredWorkflowBodySchema>(
      actionsSetSelectedReposToRequiredWorkflowBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetSelectedReposToRequiredWorkflowParamSchema,
        void,
        t_ActionsSetSelectedReposToRequiredWorkflowBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetSelectedReposToRequiredWorkflow(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsAddSelectedRepoToRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    required_workflow_id: z.coerce.number(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "actionsAddSelectedRepoToRequiredWorkflow",
    "/orgs/:org/actions/required_workflows/:requiredWorkflowId/repositories/:repositoryId",
    paramValidationFactory<t_ActionsAddSelectedRepoToRequiredWorkflowParamSchema>(
      actionsAddSelectedRepoToRequiredWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsAddSelectedRepoToRequiredWorkflowParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsAddSelectedRepoToRequiredWorkflow(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveSelectedRepoFromRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    required_workflow_id: z.coerce.number(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "actionsRemoveSelectedRepoFromRequiredWorkflow",
    "/orgs/:org/actions/required_workflows/:requiredWorkflowId/repositories/:repositoryId",
    paramValidationFactory<t_ActionsRemoveSelectedRepoFromRequiredWorkflowParamSchema>(
      actionsRemoveSelectedRepoFromRequiredWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveSelectedRepoFromRequiredWorkflowParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveSelectedRepoFromRequiredWorkflow(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelfHostedRunnerGroupsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsListSelfHostedRunnerGroupsForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    visible_to_repository: z.coerce.string().optional(),
  })

  router.get(
    "actionsListSelfHostedRunnerGroupsForOrg",
    "/orgs/:org/actions/runner-groups",
    paramValidationFactory<t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema>(
      actionsListSelfHostedRunnerGroupsForOrgParamSchema
    ),
    queryValidationFactory<t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema>(
      actionsListSelfHostedRunnerGroupsForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelfHostedRunnerGroupsForOrgParamSchema,
        t_ActionsListSelfHostedRunnerGroupsForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelfHostedRunnerGroupsForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsCreateSelfHostedRunnerGroupForOrgBodySchema = z.object({
    name: z.coerce.string(),
    visibility: z.enum(["selected", "all", "private"]).optional(),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
    runners: z.array(z.coerce.number()).optional(),
    allows_public_repositories: z.coerce.boolean().optional(),
    restricted_to_workflows: z.coerce.boolean().optional(),
    selected_workflows: z.array(z.coerce.string()).optional(),
  })

  router.post(
    "actionsCreateSelfHostedRunnerGroupForOrg",
    "/orgs/:org/actions/runner-groups",
    paramValidationFactory<t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema>(
      actionsCreateSelfHostedRunnerGroupForOrgParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateSelfHostedRunnerGroupForOrgBodySchema>(
      actionsCreateSelfHostedRunnerGroupForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateSelfHostedRunnerGroupForOrgParamSchema,
        void,
        t_ActionsCreateSelfHostedRunnerGroupForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateSelfHostedRunnerGroupForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
  })

  router.get(
    "actionsGetSelfHostedRunnerGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId",
    paramValidationFactory<t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema>(
      actionsGetSelfHostedRunnerGroupForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetSelfHostedRunnerGroupForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetSelfHostedRunnerGroupForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsUpdateSelfHostedRunnerGroupForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsUpdateSelfHostedRunnerGroupForOrgBodySchema = z.object({
    name: z.coerce.string(),
    visibility: z.enum(["selected", "all", "private"]).optional(),
    allows_public_repositories: z.coerce.boolean().optional(),
    restricted_to_workflows: z.coerce.boolean().optional(),
    selected_workflows: z.array(z.coerce.string()).optional(),
  })

  router.patch(
    "actionsUpdateSelfHostedRunnerGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId",
    paramValidationFactory<t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema>(
      actionsUpdateSelfHostedRunnerGroupForOrgParamSchema
    ),
    bodyValidationFactory<t_ActionsUpdateSelfHostedRunnerGroupForOrgBodySchema>(
      actionsUpdateSelfHostedRunnerGroupForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsUpdateSelfHostedRunnerGroupForOrgParamSchema,
        void,
        t_ActionsUpdateSelfHostedRunnerGroupForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsUpdateSelfHostedRunnerGroupForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteSelfHostedRunnerGroupFromOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteSelfHostedRunnerGroupFromOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId",
    paramValidationFactory<t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema>(
      actionsDeleteSelfHostedRunnerGroupFromOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDeleteSelfHostedRunnerGroupFromOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteSelfHostedRunnerGroupFromOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object(
    { org: z.coerce.string(), runner_group_id: z.coerce.number() }
  )

  const actionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema = z.object(
    {
      page: z.coerce.number().optional(),
      per_page: z.coerce.number().optional(),
    }
  )

  router.get(
    "actionsListRepoAccessToSelfHostedRunnerGroupInOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId/repositories",
    paramValidationFactory<t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema>(
      actionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema
    ),
    queryValidationFactory<t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema>(
      actionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
        t_ActionsListRepoAccessToSelfHostedRunnerGroupInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId/repositories",
    paramValidationFactory<t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema>(
      actionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema
    ),
    bodyValidationFactory<t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema>(
      actionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
        void,
        t_ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema =
    z.object({
      org: z.coerce.string(),
      runner_group_id: z.coerce.number(),
      repository_id: z.coerce.number(),
    })

  router.delete(
    "actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId/repositories/:repositoryId",
    paramValidationFactory<t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema>(
      actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelfHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsListSelfHostedRunnersInGroupForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListSelfHostedRunnersInGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId/runners",
    paramValidationFactory<t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema>(
      actionsListSelfHostedRunnersInGroupForOrgParamSchema
    ),
    queryValidationFactory<t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema>(
      actionsListSelfHostedRunnersInGroupForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelfHostedRunnersInGroupForOrgParamSchema,
        t_ActionsListSelfHostedRunnersInGroupForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelfHostedRunnersInGroupForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetSelfHostedRunnersInGroupForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
  })

  const actionsSetSelfHostedRunnersInGroupForOrgBodySchema = z.object({
    runners: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetSelfHostedRunnersInGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId/runners",
    paramValidationFactory<t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema>(
      actionsSetSelfHostedRunnersInGroupForOrgParamSchema
    ),
    bodyValidationFactory<t_ActionsSetSelfHostedRunnersInGroupForOrgBodySchema>(
      actionsSetSelfHostedRunnersInGroupForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetSelfHostedRunnersInGroupForOrgParamSchema,
        void,
        t_ActionsSetSelfHostedRunnersInGroupForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetSelfHostedRunnersInGroupForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsAddSelfHostedRunnerToGroupForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
    runner_id: z.coerce.number(),
  })

  router.put(
    "actionsAddSelfHostedRunnerToGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId/runners/:runnerId",
    paramValidationFactory<t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema>(
      actionsAddSelfHostedRunnerToGroupForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsAddSelfHostedRunnerToGroupForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsAddSelfHostedRunnerToGroupForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_group_id: z.coerce.number(),
    runner_id: z.coerce.number(),
  })

  router.delete(
    "actionsRemoveSelfHostedRunnerFromGroupForOrg",
    "/orgs/:org/actions/runner-groups/:runnerGroupId/runners/:runnerId",
    paramValidationFactory<t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema>(
      actionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveSelfHostedRunnerFromGroupForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveSelfHostedRunnerFromGroupForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelfHostedRunnersForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsListSelfHostedRunnersForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListSelfHostedRunnersForOrg",
    "/orgs/:org/actions/runners",
    paramValidationFactory<t_ActionsListSelfHostedRunnersForOrgParamSchema>(
      actionsListSelfHostedRunnersForOrgParamSchema
    ),
    queryValidationFactory<t_ActionsListSelfHostedRunnersForOrgQuerySchema>(
      actionsListSelfHostedRunnersForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelfHostedRunnersForOrgParamSchema,
        t_ActionsListSelfHostedRunnersForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelfHostedRunnersForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRunnerApplicationsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "actionsListRunnerApplicationsForOrg",
    "/orgs/:org/actions/runners/downloads",
    paramValidationFactory<t_ActionsListRunnerApplicationsForOrgParamSchema>(
      actionsListRunnerApplicationsForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRunnerApplicationsForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListRunnerApplicationsForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateRegistrationTokenForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.post(
    "actionsCreateRegistrationTokenForOrg",
    "/orgs/:org/actions/runners/registration-token",
    paramValidationFactory<t_ActionsCreateRegistrationTokenForOrgParamSchema>(
      actionsCreateRegistrationTokenForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateRegistrationTokenForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateRegistrationTokenForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateRemoveTokenForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.post(
    "actionsCreateRemoveTokenForOrg",
    "/orgs/:org/actions/runners/remove-token",
    paramValidationFactory<t_ActionsCreateRemoveTokenForOrgParamSchema>(
      actionsCreateRemoveTokenForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateRemoveTokenForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateRemoveTokenForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsGetSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runnerId",
    paramValidationFactory<t_ActionsGetSelfHostedRunnerForOrgParamSchema>(
      actionsGetSelfHostedRunnerForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetSelfHostedRunnerForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetSelfHostedRunnerForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteSelfHostedRunnerFromOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteSelfHostedRunnerFromOrg",
    "/orgs/:org/actions/runners/:runnerId",
    paramValidationFactory<t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema>(
      actionsDeleteSelfHostedRunnerFromOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDeleteSelfHostedRunnerFromOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteSelfHostedRunnerFromOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListLabelsForSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsListLabelsForSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema>(
      actionsListLabelsForSelfHostedRunnerForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListLabelsForSelfHostedRunnerForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListLabelsForSelfHostedRunnerForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  const actionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema = z.object({
    labels: z.array(z.coerce.string()),
  })

  router.post(
    "actionsAddCustomLabelsToSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema>(
      actionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema
    ),
    bodyValidationFactory<t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema>(
      actionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgParamSchema,
        void,
        t_ActionsAddCustomLabelsToSelfHostedRunnerForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsAddCustomLabelsToSelfHostedRunnerForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema = z.object({
    org: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  const actionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema = z.object({
    labels: z.array(z.coerce.string()),
  })

  router.put(
    "actionsSetCustomLabelsForSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema>(
      actionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema
    ),
    bodyValidationFactory<t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema>(
      actionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgParamSchema,
        void,
        t_ActionsSetCustomLabelsForSelfHostedRunnerForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetCustomLabelsForSelfHostedRunnerForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema =
    z.object({ org: z.coerce.string(), runner_id: z.coerce.number() })

  router.delete(
    "actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema>(
      actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema =
    z.object({
      org: z.coerce.string(),
      runner_id: z.coerce.number(),
      name: z.coerce.string(),
    })

  router.delete(
    "actionsRemoveCustomLabelFromSelfHostedRunnerForOrg",
    "/orgs/:org/actions/runners/:runnerId/labels/:name",
    paramValidationFactory<t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema>(
      actionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListOrgSecretsParamSchema = z.object({ org: z.coerce.string() })

  const actionsListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListOrgSecrets",
    "/orgs/:org/actions/secrets",
    paramValidationFactory<t_ActionsListOrgSecretsParamSchema>(
      actionsListOrgSecretsParamSchema
    ),
    queryValidationFactory<t_ActionsListOrgSecretsQuerySchema>(
      actionsListOrgSecretsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListOrgSecretsParamSchema,
        t_ActionsListOrgSecretsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsListOrgSecrets(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetOrgPublicKeyParamSchema = z.object({ org: z.coerce.string() })

  router.get(
    "actionsGetOrgPublicKey",
    "/orgs/:org/actions/secrets/public-key",
    paramValidationFactory<t_ActionsGetOrgPublicKeyParamSchema>(
      actionsGetOrgPublicKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetOrgPublicKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetOrgPublicKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.get(
    "actionsGetOrgSecret",
    "/orgs/:org/actions/secrets/:secretName",
    paramValidationFactory<t_ActionsGetOrgSecretParamSchema>(
      actionsGetOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetOrgSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetOrgSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const actionsCreateOrUpdateOrgSecretBodySchema = z.object({
    encrypted_value: z.coerce.string().optional(),
    key_id: z.coerce.string().optional(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.put(
    "actionsCreateOrUpdateOrgSecret",
    "/orgs/:org/actions/secrets/:secretName",
    paramValidationFactory<t_ActionsCreateOrUpdateOrgSecretParamSchema>(
      actionsCreateOrUpdateOrgSecretParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateOrUpdateOrgSecretBodySchema>(
      actionsCreateOrUpdateOrgSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateOrUpdateOrgSecretParamSchema,
        void,
        t_ActionsCreateOrUpdateOrgSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateOrUpdateOrgSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.delete(
    "actionsDeleteOrgSecret",
    "/orgs/:org/actions/secrets/:secretName",
    paramValidationFactory<t_ActionsDeleteOrgSecretParamSchema>(
      actionsDeleteOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteOrgSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDeleteOrgSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const actionsListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListSelectedReposForOrgSecret",
    "/orgs/:org/actions/secrets/:secretName/repositories",
    paramValidationFactory<t_ActionsListSelectedReposForOrgSecretParamSchema>(
      actionsListSelectedReposForOrgSecretParamSchema
    ),
    queryValidationFactory<t_ActionsListSelectedReposForOrgSecretQuerySchema>(
      actionsListSelectedReposForOrgSecretQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelectedReposForOrgSecretParamSchema,
        t_ActionsListSelectedReposForOrgSecretQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelectedReposForOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const actionsSetSelectedReposForOrgSecretBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetSelectedReposForOrgSecret",
    "/orgs/:org/actions/secrets/:secretName/repositories",
    paramValidationFactory<t_ActionsSetSelectedReposForOrgSecretParamSchema>(
      actionsSetSelectedReposForOrgSecretParamSchema
    ),
    bodyValidationFactory<t_ActionsSetSelectedReposForOrgSecretBodySchema>(
      actionsSetSelectedReposForOrgSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetSelectedReposForOrgSecretParamSchema,
        void,
        t_ActionsSetSelectedReposForOrgSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetSelectedReposForOrgSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "actionsAddSelectedRepoToOrgSecret",
    "/orgs/:org/actions/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_ActionsAddSelectedRepoToOrgSecretParamSchema>(
      actionsAddSelectedRepoToOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsAddSelectedRepoToOrgSecretParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsAddSelectedRepoToOrgSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "actionsRemoveSelectedRepoFromOrgSecret",
    "/orgs/:org/actions/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema>(
      actionsRemoveSelectedRepoFromOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveSelectedRepoFromOrgSecretParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveSelectedRepoFromOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListOrgVariablesParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsListOrgVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListOrgVariables",
    "/orgs/:org/actions/variables",
    paramValidationFactory<t_ActionsListOrgVariablesParamSchema>(
      actionsListOrgVariablesParamSchema
    ),
    queryValidationFactory<t_ActionsListOrgVariablesQuerySchema>(
      actionsListOrgVariablesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListOrgVariablesParamSchema,
        t_ActionsListOrgVariablesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsListOrgVariables(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
  })

  const actionsCreateOrgVariableBodySchema = z.object({
    name: z.coerce.string(),
    value: z.coerce.string(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.post(
    "actionsCreateOrgVariable",
    "/orgs/:org/actions/variables",
    paramValidationFactory<t_ActionsCreateOrgVariableParamSchema>(
      actionsCreateOrgVariableParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateOrgVariableBodySchema>(
      actionsCreateOrgVariableBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateOrgVariableParamSchema,
        void,
        t_ActionsCreateOrgVariableBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsCreateOrgVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.get(
    "actionsGetOrgVariable",
    "/orgs/:org/actions/variables/:name",
    paramValidationFactory<t_ActionsGetOrgVariableParamSchema>(
      actionsGetOrgVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetOrgVariableParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetOrgVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsUpdateOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
    name: z.coerce.string(),
  })

  const actionsUpdateOrgVariableBodySchema = z.object({
    name: z.coerce.string().optional(),
    value: z.coerce.string().optional(),
    visibility: z.enum(["all", "private", "selected"]).optional(),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.patch(
    "actionsUpdateOrgVariable",
    "/orgs/:org/actions/variables/:name",
    paramValidationFactory<t_ActionsUpdateOrgVariableParamSchema>(
      actionsUpdateOrgVariableParamSchema
    ),
    bodyValidationFactory<t_ActionsUpdateOrgVariableBodySchema>(
      actionsUpdateOrgVariableBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsUpdateOrgVariableParamSchema,
        void,
        t_ActionsUpdateOrgVariableBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsUpdateOrgVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.delete(
    "actionsDeleteOrgVariable",
    "/orgs/:org/actions/variables/:name",
    paramValidationFactory<t_ActionsDeleteOrgVariableParamSchema>(
      actionsDeleteOrgVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteOrgVariableParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDeleteOrgVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelectedReposForOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
    name: z.coerce.string(),
  })

  const actionsListSelectedReposForOrgVariableQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListSelectedReposForOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories",
    paramValidationFactory<t_ActionsListSelectedReposForOrgVariableParamSchema>(
      actionsListSelectedReposForOrgVariableParamSchema
    ),
    queryValidationFactory<t_ActionsListSelectedReposForOrgVariableQuerySchema>(
      actionsListSelectedReposForOrgVariableQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelectedReposForOrgVariableParamSchema,
        t_ActionsListSelectedReposForOrgVariableQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelectedReposForOrgVariable(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetSelectedReposForOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
    name: z.coerce.string(),
  })

  const actionsSetSelectedReposForOrgVariableBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "actionsSetSelectedReposForOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories",
    paramValidationFactory<t_ActionsSetSelectedReposForOrgVariableParamSchema>(
      actionsSetSelectedReposForOrgVariableParamSchema
    ),
    bodyValidationFactory<t_ActionsSetSelectedReposForOrgVariableBodySchema>(
      actionsSetSelectedReposForOrgVariableBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetSelectedReposForOrgVariableParamSchema,
        void,
        t_ActionsSetSelectedReposForOrgVariableBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetSelectedReposForOrgVariable(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsAddSelectedRepoToOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
    name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "actionsAddSelectedRepoToOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories/:repositoryId",
    paramValidationFactory<t_ActionsAddSelectedRepoToOrgVariableParamSchema>(
      actionsAddSelectedRepoToOrgVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsAddSelectedRepoToOrgVariableParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsAddSelectedRepoToOrgVariable(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveSelectedRepoFromOrgVariableParamSchema = z.object({
    org: z.coerce.string(),
    name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "actionsRemoveSelectedRepoFromOrgVariable",
    "/orgs/:org/actions/variables/:name/repositories/:repositoryId",
    paramValidationFactory<t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema>(
      actionsRemoveSelectedRepoFromOrgVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveSelectedRepoFromOrgVariableParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveSelectedRepoFromOrgVariable(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListBlockedUsersParamSchema = z.object({ org: z.coerce.string() })

  const orgsListBlockedUsersQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListBlockedUsers",
    "/orgs/:org/blocks",
    paramValidationFactory<t_OrgsListBlockedUsersParamSchema>(
      orgsListBlockedUsersParamSchema
    ),
    queryValidationFactory<t_OrgsListBlockedUsersQuerySchema>(
      orgsListBlockedUsersQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListBlockedUsersParamSchema,
        t_OrgsListBlockedUsersQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListBlockedUsers(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsCheckBlockedUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "orgsCheckBlockedUser",
    "/orgs/:org/blocks/:username",
    paramValidationFactory<t_OrgsCheckBlockedUserParamSchema>(
      orgsCheckBlockedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsCheckBlockedUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsCheckBlockedUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsBlockUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.put(
    "orgsBlockUser",
    "/orgs/:org/blocks/:username",
    paramValidationFactory<t_OrgsBlockUserParamSchema>(
      orgsBlockUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsBlockUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsBlockUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsUnblockUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "orgsUnblockUser",
    "/orgs/:org/blocks/:username",
    paramValidationFactory<t_OrgsUnblockUserParamSchema>(
      orgsUnblockUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsUnblockUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsUnblockUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningListAlertsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const codeScanningListAlertsForOrgQuerySchema = z.object({
    tool_name: z.coerce.string().optional(),
    tool_guid: z.coerce.string().optional(),
    before: z.coerce.string().optional(),
    after: z.coerce.string().optional(),
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    state: z.enum(["open", "closed", "dismissed", "fixed"]).optional(),
    sort: z.enum(["created", "updated"]).optional(),
    severity: z
      .enum(["critical", "high", "medium", "low", "warning", "note", "error"])
      .optional(),
  })

  router.get(
    "codeScanningListAlertsForOrg",
    "/orgs/:org/code-scanning/alerts",
    paramValidationFactory<t_CodeScanningListAlertsForOrgParamSchema>(
      codeScanningListAlertsForOrgParamSchema
    ),
    queryValidationFactory<t_CodeScanningListAlertsForOrgQuerySchema>(
      codeScanningListAlertsForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningListAlertsForOrgParamSchema,
        t_CodeScanningListAlertsForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codeScanningListAlertsForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListInOrganizationParamSchema = z.object({
    org: z.coerce.string(),
  })

  const codespacesListInOrganizationQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListInOrganization",
    "/orgs/:org/codespaces",
    paramValidationFactory<t_CodespacesListInOrganizationParamSchema>(
      codespacesListInOrganizationParamSchema
    ),
    queryValidationFactory<t_CodespacesListInOrganizationQuerySchema>(
      codespacesListInOrganizationQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesListInOrganizationParamSchema,
        t_CodespacesListInOrganizationQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesListInOrganization(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesSetCodespacesBillingParamSchema = z.object({
    org: z.coerce.string(),
  })

  const codespacesSetCodespacesBillingBodySchema = z.object({
    visibility: z.enum([
      "disabled",
      "selected_members",
      "all_members",
      "all_members_and_outside_collaborators",
    ]),
    selected_usernames: z.array(z.coerce.string()).optional(),
  })

  router.put(
    "codespacesSetCodespacesBilling",
    "/orgs/:org/codespaces/billing",
    paramValidationFactory<t_CodespacesSetCodespacesBillingParamSchema>(
      codespacesSetCodespacesBillingParamSchema
    ),
    bodyValidationFactory<t_CodespacesSetCodespacesBillingBodySchema>(
      codespacesSetCodespacesBillingBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesSetCodespacesBillingParamSchema,
        void,
        t_CodespacesSetCodespacesBillingBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesSetCodespacesBilling(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListOrgSecretsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const codespacesListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListOrgSecrets",
    "/orgs/:org/codespaces/secrets",
    paramValidationFactory<t_CodespacesListOrgSecretsParamSchema>(
      codespacesListOrgSecretsParamSchema
    ),
    queryValidationFactory<t_CodespacesListOrgSecretsQuerySchema>(
      codespacesListOrgSecretsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesListOrgSecretsParamSchema,
        t_CodespacesListOrgSecretsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesListOrgSecrets(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetOrgPublicKeyParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "codespacesGetOrgPublicKey",
    "/orgs/:org/codespaces/secrets/public-key",
    paramValidationFactory<t_CodespacesGetOrgPublicKeyParamSchema>(
      codespacesGetOrgPublicKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodespacesGetOrgPublicKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesGetOrgPublicKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.get(
    "codespacesGetOrgSecret",
    "/orgs/:org/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesGetOrgSecretParamSchema>(
      codespacesGetOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodespacesGetOrgSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesGetOrgSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const codespacesCreateOrUpdateOrgSecretBodySchema = z.object({
    encrypted_value: z.coerce.string().optional(),
    key_id: z.coerce.string().optional(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.number()).optional(),
  })

  router.put(
    "codespacesCreateOrUpdateOrgSecret",
    "/orgs/:org/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesCreateOrUpdateOrgSecretParamSchema>(
      codespacesCreateOrUpdateOrgSecretParamSchema
    ),
    bodyValidationFactory<t_CodespacesCreateOrUpdateOrgSecretBodySchema>(
      codespacesCreateOrUpdateOrgSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesCreateOrUpdateOrgSecretParamSchema,
        void,
        t_CodespacesCreateOrUpdateOrgSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesCreateOrUpdateOrgSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesDeleteOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.delete(
    "codespacesDeleteOrgSecret",
    "/orgs/:org/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesDeleteOrgSecretParamSchema>(
      codespacesDeleteOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodespacesDeleteOrgSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesDeleteOrgSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const codespacesListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListSelectedReposForOrgSecret",
    "/orgs/:org/codespaces/secrets/:secretName/repositories",
    paramValidationFactory<t_CodespacesListSelectedReposForOrgSecretParamSchema>(
      codespacesListSelectedReposForOrgSecretParamSchema
    ),
    queryValidationFactory<t_CodespacesListSelectedReposForOrgSecretQuerySchema>(
      codespacesListSelectedReposForOrgSecretQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesListSelectedReposForOrgSecretParamSchema,
        t_CodespacesListSelectedReposForOrgSecretQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesListSelectedReposForOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const codespacesSetSelectedReposForOrgSecretBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "codespacesSetSelectedReposForOrgSecret",
    "/orgs/:org/codespaces/secrets/:secretName/repositories",
    paramValidationFactory<t_CodespacesSetSelectedReposForOrgSecretParamSchema>(
      codespacesSetSelectedReposForOrgSecretParamSchema
    ),
    bodyValidationFactory<t_CodespacesSetSelectedReposForOrgSecretBodySchema>(
      codespacesSetSelectedReposForOrgSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesSetSelectedReposForOrgSecretParamSchema,
        void,
        t_CodespacesSetSelectedReposForOrgSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesSetSelectedReposForOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "codespacesAddSelectedRepoToOrgSecret",
    "/orgs/:org/codespaces/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_CodespacesAddSelectedRepoToOrgSecretParamSchema>(
      codespacesAddSelectedRepoToOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesAddSelectedRepoToOrgSecretParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesAddSelectedRepoToOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "codespacesRemoveSelectedRepoFromOrgSecret",
    "/orgs/:org/codespaces/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema>(
      codespacesRemoveSelectedRepoFromOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesRemoveSelectedRepoFromOrgSecretParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesRemoveSelectedRepoFromOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotListAlertsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const dependabotListAlertsForOrgQuerySchema = z.object({
    state: z.coerce.string().optional(),
    severity: z.coerce.string().optional(),
    ecosystem: z.coerce.string().optional(),
    package: z.coerce.string().optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    before: z.coerce.string().optional(),
    after: z.coerce.string().optional(),
    first: z.coerce.number().optional(),
    last: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "dependabotListAlertsForOrg",
    "/orgs/:org/dependabot/alerts",
    paramValidationFactory<t_DependabotListAlertsForOrgParamSchema>(
      dependabotListAlertsForOrgParamSchema
    ),
    queryValidationFactory<t_DependabotListAlertsForOrgQuerySchema>(
      dependabotListAlertsForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotListAlertsForOrgParamSchema,
        t_DependabotListAlertsForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotListAlertsForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotListOrgSecretsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const dependabotListOrgSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "dependabotListOrgSecrets",
    "/orgs/:org/dependabot/secrets",
    paramValidationFactory<t_DependabotListOrgSecretsParamSchema>(
      dependabotListOrgSecretsParamSchema
    ),
    queryValidationFactory<t_DependabotListOrgSecretsQuerySchema>(
      dependabotListOrgSecretsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotListOrgSecretsParamSchema,
        t_DependabotListOrgSecretsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotListOrgSecrets(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotGetOrgPublicKeyParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "dependabotGetOrgPublicKey",
    "/orgs/:org/dependabot/secrets/public-key",
    paramValidationFactory<t_DependabotGetOrgPublicKeyParamSchema>(
      dependabotGetOrgPublicKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_DependabotGetOrgPublicKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotGetOrgPublicKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotGetOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.get(
    "dependabotGetOrgSecret",
    "/orgs/:org/dependabot/secrets/:secretName",
    paramValidationFactory<t_DependabotGetOrgSecretParamSchema>(
      dependabotGetOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_DependabotGetOrgSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotGetOrgSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotCreateOrUpdateOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const dependabotCreateOrUpdateOrgSecretBodySchema = z.object({
    encrypted_value: z.coerce.string().optional(),
    key_id: z.coerce.string().optional(),
    visibility: z.enum(["all", "private", "selected"]),
    selected_repository_ids: z.array(z.coerce.string()).optional(),
  })

  router.put(
    "dependabotCreateOrUpdateOrgSecret",
    "/orgs/:org/dependabot/secrets/:secretName",
    paramValidationFactory<t_DependabotCreateOrUpdateOrgSecretParamSchema>(
      dependabotCreateOrUpdateOrgSecretParamSchema
    ),
    bodyValidationFactory<t_DependabotCreateOrUpdateOrgSecretBodySchema>(
      dependabotCreateOrUpdateOrgSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotCreateOrUpdateOrgSecretParamSchema,
        void,
        t_DependabotCreateOrUpdateOrgSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependabotCreateOrUpdateOrgSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotDeleteOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.delete(
    "dependabotDeleteOrgSecret",
    "/orgs/:org/dependabot/secrets/:secretName",
    paramValidationFactory<t_DependabotDeleteOrgSecretParamSchema>(
      dependabotDeleteOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_DependabotDeleteOrgSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotDeleteOrgSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotListSelectedReposForOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const dependabotListSelectedReposForOrgSecretQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "dependabotListSelectedReposForOrgSecret",
    "/orgs/:org/dependabot/secrets/:secretName/repositories",
    paramValidationFactory<t_DependabotListSelectedReposForOrgSecretParamSchema>(
      dependabotListSelectedReposForOrgSecretParamSchema
    ),
    queryValidationFactory<t_DependabotListSelectedReposForOrgSecretQuerySchema>(
      dependabotListSelectedReposForOrgSecretQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotListSelectedReposForOrgSecretParamSchema,
        t_DependabotListSelectedReposForOrgSecretQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependabotListSelectedReposForOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotSetSelectedReposForOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const dependabotSetSelectedReposForOrgSecretBodySchema = z.object({
    selected_repository_ids: z.array(z.coerce.number()),
  })

  router.put(
    "dependabotSetSelectedReposForOrgSecret",
    "/orgs/:org/dependabot/secrets/:secretName/repositories",
    paramValidationFactory<t_DependabotSetSelectedReposForOrgSecretParamSchema>(
      dependabotSetSelectedReposForOrgSecretParamSchema
    ),
    bodyValidationFactory<t_DependabotSetSelectedReposForOrgSecretBodySchema>(
      dependabotSetSelectedReposForOrgSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotSetSelectedReposForOrgSecretParamSchema,
        void,
        t_DependabotSetSelectedReposForOrgSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependabotSetSelectedReposForOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotAddSelectedRepoToOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "dependabotAddSelectedRepoToOrgSecret",
    "/orgs/:org/dependabot/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_DependabotAddSelectedRepoToOrgSecretParamSchema>(
      dependabotAddSelectedRepoToOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotAddSelectedRepoToOrgSecretParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependabotAddSelectedRepoToOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotRemoveSelectedRepoFromOrgSecretParamSchema = z.object({
    org: z.coerce.string(),
    secret_name: z.coerce.string(),
    repository_id: z.coerce.number(),
  })

  router.delete(
    "dependabotRemoveSelectedRepoFromOrgSecret",
    "/orgs/:org/dependabot/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema>(
      dependabotRemoveSelectedRepoFromOrgSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotRemoveSelectedRepoFromOrgSecretParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependabotRemoveSelectedRepoFromOrgSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListPublicOrgEventsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const activityListPublicOrgEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListPublicOrgEvents",
    "/orgs/:org/events",
    paramValidationFactory<t_ActivityListPublicOrgEventsParamSchema>(
      activityListPublicOrgEventsParamSchema
    ),
    queryValidationFactory<t_ActivityListPublicOrgEventsQuerySchema>(
      activityListPublicOrgEventsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListPublicOrgEventsParamSchema,
        t_ActivityListPublicOrgEventsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.activityListPublicOrgEvents(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListFailedInvitationsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const orgsListFailedInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListFailedInvitations",
    "/orgs/:org/failed_invitations",
    paramValidationFactory<t_OrgsListFailedInvitationsParamSchema>(
      orgsListFailedInvitationsParamSchema
    ),
    queryValidationFactory<t_OrgsListFailedInvitationsQuerySchema>(
      orgsListFailedInvitationsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListFailedInvitationsParamSchema,
        t_OrgsListFailedInvitationsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListFailedInvitations(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListWebhooksParamSchema = z.object({ org: z.coerce.string() })

  const orgsListWebhooksQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListWebhooks",
    "/orgs/:org/hooks",
    paramValidationFactory<t_OrgsListWebhooksParamSchema>(
      orgsListWebhooksParamSchema
    ),
    queryValidationFactory<t_OrgsListWebhooksQuerySchema>(
      orgsListWebhooksQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListWebhooksParamSchema,
        t_OrgsListWebhooksQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListWebhooks(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsCreateWebhookParamSchema = z.object({ org: z.coerce.string() })

  const orgsCreateWebhookBodySchema = z.object({
    name: z.coerce.string(),
    config: z.object({
      url: z.coerce.string(),
      content_type: z.coerce.string().optional(),
      secret: z.coerce.string().optional(),
      insecure_ssl: z.union([z.coerce.string(), z.coerce.number()]),
      username: z.coerce.string().optional(),
      password: z.coerce.string().optional(),
    }),
    events: z.array(z.coerce.string()).optional(),
    active: z.coerce.boolean().optional(),
  })

  router.post(
    "orgsCreateWebhook",
    "/orgs/:org/hooks",
    paramValidationFactory<t_OrgsCreateWebhookParamSchema>(
      orgsCreateWebhookParamSchema
    ),
    bodyValidationFactory<t_OrgsCreateWebhookBodySchema>(
      orgsCreateWebhookBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsCreateWebhookParamSchema,
        void,
        t_OrgsCreateWebhookBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsCreateWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsGetWebhookParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "orgsGetWebhook",
    "/orgs/:org/hooks/:hookId",
    paramValidationFactory<t_OrgsGetWebhookParamSchema>(
      orgsGetWebhookParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsGetWebhookParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsGetWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsUpdateWebhookParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  const orgsUpdateWebhookBodySchema = z
    .object({
      config: z
        .object({
          url: z.coerce.string(),
          content_type: z.coerce.string().optional(),
          secret: z.coerce.string().optional(),
          insecure_ssl: z.union([z.coerce.string(), z.coerce.number()]),
        })
        .optional(),
      events: z.array(z.coerce.string()).optional(),
      active: z.coerce.boolean().optional(),
      name: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "orgsUpdateWebhook",
    "/orgs/:org/hooks/:hookId",
    paramValidationFactory<t_OrgsUpdateWebhookParamSchema>(
      orgsUpdateWebhookParamSchema
    ),
    bodyValidationFactory<t_OrgsUpdateWebhookBodySchema>(
      orgsUpdateWebhookBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsUpdateWebhookParamSchema,
        void,
        t_OrgsUpdateWebhookBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsUpdateWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsDeleteWebhookParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.delete(
    "orgsDeleteWebhook",
    "/orgs/:org/hooks/:hookId",
    paramValidationFactory<t_OrgsDeleteWebhookParamSchema>(
      orgsDeleteWebhookParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsDeleteWebhookParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsDeleteWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsGetWebhookConfigForOrgParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "orgsGetWebhookConfigForOrg",
    "/orgs/:org/hooks/:hookId/config",
    paramValidationFactory<t_OrgsGetWebhookConfigForOrgParamSchema>(
      orgsGetWebhookConfigForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsGetWebhookConfigForOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsGetWebhookConfigForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsUpdateWebhookConfigForOrgParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  const orgsUpdateWebhookConfigForOrgBodySchema = z
    .object({
      url: z.coerce.string().optional(),
      content_type: z.coerce.string().optional(),
      secret: z.coerce.string().optional(),
      insecure_ssl: z.union([z.coerce.string(), z.coerce.number()]),
    })
    .optional()

  router.patch(
    "orgsUpdateWebhookConfigForOrg",
    "/orgs/:org/hooks/:hookId/config",
    paramValidationFactory<t_OrgsUpdateWebhookConfigForOrgParamSchema>(
      orgsUpdateWebhookConfigForOrgParamSchema
    ),
    bodyValidationFactory<t_OrgsUpdateWebhookConfigForOrgBodySchema>(
      orgsUpdateWebhookConfigForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsUpdateWebhookConfigForOrgParamSchema,
        void,
        t_OrgsUpdateWebhookConfigForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsUpdateWebhookConfigForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListWebhookDeliveriesParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  const orgsListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    cursor: z.coerce.string().optional(),
    redelivery: z.coerce.boolean().optional(),
  })

  router.get(
    "orgsListWebhookDeliveries",
    "/orgs/:org/hooks/:hookId/deliveries",
    paramValidationFactory<t_OrgsListWebhookDeliveriesParamSchema>(
      orgsListWebhookDeliveriesParamSchema
    ),
    queryValidationFactory<t_OrgsListWebhookDeliveriesQuerySchema>(
      orgsListWebhookDeliveriesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListWebhookDeliveriesParamSchema,
        t_OrgsListWebhookDeliveriesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListWebhookDeliveries(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsGetWebhookDeliveryParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.get(
    "orgsGetWebhookDelivery",
    "/orgs/:org/hooks/:hookId/deliveries/:deliveryId",
    paramValidationFactory<t_OrgsGetWebhookDeliveryParamSchema>(
      orgsGetWebhookDeliveryParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsGetWebhookDeliveryParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsGetWebhookDelivery(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsRedeliverWebhookDeliveryParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.post(
    "orgsRedeliverWebhookDelivery",
    "/orgs/:org/hooks/:hookId/deliveries/:deliveryId/attempts",
    paramValidationFactory<t_OrgsRedeliverWebhookDeliveryParamSchema>(
      orgsRedeliverWebhookDeliveryParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsRedeliverWebhookDeliveryParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsRedeliverWebhookDelivery(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsPingWebhookParamSchema = z.object({
    org: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.post(
    "orgsPingWebhook",
    "/orgs/:org/hooks/:hookId/pings",
    paramValidationFactory<t_OrgsPingWebhookParamSchema>(
      orgsPingWebhookParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsPingWebhookParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsPingWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetOrgInstallationParamSchema = z.object({ org: z.coerce.string() })

  router.get(
    "appsGetOrgInstallation",
    "/orgs/:org/installation",
    paramValidationFactory<t_AppsGetOrgInstallationParamSchema>(
      appsGetOrgInstallationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsGetOrgInstallationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsGetOrgInstallation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListAppInstallationsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const orgsListAppInstallationsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListAppInstallations",
    "/orgs/:org/installations",
    paramValidationFactory<t_OrgsListAppInstallationsParamSchema>(
      orgsListAppInstallationsParamSchema
    ),
    queryValidationFactory<t_OrgsListAppInstallationsQuerySchema>(
      orgsListAppInstallationsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListAppInstallationsParamSchema,
        t_OrgsListAppInstallationsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListAppInstallations(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const interactionsGetRestrictionsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "interactionsGetRestrictionsForOrg",
    "/orgs/:org/interaction-limits",
    paramValidationFactory<t_InteractionsGetRestrictionsForOrgParamSchema>(
      interactionsGetRestrictionsForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_InteractionsGetRestrictionsForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.interactionsGetRestrictionsForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const interactionsSetRestrictionsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const interactionsSetRestrictionsForOrgBodySchema = z.object({
    limit: z.enum([
      "existing_users",
      "contributors_only",
      "collaborators_only",
    ]),
    expiry: z
      .enum(["one_day", "three_days", "one_week", "one_month", "six_months"])
      .optional(),
  })

  router.put(
    "interactionsSetRestrictionsForOrg",
    "/orgs/:org/interaction-limits",
    paramValidationFactory<t_InteractionsSetRestrictionsForOrgParamSchema>(
      interactionsSetRestrictionsForOrgParamSchema
    ),
    bodyValidationFactory<t_InteractionsSetRestrictionsForOrgBodySchema>(
      interactionsSetRestrictionsForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_InteractionsSetRestrictionsForOrgParamSchema,
        void,
        t_InteractionsSetRestrictionsForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.interactionsSetRestrictionsForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const interactionsRemoveRestrictionsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.delete(
    "interactionsRemoveRestrictionsForOrg",
    "/orgs/:org/interaction-limits",
    paramValidationFactory<t_InteractionsRemoveRestrictionsForOrgParamSchema>(
      interactionsRemoveRestrictionsForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_InteractionsRemoveRestrictionsForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.interactionsRemoveRestrictionsForOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListPendingInvitationsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const orgsListPendingInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListPendingInvitations",
    "/orgs/:org/invitations",
    paramValidationFactory<t_OrgsListPendingInvitationsParamSchema>(
      orgsListPendingInvitationsParamSchema
    ),
    queryValidationFactory<t_OrgsListPendingInvitationsQuerySchema>(
      orgsListPendingInvitationsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListPendingInvitationsParamSchema,
        t_OrgsListPendingInvitationsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListPendingInvitations(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsCreateInvitationParamSchema = z.object({ org: z.coerce.string() })

  const orgsCreateInvitationBodySchema = z
    .object({
      invitee_id: z.coerce.number().optional(),
      email: z.coerce.string().optional(),
      role: z.enum(["admin", "direct_member", "billing_manager"]).optional(),
      team_ids: z.array(z.coerce.number()).optional(),
    })
    .optional()

  router.post(
    "orgsCreateInvitation",
    "/orgs/:org/invitations",
    paramValidationFactory<t_OrgsCreateInvitationParamSchema>(
      orgsCreateInvitationParamSchema
    ),
    bodyValidationFactory<t_OrgsCreateInvitationBodySchema>(
      orgsCreateInvitationBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsCreateInvitationParamSchema,
        void,
        t_OrgsCreateInvitationBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsCreateInvitation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsCancelInvitationParamSchema = z.object({
    org: z.coerce.string(),
    invitation_id: z.coerce.number(),
  })

  router.delete(
    "orgsCancelInvitation",
    "/orgs/:org/invitations/:invitationId",
    paramValidationFactory<t_OrgsCancelInvitationParamSchema>(
      orgsCancelInvitationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsCancelInvitationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsCancelInvitation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListInvitationTeamsParamSchema = z.object({
    org: z.coerce.string(),
    invitation_id: z.coerce.number(),
  })

  const orgsListInvitationTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListInvitationTeams",
    "/orgs/:org/invitations/:invitationId/teams",
    paramValidationFactory<t_OrgsListInvitationTeamsParamSchema>(
      orgsListInvitationTeamsParamSchema
    ),
    queryValidationFactory<t_OrgsListInvitationTeamsQuerySchema>(
      orgsListInvitationTeamsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListInvitationTeamsParamSchema,
        t_OrgsListInvitationTeamsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListInvitationTeams(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListForOrgParamSchema = z.object({ org: z.coerce.string() })

  const issuesListForOrgQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional(),
    state: z.enum(["open", "closed", "all"]).optional(),
    labels: z.coerce.string().optional(),
    sort: z.enum(["created", "updated", "comments"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListForOrg",
    "/orgs/:org/issues",
    paramValidationFactory<t_IssuesListForOrgParamSchema>(
      issuesListForOrgParamSchema
    ),
    queryValidationFactory<t_IssuesListForOrgQuerySchema>(
      issuesListForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListForOrgParamSchema,
        t_IssuesListForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListMembersParamSchema = z.object({ org: z.coerce.string() })

  const orgsListMembersQuerySchema = z.object({
    filter: z.enum(["2fa_disabled", "all"]).optional(),
    role: z.enum(["all", "admin", "member"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListMembers",
    "/orgs/:org/members",
    paramValidationFactory<t_OrgsListMembersParamSchema>(
      orgsListMembersParamSchema
    ),
    queryValidationFactory<t_OrgsListMembersQuerySchema>(
      orgsListMembersQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListMembersParamSchema,
        t_OrgsListMembersQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListMembers(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsCheckMembershipForUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "orgsCheckMembershipForUser",
    "/orgs/:org/members/:username",
    paramValidationFactory<t_OrgsCheckMembershipForUserParamSchema>(
      orgsCheckMembershipForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsCheckMembershipForUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsCheckMembershipForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsRemoveMemberParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "orgsRemoveMember",
    "/orgs/:org/members/:username",
    paramValidationFactory<t_OrgsRemoveMemberParamSchema>(
      orgsRemoveMemberParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsRemoveMemberParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsRemoveMember(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetCodespacesForUserInOrgParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  const codespacesGetCodespacesForUserInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "codespacesGetCodespacesForUserInOrg",
    "/orgs/:org/members/:username/codespaces",
    paramValidationFactory<t_CodespacesGetCodespacesForUserInOrgParamSchema>(
      codespacesGetCodespacesForUserInOrgParamSchema
    ),
    queryValidationFactory<t_CodespacesGetCodespacesForUserInOrgQuerySchema>(
      codespacesGetCodespacesForUserInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesGetCodespacesForUserInOrgParamSchema,
        t_CodespacesGetCodespacesForUserInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesGetCodespacesForUserInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesDeleteFromOrganizationParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
    codespace_name: z.coerce.string(),
  })

  router.delete(
    "codespacesDeleteFromOrganization",
    "/orgs/:org/members/:username/codespaces/:codespaceName",
    paramValidationFactory<t_CodespacesDeleteFromOrganizationParamSchema>(
      codespacesDeleteFromOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesDeleteFromOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesDeleteFromOrganization(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesStopInOrganizationParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
    codespace_name: z.coerce.string(),
  })

  router.post(
    "codespacesStopInOrganization",
    "/orgs/:org/members/:username/codespaces/:codespaceName/stop",
    paramValidationFactory<t_CodespacesStopInOrganizationParamSchema>(
      codespacesStopInOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodespacesStopInOrganizationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesStopInOrganization(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsGetMembershipForUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "orgsGetMembershipForUser",
    "/orgs/:org/memberships/:username",
    paramValidationFactory<t_OrgsGetMembershipForUserParamSchema>(
      orgsGetMembershipForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsGetMembershipForUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsGetMembershipForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsSetMembershipForUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  const orgsSetMembershipForUserBodySchema = z
    .object({ role: z.enum(["admin", "member"]).optional() })
    .optional()

  router.put(
    "orgsSetMembershipForUser",
    "/orgs/:org/memberships/:username",
    paramValidationFactory<t_OrgsSetMembershipForUserParamSchema>(
      orgsSetMembershipForUserParamSchema
    ),
    bodyValidationFactory<t_OrgsSetMembershipForUserBodySchema>(
      orgsSetMembershipForUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsSetMembershipForUserParamSchema,
        void,
        t_OrgsSetMembershipForUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsSetMembershipForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsRemoveMembershipForUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "orgsRemoveMembershipForUser",
    "/orgs/:org/memberships/:username",
    paramValidationFactory<t_OrgsRemoveMembershipForUserParamSchema>(
      orgsRemoveMembershipForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsRemoveMembershipForUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsRemoveMembershipForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsListForOrgParamSchema = z.object({ org: z.coerce.string() })

  const migrationsListForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    exclude: z.array(z.enum(["repositories"])).optional(),
  })

  router.get(
    "migrationsListForOrg",
    "/orgs/:org/migrations",
    paramValidationFactory<t_MigrationsListForOrgParamSchema>(
      migrationsListForOrgParamSchema
    ),
    queryValidationFactory<t_MigrationsListForOrgQuerySchema>(
      migrationsListForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsListForOrgParamSchema,
        t_MigrationsListForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsListForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsStartForOrgParamSchema = z.object({ org: z.coerce.string() })

  const migrationsStartForOrgBodySchema = z.object({
    repositories: z.array(z.coerce.string()),
    lock_repositories: z.coerce.boolean().optional(),
    exclude_metadata: z.coerce.boolean().optional(),
    exclude_git_data: z.coerce.boolean().optional(),
    exclude_attachments: z.coerce.boolean().optional(),
    exclude_releases: z.coerce.boolean().optional(),
    exclude_owner_projects: z.coerce.boolean().optional(),
    org_metadata_only: z.coerce.boolean().optional(),
    exclude: z.array(z.enum(["repositories"])).optional(),
  })

  router.post(
    "migrationsStartForOrg",
    "/orgs/:org/migrations",
    paramValidationFactory<t_MigrationsStartForOrgParamSchema>(
      migrationsStartForOrgParamSchema
    ),
    bodyValidationFactory<t_MigrationsStartForOrgBodySchema>(
      migrationsStartForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsStartForOrgParamSchema,
        void,
        t_MigrationsStartForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsStartForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsGetStatusForOrgParamSchema = z.object({
    org: z.coerce.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsGetStatusForOrgQuerySchema = z.object({
    exclude: z.array(z.enum(["repositories"])).optional(),
  })

  router.get(
    "migrationsGetStatusForOrg",
    "/orgs/:org/migrations/:migrationId",
    paramValidationFactory<t_MigrationsGetStatusForOrgParamSchema>(
      migrationsGetStatusForOrgParamSchema
    ),
    queryValidationFactory<t_MigrationsGetStatusForOrgQuerySchema>(
      migrationsGetStatusForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsGetStatusForOrgParamSchema,
        t_MigrationsGetStatusForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsGetStatusForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsDownloadArchiveForOrgParamSchema = z.object({
    org: z.coerce.string(),
    migration_id: z.coerce.number(),
  })

  router.get(
    "migrationsDownloadArchiveForOrg",
    "/orgs/:org/migrations/:migrationId/archive",
    paramValidationFactory<t_MigrationsDownloadArchiveForOrgParamSchema>(
      migrationsDownloadArchiveForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsDownloadArchiveForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsDownloadArchiveForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsDeleteArchiveForOrgParamSchema = z.object({
    org: z.coerce.string(),
    migration_id: z.coerce.number(),
  })

  router.delete(
    "migrationsDeleteArchiveForOrg",
    "/orgs/:org/migrations/:migrationId/archive",
    paramValidationFactory<t_MigrationsDeleteArchiveForOrgParamSchema>(
      migrationsDeleteArchiveForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_MigrationsDeleteArchiveForOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsDeleteArchiveForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsUnlockRepoForOrgParamSchema = z.object({
    org: z.coerce.string(),
    migration_id: z.coerce.number(),
    repo_name: z.coerce.string(),
  })

  router.delete(
    "migrationsUnlockRepoForOrg",
    "/orgs/:org/migrations/:migrationId/repos/:repoName/lock",
    paramValidationFactory<t_MigrationsUnlockRepoForOrgParamSchema>(
      migrationsUnlockRepoForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_MigrationsUnlockRepoForOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsUnlockRepoForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsListReposForOrgParamSchema = z.object({
    org: z.coerce.string(),
    migration_id: z.coerce.number(),
  })

  const migrationsListReposForOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "migrationsListReposForOrg",
    "/orgs/:org/migrations/:migrationId/repositories",
    paramValidationFactory<t_MigrationsListReposForOrgParamSchema>(
      migrationsListReposForOrgParamSchema
    ),
    queryValidationFactory<t_MigrationsListReposForOrgQuerySchema>(
      migrationsListReposForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsListReposForOrgParamSchema,
        t_MigrationsListReposForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsListReposForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListOutsideCollaboratorsParamSchema = z.object({
    org: z.coerce.string(),
  })

  const orgsListOutsideCollaboratorsQuerySchema = z.object({
    filter: z.enum(["2fa_disabled", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListOutsideCollaborators",
    "/orgs/:org/outside_collaborators",
    paramValidationFactory<t_OrgsListOutsideCollaboratorsParamSchema>(
      orgsListOutsideCollaboratorsParamSchema
    ),
    queryValidationFactory<t_OrgsListOutsideCollaboratorsQuerySchema>(
      orgsListOutsideCollaboratorsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListOutsideCollaboratorsParamSchema,
        t_OrgsListOutsideCollaboratorsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsListOutsideCollaborators(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsConvertMemberToOutsideCollaboratorParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  const orgsConvertMemberToOutsideCollaboratorBodySchema = z
    .object({ async: z.coerce.boolean().optional() })
    .optional()

  router.put(
    "orgsConvertMemberToOutsideCollaborator",
    "/orgs/:org/outside_collaborators/:username",
    paramValidationFactory<t_OrgsConvertMemberToOutsideCollaboratorParamSchema>(
      orgsConvertMemberToOutsideCollaboratorParamSchema
    ),
    bodyValidationFactory<t_OrgsConvertMemberToOutsideCollaboratorBodySchema>(
      orgsConvertMemberToOutsideCollaboratorBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsConvertMemberToOutsideCollaboratorParamSchema,
        void,
        t_OrgsConvertMemberToOutsideCollaboratorBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsConvertMemberToOutsideCollaborator(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsRemoveOutsideCollaboratorParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "orgsRemoveOutsideCollaborator",
    "/orgs/:org/outside_collaborators/:username",
    paramValidationFactory<t_OrgsRemoveOutsideCollaboratorParamSchema>(
      orgsRemoveOutsideCollaboratorParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsRemoveOutsideCollaboratorParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsRemoveOutsideCollaborator(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesListPackagesForOrganizationParamSchema = z.object({
    org: z.coerce.string(),
  })

  const packagesListPackagesForOrganizationQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
  })

  router.get(
    "packagesListPackagesForOrganization",
    "/orgs/:org/packages",
    paramValidationFactory<t_PackagesListPackagesForOrganizationParamSchema>(
      packagesListPackagesForOrganizationParamSchema
    ),
    queryValidationFactory<t_PackagesListPackagesForOrganizationQuerySchema>(
      packagesListPackagesForOrganizationQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesListPackagesForOrganizationParamSchema,
        t_PackagesListPackagesForOrganizationQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesListPackagesForOrganization(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetPackageForOrganizationParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    org: z.coerce.string(),
  })

  router.get(
    "packagesGetPackageForOrganization",
    "/orgs/:org/packages/:packageType/:packageName",
    paramValidationFactory<t_PackagesGetPackageForOrganizationParamSchema>(
      packagesGetPackageForOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetPackageForOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetPackageForOrganization(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesDeletePackageForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    org: z.coerce.string(),
  })

  router.delete(
    "packagesDeletePackageForOrg",
    "/orgs/:org/packages/:packageType/:packageName",
    paramValidationFactory<t_PackagesDeletePackageForOrgParamSchema>(
      packagesDeletePackageForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PackagesDeletePackageForOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.packagesDeletePackageForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesRestorePackageForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    org: z.coerce.string(),
  })

  const packagesRestorePackageForOrgQuerySchema = z.object({
    token: z.coerce.string().optional(),
  })

  router.post(
    "packagesRestorePackageForOrg",
    "/orgs/:org/packages/:packageType/:packageName/restore",
    paramValidationFactory<t_PackagesRestorePackageForOrgParamSchema>(
      packagesRestorePackageForOrgParamSchema
    ),
    queryValidationFactory<t_PackagesRestorePackageForOrgQuerySchema>(
      packagesRestorePackageForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesRestorePackageForOrgParamSchema,
        t_PackagesRestorePackageForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesRestorePackageForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema = z.object(
    {
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.coerce.string(),
      org: z.coerce.string(),
    }
  )

  const packagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema = z.object(
    {
      page: z.coerce.number().optional(),
      per_page: z.coerce.number().optional(),
      state: z.enum(["active", "deleted"]).optional(),
    }
  )

  router.get(
    "packagesGetAllPackageVersionsForPackageOwnedByOrg",
    "/orgs/:org/packages/:packageType/:packageName/versions",
    paramValidationFactory<t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema>(
      packagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema
    ),
    queryValidationFactory<t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema>(
      packagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetAllPackageVersionsForPackageOwnedByOrgParamSchema,
        t_PackagesGetAllPackageVersionsForPackageOwnedByOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetAllPackageVersionsForPackageOwnedByOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetPackageVersionForOrganizationParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    org: z.coerce.string(),
    package_version_id: z.coerce.number(),
  })

  router.get(
    "packagesGetPackageVersionForOrganization",
    "/orgs/:org/packages/:packageType/:packageName/versions/:packageVersionId",
    paramValidationFactory<t_PackagesGetPackageVersionForOrganizationParamSchema>(
      packagesGetPackageVersionForOrganizationParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetPackageVersionForOrganizationParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetPackageVersionForOrganization(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesDeletePackageVersionForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    org: z.coerce.string(),
    package_version_id: z.coerce.number(),
  })

  router.delete(
    "packagesDeletePackageVersionForOrg",
    "/orgs/:org/packages/:packageType/:packageName/versions/:packageVersionId",
    paramValidationFactory<t_PackagesDeletePackageVersionForOrgParamSchema>(
      packagesDeletePackageVersionForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesDeletePackageVersionForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesDeletePackageVersionForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesRestorePackageVersionForOrgParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    org: z.coerce.string(),
    package_version_id: z.coerce.number(),
  })

  router.post(
    "packagesRestorePackageVersionForOrg",
    "/orgs/:org/packages/:packageType/:packageName/versions/:packageVersionId/restore",
    paramValidationFactory<t_PackagesRestorePackageVersionForOrgParamSchema>(
      packagesRestorePackageVersionForOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesRestorePackageVersionForOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesRestorePackageVersionForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsListForOrgParamSchema = z.object({ org: z.coerce.string() })

  const projectsListForOrgQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "projectsListForOrg",
    "/orgs/:org/projects",
    paramValidationFactory<t_ProjectsListForOrgParamSchema>(
      projectsListForOrgParamSchema
    ),
    queryValidationFactory<t_ProjectsListForOrgQuerySchema>(
      projectsListForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsListForOrgParamSchema,
        t_ProjectsListForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsListForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsCreateForOrgParamSchema = z.object({ org: z.coerce.string() })

  const projectsCreateForOrgBodySchema = z.object({
    name: z.coerce.string(),
    body: z.coerce.string().optional(),
  })

  router.post(
    "projectsCreateForOrg",
    "/orgs/:org/projects",
    paramValidationFactory<t_ProjectsCreateForOrgParamSchema>(
      projectsCreateForOrgParamSchema
    ),
    bodyValidationFactory<t_ProjectsCreateForOrgBodySchema>(
      projectsCreateForOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsCreateForOrgParamSchema,
        void,
        t_ProjectsCreateForOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsCreateForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListPublicMembersParamSchema = z.object({ org: z.coerce.string() })

  const orgsListPublicMembersQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListPublicMembers",
    "/orgs/:org/public_members",
    paramValidationFactory<t_OrgsListPublicMembersParamSchema>(
      orgsListPublicMembersParamSchema
    ),
    queryValidationFactory<t_OrgsListPublicMembersQuerySchema>(
      orgsListPublicMembersQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListPublicMembersParamSchema,
        t_OrgsListPublicMembersQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListPublicMembers(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsCheckPublicMembershipForUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "orgsCheckPublicMembershipForUser",
    "/orgs/:org/public_members/:username",
    paramValidationFactory<t_OrgsCheckPublicMembershipForUserParamSchema>(
      orgsCheckPublicMembershipForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsCheckPublicMembershipForUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsCheckPublicMembershipForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsSetPublicMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.put(
    "orgsSetPublicMembershipForAuthenticatedUser",
    "/orgs/:org/public_members/:username",
    paramValidationFactory<t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema>(
      orgsSetPublicMembershipForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsSetPublicMembershipForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsSetPublicMembershipForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsRemovePublicMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "orgsRemovePublicMembershipForAuthenticatedUser",
    "/orgs/:org/public_members/:username",
    paramValidationFactory<t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema>(
      orgsRemovePublicMembershipForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsRemovePublicMembershipForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsRemovePublicMembershipForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListForOrgParamSchema = z.object({ org: z.coerce.string() })

  const reposListForOrgQuerySchema = z.object({
    type: z
      .enum(["all", "public", "private", "forks", "sources", "member"])
      .optional(),
    sort: z.enum(["created", "updated", "pushed", "full_name"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListForOrg",
    "/orgs/:org/repos",
    paramValidationFactory<t_ReposListForOrgParamSchema>(
      reposListForOrgParamSchema
    ),
    queryValidationFactory<t_ReposListForOrgQuerySchema>(
      reposListForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListForOrgParamSchema,
        t_ReposListForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListForOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateInOrgParamSchema = z.object({ org: z.coerce.string() })

  const reposCreateInOrgBodySchema = z.object({
    name: z.coerce.string(),
    description: z.coerce.string().optional(),
    homepage: z.coerce.string().optional(),
    private: z.coerce.boolean().optional(),
    visibility: z.enum(["public", "private"]).optional(),
    has_issues: z.coerce.boolean().optional(),
    has_projects: z.coerce.boolean().optional(),
    has_wiki: z.coerce.boolean().optional(),
    has_downloads: z.coerce.boolean().optional(),
    is_template: z.coerce.boolean().optional(),
    team_id: z.coerce.number().optional(),
    auto_init: z.coerce.boolean().optional(),
    gitignore_template: z.coerce.string().optional(),
    license_template: z.coerce.string().optional(),
    allow_squash_merge: z.coerce.boolean().optional(),
    allow_merge_commit: z.coerce.boolean().optional(),
    allow_rebase_merge: z.coerce.boolean().optional(),
    allow_auto_merge: z.coerce.boolean().optional(),
    delete_branch_on_merge: z.coerce.boolean().optional(),
    use_squash_pr_title_as_default: z.coerce.boolean().optional(),
    squash_merge_commit_title: z
      .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
      .optional(),
    squash_merge_commit_message: z
      .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
      .optional(),
    merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
    merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
  })

  router.post(
    "reposCreateInOrg",
    "/orgs/:org/repos",
    paramValidationFactory<t_ReposCreateInOrgParamSchema>(
      reposCreateInOrgParamSchema
    ),
    bodyValidationFactory<t_ReposCreateInOrgBodySchema>(
      reposCreateInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateInOrgParamSchema,
        void,
        t_ReposCreateInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningListAlertsForOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  const secretScanningListAlertsForOrgQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.coerce.string().optional(),
    resolution: z.coerce.string().optional(),
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
    before: z.coerce.string().optional(),
    after: z.coerce.string().optional(),
  })

  router.get(
    "secretScanningListAlertsForOrg",
    "/orgs/:org/secret-scanning/alerts",
    paramValidationFactory<t_SecretScanningListAlertsForOrgParamSchema>(
      secretScanningListAlertsForOrgParamSchema
    ),
    queryValidationFactory<t_SecretScanningListAlertsForOrgQuerySchema>(
      secretScanningListAlertsForOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningListAlertsForOrgParamSchema,
        t_SecretScanningListAlertsForOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.secretScanningListAlertsForOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListSecurityManagerTeamsParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "orgsListSecurityManagerTeams",
    "/orgs/:org/security-managers",
    paramValidationFactory<t_OrgsListSecurityManagerTeamsParamSchema>(
      orgsListSecurityManagerTeamsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsListSecurityManagerTeamsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsListSecurityManagerTeams(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsAddSecurityManagerTeamParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  router.put(
    "orgsAddSecurityManagerTeam",
    "/orgs/:org/security-managers/teams/:teamSlug",
    paramValidationFactory<t_OrgsAddSecurityManagerTeamParamSchema>(
      orgsAddSecurityManagerTeamParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsAddSecurityManagerTeamParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsAddSecurityManagerTeam(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsRemoveSecurityManagerTeamParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  router.delete(
    "orgsRemoveSecurityManagerTeam",
    "/orgs/:org/security-managers/teams/:teamSlug",
    paramValidationFactory<t_OrgsRemoveSecurityManagerTeamParamSchema>(
      orgsRemoveSecurityManagerTeamParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_OrgsRemoveSecurityManagerTeamParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsRemoveSecurityManagerTeam(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const billingGetGithubActionsBillingOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "billingGetGithubActionsBillingOrg",
    "/orgs/:org/settings/billing/actions",
    paramValidationFactory<t_BillingGetGithubActionsBillingOrgParamSchema>(
      billingGetGithubActionsBillingOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_BillingGetGithubActionsBillingOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.billingGetGithubActionsBillingOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const billingGetGithubPackagesBillingOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "billingGetGithubPackagesBillingOrg",
    "/orgs/:org/settings/billing/packages",
    paramValidationFactory<t_BillingGetGithubPackagesBillingOrgParamSchema>(
      billingGetGithubPackagesBillingOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_BillingGetGithubPackagesBillingOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.billingGetGithubPackagesBillingOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const billingGetSharedStorageBillingOrgParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "billingGetSharedStorageBillingOrg",
    "/orgs/:org/settings/billing/shared-storage",
    paramValidationFactory<t_BillingGetSharedStorageBillingOrgParamSchema>(
      billingGetSharedStorageBillingOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_BillingGetSharedStorageBillingOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.billingGetSharedStorageBillingOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListParamSchema = z.object({ org: z.coerce.string() })

  const teamsListQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsList",
    "/orgs/:org/teams",
    paramValidationFactory<t_TeamsListParamSchema>(teamsListParamSchema),
    queryValidationFactory<t_TeamsListQuerySchema>(teamsListQuerySchema),
    async (
      ctx: ValidatedCtx<t_TeamsListParamSchema, t_TeamsListQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsList(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCreateParamSchema = z.object({ org: z.coerce.string() })

  const teamsCreateBodySchema = z.object({
    name: z.coerce.string(),
    description: z.coerce.string().optional(),
    maintainers: z.array(z.coerce.string()).optional(),
    repo_names: z.array(z.coerce.string()).optional(),
    privacy: z.enum(["secret", "closed"]).optional(),
    permission: z.enum(["pull", "push"]).optional(),
    parent_team_id: z.coerce.number().optional(),
  })

  router.post(
    "teamsCreate",
    "/orgs/:org/teams",
    paramValidationFactory<t_TeamsCreateParamSchema>(teamsCreateParamSchema),
    bodyValidationFactory<t_TeamsCreateBodySchema>(teamsCreateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_TeamsCreateParamSchema,
        void,
        t_TeamsCreateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsCreate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetByNameParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  router.get(
    "teamsGetByName",
    "/orgs/:org/teams/:teamSlug",
    paramValidationFactory<t_TeamsGetByNameParamSchema>(
      teamsGetByNameParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsGetByNameParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsGetByName(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsUpdateInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsUpdateInOrgBodySchema = z
    .object({
      name: z.coerce.string().optional(),
      description: z.coerce.string().optional(),
      privacy: z.enum(["secret", "closed"]).optional(),
      permission: z.enum(["pull", "push", "admin"]).optional(),
      parent_team_id: z.coerce.number().optional(),
    })
    .optional()

  router.patch(
    "teamsUpdateInOrg",
    "/orgs/:org/teams/:teamSlug",
    paramValidationFactory<t_TeamsUpdateInOrgParamSchema>(
      teamsUpdateInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsUpdateInOrgBodySchema>(
      teamsUpdateInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsUpdateInOrgParamSchema,
        void,
        t_TeamsUpdateInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsUpdateInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsDeleteInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  router.delete(
    "teamsDeleteInOrg",
    "/orgs/:org/teams/:teamSlug",
    paramValidationFactory<t_TeamsDeleteInOrgParamSchema>(
      teamsDeleteInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsDeleteInOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsDeleteInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListDiscussionsInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsListDiscussionsInOrgQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    pinned: z.coerce.string().optional(),
  })

  router.get(
    "teamsListDiscussionsInOrg",
    "/orgs/:org/teams/:teamSlug/discussions",
    paramValidationFactory<t_TeamsListDiscussionsInOrgParamSchema>(
      teamsListDiscussionsInOrgParamSchema
    ),
    queryValidationFactory<t_TeamsListDiscussionsInOrgQuerySchema>(
      teamsListDiscussionsInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListDiscussionsInOrgParamSchema,
        t_TeamsListDiscussionsInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListDiscussionsInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCreateDiscussionInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsCreateDiscussionInOrgBodySchema = z.object({
    title: z.coerce.string(),
    body: z.coerce.string(),
    private: z.coerce.boolean().optional(),
  })

  router.post(
    "teamsCreateDiscussionInOrg",
    "/orgs/:org/teams/:teamSlug/discussions",
    paramValidationFactory<t_TeamsCreateDiscussionInOrgParamSchema>(
      teamsCreateDiscussionInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsCreateDiscussionInOrgBodySchema>(
      teamsCreateDiscussionInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCreateDiscussionInOrgParamSchema,
        void,
        t_TeamsCreateDiscussionInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsCreateDiscussionInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetDiscussionInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber",
    paramValidationFactory<t_TeamsGetDiscussionInOrgParamSchema>(
      teamsGetDiscussionInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsGetDiscussionInOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsGetDiscussionInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsUpdateDiscussionInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionInOrgBodySchema = z
    .object({
      title: z.coerce.string().optional(),
      body: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "teamsUpdateDiscussionInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber",
    paramValidationFactory<t_TeamsUpdateDiscussionInOrgParamSchema>(
      teamsUpdateDiscussionInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsUpdateDiscussionInOrgBodySchema>(
      teamsUpdateDiscussionInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsUpdateDiscussionInOrgParamSchema,
        void,
        t_TeamsUpdateDiscussionInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsUpdateDiscussionInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsDeleteDiscussionInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber",
    paramValidationFactory<t_TeamsDeleteDiscussionInOrgParamSchema>(
      teamsDeleteDiscussionInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsDeleteDiscussionInOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsDeleteDiscussionInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListDiscussionCommentsInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsListDiscussionCommentsInOrgQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListDiscussionCommentsInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments",
    paramValidationFactory<t_TeamsListDiscussionCommentsInOrgParamSchema>(
      teamsListDiscussionCommentsInOrgParamSchema
    ),
    queryValidationFactory<t_TeamsListDiscussionCommentsInOrgQuerySchema>(
      teamsListDiscussionCommentsInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListDiscussionCommentsInOrgParamSchema,
        t_TeamsListDiscussionCommentsInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsListDiscussionCommentsInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCreateDiscussionCommentInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
  })

  const teamsCreateDiscussionCommentInOrgBodySchema = z.object({
    body: z.coerce.string(),
  })

  router.post(
    "teamsCreateDiscussionCommentInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments",
    paramValidationFactory<t_TeamsCreateDiscussionCommentInOrgParamSchema>(
      teamsCreateDiscussionCommentInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsCreateDiscussionCommentInOrgBodySchema>(
      teamsCreateDiscussionCommentInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCreateDiscussionCommentInOrgParamSchema,
        void,
        t_TeamsCreateDiscussionCommentInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsCreateDiscussionCommentInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetDiscussionCommentInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionCommentInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments/:commentNumber",
    paramValidationFactory<t_TeamsGetDiscussionCommentInOrgParamSchema>(
      teamsGetDiscussionCommentInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsGetDiscussionCommentInOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsGetDiscussionCommentInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsUpdateDiscussionCommentInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionCommentInOrgBodySchema = z.object({
    body: z.coerce.string(),
  })

  router.patch(
    "teamsUpdateDiscussionCommentInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments/:commentNumber",
    paramValidationFactory<t_TeamsUpdateDiscussionCommentInOrgParamSchema>(
      teamsUpdateDiscussionCommentInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsUpdateDiscussionCommentInOrgBodySchema>(
      teamsUpdateDiscussionCommentInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsUpdateDiscussionCommentInOrgParamSchema,
        void,
        t_TeamsUpdateDiscussionCommentInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsUpdateDiscussionCommentInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsDeleteDiscussionCommentInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionCommentInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments/:commentNumber",
    paramValidationFactory<t_TeamsDeleteDiscussionCommentInOrgParamSchema>(
      teamsDeleteDiscussionCommentInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsDeleteDiscussionCommentInOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsDeleteDiscussionCommentInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForTeamDiscussionCommentInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionCommentInOrgQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForTeamDiscussionCommentInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments/:commentNumber/reactions",
    paramValidationFactory<t_ReactionsListForTeamDiscussionCommentInOrgParamSchema>(
      reactionsListForTeamDiscussionCommentInOrgParamSchema
    ),
    queryValidationFactory<t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema>(
      reactionsListForTeamDiscussionCommentInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForTeamDiscussionCommentInOrgParamSchema,
        t_ReactionsListForTeamDiscussionCommentInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsListForTeamDiscussionCommentInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForTeamDiscussionCommentInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionCommentInOrgBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionCommentInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments/:commentNumber/reactions",
    paramValidationFactory<t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema>(
      reactionsCreateForTeamDiscussionCommentInOrgParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForTeamDiscussionCommentInOrgBodySchema>(
      reactionsCreateForTeamDiscussionCommentInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForTeamDiscussionCommentInOrgParamSchema,
        void,
        t_ReactionsCreateForTeamDiscussionCommentInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsCreateForTeamDiscussionCommentInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsDeleteForTeamDiscussionCommentParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForTeamDiscussionComment",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/comments/:commentNumber/reactions/:reactionId",
    paramValidationFactory<t_ReactionsDeleteForTeamDiscussionCommentParamSchema>(
      reactionsDeleteForTeamDiscussionCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsDeleteForTeamDiscussionCommentParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsDeleteForTeamDiscussionComment(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForTeamDiscussionInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionInOrgQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForTeamDiscussionInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/reactions",
    paramValidationFactory<t_ReactionsListForTeamDiscussionInOrgParamSchema>(
      reactionsListForTeamDiscussionInOrgParamSchema
    ),
    queryValidationFactory<t_ReactionsListForTeamDiscussionInOrgQuerySchema>(
      reactionsListForTeamDiscussionInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForTeamDiscussionInOrgParamSchema,
        t_ReactionsListForTeamDiscussionInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsListForTeamDiscussionInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForTeamDiscussionInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionInOrgBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionInOrg",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/reactions",
    paramValidationFactory<t_ReactionsCreateForTeamDiscussionInOrgParamSchema>(
      reactionsCreateForTeamDiscussionInOrgParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForTeamDiscussionInOrgBodySchema>(
      reactionsCreateForTeamDiscussionInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForTeamDiscussionInOrgParamSchema,
        void,
        t_ReactionsCreateForTeamDiscussionInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsCreateForTeamDiscussionInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsDeleteForTeamDiscussionParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    discussion_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForTeamDiscussion",
    "/orgs/:org/teams/:teamSlug/discussions/:discussionNumber/reactions/:reactionId",
    paramValidationFactory<t_ReactionsDeleteForTeamDiscussionParamSchema>(
      reactionsDeleteForTeamDiscussionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsDeleteForTeamDiscussionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsDeleteForTeamDiscussion(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListPendingInvitationsInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsListPendingInvitationsInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListPendingInvitationsInOrg",
    "/orgs/:org/teams/:teamSlug/invitations",
    paramValidationFactory<t_TeamsListPendingInvitationsInOrgParamSchema>(
      teamsListPendingInvitationsInOrgParamSchema
    ),
    queryValidationFactory<t_TeamsListPendingInvitationsInOrgQuerySchema>(
      teamsListPendingInvitationsInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListPendingInvitationsInOrgParamSchema,
        t_TeamsListPendingInvitationsInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsListPendingInvitationsInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListMembersInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsListMembersInOrgQuerySchema = z.object({
    role: z.enum(["member", "maintainer", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListMembersInOrg",
    "/orgs/:org/teams/:teamSlug/members",
    paramValidationFactory<t_TeamsListMembersInOrgParamSchema>(
      teamsListMembersInOrgParamSchema
    ),
    queryValidationFactory<t_TeamsListMembersInOrgQuerySchema>(
      teamsListMembersInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListMembersInOrgParamSchema,
        t_TeamsListMembersInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListMembersInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetMembershipForUserInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "teamsGetMembershipForUserInOrg",
    "/orgs/:org/teams/:teamSlug/memberships/:username",
    paramValidationFactory<t_TeamsGetMembershipForUserInOrgParamSchema>(
      teamsGetMembershipForUserInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsGetMembershipForUserInOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsGetMembershipForUserInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsAddOrUpdateMembershipForUserInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    username: z.coerce.string(),
  })

  const teamsAddOrUpdateMembershipForUserInOrgBodySchema = z
    .object({ role: z.enum(["member", "maintainer"]).optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateMembershipForUserInOrg",
    "/orgs/:org/teams/:teamSlug/memberships/:username",
    paramValidationFactory<t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema>(
      teamsAddOrUpdateMembershipForUserInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsAddOrUpdateMembershipForUserInOrgBodySchema>(
      teamsAddOrUpdateMembershipForUserInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsAddOrUpdateMembershipForUserInOrgParamSchema,
        void,
        t_TeamsAddOrUpdateMembershipForUserInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsAddOrUpdateMembershipForUserInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsRemoveMembershipForUserInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "teamsRemoveMembershipForUserInOrg",
    "/orgs/:org/teams/:teamSlug/memberships/:username",
    paramValidationFactory<t_TeamsRemoveMembershipForUserInOrgParamSchema>(
      teamsRemoveMembershipForUserInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsRemoveMembershipForUserInOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsRemoveMembershipForUserInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListProjectsInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsListProjectsInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListProjectsInOrg",
    "/orgs/:org/teams/:teamSlug/projects",
    paramValidationFactory<t_TeamsListProjectsInOrgParamSchema>(
      teamsListProjectsInOrgParamSchema
    ),
    queryValidationFactory<t_TeamsListProjectsInOrgQuerySchema>(
      teamsListProjectsInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListProjectsInOrgParamSchema,
        t_TeamsListProjectsInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListProjectsInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCheckPermissionsForProjectInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    project_id: z.coerce.number(),
  })

  router.get(
    "teamsCheckPermissionsForProjectInOrg",
    "/orgs/:org/teams/:teamSlug/projects/:projectId",
    paramValidationFactory<t_TeamsCheckPermissionsForProjectInOrgParamSchema>(
      teamsCheckPermissionsForProjectInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCheckPermissionsForProjectInOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsCheckPermissionsForProjectInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsAddOrUpdateProjectPermissionsInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    project_id: z.coerce.number(),
  })

  const teamsAddOrUpdateProjectPermissionsInOrgBodySchema = z
    .object({ permission: z.enum(["read", "write", "admin"]).optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateProjectPermissionsInOrg",
    "/orgs/:org/teams/:teamSlug/projects/:projectId",
    paramValidationFactory<t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema>(
      teamsAddOrUpdateProjectPermissionsInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsAddOrUpdateProjectPermissionsInOrgBodySchema>(
      teamsAddOrUpdateProjectPermissionsInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsAddOrUpdateProjectPermissionsInOrgParamSchema,
        void,
        t_TeamsAddOrUpdateProjectPermissionsInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsAddOrUpdateProjectPermissionsInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsRemoveProjectInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    project_id: z.coerce.number(),
  })

  router.delete(
    "teamsRemoveProjectInOrg",
    "/orgs/:org/teams/:teamSlug/projects/:projectId",
    paramValidationFactory<t_TeamsRemoveProjectInOrgParamSchema>(
      teamsRemoveProjectInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsRemoveProjectInOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsRemoveProjectInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListReposInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsListReposInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListReposInOrg",
    "/orgs/:org/teams/:teamSlug/repos",
    paramValidationFactory<t_TeamsListReposInOrgParamSchema>(
      teamsListReposInOrgParamSchema
    ),
    queryValidationFactory<t_TeamsListReposInOrgQuerySchema>(
      teamsListReposInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListReposInOrgParamSchema,
        t_TeamsListReposInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListReposInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCheckPermissionsForRepoInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "teamsCheckPermissionsForRepoInOrg",
    "/orgs/:org/teams/:teamSlug/repos/:owner/:repo",
    paramValidationFactory<t_TeamsCheckPermissionsForRepoInOrgParamSchema>(
      teamsCheckPermissionsForRepoInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCheckPermissionsForRepoInOrgParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsCheckPermissionsForRepoInOrg(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsAddOrUpdateRepoPermissionsInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const teamsAddOrUpdateRepoPermissionsInOrgBodySchema = z
    .object({ permission: z.coerce.string().optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateRepoPermissionsInOrg",
    "/orgs/:org/teams/:teamSlug/repos/:owner/:repo",
    paramValidationFactory<t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema>(
      teamsAddOrUpdateRepoPermissionsInOrgParamSchema
    ),
    bodyValidationFactory<t_TeamsAddOrUpdateRepoPermissionsInOrgBodySchema>(
      teamsAddOrUpdateRepoPermissionsInOrgBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsAddOrUpdateRepoPermissionsInOrgParamSchema,
        void,
        t_TeamsAddOrUpdateRepoPermissionsInOrgBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsAddOrUpdateRepoPermissionsInOrg(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsRemoveRepoInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "teamsRemoveRepoInOrg",
    "/orgs/:org/teams/:teamSlug/repos/:owner/:repo",
    paramValidationFactory<t_TeamsRemoveRepoInOrgParamSchema>(
      teamsRemoveRepoInOrgParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsRemoveRepoInOrgParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsRemoveRepoInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListChildInOrgParamSchema = z.object({
    org: z.coerce.string(),
    team_slug: z.coerce.string(),
  })

  const teamsListChildInOrgQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListChildInOrg",
    "/orgs/:org/teams/:teamSlug/teams",
    paramValidationFactory<t_TeamsListChildInOrgParamSchema>(
      teamsListChildInOrgParamSchema
    ),
    queryValidationFactory<t_TeamsListChildInOrgQuerySchema>(
      teamsListChildInOrgQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListChildInOrgParamSchema,
        t_TeamsListChildInOrgQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListChildInOrg(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema = z.object({
    org: z.coerce.string(),
    security_product: z.enum([
      "dependency_graph",
      "dependabot_alerts",
      "dependabot_security_updates",
      "advanced_security",
      "secret_scanning",
      "secret_scanning_push_protection",
    ]),
    enablement: z.enum(["enable_all", "disable_all"]),
  })

  router.post(
    "orgsEnableOrDisableSecurityProductOnAllOrgRepos",
    "/orgs/:org/:securityProduct/:enablement",
    paramValidationFactory<t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema>(
      orgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsEnableOrDisableSecurityProductOnAllOrgReposParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsEnableOrDisableSecurityProductOnAllOrgRepos(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsGetCardParamSchema = z.object({ card_id: z.coerce.number() })

  router.get(
    "projectsGetCard",
    "/projects/columns/cards/:cardId",
    paramValidationFactory<t_ProjectsGetCardParamSchema>(
      projectsGetCardParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ProjectsGetCardParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsGetCard(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsUpdateCardParamSchema = z.object({ card_id: z.coerce.number() })

  const projectsUpdateCardBodySchema = z
    .object({
      note: z.coerce.string().optional(),
      archived: z.coerce.boolean().optional(),
    })
    .optional()

  router.patch(
    "projectsUpdateCard",
    "/projects/columns/cards/:cardId",
    paramValidationFactory<t_ProjectsUpdateCardParamSchema>(
      projectsUpdateCardParamSchema
    ),
    bodyValidationFactory<t_ProjectsUpdateCardBodySchema>(
      projectsUpdateCardBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsUpdateCardParamSchema,
        void,
        t_ProjectsUpdateCardBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsUpdateCard(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsDeleteCardParamSchema = z.object({ card_id: z.coerce.number() })

  router.delete(
    "projectsDeleteCard",
    "/projects/columns/cards/:cardId",
    paramValidationFactory<t_ProjectsDeleteCardParamSchema>(
      projectsDeleteCardParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ProjectsDeleteCardParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsDeleteCard(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsMoveCardParamSchema = z.object({ card_id: z.coerce.number() })

  const projectsMoveCardBodySchema = z.object({
    position: z.coerce.string(),
    column_id: z.coerce.number().optional(),
  })

  router.post(
    "projectsMoveCard",
    "/projects/columns/cards/:cardId/moves",
    paramValidationFactory<t_ProjectsMoveCardParamSchema>(
      projectsMoveCardParamSchema
    ),
    bodyValidationFactory<t_ProjectsMoveCardBodySchema>(
      projectsMoveCardBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsMoveCardParamSchema,
        void,
        t_ProjectsMoveCardBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsMoveCard(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsGetColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  router.get(
    "projectsGetColumn",
    "/projects/columns/:columnId",
    paramValidationFactory<t_ProjectsGetColumnParamSchema>(
      projectsGetColumnParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ProjectsGetColumnParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsGetColumn(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsUpdateColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsUpdateColumnBodySchema = z.object({ name: z.coerce.string() })

  router.patch(
    "projectsUpdateColumn",
    "/projects/columns/:columnId",
    paramValidationFactory<t_ProjectsUpdateColumnParamSchema>(
      projectsUpdateColumnParamSchema
    ),
    bodyValidationFactory<t_ProjectsUpdateColumnBodySchema>(
      projectsUpdateColumnBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsUpdateColumnParamSchema,
        void,
        t_ProjectsUpdateColumnBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsUpdateColumn(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsDeleteColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  router.delete(
    "projectsDeleteColumn",
    "/projects/columns/:columnId",
    paramValidationFactory<t_ProjectsDeleteColumnParamSchema>(
      projectsDeleteColumnParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ProjectsDeleteColumnParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsDeleteColumn(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsListCardsParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsListCardsQuerySchema = z.object({
    archived_state: z.enum(["all", "archived", "not_archived"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "projectsListCards",
    "/projects/columns/:columnId/cards",
    paramValidationFactory<t_ProjectsListCardsParamSchema>(
      projectsListCardsParamSchema
    ),
    queryValidationFactory<t_ProjectsListCardsQuerySchema>(
      projectsListCardsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsListCardsParamSchema,
        t_ProjectsListCardsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsListCards(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsCreateCardParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsCreateCardBodySchema = z.union([
    z.object({ note: z.coerce.string() }),
    z.object({
      content_id: z.coerce.number(),
      content_type: z.coerce.string(),
    }),
  ])

  router.post(
    "projectsCreateCard",
    "/projects/columns/:columnId/cards",
    paramValidationFactory<t_ProjectsCreateCardParamSchema>(
      projectsCreateCardParamSchema
    ),
    bodyValidationFactory<t_ProjectsCreateCardBodySchema>(
      projectsCreateCardBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsCreateCardParamSchema,
        void,
        t_ProjectsCreateCardBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsCreateCard(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsMoveColumnParamSchema = z.object({
    column_id: z.coerce.number(),
  })

  const projectsMoveColumnBodySchema = z.object({ position: z.coerce.string() })

  router.post(
    "projectsMoveColumn",
    "/projects/columns/:columnId/moves",
    paramValidationFactory<t_ProjectsMoveColumnParamSchema>(
      projectsMoveColumnParamSchema
    ),
    bodyValidationFactory<t_ProjectsMoveColumnBodySchema>(
      projectsMoveColumnBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsMoveColumnParamSchema,
        void,
        t_ProjectsMoveColumnBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsMoveColumn(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsGetParamSchema = z.object({ project_id: z.coerce.number() })

  router.get(
    "projectsGet",
    "/projects/:projectId",
    paramValidationFactory<t_ProjectsGetParamSchema>(projectsGetParamSchema),
    async (
      ctx: ValidatedCtx<t_ProjectsGetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsUpdateParamSchema = z.object({ project_id: z.coerce.number() })

  const projectsUpdateBodySchema = z
    .object({
      name: z.coerce.string().optional(),
      body: z.coerce.string().optional(),
      state: z.coerce.string().optional(),
      organization_permission: z
        .enum(["read", "write", "admin", "none"])
        .optional(),
      private: z.coerce.boolean().optional(),
    })
    .optional()

  router.patch(
    "projectsUpdate",
    "/projects/:projectId",
    paramValidationFactory<t_ProjectsUpdateParamSchema>(
      projectsUpdateParamSchema
    ),
    bodyValidationFactory<t_ProjectsUpdateBodySchema>(projectsUpdateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_ProjectsUpdateParamSchema,
        void,
        t_ProjectsUpdateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsUpdate(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsDeleteParamSchema = z.object({ project_id: z.coerce.number() })

  router.delete(
    "projectsDelete",
    "/projects/:projectId",
    paramValidationFactory<t_ProjectsDeleteParamSchema>(
      projectsDeleteParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ProjectsDeleteParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsDelete(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsListCollaboratorsParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsListCollaboratorsQuerySchema = z.object({
    affiliation: z.enum(["outside", "direct", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "projectsListCollaborators",
    "/projects/:projectId/collaborators",
    paramValidationFactory<t_ProjectsListCollaboratorsParamSchema>(
      projectsListCollaboratorsParamSchema
    ),
    queryValidationFactory<t_ProjectsListCollaboratorsQuerySchema>(
      projectsListCollaboratorsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsListCollaboratorsParamSchema,
        t_ProjectsListCollaboratorsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsListCollaborators(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsAddCollaboratorParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  const projectsAddCollaboratorBodySchema = z
    .object({ permission: z.enum(["read", "write", "admin"]).optional() })
    .optional()

  router.put(
    "projectsAddCollaborator",
    "/projects/:projectId/collaborators/:username",
    paramValidationFactory<t_ProjectsAddCollaboratorParamSchema>(
      projectsAddCollaboratorParamSchema
    ),
    bodyValidationFactory<t_ProjectsAddCollaboratorBodySchema>(
      projectsAddCollaboratorBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsAddCollaboratorParamSchema,
        void,
        t_ProjectsAddCollaboratorBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsAddCollaborator(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsRemoveCollaboratorParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.delete(
    "projectsRemoveCollaborator",
    "/projects/:projectId/collaborators/:username",
    paramValidationFactory<t_ProjectsRemoveCollaboratorParamSchema>(
      projectsRemoveCollaboratorParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ProjectsRemoveCollaboratorParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsRemoveCollaborator(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsGetPermissionForUserParamSchema = z.object({
    project_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.get(
    "projectsGetPermissionForUser",
    "/projects/:projectId/collaborators/:username/permission",
    paramValidationFactory<t_ProjectsGetPermissionForUserParamSchema>(
      projectsGetPermissionForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ProjectsGetPermissionForUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.projectsGetPermissionForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsListColumnsParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsListColumnsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "projectsListColumns",
    "/projects/:projectId/columns",
    paramValidationFactory<t_ProjectsListColumnsParamSchema>(
      projectsListColumnsParamSchema
    ),
    queryValidationFactory<t_ProjectsListColumnsQuerySchema>(
      projectsListColumnsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsListColumnsParamSchema,
        t_ProjectsListColumnsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsListColumns(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsCreateColumnParamSchema = z.object({
    project_id: z.coerce.number(),
  })

  const projectsCreateColumnBodySchema = z.object({ name: z.coerce.string() })

  router.post(
    "projectsCreateColumn",
    "/projects/:projectId/columns",
    paramValidationFactory<t_ProjectsCreateColumnParamSchema>(
      projectsCreateColumnParamSchema
    ),
    bodyValidationFactory<t_ProjectsCreateColumnBodySchema>(
      projectsCreateColumnBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsCreateColumnParamSchema,
        void,
        t_ProjectsCreateColumnBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsCreateColumn(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "rateLimitGet",
    "/rate_limit",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.rateLimitGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRepoRequiredWorkflowsParamSchema = z.object({
    org: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsListRepoRequiredWorkflowsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListRepoRequiredWorkflows",
    "/repos/:org/:repo/actions/required_workflows",
    paramValidationFactory<t_ActionsListRepoRequiredWorkflowsParamSchema>(
      actionsListRepoRequiredWorkflowsParamSchema
    ),
    queryValidationFactory<t_ActionsListRepoRequiredWorkflowsQuerySchema>(
      actionsListRepoRequiredWorkflowsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRepoRequiredWorkflowsParamSchema,
        t_ActionsListRepoRequiredWorkflowsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListRepoRequiredWorkflows(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetRepoRequiredWorkflowParamSchema = z.object({
    org: z.coerce.string(),
    repo: z.coerce.string(),
    required_workflow_id_for_repo: z.coerce.number(),
  })

  router.get(
    "actionsGetRepoRequiredWorkflow",
    "/repos/:org/:repo/actions/required_workflows/:requiredWorkflowIdForRepo",
    paramValidationFactory<t_ActionsGetRepoRequiredWorkflowParamSchema>(
      actionsGetRepoRequiredWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetRepoRequiredWorkflowParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetRepoRequiredWorkflow(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetRepoRequiredWorkflowUsageParamSchema = z.object({
    org: z.coerce.string(),
    repo: z.coerce.string(),
    required_workflow_id_for_repo: z.coerce.number(),
  })

  router.get(
    "actionsGetRepoRequiredWorkflowUsage",
    "/repos/:org/:repo/actions/required_workflows/:requiredWorkflowIdForRepo/timing",
    paramValidationFactory<t_ActionsGetRepoRequiredWorkflowUsageParamSchema>(
      actionsGetRepoRequiredWorkflowUsageParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetRepoRequiredWorkflowUsageParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetRepoRequiredWorkflowUsage(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGet",
    "/repos/:owner/:repo",
    paramValidationFactory<t_ReposGetParamSchema>(reposGetParamSchema),
    async (
      ctx: ValidatedCtx<t_ReposGetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposUpdateBodySchema = z
    .object({
      name: z.coerce.string().optional(),
      description: z.coerce.string().optional(),
      homepage: z.coerce.string().optional(),
      private: z.coerce.boolean().optional(),
      visibility: z.enum(["public", "private"]).optional(),
      security_and_analysis: z
        .object({
          advanced_security: z
            .object({ status: z.coerce.string().optional() })
            .optional(),
          secret_scanning: z
            .object({ status: z.coerce.string().optional() })
            .optional(),
          secret_scanning_push_protection: z
            .object({ status: z.coerce.string().optional() })
            .optional(),
        })
        .optional(),
      has_issues: z.coerce.boolean().optional(),
      has_projects: z.coerce.boolean().optional(),
      has_wiki: z.coerce.boolean().optional(),
      is_template: z.coerce.boolean().optional(),
      default_branch: z.coerce.string().optional(),
      allow_squash_merge: z.coerce.boolean().optional(),
      allow_merge_commit: z.coerce.boolean().optional(),
      allow_rebase_merge: z.coerce.boolean().optional(),
      allow_auto_merge: z.coerce.boolean().optional(),
      delete_branch_on_merge: z.coerce.boolean().optional(),
      allow_update_branch: z.coerce.boolean().optional(),
      use_squash_pr_title_as_default: z.coerce.boolean().optional(),
      squash_merge_commit_title: z
        .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
        .optional(),
      squash_merge_commit_message: z
        .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
        .optional(),
      merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
      merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
      archived: z.coerce.boolean().optional(),
      allow_forking: z.coerce.boolean().optional(),
      web_commit_signoff_required: z.coerce.boolean().optional(),
    })
    .optional()

  router.patch(
    "reposUpdate",
    "/repos/:owner/:repo",
    paramValidationFactory<t_ReposUpdateParamSchema>(reposUpdateParamSchema),
    bodyValidationFactory<t_ReposUpdateBodySchema>(reposUpdateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateParamSchema,
        void,
        t_ReposUpdateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUpdate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "reposDelete",
    "/repos/:owner/:repo",
    paramValidationFactory<t_ReposDeleteParamSchema>(reposDeleteParamSchema),
    async (
      ctx: ValidatedCtx<t_ReposDeleteParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDelete(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListArtifactsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsListArtifactsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    name: z.coerce.string().optional(),
  })

  router.get(
    "actionsListArtifactsForRepo",
    "/repos/:owner/:repo/actions/artifacts",
    paramValidationFactory<t_ActionsListArtifactsForRepoParamSchema>(
      actionsListArtifactsForRepoParamSchema
    ),
    queryValidationFactory<t_ActionsListArtifactsForRepoQuerySchema>(
      actionsListArtifactsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListArtifactsForRepoParamSchema,
        t_ActionsListArtifactsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsListArtifactsForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetArtifactParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    artifact_id: z.coerce.number(),
  })

  router.get(
    "actionsGetArtifact",
    "/repos/:owner/:repo/actions/artifacts/:artifactId",
    paramValidationFactory<t_ActionsGetArtifactParamSchema>(
      actionsGetArtifactParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetArtifactParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetArtifact(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteArtifactParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    artifact_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteArtifact",
    "/repos/:owner/:repo/actions/artifacts/:artifactId",
    paramValidationFactory<t_ActionsDeleteArtifactParamSchema>(
      actionsDeleteArtifactParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteArtifactParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDeleteArtifact(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDownloadArtifactParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    artifact_id: z.coerce.number(),
    archive_format: z.coerce.string(),
  })

  router.get(
    "actionsDownloadArtifact",
    "/repos/:owner/:repo/actions/artifacts/:artifactId/:archiveFormat",
    paramValidationFactory<t_ActionsDownloadArtifactParamSchema>(
      actionsDownloadArtifactParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDownloadArtifactParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDownloadArtifact(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetActionsCacheUsageParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "actionsGetActionsCacheUsage",
    "/repos/:owner/:repo/actions/cache/usage",
    paramValidationFactory<t_ActionsGetActionsCacheUsageParamSchema>(
      actionsGetActionsCacheUsageParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetActionsCacheUsageParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetActionsCacheUsage(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetActionsCacheListParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsGetActionsCacheListQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    ref: z.coerce.string().optional(),
    key: z.coerce.string().optional(),
    sort: z
      .enum(["created_at", "last_accessed_at", "size_in_bytes"])
      .optional(),
    direction: z.enum(["asc", "desc"]).optional(),
  })

  router.get(
    "actionsGetActionsCacheList",
    "/repos/:owner/:repo/actions/caches",
    paramValidationFactory<t_ActionsGetActionsCacheListParamSchema>(
      actionsGetActionsCacheListParamSchema
    ),
    queryValidationFactory<t_ActionsGetActionsCacheListQuerySchema>(
      actionsGetActionsCacheListQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetActionsCacheListParamSchema,
        t_ActionsGetActionsCacheListQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetActionsCacheList(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteActionsCacheByKeyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsDeleteActionsCacheByKeyQuerySchema = z.object({
    key: z.coerce.string(),
    ref: z.coerce.string().optional(),
  })

  router.delete(
    "actionsDeleteActionsCacheByKey",
    "/repos/:owner/:repo/actions/caches",
    paramValidationFactory<t_ActionsDeleteActionsCacheByKeyParamSchema>(
      actionsDeleteActionsCacheByKeyParamSchema
    ),
    queryValidationFactory<t_ActionsDeleteActionsCacheByKeyQuerySchema>(
      actionsDeleteActionsCacheByKeyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDeleteActionsCacheByKeyParamSchema,
        t_ActionsDeleteActionsCacheByKeyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteActionsCacheByKey(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteActionsCacheByIdParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    cache_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteActionsCacheById",
    "/repos/:owner/:repo/actions/caches/:cacheId",
    paramValidationFactory<t_ActionsDeleteActionsCacheByIdParamSchema>(
      actionsDeleteActionsCacheByIdParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteActionsCacheByIdParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteActionsCacheById(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetJobForWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    job_id: z.coerce.number(),
  })

  router.get(
    "actionsGetJobForWorkflowRun",
    "/repos/:owner/:repo/actions/jobs/:jobId",
    paramValidationFactory<t_ActionsGetJobForWorkflowRunParamSchema>(
      actionsGetJobForWorkflowRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetJobForWorkflowRunParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetJobForWorkflowRun(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDownloadJobLogsForWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    job_id: z.coerce.number(),
  })

  router.get(
    "actionsDownloadJobLogsForWorkflowRun",
    "/repos/:owner/:repo/actions/jobs/:jobId/logs",
    paramValidationFactory<t_ActionsDownloadJobLogsForWorkflowRunParamSchema>(
      actionsDownloadJobLogsForWorkflowRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDownloadJobLogsForWorkflowRunParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDownloadJobLogsForWorkflowRun(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsReRunJobForWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    job_id: z.coerce.number(),
  })

  const actionsReRunJobForWorkflowRunBodySchema = z
    .object({ enable_debug_logging: z.coerce.boolean().optional() })
    .optional()

  router.post(
    "actionsReRunJobForWorkflowRun",
    "/repos/:owner/:repo/actions/jobs/:jobId/rerun",
    paramValidationFactory<t_ActionsReRunJobForWorkflowRunParamSchema>(
      actionsReRunJobForWorkflowRunParamSchema
    ),
    bodyValidationFactory<t_ActionsReRunJobForWorkflowRunBodySchema>(
      actionsReRunJobForWorkflowRunBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsReRunJobForWorkflowRunParamSchema,
        void,
        t_ActionsReRunJobForWorkflowRunBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsReRunJobForWorkflowRun(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetCustomOidcSubClaimForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "actionsGetCustomOidcSubClaimForRepo",
    "/repos/:owner/:repo/actions/oidc/customization/sub",
    paramValidationFactory<t_ActionsGetCustomOidcSubClaimForRepoParamSchema>(
      actionsGetCustomOidcSubClaimForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetCustomOidcSubClaimForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetCustomOidcSubClaimForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetCustomOidcSubClaimForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsSetCustomOidcSubClaimForRepoBodySchema = z.object({
    use_default: z.coerce.boolean(),
    include_claim_keys: z.array(z.coerce.string()).optional(),
  })

  router.put(
    "actionsSetCustomOidcSubClaimForRepo",
    "/repos/:owner/:repo/actions/oidc/customization/sub",
    paramValidationFactory<t_ActionsSetCustomOidcSubClaimForRepoParamSchema>(
      actionsSetCustomOidcSubClaimForRepoParamSchema
    ),
    bodyValidationFactory<t_ActionsSetCustomOidcSubClaimForRepoBodySchema>(
      actionsSetCustomOidcSubClaimForRepoBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetCustomOidcSubClaimForRepoParamSchema,
        void,
        t_ActionsSetCustomOidcSubClaimForRepoBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetCustomOidcSubClaimForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetGithubActionsPermissionsRepositoryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "actionsGetGithubActionsPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions",
    paramValidationFactory<t_ActionsGetGithubActionsPermissionsRepositoryParamSchema>(
      actionsGetGithubActionsPermissionsRepositoryParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetGithubActionsPermissionsRepositoryParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetGithubActionsPermissionsRepository(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetGithubActionsPermissionsRepositoryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsSetGithubActionsPermissionsRepositoryBodySchema = z.object({
    enabled: z.coerce.boolean(),
    allowed_actions: z.enum(["all", "local_only", "selected"]).optional(),
  })

  router.put(
    "actionsSetGithubActionsPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions",
    paramValidationFactory<t_ActionsSetGithubActionsPermissionsRepositoryParamSchema>(
      actionsSetGithubActionsPermissionsRepositoryParamSchema
    ),
    bodyValidationFactory<t_ActionsSetGithubActionsPermissionsRepositoryBodySchema>(
      actionsSetGithubActionsPermissionsRepositoryBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetGithubActionsPermissionsRepositoryParamSchema,
        void,
        t_ActionsSetGithubActionsPermissionsRepositoryBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetGithubActionsPermissionsRepository(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetWorkflowAccessToRepositoryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "actionsGetWorkflowAccessToRepository",
    "/repos/:owner/:repo/actions/permissions/access",
    paramValidationFactory<t_ActionsGetWorkflowAccessToRepositoryParamSchema>(
      actionsGetWorkflowAccessToRepositoryParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetWorkflowAccessToRepositoryParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetWorkflowAccessToRepository(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetWorkflowAccessToRepositoryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsSetWorkflowAccessToRepositoryBodySchema = z.object({
    access_level: z.enum(["none", "user", "organization", "enterprise"]),
  })

  router.put(
    "actionsSetWorkflowAccessToRepository",
    "/repos/:owner/:repo/actions/permissions/access",
    paramValidationFactory<t_ActionsSetWorkflowAccessToRepositoryParamSchema>(
      actionsSetWorkflowAccessToRepositoryParamSchema
    ),
    bodyValidationFactory<t_ActionsSetWorkflowAccessToRepositoryBodySchema>(
      actionsSetWorkflowAccessToRepositoryBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetWorkflowAccessToRepositoryParamSchema,
        void,
        t_ActionsSetWorkflowAccessToRepositoryBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetWorkflowAccessToRepository(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetAllowedActionsRepositoryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "actionsGetAllowedActionsRepository",
    "/repos/:owner/:repo/actions/permissions/selected-actions",
    paramValidationFactory<t_ActionsGetAllowedActionsRepositoryParamSchema>(
      actionsGetAllowedActionsRepositoryParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetAllowedActionsRepositoryParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetAllowedActionsRepository(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetAllowedActionsRepositoryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsSetAllowedActionsRepositoryBodySchema = z
    .object({
      github_owned_allowed: z.coerce.boolean().optional(),
      verified_allowed: z.coerce.boolean().optional(),
      patterns_allowed: z.array(z.coerce.string()).optional(),
    })
    .optional()

  router.put(
    "actionsSetAllowedActionsRepository",
    "/repos/:owner/:repo/actions/permissions/selected-actions",
    paramValidationFactory<t_ActionsSetAllowedActionsRepositoryParamSchema>(
      actionsSetAllowedActionsRepositoryParamSchema
    ),
    bodyValidationFactory<t_ActionsSetAllowedActionsRepositoryBodySchema>(
      actionsSetAllowedActionsRepositoryBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetAllowedActionsRepositoryParamSchema,
        void,
        t_ActionsSetAllowedActionsRepositoryBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetAllowedActionsRepository(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema =
    z.object({ owner: z.coerce.string(), repo: z.coerce.string() })

  router.get(
    "actionsGetGithubActionsDefaultWorkflowPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions/workflow",
    paramValidationFactory<t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema>(
      actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema =
    z.object({ owner: z.coerce.string(), repo: z.coerce.string() })

  const actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema =
    z.object({
      default_workflow_permissions: z.enum(["read", "write"]).optional(),
      can_approve_pull_request_reviews: z.coerce.boolean().optional(),
    })

  router.put(
    "actionsSetGithubActionsDefaultWorkflowPermissionsRepository",
    "/repos/:owner/:repo/actions/permissions/workflow",
    paramValidationFactory<t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema>(
      actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema
    ),
    bodyValidationFactory<t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema>(
      actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryParamSchema,
        void,
        t_ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRequiredWorkflowRunsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    required_workflow_id_for_repo: z.coerce.number(),
  })

  const actionsListRequiredWorkflowRunsQuerySchema = z.object({
    actor: z.coerce.string().optional(),
    branch: z.coerce.string().optional(),
    event: z.coerce.string().optional(),
    status: z
      .enum([
        "completed",
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "skipped",
        "stale",
        "success",
        "timed_out",
        "in_progress",
        "queued",
        "requested",
        "waiting",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    created: z.coerce.string().datetime({ offset: true }).optional(),
    exclude_pull_requests: z.coerce.boolean().optional(),
    check_suite_id: z.coerce.number().optional(),
    head_sha: z.coerce.string().optional(),
  })

  router.get(
    "actionsListRequiredWorkflowRuns",
    "/repos/:owner/:repo/actions/required_workflows/:requiredWorkflowIdForRepo/runs",
    paramValidationFactory<t_ActionsListRequiredWorkflowRunsParamSchema>(
      actionsListRequiredWorkflowRunsParamSchema
    ),
    queryValidationFactory<t_ActionsListRequiredWorkflowRunsQuerySchema>(
      actionsListRequiredWorkflowRunsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRequiredWorkflowRunsParamSchema,
        t_ActionsListRequiredWorkflowRunsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListRequiredWorkflowRuns(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListSelfHostedRunnersForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsListSelfHostedRunnersForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListSelfHostedRunnersForRepo",
    "/repos/:owner/:repo/actions/runners",
    paramValidationFactory<t_ActionsListSelfHostedRunnersForRepoParamSchema>(
      actionsListSelfHostedRunnersForRepoParamSchema
    ),
    queryValidationFactory<t_ActionsListSelfHostedRunnersForRepoQuerySchema>(
      actionsListSelfHostedRunnersForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListSelfHostedRunnersForRepoParamSchema,
        t_ActionsListSelfHostedRunnersForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListSelfHostedRunnersForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRunnerApplicationsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "actionsListRunnerApplicationsForRepo",
    "/repos/:owner/:repo/actions/runners/downloads",
    paramValidationFactory<t_ActionsListRunnerApplicationsForRepoParamSchema>(
      actionsListRunnerApplicationsForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRunnerApplicationsForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListRunnerApplicationsForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateRegistrationTokenForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.post(
    "actionsCreateRegistrationTokenForRepo",
    "/repos/:owner/:repo/actions/runners/registration-token",
    paramValidationFactory<t_ActionsCreateRegistrationTokenForRepoParamSchema>(
      actionsCreateRegistrationTokenForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateRegistrationTokenForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateRegistrationTokenForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateRemoveTokenForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.post(
    "actionsCreateRemoveTokenForRepo",
    "/repos/:owner/:repo/actions/runners/remove-token",
    paramValidationFactory<t_ActionsCreateRemoveTokenForRepoParamSchema>(
      actionsCreateRemoveTokenForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateRemoveTokenForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateRemoveTokenForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsGetSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runnerId",
    paramValidationFactory<t_ActionsGetSelfHostedRunnerForRepoParamSchema>(
      actionsGetSelfHostedRunnerForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetSelfHostedRunnerForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetSelfHostedRunnerForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteSelfHostedRunnerFromRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteSelfHostedRunnerFromRepo",
    "/repos/:owner/:repo/actions/runners/:runnerId",
    paramValidationFactory<t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema>(
      actionsDeleteSelfHostedRunnerFromRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDeleteSelfHostedRunnerFromRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteSelfHostedRunnerFromRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListLabelsForSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  router.get(
    "actionsListLabelsForSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema>(
      actionsListLabelsForSelfHostedRunnerForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListLabelsForSelfHostedRunnerForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListLabelsForSelfHostedRunnerForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  const actionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema = z.object({
    labels: z.array(z.coerce.string()),
  })

  router.post(
    "actionsAddCustomLabelsToSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema>(
      actionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema
    ),
    bodyValidationFactory<t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema>(
      actionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoParamSchema,
        void,
        t_ActionsAddCustomLabelsToSelfHostedRunnerForRepoBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsAddCustomLabelsToSelfHostedRunnerForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    runner_id: z.coerce.number(),
  })

  const actionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema = z.object({
    labels: z.array(z.coerce.string()),
  })

  router.put(
    "actionsSetCustomLabelsForSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema>(
      actionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema
    ),
    bodyValidationFactory<t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema>(
      actionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoParamSchema,
        void,
        t_ActionsSetCustomLabelsForSelfHostedRunnerForRepoBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsSetCustomLabelsForSelfHostedRunnerForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema =
    z.object({
      owner: z.coerce.string(),
      repo: z.coerce.string(),
      runner_id: z.coerce.number(),
    })

  router.delete(
    "actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runnerId/labels",
    paramValidationFactory<t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema>(
      actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema =
    z.object({
      owner: z.coerce.string(),
      repo: z.coerce.string(),
      runner_id: z.coerce.number(),
      name: z.coerce.string(),
    })

  router.delete(
    "actionsRemoveCustomLabelFromSelfHostedRunnerForRepo",
    "/repos/:owner/:repo/actions/runners/:runnerId/labels/:name",
    paramValidationFactory<t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema>(
      actionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListWorkflowRunsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsListWorkflowRunsForRepoQuerySchema = z.object({
    actor: z.coerce.string().optional(),
    branch: z.coerce.string().optional(),
    event: z.coerce.string().optional(),
    status: z
      .enum([
        "completed",
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "skipped",
        "stale",
        "success",
        "timed_out",
        "in_progress",
        "queued",
        "requested",
        "waiting",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    created: z.coerce.string().datetime({ offset: true }).optional(),
    exclude_pull_requests: z.coerce.boolean().optional(),
    check_suite_id: z.coerce.number().optional(),
    head_sha: z.coerce.string().optional(),
  })

  router.get(
    "actionsListWorkflowRunsForRepo",
    "/repos/:owner/:repo/actions/runs",
    paramValidationFactory<t_ActionsListWorkflowRunsForRepoParamSchema>(
      actionsListWorkflowRunsForRepoParamSchema
    ),
    queryValidationFactory<t_ActionsListWorkflowRunsForRepoQuerySchema>(
      actionsListWorkflowRunsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListWorkflowRunsForRepoParamSchema,
        t_ActionsListWorkflowRunsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListWorkflowRunsForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  const actionsGetWorkflowRunQuerySchema = z.object({
    exclude_pull_requests: z.coerce.boolean().optional(),
  })

  router.get(
    "actionsGetWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:runId",
    paramValidationFactory<t_ActionsGetWorkflowRunParamSchema>(
      actionsGetWorkflowRunParamSchema
    ),
    queryValidationFactory<t_ActionsGetWorkflowRunQuerySchema>(
      actionsGetWorkflowRunQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetWorkflowRunParamSchema,
        t_ActionsGetWorkflowRunQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetWorkflowRun(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:runId",
    paramValidationFactory<t_ActionsDeleteWorkflowRunParamSchema>(
      actionsDeleteWorkflowRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteWorkflowRunParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDeleteWorkflowRun(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetReviewsForRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsGetReviewsForRun",
    "/repos/:owner/:repo/actions/runs/:runId/approvals",
    paramValidationFactory<t_ActionsGetReviewsForRunParamSchema>(
      actionsGetReviewsForRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetReviewsForRunParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetReviewsForRun(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsApproveWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.post(
    "actionsApproveWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:runId/approve",
    paramValidationFactory<t_ActionsApproveWorkflowRunParamSchema>(
      actionsApproveWorkflowRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsApproveWorkflowRunParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsApproveWorkflowRun(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListWorkflowRunArtifactsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  const actionsListWorkflowRunArtifactsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListWorkflowRunArtifacts",
    "/repos/:owner/:repo/actions/runs/:runId/artifacts",
    paramValidationFactory<t_ActionsListWorkflowRunArtifactsParamSchema>(
      actionsListWorkflowRunArtifactsParamSchema
    ),
    queryValidationFactory<t_ActionsListWorkflowRunArtifactsQuerySchema>(
      actionsListWorkflowRunArtifactsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListWorkflowRunArtifactsParamSchema,
        t_ActionsListWorkflowRunArtifactsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListWorkflowRunArtifacts(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetWorkflowRunAttemptParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  const actionsGetWorkflowRunAttemptQuerySchema = z.object({
    exclude_pull_requests: z.coerce.boolean().optional(),
  })

  router.get(
    "actionsGetWorkflowRunAttempt",
    "/repos/:owner/:repo/actions/runs/:runId/attempts/:attemptNumber",
    paramValidationFactory<t_ActionsGetWorkflowRunAttemptParamSchema>(
      actionsGetWorkflowRunAttemptParamSchema
    ),
    queryValidationFactory<t_ActionsGetWorkflowRunAttemptQuerySchema>(
      actionsGetWorkflowRunAttemptQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetWorkflowRunAttemptParamSchema,
        t_ActionsGetWorkflowRunAttemptQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetWorkflowRunAttempt(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListJobsForWorkflowRunAttemptParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  const actionsListJobsForWorkflowRunAttemptQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListJobsForWorkflowRunAttempt",
    "/repos/:owner/:repo/actions/runs/:runId/attempts/:attemptNumber/jobs",
    paramValidationFactory<t_ActionsListJobsForWorkflowRunAttemptParamSchema>(
      actionsListJobsForWorkflowRunAttemptParamSchema
    ),
    queryValidationFactory<t_ActionsListJobsForWorkflowRunAttemptQuerySchema>(
      actionsListJobsForWorkflowRunAttemptQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListJobsForWorkflowRunAttemptParamSchema,
        t_ActionsListJobsForWorkflowRunAttemptQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListJobsForWorkflowRunAttempt(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDownloadWorkflowRunAttemptLogsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
    attempt_number: z.coerce.number(),
  })

  router.get(
    "actionsDownloadWorkflowRunAttemptLogs",
    "/repos/:owner/:repo/actions/runs/:runId/attempts/:attemptNumber/logs",
    paramValidationFactory<t_ActionsDownloadWorkflowRunAttemptLogsParamSchema>(
      actionsDownloadWorkflowRunAttemptLogsParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDownloadWorkflowRunAttemptLogsParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDownloadWorkflowRunAttemptLogs(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCancelWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.post(
    "actionsCancelWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:runId/cancel",
    paramValidationFactory<t_ActionsCancelWorkflowRunParamSchema>(
      actionsCancelWorkflowRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsCancelWorkflowRunParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsCancelWorkflowRun(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListJobsForWorkflowRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  const actionsListJobsForWorkflowRunQuerySchema = z.object({
    filter: z.enum(["latest", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListJobsForWorkflowRun",
    "/repos/:owner/:repo/actions/runs/:runId/jobs",
    paramValidationFactory<t_ActionsListJobsForWorkflowRunParamSchema>(
      actionsListJobsForWorkflowRunParamSchema
    ),
    queryValidationFactory<t_ActionsListJobsForWorkflowRunQuerySchema>(
      actionsListJobsForWorkflowRunQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListJobsForWorkflowRunParamSchema,
        t_ActionsListJobsForWorkflowRunQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListJobsForWorkflowRun(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDownloadWorkflowRunLogsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsDownloadWorkflowRunLogs",
    "/repos/:owner/:repo/actions/runs/:runId/logs",
    paramValidationFactory<t_ActionsDownloadWorkflowRunLogsParamSchema>(
      actionsDownloadWorkflowRunLogsParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDownloadWorkflowRunLogsParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDownloadWorkflowRunLogs(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteWorkflowRunLogsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.delete(
    "actionsDeleteWorkflowRunLogs",
    "/repos/:owner/:repo/actions/runs/:runId/logs",
    paramValidationFactory<t_ActionsDeleteWorkflowRunLogsParamSchema>(
      actionsDeleteWorkflowRunLogsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteWorkflowRunLogsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteWorkflowRunLogs(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetPendingDeploymentsForRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsGetPendingDeploymentsForRun",
    "/repos/:owner/:repo/actions/runs/:runId/pending_deployments",
    paramValidationFactory<t_ActionsGetPendingDeploymentsForRunParamSchema>(
      actionsGetPendingDeploymentsForRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetPendingDeploymentsForRunParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetPendingDeploymentsForRun(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsReviewPendingDeploymentsForRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  const actionsReviewPendingDeploymentsForRunBodySchema = z.object({
    environment_ids: z.array(z.coerce.number()),
    state: z.enum(["approved", "rejected"]),
    comment: z.coerce.string(),
  })

  router.post(
    "actionsReviewPendingDeploymentsForRun",
    "/repos/:owner/:repo/actions/runs/:runId/pending_deployments",
    paramValidationFactory<t_ActionsReviewPendingDeploymentsForRunParamSchema>(
      actionsReviewPendingDeploymentsForRunParamSchema
    ),
    bodyValidationFactory<t_ActionsReviewPendingDeploymentsForRunBodySchema>(
      actionsReviewPendingDeploymentsForRunBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsReviewPendingDeploymentsForRunParamSchema,
        void,
        t_ActionsReviewPendingDeploymentsForRunBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsReviewPendingDeploymentsForRun(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsReRunWorkflowParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  const actionsReRunWorkflowBodySchema = z
    .object({ enable_debug_logging: z.coerce.boolean().optional() })
    .optional()

  router.post(
    "actionsReRunWorkflow",
    "/repos/:owner/:repo/actions/runs/:runId/rerun",
    paramValidationFactory<t_ActionsReRunWorkflowParamSchema>(
      actionsReRunWorkflowParamSchema
    ),
    bodyValidationFactory<t_ActionsReRunWorkflowBodySchema>(
      actionsReRunWorkflowBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsReRunWorkflowParamSchema,
        void,
        t_ActionsReRunWorkflowBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsReRunWorkflow(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsReRunWorkflowFailedJobsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  const actionsReRunWorkflowFailedJobsBodySchema = z
    .object({ enable_debug_logging: z.coerce.boolean().optional() })
    .optional()

  router.post(
    "actionsReRunWorkflowFailedJobs",
    "/repos/:owner/:repo/actions/runs/:runId/rerun-failed-jobs",
    paramValidationFactory<t_ActionsReRunWorkflowFailedJobsParamSchema>(
      actionsReRunWorkflowFailedJobsParamSchema
    ),
    bodyValidationFactory<t_ActionsReRunWorkflowFailedJobsBodySchema>(
      actionsReRunWorkflowFailedJobsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsReRunWorkflowFailedJobsParamSchema,
        void,
        t_ActionsReRunWorkflowFailedJobsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsReRunWorkflowFailedJobs(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetWorkflowRunUsageParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    run_id: z.coerce.number(),
  })

  router.get(
    "actionsGetWorkflowRunUsage",
    "/repos/:owner/:repo/actions/runs/:runId/timing",
    paramValidationFactory<t_ActionsGetWorkflowRunUsageParamSchema>(
      actionsGetWorkflowRunUsageParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetWorkflowRunUsageParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetWorkflowRunUsage(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRepoSecretsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListRepoSecrets",
    "/repos/:owner/:repo/actions/secrets",
    paramValidationFactory<t_ActionsListRepoSecretsParamSchema>(
      actionsListRepoSecretsParamSchema
    ),
    queryValidationFactory<t_ActionsListRepoSecretsQuerySchema>(
      actionsListRepoSecretsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRepoSecretsParamSchema,
        t_ActionsListRepoSecretsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsListRepoSecrets(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetRepoPublicKeyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "actionsGetRepoPublicKey",
    "/repos/:owner/:repo/actions/secrets/public-key",
    paramValidationFactory<t_ActionsGetRepoPublicKeyParamSchema>(
      actionsGetRepoPublicKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetRepoPublicKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetRepoPublicKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.get(
    "actionsGetRepoSecret",
    "/repos/:owner/:repo/actions/secrets/:secretName",
    paramValidationFactory<t_ActionsGetRepoSecretParamSchema>(
      actionsGetRepoSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetRepoSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetRepoSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const actionsCreateOrUpdateRepoSecretBodySchema = z.object({
    encrypted_value: z.coerce.string().optional(),
    key_id: z.coerce.string().optional(),
  })

  router.put(
    "actionsCreateOrUpdateRepoSecret",
    "/repos/:owner/:repo/actions/secrets/:secretName",
    paramValidationFactory<t_ActionsCreateOrUpdateRepoSecretParamSchema>(
      actionsCreateOrUpdateRepoSecretParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateOrUpdateRepoSecretBodySchema>(
      actionsCreateOrUpdateRepoSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateOrUpdateRepoSecretParamSchema,
        void,
        t_ActionsCreateOrUpdateRepoSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateOrUpdateRepoSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.delete(
    "actionsDeleteRepoSecret",
    "/repos/:owner/:repo/actions/secrets/:secretName",
    paramValidationFactory<t_ActionsDeleteRepoSecretParamSchema>(
      actionsDeleteRepoSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteRepoSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDeleteRepoSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRepoVariablesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsListRepoVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListRepoVariables",
    "/repos/:owner/:repo/actions/variables",
    paramValidationFactory<t_ActionsListRepoVariablesParamSchema>(
      actionsListRepoVariablesParamSchema
    ),
    queryValidationFactory<t_ActionsListRepoVariablesQuerySchema>(
      actionsListRepoVariablesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRepoVariablesParamSchema,
        t_ActionsListRepoVariablesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsListRepoVariables(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateRepoVariableParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsCreateRepoVariableBodySchema = z.object({
    name: z.coerce.string(),
    value: z.coerce.string(),
  })

  router.post(
    "actionsCreateRepoVariable",
    "/repos/:owner/:repo/actions/variables",
    paramValidationFactory<t_ActionsCreateRepoVariableParamSchema>(
      actionsCreateRepoVariableParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateRepoVariableBodySchema>(
      actionsCreateRepoVariableBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateRepoVariableParamSchema,
        void,
        t_ActionsCreateRepoVariableBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsCreateRepoVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetRepoVariableParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.get(
    "actionsGetRepoVariable",
    "/repos/:owner/:repo/actions/variables/:name",
    paramValidationFactory<t_ActionsGetRepoVariableParamSchema>(
      actionsGetRepoVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetRepoVariableParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetRepoVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsUpdateRepoVariableParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    name: z.coerce.string(),
  })

  const actionsUpdateRepoVariableBodySchema = z.object({
    name: z.coerce.string().optional(),
    value: z.coerce.string().optional(),
  })

  router.patch(
    "actionsUpdateRepoVariable",
    "/repos/:owner/:repo/actions/variables/:name",
    paramValidationFactory<t_ActionsUpdateRepoVariableParamSchema>(
      actionsUpdateRepoVariableParamSchema
    ),
    bodyValidationFactory<t_ActionsUpdateRepoVariableBodySchema>(
      actionsUpdateRepoVariableBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsUpdateRepoVariableParamSchema,
        void,
        t_ActionsUpdateRepoVariableBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsUpdateRepoVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteRepoVariableParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.delete(
    "actionsDeleteRepoVariable",
    "/repos/:owner/:repo/actions/variables/:name",
    paramValidationFactory<t_ActionsDeleteRepoVariableParamSchema>(
      actionsDeleteRepoVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDeleteRepoVariableParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDeleteRepoVariable(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListRepoWorkflowsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const actionsListRepoWorkflowsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListRepoWorkflows",
    "/repos/:owner/:repo/actions/workflows",
    paramValidationFactory<t_ActionsListRepoWorkflowsParamSchema>(
      actionsListRepoWorkflowsParamSchema
    ),
    queryValidationFactory<t_ActionsListRepoWorkflowsQuerySchema>(
      actionsListRepoWorkflowsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListRepoWorkflowsParamSchema,
        t_ActionsListRepoWorkflowsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsListRepoWorkflows(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetWorkflowParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    workflow_id: z.union([z.coerce.number(), z.coerce.string()]),
  })

  router.get(
    "actionsGetWorkflow",
    "/repos/:owner/:repo/actions/workflows/:workflowId",
    paramValidationFactory<t_ActionsGetWorkflowParamSchema>(
      actionsGetWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetWorkflowParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetWorkflow(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDisableWorkflowParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    workflow_id: z.union([z.coerce.number(), z.coerce.string()]),
  })

  router.put(
    "actionsDisableWorkflow",
    "/repos/:owner/:repo/actions/workflows/:workflowId/disable",
    paramValidationFactory<t_ActionsDisableWorkflowParamSchema>(
      actionsDisableWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsDisableWorkflowParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsDisableWorkflow(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateWorkflowDispatchParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    workflow_id: z.union([z.coerce.number(), z.coerce.string()]),
  })

  const actionsCreateWorkflowDispatchBodySchema = z.object({
    ref: z.coerce.string(),
    inputs: z.object({}).optional(),
  })

  router.post(
    "actionsCreateWorkflowDispatch",
    "/repos/:owner/:repo/actions/workflows/:workflowId/dispatches",
    paramValidationFactory<t_ActionsCreateWorkflowDispatchParamSchema>(
      actionsCreateWorkflowDispatchParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateWorkflowDispatchBodySchema>(
      actionsCreateWorkflowDispatchBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateWorkflowDispatchParamSchema,
        void,
        t_ActionsCreateWorkflowDispatchBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateWorkflowDispatch(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsEnableWorkflowParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    workflow_id: z.union([z.coerce.number(), z.coerce.string()]),
  })

  router.put(
    "actionsEnableWorkflow",
    "/repos/:owner/:repo/actions/workflows/:workflowId/enable",
    paramValidationFactory<t_ActionsEnableWorkflowParamSchema>(
      actionsEnableWorkflowParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsEnableWorkflowParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsEnableWorkflow(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListWorkflowRunsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    workflow_id: z.union([z.coerce.number(), z.coerce.string()]),
  })

  const actionsListWorkflowRunsQuerySchema = z.object({
    actor: z.coerce.string().optional(),
    branch: z.coerce.string().optional(),
    event: z.coerce.string().optional(),
    status: z
      .enum([
        "completed",
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "skipped",
        "stale",
        "success",
        "timed_out",
        "in_progress",
        "queued",
        "requested",
        "waiting",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    created: z.coerce.string().datetime({ offset: true }).optional(),
    exclude_pull_requests: z.coerce.boolean().optional(),
    check_suite_id: z.coerce.number().optional(),
    head_sha: z.coerce.string().optional(),
  })

  router.get(
    "actionsListWorkflowRuns",
    "/repos/:owner/:repo/actions/workflows/:workflowId/runs",
    paramValidationFactory<t_ActionsListWorkflowRunsParamSchema>(
      actionsListWorkflowRunsParamSchema
    ),
    queryValidationFactory<t_ActionsListWorkflowRunsQuerySchema>(
      actionsListWorkflowRunsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListWorkflowRunsParamSchema,
        t_ActionsListWorkflowRunsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsListWorkflowRuns(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetWorkflowUsageParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    workflow_id: z.union([z.coerce.number(), z.coerce.string()]),
  })

  router.get(
    "actionsGetWorkflowUsage",
    "/repos/:owner/:repo/actions/workflows/:workflowId/timing",
    paramValidationFactory<t_ActionsGetWorkflowUsageParamSchema>(
      actionsGetWorkflowUsageParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetWorkflowUsageParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetWorkflowUsage(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListAssigneesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesListAssigneesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListAssignees",
    "/repos/:owner/:repo/assignees",
    paramValidationFactory<t_IssuesListAssigneesParamSchema>(
      issuesListAssigneesParamSchema
    ),
    queryValidationFactory<t_IssuesListAssigneesQuerySchema>(
      issuesListAssigneesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListAssigneesParamSchema,
        t_IssuesListAssigneesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListAssignees(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesCheckUserCanBeAssignedParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    assignee: z.coerce.string(),
  })

  router.get(
    "issuesCheckUserCanBeAssigned",
    "/repos/:owner/:repo/assignees/:assignee",
    paramValidationFactory<t_IssuesCheckUserCanBeAssignedParamSchema>(
      issuesCheckUserCanBeAssignedParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesCheckUserCanBeAssignedParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.issuesCheckUserCanBeAssigned(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListAutolinksParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListAutolinksQuerySchema = z.object({
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListAutolinks",
    "/repos/:owner/:repo/autolinks",
    paramValidationFactory<t_ReposListAutolinksParamSchema>(
      reposListAutolinksParamSchema
    ),
    queryValidationFactory<t_ReposListAutolinksQuerySchema>(
      reposListAutolinksQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListAutolinksParamSchema,
        t_ReposListAutolinksQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListAutolinks(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateAutolinkParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateAutolinkBodySchema = z.object({
    key_prefix: z.coerce.string(),
    url_template: z.coerce.string(),
    is_alphanumeric: z.coerce.boolean().optional(),
  })

  router.post(
    "reposCreateAutolink",
    "/repos/:owner/:repo/autolinks",
    paramValidationFactory<t_ReposCreateAutolinkParamSchema>(
      reposCreateAutolinkParamSchema
    ),
    bodyValidationFactory<t_ReposCreateAutolinkBodySchema>(
      reposCreateAutolinkBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateAutolinkParamSchema,
        void,
        t_ReposCreateAutolinkBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateAutolink(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetAutolinkParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    autolink_id: z.coerce.number(),
  })

  router.get(
    "reposGetAutolink",
    "/repos/:owner/:repo/autolinks/:autolinkId",
    paramValidationFactory<t_ReposGetAutolinkParamSchema>(
      reposGetAutolinkParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetAutolinkParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetAutolink(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteAutolinkParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    autolink_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteAutolink",
    "/repos/:owner/:repo/autolinks/:autolinkId",
    paramValidationFactory<t_ReposDeleteAutolinkParamSchema>(
      reposDeleteAutolinkParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteAutolinkParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteAutolink(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposEnableAutomatedSecurityFixesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.put(
    "reposEnableAutomatedSecurityFixes",
    "/repos/:owner/:repo/automated-security-fixes",
    paramValidationFactory<t_ReposEnableAutomatedSecurityFixesParamSchema>(
      reposEnableAutomatedSecurityFixesParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposEnableAutomatedSecurityFixesParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposEnableAutomatedSecurityFixes(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDisableAutomatedSecurityFixesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "reposDisableAutomatedSecurityFixes",
    "/repos/:owner/:repo/automated-security-fixes",
    paramValidationFactory<t_ReposDisableAutomatedSecurityFixesParamSchema>(
      reposDisableAutomatedSecurityFixesParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDisableAutomatedSecurityFixesParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDisableAutomatedSecurityFixes(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListBranchesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListBranchesQuerySchema = z.object({
    protected: z.coerce.boolean().optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListBranches",
    "/repos/:owner/:repo/branches",
    paramValidationFactory<t_ReposListBranchesParamSchema>(
      reposListBranchesParamSchema
    ),
    queryValidationFactory<t_ReposListBranchesQuerySchema>(
      reposListBranchesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListBranchesParamSchema,
        t_ReposListBranchesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListBranches(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetBranchParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetBranch",
    "/repos/:owner/:repo/branches/:branch",
    paramValidationFactory<t_ReposGetBranchParamSchema>(
      reposGetBranchParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetBranchParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetBranch(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetBranchProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection",
    paramValidationFactory<t_ReposGetBranchProtectionParamSchema>(
      reposGetBranchProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetBranchProtectionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetBranchProtection(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateBranchProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposUpdateBranchProtectionBodySchema = z.object({
    required_status_checks: z.object({
      strict: z.coerce.boolean(),
      contexts: z.array(z.coerce.string()),
      checks: z
        .array(
          z.object({
            context: z.coerce.string(),
            app_id: z.coerce.number().optional(),
          })
        )
        .optional(),
    }),
    enforce_admins: z.coerce.boolean(),
    required_pull_request_reviews: z.object({
      dismissal_restrictions: z
        .object({
          users: z.array(z.coerce.string()).optional(),
          teams: z.array(z.coerce.string()).optional(),
          apps: z.array(z.coerce.string()).optional(),
        })
        .optional(),
      dismiss_stale_reviews: z.coerce.boolean().optional(),
      require_code_owner_reviews: z.coerce.boolean().optional(),
      required_approving_review_count: z.coerce.number().optional(),
      require_last_push_approval: z.coerce.boolean().optional(),
      bypass_pull_request_allowances: z
        .object({
          users: z.array(z.coerce.string()).optional(),
          teams: z.array(z.coerce.string()).optional(),
          apps: z.array(z.coerce.string()).optional(),
        })
        .optional(),
    }),
    restrictions: z.object({
      users: z.array(z.coerce.string()),
      teams: z.array(z.coerce.string()),
      apps: z.array(z.coerce.string()).optional(),
    }),
    required_linear_history: z.coerce.boolean().optional(),
    allow_force_pushes: z.coerce.boolean().optional(),
    allow_deletions: z.coerce.boolean().optional(),
    block_creations: z.coerce.boolean().optional(),
    required_conversation_resolution: z.coerce.boolean().optional(),
    lock_branch: z.coerce.boolean().optional(),
    allow_fork_syncing: z.coerce.boolean().optional(),
  })

  router.put(
    "reposUpdateBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection",
    paramValidationFactory<t_ReposUpdateBranchProtectionParamSchema>(
      reposUpdateBranchProtectionParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateBranchProtectionBodySchema>(
      reposUpdateBranchProtectionBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateBranchProtectionParamSchema,
        void,
        t_ReposUpdateBranchProtectionBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUpdateBranchProtection(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteBranchProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.delete(
    "reposDeleteBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection",
    paramValidationFactory<t_ReposDeleteBranchProtectionParamSchema>(
      reposDeleteBranchProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteBranchProtectionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteBranchProtection(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetAdminBranchProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetAdminBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection/enforce_admins",
    paramValidationFactory<t_ReposGetAdminBranchProtectionParamSchema>(
      reposGetAdminBranchProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetAdminBranchProtectionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetAdminBranchProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposSetAdminBranchProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.post(
    "reposSetAdminBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection/enforce_admins",
    paramValidationFactory<t_ReposSetAdminBranchProtectionParamSchema>(
      reposSetAdminBranchProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposSetAdminBranchProtectionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposSetAdminBranchProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteAdminBranchProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.delete(
    "reposDeleteAdminBranchProtection",
    "/repos/:owner/:repo/branches/:branch/protection/enforce_admins",
    paramValidationFactory<t_ReposDeleteAdminBranchProtectionParamSchema>(
      reposDeleteAdminBranchProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDeleteAdminBranchProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDeleteAdminBranchProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetPullRequestReviewProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetPullRequestReviewProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews",
    paramValidationFactory<t_ReposGetPullRequestReviewProtectionParamSchema>(
      reposGetPullRequestReviewProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetPullRequestReviewProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetPullRequestReviewProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdatePullRequestReviewProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposUpdatePullRequestReviewProtectionBodySchema = z
    .object({
      dismissal_restrictions: z
        .object({
          users: z.array(z.coerce.string()).optional(),
          teams: z.array(z.coerce.string()).optional(),
          apps: z.array(z.coerce.string()).optional(),
        })
        .optional(),
      dismiss_stale_reviews: z.coerce.boolean().optional(),
      require_code_owner_reviews: z.coerce.boolean().optional(),
      required_approving_review_count: z.coerce.number().optional(),
      require_last_push_approval: z.coerce.boolean().optional(),
      bypass_pull_request_allowances: z
        .object({
          users: z.array(z.coerce.string()).optional(),
          teams: z.array(z.coerce.string()).optional(),
          apps: z.array(z.coerce.string()).optional(),
        })
        .optional(),
    })
    .optional()

  router.patch(
    "reposUpdatePullRequestReviewProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews",
    paramValidationFactory<t_ReposUpdatePullRequestReviewProtectionParamSchema>(
      reposUpdatePullRequestReviewProtectionParamSchema
    ),
    bodyValidationFactory<t_ReposUpdatePullRequestReviewProtectionBodySchema>(
      reposUpdatePullRequestReviewProtectionBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdatePullRequestReviewProtectionParamSchema,
        void,
        t_ReposUpdatePullRequestReviewProtectionBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposUpdatePullRequestReviewProtection(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeletePullRequestReviewProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.delete(
    "reposDeletePullRequestReviewProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews",
    paramValidationFactory<t_ReposDeletePullRequestReviewProtectionParamSchema>(
      reposDeletePullRequestReviewProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDeletePullRequestReviewProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDeletePullRequestReviewProtection(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCommitSignatureProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetCommitSignatureProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_signatures",
    paramValidationFactory<t_ReposGetCommitSignatureProtectionParamSchema>(
      reposGetCommitSignatureProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetCommitSignatureProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetCommitSignatureProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateCommitSignatureProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.post(
    "reposCreateCommitSignatureProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_signatures",
    paramValidationFactory<t_ReposCreateCommitSignatureProtectionParamSchema>(
      reposCreateCommitSignatureProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateCommitSignatureProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposCreateCommitSignatureProtection(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteCommitSignatureProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.delete(
    "reposDeleteCommitSignatureProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_signatures",
    paramValidationFactory<t_ReposDeleteCommitSignatureProtectionParamSchema>(
      reposDeleteCommitSignatureProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDeleteCommitSignatureProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDeleteCommitSignatureProtection(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetStatusChecksProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetStatusChecksProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks",
    paramValidationFactory<t_ReposGetStatusChecksProtectionParamSchema>(
      reposGetStatusChecksProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetStatusChecksProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetStatusChecksProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateStatusCheckProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposUpdateStatusCheckProtectionBodySchema = z
    .object({
      strict: z.coerce.boolean().optional(),
      contexts: z.array(z.coerce.string()).optional(),
      checks: z
        .array(
          z.object({
            context: z.coerce.string(),
            app_id: z.coerce.number().optional(),
          })
        )
        .optional(),
    })
    .optional()

  router.patch(
    "reposUpdateStatusCheckProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks",
    paramValidationFactory<t_ReposUpdateStatusCheckProtectionParamSchema>(
      reposUpdateStatusCheckProtectionParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateStatusCheckProtectionBodySchema>(
      reposUpdateStatusCheckProtectionBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateStatusCheckProtectionParamSchema,
        void,
        t_ReposUpdateStatusCheckProtectionBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposUpdateStatusCheckProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRemoveStatusCheckProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.delete(
    "reposRemoveStatusCheckProtection",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks",
    paramValidationFactory<t_ReposRemoveStatusCheckProtectionParamSchema>(
      reposRemoveStatusCheckProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposRemoveStatusCheckProtectionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposRemoveStatusCheckProtection(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetAllStatusCheckContextsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetAllStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    paramValidationFactory<t_ReposGetAllStatusCheckContextsParamSchema>(
      reposGetAllStatusCheckContextsParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetAllStatusCheckContextsParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetAllStatusCheckContexts(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposAddStatusCheckContextsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposAddStatusCheckContextsBodySchema = z.union([
    z.object({ contexts: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.post(
    "reposAddStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    paramValidationFactory<t_ReposAddStatusCheckContextsParamSchema>(
      reposAddStatusCheckContextsParamSchema
    ),
    bodyValidationFactory<t_ReposAddStatusCheckContextsBodySchema>(
      reposAddStatusCheckContextsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposAddStatusCheckContextsParamSchema,
        void,
        t_ReposAddStatusCheckContextsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposAddStatusCheckContexts(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposSetStatusCheckContextsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposSetStatusCheckContextsBodySchema = z.union([
    z.object({ contexts: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.put(
    "reposSetStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    paramValidationFactory<t_ReposSetStatusCheckContextsParamSchema>(
      reposSetStatusCheckContextsParamSchema
    ),
    bodyValidationFactory<t_ReposSetStatusCheckContextsBodySchema>(
      reposSetStatusCheckContextsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposSetStatusCheckContextsParamSchema,
        void,
        t_ReposSetStatusCheckContextsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposSetStatusCheckContexts(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRemoveStatusCheckContextsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposRemoveStatusCheckContextsBodySchema = z.union([
    z.object({ contexts: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.delete(
    "reposRemoveStatusCheckContexts",
    "/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts",
    paramValidationFactory<t_ReposRemoveStatusCheckContextsParamSchema>(
      reposRemoveStatusCheckContextsParamSchema
    ),
    bodyValidationFactory<t_ReposRemoveStatusCheckContextsBodySchema>(
      reposRemoveStatusCheckContextsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposRemoveStatusCheckContextsParamSchema,
        void,
        t_ReposRemoveStatusCheckContextsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposRemoveStatusCheckContexts(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions",
    paramValidationFactory<t_ReposGetAccessRestrictionsParamSchema>(
      reposGetAccessRestrictionsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetAccessRestrictionsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetAccessRestrictions(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.delete(
    "reposDeleteAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions",
    paramValidationFactory<t_ReposDeleteAccessRestrictionsParamSchema>(
      reposDeleteAccessRestrictionsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteAccessRestrictionsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDeleteAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetAppsWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetAppsWithAccessToProtectedBranch",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    paramValidationFactory<t_ReposGetAppsWithAccessToProtectedBranchParamSchema>(
      reposGetAppsWithAccessToProtectedBranchParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetAppsWithAccessToProtectedBranchParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetAppsWithAccessToProtectedBranch(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposAddAppAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposAddAppAccessRestrictionsBodySchema = z.union([
    z.object({ apps: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.post(
    "reposAddAppAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    paramValidationFactory<t_ReposAddAppAccessRestrictionsParamSchema>(
      reposAddAppAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposAddAppAccessRestrictionsBodySchema>(
      reposAddAppAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposAddAppAccessRestrictionsParamSchema,
        void,
        t_ReposAddAppAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposAddAppAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposSetAppAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposSetAppAccessRestrictionsBodySchema = z.union([
    z.object({ apps: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.put(
    "reposSetAppAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    paramValidationFactory<t_ReposSetAppAccessRestrictionsParamSchema>(
      reposSetAppAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposSetAppAccessRestrictionsBodySchema>(
      reposSetAppAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposSetAppAccessRestrictionsParamSchema,
        void,
        t_ReposSetAppAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposSetAppAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRemoveAppAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposRemoveAppAccessRestrictionsBodySchema = z.union([
    z.object({ apps: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.delete(
    "reposRemoveAppAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/apps",
    paramValidationFactory<t_ReposRemoveAppAccessRestrictionsParamSchema>(
      reposRemoveAppAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposRemoveAppAccessRestrictionsBodySchema>(
      reposRemoveAppAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposRemoveAppAccessRestrictionsParamSchema,
        void,
        t_ReposRemoveAppAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposRemoveAppAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetTeamsWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetTeamsWithAccessToProtectedBranch",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    paramValidationFactory<t_ReposGetTeamsWithAccessToProtectedBranchParamSchema>(
      reposGetTeamsWithAccessToProtectedBranchParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetTeamsWithAccessToProtectedBranchParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetTeamsWithAccessToProtectedBranch(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposAddTeamAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposAddTeamAccessRestrictionsBodySchema = z.union([
    z.object({ teams: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.post(
    "reposAddTeamAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    paramValidationFactory<t_ReposAddTeamAccessRestrictionsParamSchema>(
      reposAddTeamAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposAddTeamAccessRestrictionsBodySchema>(
      reposAddTeamAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposAddTeamAccessRestrictionsParamSchema,
        void,
        t_ReposAddTeamAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposAddTeamAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposSetTeamAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposSetTeamAccessRestrictionsBodySchema = z.union([
    z.object({ teams: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.put(
    "reposSetTeamAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    paramValidationFactory<t_ReposSetTeamAccessRestrictionsParamSchema>(
      reposSetTeamAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposSetTeamAccessRestrictionsBodySchema>(
      reposSetTeamAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposSetTeamAccessRestrictionsParamSchema,
        void,
        t_ReposSetTeamAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposSetTeamAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRemoveTeamAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposRemoveTeamAccessRestrictionsBodySchema = z.union([
    z.object({ teams: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.delete(
    "reposRemoveTeamAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/teams",
    paramValidationFactory<t_ReposRemoveTeamAccessRestrictionsParamSchema>(
      reposRemoveTeamAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposRemoveTeamAccessRestrictionsBodySchema>(
      reposRemoveTeamAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposRemoveTeamAccessRestrictionsParamSchema,
        void,
        t_ReposRemoveTeamAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposRemoveTeamAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetUsersWithAccessToProtectedBranchParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  router.get(
    "reposGetUsersWithAccessToProtectedBranch",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    paramValidationFactory<t_ReposGetUsersWithAccessToProtectedBranchParamSchema>(
      reposGetUsersWithAccessToProtectedBranchParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetUsersWithAccessToProtectedBranchParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetUsersWithAccessToProtectedBranch(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposAddUserAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposAddUserAccessRestrictionsBodySchema = z.union([
    z.object({ users: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.post(
    "reposAddUserAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    paramValidationFactory<t_ReposAddUserAccessRestrictionsParamSchema>(
      reposAddUserAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposAddUserAccessRestrictionsBodySchema>(
      reposAddUserAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposAddUserAccessRestrictionsParamSchema,
        void,
        t_ReposAddUserAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposAddUserAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposSetUserAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposSetUserAccessRestrictionsBodySchema = z.union([
    z.object({ users: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.put(
    "reposSetUserAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    paramValidationFactory<t_ReposSetUserAccessRestrictionsParamSchema>(
      reposSetUserAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposSetUserAccessRestrictionsBodySchema>(
      reposSetUserAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposSetUserAccessRestrictionsParamSchema,
        void,
        t_ReposSetUserAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposSetUserAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRemoveUserAccessRestrictionsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposRemoveUserAccessRestrictionsBodySchema = z.union([
    z.object({ users: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
  ])

  router.delete(
    "reposRemoveUserAccessRestrictions",
    "/repos/:owner/:repo/branches/:branch/protection/restrictions/users",
    paramValidationFactory<t_ReposRemoveUserAccessRestrictionsParamSchema>(
      reposRemoveUserAccessRestrictionsParamSchema
    ),
    bodyValidationFactory<t_ReposRemoveUserAccessRestrictionsBodySchema>(
      reposRemoveUserAccessRestrictionsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposRemoveUserAccessRestrictionsParamSchema,
        void,
        t_ReposRemoveUserAccessRestrictionsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposRemoveUserAccessRestrictions(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRenameBranchParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    branch: z.coerce.string(),
  })

  const reposRenameBranchBodySchema = z.object({ new_name: z.coerce.string() })

  router.post(
    "reposRenameBranch",
    "/repos/:owner/:repo/branches/:branch/rename",
    paramValidationFactory<t_ReposRenameBranchParamSchema>(
      reposRenameBranchParamSchema
    ),
    bodyValidationFactory<t_ReposRenameBranchBodySchema>(
      reposRenameBranchBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposRenameBranchParamSchema,
        void,
        t_ReposRenameBranchBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposRenameBranch(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksCreateParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const checksCreateBodySchema = z.union([
    z.object({ status: z.object({}) }),
    z.object({ status: z.object({}).optional() }),
  ])

  router.post(
    "checksCreate",
    "/repos/:owner/:repo/check-runs",
    paramValidationFactory<t_ChecksCreateParamSchema>(checksCreateParamSchema),
    bodyValidationFactory<t_ChecksCreateBodySchema>(checksCreateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_ChecksCreateParamSchema,
        void,
        t_ChecksCreateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksCreate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksGetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    check_run_id: z.coerce.number(),
  })

  router.get(
    "checksGet",
    "/repos/:owner/:repo/check-runs/:checkRunId",
    paramValidationFactory<t_ChecksGetParamSchema>(checksGetParamSchema),
    async (
      ctx: ValidatedCtx<t_ChecksGetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.checksGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksUpdateParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    check_run_id: z.coerce.number(),
  })

  const checksUpdateBodySchema = z.object({
    name: z.coerce.string().optional(),
    details_url: z.coerce.string().optional(),
    external_id: z.coerce.string().optional(),
    started_at: z.coerce.string().datetime({ offset: true }).optional(),
    status: z.enum(["queued", "in_progress", "completed"]).optional(),
    conclusion: z
      .enum([
        "action_required",
        "cancelled",
        "failure",
        "neutral",
        "success",
        "skipped",
        "stale",
        "timed_out",
      ])
      .optional(),
    completed_at: z.coerce.string().datetime({ offset: true }).optional(),
    output: z
      .object({
        title: z.coerce.string().optional(),
        summary: z.coerce.string(),
        text: z.coerce.string().optional(),
        annotations: z
          .array(
            z.object({
              path: z.coerce.string(),
              start_line: z.coerce.number(),
              end_line: z.coerce.number(),
              start_column: z.coerce.number().optional(),
              end_column: z.coerce.number().optional(),
              annotation_level: z.enum(["notice", "warning", "failure"]),
              message: z.coerce.string(),
              title: z.coerce.string().optional(),
              raw_details: z.coerce.string().optional(),
            })
          )
          .optional(),
        images: z
          .array(
            z.object({
              alt: z.coerce.string(),
              image_url: z.coerce.string(),
              caption: z.coerce.string().optional(),
            })
          )
          .optional(),
      })
      .optional(),
    actions: z
      .array(
        z.object({
          label: z.coerce.string(),
          description: z.coerce.string(),
          identifier: z.coerce.string(),
        })
      )
      .optional(),
  })

  router.patch(
    "checksUpdate",
    "/repos/:owner/:repo/check-runs/:checkRunId",
    paramValidationFactory<t_ChecksUpdateParamSchema>(checksUpdateParamSchema),
    bodyValidationFactory<t_ChecksUpdateBodySchema>(checksUpdateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_ChecksUpdateParamSchema,
        void,
        t_ChecksUpdateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksUpdate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksListAnnotationsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    check_run_id: z.coerce.number(),
  })

  const checksListAnnotationsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "checksListAnnotations",
    "/repos/:owner/:repo/check-runs/:checkRunId/annotations",
    paramValidationFactory<t_ChecksListAnnotationsParamSchema>(
      checksListAnnotationsParamSchema
    ),
    queryValidationFactory<t_ChecksListAnnotationsQuerySchema>(
      checksListAnnotationsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ChecksListAnnotationsParamSchema,
        t_ChecksListAnnotationsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksListAnnotations(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksRerequestRunParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    check_run_id: z.coerce.number(),
  })

  router.post(
    "checksRerequestRun",
    "/repos/:owner/:repo/check-runs/:checkRunId/rerequest",
    paramValidationFactory<t_ChecksRerequestRunParamSchema>(
      checksRerequestRunParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ChecksRerequestRunParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.checksRerequestRun(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksCreateSuiteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const checksCreateSuiteBodySchema = z.object({ head_sha: z.coerce.string() })

  router.post(
    "checksCreateSuite",
    "/repos/:owner/:repo/check-suites",
    paramValidationFactory<t_ChecksCreateSuiteParamSchema>(
      checksCreateSuiteParamSchema
    ),
    bodyValidationFactory<t_ChecksCreateSuiteBodySchema>(
      checksCreateSuiteBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ChecksCreateSuiteParamSchema,
        void,
        t_ChecksCreateSuiteBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksCreateSuite(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksSetSuitesPreferencesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const checksSetSuitesPreferencesBodySchema = z.object({
    auto_trigger_checks: z
      .array(
        z.object({ app_id: z.coerce.number(), setting: z.coerce.boolean() })
      )
      .optional(),
  })

  router.patch(
    "checksSetSuitesPreferences",
    "/repos/:owner/:repo/check-suites/preferences",
    paramValidationFactory<t_ChecksSetSuitesPreferencesParamSchema>(
      checksSetSuitesPreferencesParamSchema
    ),
    bodyValidationFactory<t_ChecksSetSuitesPreferencesBodySchema>(
      checksSetSuitesPreferencesBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ChecksSetSuitesPreferencesParamSchema,
        void,
        t_ChecksSetSuitesPreferencesBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksSetSuitesPreferences(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksGetSuiteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    check_suite_id: z.coerce.number(),
  })

  router.get(
    "checksGetSuite",
    "/repos/:owner/:repo/check-suites/:checkSuiteId",
    paramValidationFactory<t_ChecksGetSuiteParamSchema>(
      checksGetSuiteParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ChecksGetSuiteParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.checksGetSuite(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksListForSuiteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    check_suite_id: z.coerce.number(),
  })

  const checksListForSuiteQuerySchema = z.object({
    check_name: z.coerce.string().optional(),
    status: z.enum(["queued", "in_progress", "completed"]).optional(),
    filter: z.enum(["latest", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "checksListForSuite",
    "/repos/:owner/:repo/check-suites/:checkSuiteId/check-runs",
    paramValidationFactory<t_ChecksListForSuiteParamSchema>(
      checksListForSuiteParamSchema
    ),
    queryValidationFactory<t_ChecksListForSuiteQuerySchema>(
      checksListForSuiteQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ChecksListForSuiteParamSchema,
        t_ChecksListForSuiteQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksListForSuite(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksRerequestSuiteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    check_suite_id: z.coerce.number(),
  })

  router.post(
    "checksRerequestSuite",
    "/repos/:owner/:repo/check-suites/:checkSuiteId/rerequest",
    paramValidationFactory<t_ChecksRerequestSuiteParamSchema>(
      checksRerequestSuiteParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ChecksRerequestSuiteParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.checksRerequestSuite(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningListAlertsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codeScanningListAlertsForRepoQuerySchema = z.object({
    tool_name: z.coerce.string().optional(),
    tool_guid: z.coerce.string().optional(),
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
    ref: z.coerce.string().optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    sort: z.enum(["created", "updated"]).optional(),
    state: z.enum(["open", "closed", "dismissed", "fixed"]).optional(),
    severity: z
      .enum(["critical", "high", "medium", "low", "warning", "note", "error"])
      .optional(),
  })

  router.get(
    "codeScanningListAlertsForRepo",
    "/repos/:owner/:repo/code-scanning/alerts",
    paramValidationFactory<t_CodeScanningListAlertsForRepoParamSchema>(
      codeScanningListAlertsForRepoParamSchema
    ),
    queryValidationFactory<t_CodeScanningListAlertsForRepoQuerySchema>(
      codeScanningListAlertsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningListAlertsForRepoParamSchema,
        t_CodeScanningListAlertsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codeScanningListAlertsForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningGetAlertParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  router.get(
    "codeScanningGetAlert",
    "/repos/:owner/:repo/code-scanning/alerts/:alertNumber",
    paramValidationFactory<t_CodeScanningGetAlertParamSchema>(
      codeScanningGetAlertParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodeScanningGetAlertParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codeScanningGetAlert(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningUpdateAlertParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  const codeScanningUpdateAlertBodySchema = z.object({
    state: z.enum(["open", "dismissed"]),
    dismissed_reason: z
      .enum(["null", "false positive", "won't fix", "used in tests"])
      .optional(),
    dismissed_comment: z.coerce.string().optional(),
  })

  router.patch(
    "codeScanningUpdateAlert",
    "/repos/:owner/:repo/code-scanning/alerts/:alertNumber",
    paramValidationFactory<t_CodeScanningUpdateAlertParamSchema>(
      codeScanningUpdateAlertParamSchema
    ),
    bodyValidationFactory<t_CodeScanningUpdateAlertBodySchema>(
      codeScanningUpdateAlertBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningUpdateAlertParamSchema,
        void,
        t_CodeScanningUpdateAlertBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.codeScanningUpdateAlert(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningListAlertInstancesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  const codeScanningListAlertInstancesQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
    ref: z.coerce.string().optional(),
  })

  router.get(
    "codeScanningListAlertInstances",
    "/repos/:owner/:repo/code-scanning/alerts/:alertNumber/instances",
    paramValidationFactory<t_CodeScanningListAlertInstancesParamSchema>(
      codeScanningListAlertInstancesParamSchema
    ),
    queryValidationFactory<t_CodeScanningListAlertInstancesQuerySchema>(
      codeScanningListAlertInstancesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningListAlertInstancesParamSchema,
        t_CodeScanningListAlertInstancesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codeScanningListAlertInstances(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningListRecentAnalysesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codeScanningListRecentAnalysesQuerySchema = z.object({
    tool_name: z.coerce.string().optional(),
    tool_guid: z.coerce.string().optional(),
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
    ref: z.coerce.string().optional(),
    sarif_id: z.coerce.string().optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    sort: z.enum(["created"]).optional(),
  })

  router.get(
    "codeScanningListRecentAnalyses",
    "/repos/:owner/:repo/code-scanning/analyses",
    paramValidationFactory<t_CodeScanningListRecentAnalysesParamSchema>(
      codeScanningListRecentAnalysesParamSchema
    ),
    queryValidationFactory<t_CodeScanningListRecentAnalysesQuerySchema>(
      codeScanningListRecentAnalysesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningListRecentAnalysesParamSchema,
        t_CodeScanningListRecentAnalysesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codeScanningListRecentAnalyses(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningGetAnalysisParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    analysis_id: z.coerce.number(),
  })

  router.get(
    "codeScanningGetAnalysis",
    "/repos/:owner/:repo/code-scanning/analyses/:analysisId",
    paramValidationFactory<t_CodeScanningGetAnalysisParamSchema>(
      codeScanningGetAnalysisParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodeScanningGetAnalysisParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codeScanningGetAnalysis(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningDeleteAnalysisParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    analysis_id: z.coerce.number(),
  })

  const codeScanningDeleteAnalysisQuerySchema = z.object({
    confirm_delete: z.coerce.string().optional(),
  })

  router.delete(
    "codeScanningDeleteAnalysis",
    "/repos/:owner/:repo/code-scanning/analyses/:analysisId",
    paramValidationFactory<t_CodeScanningDeleteAnalysisParamSchema>(
      codeScanningDeleteAnalysisParamSchema
    ),
    queryValidationFactory<t_CodeScanningDeleteAnalysisQuerySchema>(
      codeScanningDeleteAnalysisQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningDeleteAnalysisParamSchema,
        t_CodeScanningDeleteAnalysisQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.codeScanningDeleteAnalysis(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningListCodeqlDatabasesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "codeScanningListCodeqlDatabases",
    "/repos/:owner/:repo/code-scanning/codeql/databases",
    paramValidationFactory<t_CodeScanningListCodeqlDatabasesParamSchema>(
      codeScanningListCodeqlDatabasesParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningListCodeqlDatabasesParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codeScanningListCodeqlDatabases(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningGetCodeqlDatabaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    language: z.coerce.string(),
  })

  router.get(
    "codeScanningGetCodeqlDatabase",
    "/repos/:owner/:repo/code-scanning/codeql/databases/:language",
    paramValidationFactory<t_CodeScanningGetCodeqlDatabaseParamSchema>(
      codeScanningGetCodeqlDatabaseParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodeScanningGetCodeqlDatabaseParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codeScanningGetCodeqlDatabase(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningUploadSarifParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codeScanningUploadSarifBodySchema = z.object({
    commit_sha: z.coerce.string(),
    ref: z.coerce.string(),
    sarif: z.coerce.string(),
    checkout_uri: z.coerce.string().optional(),
    started_at: z.coerce.string().datetime({ offset: true }).optional(),
    tool_name: z.coerce.string().optional(),
    validate: z.coerce.boolean().optional(),
  })

  router.post(
    "codeScanningUploadSarif",
    "/repos/:owner/:repo/code-scanning/sarifs",
    paramValidationFactory<t_CodeScanningUploadSarifParamSchema>(
      codeScanningUploadSarifParamSchema
    ),
    bodyValidationFactory<t_CodeScanningUploadSarifBodySchema>(
      codeScanningUploadSarifBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodeScanningUploadSarifParamSchema,
        void,
        t_CodeScanningUploadSarifBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.codeScanningUploadSarif(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codeScanningGetSarifParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    sarif_id: z.coerce.string(),
  })

  router.get(
    "codeScanningGetSarif",
    "/repos/:owner/:repo/code-scanning/sarifs/:sarifId",
    paramValidationFactory<t_CodeScanningGetSarifParamSchema>(
      codeScanningGetSarifParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodeScanningGetSarifParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codeScanningGetSarif(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCodeownersErrorsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCodeownersErrorsQuerySchema = z.object({
    ref: z.coerce.string().optional(),
  })

  router.get(
    "reposCodeownersErrors",
    "/repos/:owner/:repo/codeowners/errors",
    paramValidationFactory<t_ReposCodeownersErrorsParamSchema>(
      reposCodeownersErrorsParamSchema
    ),
    queryValidationFactory<t_ReposCodeownersErrorsQuerySchema>(
      reposCodeownersErrorsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCodeownersErrorsParamSchema,
        t_ReposCodeownersErrorsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCodeownersErrors(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListInRepositoryForAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codespacesListInRepositoryForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListInRepositoryForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces",
    paramValidationFactory<t_CodespacesListInRepositoryForAuthenticatedUserParamSchema>(
      codespacesListInRepositoryForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema>(
      codespacesListInRepositoryForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesListInRepositoryForAuthenticatedUserParamSchema,
        t_CodespacesListInRepositoryForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesListInRepositoryForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesCreateWithRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codespacesCreateWithRepoForAuthenticatedUserBodySchema = z.object({
    ref: z.coerce.string().optional(),
    location: z.coerce.string().optional(),
    client_ip: z.coerce.string().optional(),
    machine: z.coerce.string().optional(),
    devcontainer_path: z.coerce.string().optional(),
    multi_repo_permissions_opt_out: z.coerce.boolean().optional(),
    working_directory: z.coerce.string().optional(),
    idle_timeout_minutes: z.coerce.number().optional(),
    display_name: z.coerce.string().optional(),
    retention_period_minutes: z.coerce.number().optional(),
  })

  router.post(
    "codespacesCreateWithRepoForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces",
    paramValidationFactory<t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema>(
      codespacesCreateWithRepoForAuthenticatedUserParamSchema
    ),
    bodyValidationFactory<t_CodespacesCreateWithRepoForAuthenticatedUserBodySchema>(
      codespacesCreateWithRepoForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesCreateWithRepoForAuthenticatedUserParamSchema,
        void,
        t_CodespacesCreateWithRepoForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesCreateWithRepoForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema =
    z.object({ owner: z.coerce.string(), repo: z.coerce.string() })

  const codespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema =
    z.object({
      per_page: z.coerce.number().optional(),
      page: z.coerce.number().optional(),
    })

  router.get(
    "codespacesListDevcontainersInRepositoryForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces/devcontainers",
    paramValidationFactory<t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema>(
      codespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema>(
      codespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserParamSchema,
        t_CodespacesListDevcontainersInRepositoryForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesListDevcontainersInRepositoryForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesRepoMachinesForAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codespacesRepoMachinesForAuthenticatedUserQuerySchema = z.object({
    location: z.coerce.string().optional(),
    client_ip: z.coerce.string().optional(),
  })

  router.get(
    "codespacesRepoMachinesForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces/machines",
    paramValidationFactory<t_CodespacesRepoMachinesForAuthenticatedUserParamSchema>(
      codespacesRepoMachinesForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema>(
      codespacesRepoMachinesForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesRepoMachinesForAuthenticatedUserParamSchema,
        t_CodespacesRepoMachinesForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesRepoMachinesForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesPreFlightWithRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codespacesPreFlightWithRepoForAuthenticatedUserQuerySchema = z.object({
    ref: z.coerce.string().optional(),
    client_ip: z.coerce.string().optional(),
  })

  router.get(
    "codespacesPreFlightWithRepoForAuthenticatedUser",
    "/repos/:owner/:repo/codespaces/new",
    paramValidationFactory<t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema>(
      codespacesPreFlightWithRepoForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema>(
      codespacesPreFlightWithRepoForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesPreFlightWithRepoForAuthenticatedUserParamSchema,
        t_CodespacesPreFlightWithRepoForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesPreFlightWithRepoForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListRepoSecretsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const codespacesListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListRepoSecrets",
    "/repos/:owner/:repo/codespaces/secrets",
    paramValidationFactory<t_CodespacesListRepoSecretsParamSchema>(
      codespacesListRepoSecretsParamSchema
    ),
    queryValidationFactory<t_CodespacesListRepoSecretsQuerySchema>(
      codespacesListRepoSecretsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesListRepoSecretsParamSchema,
        t_CodespacesListRepoSecretsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesListRepoSecrets(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetRepoPublicKeyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "codespacesGetRepoPublicKey",
    "/repos/:owner/:repo/codespaces/secrets/public-key",
    paramValidationFactory<t_CodespacesGetRepoPublicKeyParamSchema>(
      codespacesGetRepoPublicKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodespacesGetRepoPublicKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesGetRepoPublicKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.get(
    "codespacesGetRepoSecret",
    "/repos/:owner/:repo/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesGetRepoSecretParamSchema>(
      codespacesGetRepoSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodespacesGetRepoSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesGetRepoSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const codespacesCreateOrUpdateRepoSecretBodySchema = z.object({
    encrypted_value: z.coerce.string().optional(),
    key_id: z.coerce.string().optional(),
  })

  router.put(
    "codespacesCreateOrUpdateRepoSecret",
    "/repos/:owner/:repo/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesCreateOrUpdateRepoSecretParamSchema>(
      codespacesCreateOrUpdateRepoSecretParamSchema
    ),
    bodyValidationFactory<t_CodespacesCreateOrUpdateRepoSecretBodySchema>(
      codespacesCreateOrUpdateRepoSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesCreateOrUpdateRepoSecretParamSchema,
        void,
        t_CodespacesCreateOrUpdateRepoSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesCreateOrUpdateRepoSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesDeleteRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.delete(
    "codespacesDeleteRepoSecret",
    "/repos/:owner/:repo/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesDeleteRepoSecretParamSchema>(
      codespacesDeleteRepoSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_CodespacesDeleteRepoSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.codespacesDeleteRepoSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListCollaboratorsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListCollaboratorsQuerySchema = z.object({
    affiliation: z.enum(["outside", "direct", "all"]).optional(),
    permission: z
      .enum(["pull", "triage", "push", "maintain", "admin"])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListCollaborators",
    "/repos/:owner/:repo/collaborators",
    paramValidationFactory<t_ReposListCollaboratorsParamSchema>(
      reposListCollaboratorsParamSchema
    ),
    queryValidationFactory<t_ReposListCollaboratorsQuerySchema>(
      reposListCollaboratorsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListCollaboratorsParamSchema,
        t_ReposListCollaboratorsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListCollaborators(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCheckCollaboratorParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "reposCheckCollaborator",
    "/repos/:owner/:repo/collaborators/:username",
    paramValidationFactory<t_ReposCheckCollaboratorParamSchema>(
      reposCheckCollaboratorParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposCheckCollaboratorParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCheckCollaborator(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposAddCollaboratorParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    username: z.coerce.string(),
  })

  const reposAddCollaboratorBodySchema = z
    .object({ permission: z.coerce.string().optional() })
    .optional()

  router.put(
    "reposAddCollaborator",
    "/repos/:owner/:repo/collaborators/:username",
    paramValidationFactory<t_ReposAddCollaboratorParamSchema>(
      reposAddCollaboratorParamSchema
    ),
    bodyValidationFactory<t_ReposAddCollaboratorBodySchema>(
      reposAddCollaboratorBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposAddCollaboratorParamSchema,
        void,
        t_ReposAddCollaboratorBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposAddCollaborator(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRemoveCollaboratorParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "reposRemoveCollaborator",
    "/repos/:owner/:repo/collaborators/:username",
    paramValidationFactory<t_ReposRemoveCollaboratorParamSchema>(
      reposRemoveCollaboratorParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposRemoveCollaboratorParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposRemoveCollaborator(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCollaboratorPermissionLevelParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "reposGetCollaboratorPermissionLevel",
    "/repos/:owner/:repo/collaborators/:username/permission",
    paramValidationFactory<t_ReposGetCollaboratorPermissionLevelParamSchema>(
      reposGetCollaboratorPermissionLevelParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetCollaboratorPermissionLevelParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetCollaboratorPermissionLevel(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListCommitCommentsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListCommitCommentsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListCommitCommentsForRepo",
    "/repos/:owner/:repo/comments",
    paramValidationFactory<t_ReposListCommitCommentsForRepoParamSchema>(
      reposListCommitCommentsForRepoParamSchema
    ),
    queryValidationFactory<t_ReposListCommitCommentsForRepoQuerySchema>(
      reposListCommitCommentsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListCommitCommentsForRepoParamSchema,
        t_ReposListCommitCommentsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposListCommitCommentsForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCommitCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "reposGetCommitComment",
    "/repos/:owner/:repo/comments/:commentId",
    paramValidationFactory<t_ReposGetCommitCommentParamSchema>(
      reposGetCommitCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetCommitCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetCommitComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateCommitCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const reposUpdateCommitCommentBodySchema = z.object({
    body: z.coerce.string(),
  })

  router.patch(
    "reposUpdateCommitComment",
    "/repos/:owner/:repo/comments/:commentId",
    paramValidationFactory<t_ReposUpdateCommitCommentParamSchema>(
      reposUpdateCommitCommentParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateCommitCommentBodySchema>(
      reposUpdateCommitCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateCommitCommentParamSchema,
        void,
        t_ReposUpdateCommitCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUpdateCommitComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteCommitCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteCommitComment",
    "/repos/:owner/:repo/comments/:commentId",
    paramValidationFactory<t_ReposDeleteCommitCommentParamSchema>(
      reposDeleteCommitCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteCommitCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteCommitComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForCommitCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForCommitCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForCommitComment",
    "/repos/:owner/:repo/comments/:commentId/reactions",
    paramValidationFactory<t_ReactionsListForCommitCommentParamSchema>(
      reactionsListForCommitCommentParamSchema
    ),
    queryValidationFactory<t_ReactionsListForCommitCommentQuerySchema>(
      reactionsListForCommitCommentQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForCommitCommentParamSchema,
        t_ReactionsListForCommitCommentQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsListForCommitComment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForCommitCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForCommitCommentBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForCommitComment",
    "/repos/:owner/:repo/comments/:commentId/reactions",
    paramValidationFactory<t_ReactionsCreateForCommitCommentParamSchema>(
      reactionsCreateForCommitCommentParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForCommitCommentBodySchema>(
      reactionsCreateForCommitCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForCommitCommentParamSchema,
        void,
        t_ReactionsCreateForCommitCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsCreateForCommitComment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsDeleteForCommitCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForCommitComment",
    "/repos/:owner/:repo/comments/:commentId/reactions/:reactionId",
    paramValidationFactory<t_ReactionsDeleteForCommitCommentParamSchema>(
      reactionsDeleteForCommitCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsDeleteForCommitCommentParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsDeleteForCommitComment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListCommitsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListCommitsQuerySchema = z.object({
    sha: z.coerce.string().optional(),
    path: z.coerce.string().optional(),
    author: z.coerce.string().optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    until: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListCommits",
    "/repos/:owner/:repo/commits",
    paramValidationFactory<t_ReposListCommitsParamSchema>(
      reposListCommitsParamSchema
    ),
    queryValidationFactory<t_ReposListCommitsQuerySchema>(
      reposListCommitsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListCommitsParamSchema,
        t_ReposListCommitsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListCommits(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListBranchesForHeadCommitParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    commit_sha: z.coerce.string(),
  })

  router.get(
    "reposListBranchesForHeadCommit",
    "/repos/:owner/:repo/commits/:commitSha/branches-where-head",
    paramValidationFactory<t_ReposListBranchesForHeadCommitParamSchema>(
      reposListBranchesForHeadCommitParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListBranchesForHeadCommitParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposListBranchesForHeadCommit(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListCommentsForCommitParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    commit_sha: z.coerce.string(),
  })

  const reposListCommentsForCommitQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListCommentsForCommit",
    "/repos/:owner/:repo/commits/:commitSha/comments",
    paramValidationFactory<t_ReposListCommentsForCommitParamSchema>(
      reposListCommentsForCommitParamSchema
    ),
    queryValidationFactory<t_ReposListCommentsForCommitQuerySchema>(
      reposListCommentsForCommitQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListCommentsForCommitParamSchema,
        t_ReposListCommentsForCommitQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListCommentsForCommit(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateCommitCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    commit_sha: z.coerce.string(),
  })

  const reposCreateCommitCommentBodySchema = z.object({
    body: z.coerce.string(),
    path: z.coerce.string().optional(),
    position: z.coerce.number().optional(),
    line: z.coerce.number().optional(),
  })

  router.post(
    "reposCreateCommitComment",
    "/repos/:owner/:repo/commits/:commitSha/comments",
    paramValidationFactory<t_ReposCreateCommitCommentParamSchema>(
      reposCreateCommitCommentParamSchema
    ),
    bodyValidationFactory<t_ReposCreateCommitCommentBodySchema>(
      reposCreateCommitCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateCommitCommentParamSchema,
        void,
        t_ReposCreateCommitCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateCommitComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListPullRequestsAssociatedWithCommitParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    commit_sha: z.coerce.string(),
  })

  const reposListPullRequestsAssociatedWithCommitQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListPullRequestsAssociatedWithCommit",
    "/repos/:owner/:repo/commits/:commitSha/pulls",
    paramValidationFactory<t_ReposListPullRequestsAssociatedWithCommitParamSchema>(
      reposListPullRequestsAssociatedWithCommitParamSchema
    ),
    queryValidationFactory<t_ReposListPullRequestsAssociatedWithCommitQuerySchema>(
      reposListPullRequestsAssociatedWithCommitQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListPullRequestsAssociatedWithCommitParamSchema,
        t_ReposListPullRequestsAssociatedWithCommitQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposListPullRequestsAssociatedWithCommit(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCommitParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  const reposGetCommitQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "reposGetCommit",
    "/repos/:owner/:repo/commits/:ref",
    paramValidationFactory<t_ReposGetCommitParamSchema>(
      reposGetCommitParamSchema
    ),
    queryValidationFactory<t_ReposGetCommitQuerySchema>(
      reposGetCommitQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetCommitParamSchema,
        t_ReposGetCommitQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetCommit(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksListForRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  const checksListForRefQuerySchema = z.object({
    check_name: z.coerce.string().optional(),
    status: z.enum(["queued", "in_progress", "completed"]).optional(),
    filter: z.enum(["latest", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    app_id: z.coerce.number().optional(),
  })

  router.get(
    "checksListForRef",
    "/repos/:owner/:repo/commits/:ref/check-runs",
    paramValidationFactory<t_ChecksListForRefParamSchema>(
      checksListForRefParamSchema
    ),
    queryValidationFactory<t_ChecksListForRefQuerySchema>(
      checksListForRefQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ChecksListForRefParamSchema,
        t_ChecksListForRefQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksListForRef(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const checksListSuitesForRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  const checksListSuitesForRefQuerySchema = z.object({
    app_id: z.coerce.number().optional(),
    check_name: z.coerce.string().optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "checksListSuitesForRef",
    "/repos/:owner/:repo/commits/:ref/check-suites",
    paramValidationFactory<t_ChecksListSuitesForRefParamSchema>(
      checksListSuitesForRefParamSchema
    ),
    queryValidationFactory<t_ChecksListSuitesForRefQuerySchema>(
      checksListSuitesForRefQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ChecksListSuitesForRefParamSchema,
        t_ChecksListSuitesForRefQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.checksListSuitesForRef(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCombinedStatusForRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  const reposGetCombinedStatusForRefQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposGetCombinedStatusForRef",
    "/repos/:owner/:repo/commits/:ref/status",
    paramValidationFactory<t_ReposGetCombinedStatusForRefParamSchema>(
      reposGetCombinedStatusForRefParamSchema
    ),
    queryValidationFactory<t_ReposGetCombinedStatusForRefQuerySchema>(
      reposGetCombinedStatusForRefQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetCombinedStatusForRefParamSchema,
        t_ReposGetCombinedStatusForRefQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetCombinedStatusForRef(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListCommitStatusesForRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  const reposListCommitStatusesForRefQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListCommitStatusesForRef",
    "/repos/:owner/:repo/commits/:ref/statuses",
    paramValidationFactory<t_ReposListCommitStatusesForRefParamSchema>(
      reposListCommitStatusesForRefParamSchema
    ),
    queryValidationFactory<t_ReposListCommitStatusesForRefQuerySchema>(
      reposListCommitStatusesForRefQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListCommitStatusesForRefParamSchema,
        t_ReposListCommitStatusesForRefQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposListCommitStatusesForRef(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCommunityProfileMetricsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetCommunityProfileMetrics",
    "/repos/:owner/:repo/community/profile",
    paramValidationFactory<t_ReposGetCommunityProfileMetricsParamSchema>(
      reposGetCommunityProfileMetricsParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetCommunityProfileMetricsParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetCommunityProfileMetrics(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCompareCommitsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    basehead: z.coerce.string(),
  })

  const reposCompareCommitsQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "reposCompareCommits",
    "/repos/:owner/:repo/compare/:basehead",
    paramValidationFactory<t_ReposCompareCommitsParamSchema>(
      reposCompareCommitsParamSchema
    ),
    queryValidationFactory<t_ReposCompareCommitsQuerySchema>(
      reposCompareCommitsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCompareCommitsParamSchema,
        t_ReposCompareCommitsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCompareCommits(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetContentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    path: z.coerce.string(),
  })

  const reposGetContentQuerySchema = z.object({
    ref: z.coerce.string().optional(),
  })

  router.get(
    "reposGetContent",
    "/repos/:owner/:repo/contents/:path",
    paramValidationFactory<t_ReposGetContentParamSchema>(
      reposGetContentParamSchema
    ),
    queryValidationFactory<t_ReposGetContentQuerySchema>(
      reposGetContentQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetContentParamSchema,
        t_ReposGetContentQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetContent(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateOrUpdateFileContentsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    path: z.coerce.string(),
  })

  const reposCreateOrUpdateFileContentsBodySchema = z.object({
    message: z.coerce.string(),
    content: z.coerce.string(),
    sha: z.coerce.string().optional(),
    branch: z.coerce.string().optional(),
    committer: z
      .object({
        name: z.coerce.string(),
        email: z.coerce.string(),
        date: z.coerce.string().optional(),
      })
      .optional(),
    author: z
      .object({
        name: z.coerce.string(),
        email: z.coerce.string(),
        date: z.coerce.string().optional(),
      })
      .optional(),
  })

  router.put(
    "reposCreateOrUpdateFileContents",
    "/repos/:owner/:repo/contents/:path",
    paramValidationFactory<t_ReposCreateOrUpdateFileContentsParamSchema>(
      reposCreateOrUpdateFileContentsParamSchema
    ),
    bodyValidationFactory<t_ReposCreateOrUpdateFileContentsBodySchema>(
      reposCreateOrUpdateFileContentsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateOrUpdateFileContentsParamSchema,
        void,
        t_ReposCreateOrUpdateFileContentsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposCreateOrUpdateFileContents(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteFileParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    path: z.coerce.string(),
  })

  const reposDeleteFileBodySchema = z.object({
    message: z.coerce.string(),
    sha: z.coerce.string(),
    branch: z.coerce.string().optional(),
    committer: z
      .object({
        name: z.coerce.string().optional(),
        email: z.coerce.string().optional(),
      })
      .optional(),
    author: z
      .object({
        name: z.coerce.string().optional(),
        email: z.coerce.string().optional(),
      })
      .optional(),
  })

  router.delete(
    "reposDeleteFile",
    "/repos/:owner/:repo/contents/:path",
    paramValidationFactory<t_ReposDeleteFileParamSchema>(
      reposDeleteFileParamSchema
    ),
    bodyValidationFactory<t_ReposDeleteFileBodySchema>(
      reposDeleteFileBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDeleteFileParamSchema,
        void,
        t_ReposDeleteFileBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteFile(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListContributorsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListContributorsQuerySchema = z.object({
    anon: z.coerce.string().optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListContributors",
    "/repos/:owner/:repo/contributors",
    paramValidationFactory<t_ReposListContributorsParamSchema>(
      reposListContributorsParamSchema
    ),
    queryValidationFactory<t_ReposListContributorsQuerySchema>(
      reposListContributorsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListContributorsParamSchema,
        t_ReposListContributorsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListContributors(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotListAlertsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const dependabotListAlertsForRepoQuerySchema = z.object({
    state: z.coerce.string().optional(),
    severity: z.coerce.string().optional(),
    ecosystem: z.coerce.string().optional(),
    package: z.coerce.string().optional(),
    manifest: z.coerce.string().optional(),
    scope: z.enum(["development", "runtime"]).optional(),
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
    before: z.coerce.string().optional(),
    after: z.coerce.string().optional(),
    first: z.coerce.number().optional(),
    last: z.coerce.number().optional(),
  })

  router.get(
    "dependabotListAlertsForRepo",
    "/repos/:owner/:repo/dependabot/alerts",
    paramValidationFactory<t_DependabotListAlertsForRepoParamSchema>(
      dependabotListAlertsForRepoParamSchema
    ),
    queryValidationFactory<t_DependabotListAlertsForRepoQuerySchema>(
      dependabotListAlertsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotListAlertsForRepoParamSchema,
        t_DependabotListAlertsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotListAlertsForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotGetAlertParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  router.get(
    "dependabotGetAlert",
    "/repos/:owner/:repo/dependabot/alerts/:alertNumber",
    paramValidationFactory<t_DependabotGetAlertParamSchema>(
      dependabotGetAlertParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_DependabotGetAlertParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotGetAlert(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotUpdateAlertParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  const dependabotUpdateAlertBodySchema = z.object({
    state: z.enum(["dismissed", "open"]),
    dismissed_reason: z
      .enum([
        "fix_started",
        "inaccurate",
        "no_bandwidth",
        "not_used",
        "tolerable_risk",
      ])
      .optional(),
    dismissed_comment: z.coerce.string().optional(),
  })

  router.patch(
    "dependabotUpdateAlert",
    "/repos/:owner/:repo/dependabot/alerts/:alertNumber",
    paramValidationFactory<t_DependabotUpdateAlertParamSchema>(
      dependabotUpdateAlertParamSchema
    ),
    bodyValidationFactory<t_DependabotUpdateAlertBodySchema>(
      dependabotUpdateAlertBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotUpdateAlertParamSchema,
        void,
        t_DependabotUpdateAlertBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotUpdateAlert(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotListRepoSecretsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const dependabotListRepoSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "dependabotListRepoSecrets",
    "/repos/:owner/:repo/dependabot/secrets",
    paramValidationFactory<t_DependabotListRepoSecretsParamSchema>(
      dependabotListRepoSecretsParamSchema
    ),
    queryValidationFactory<t_DependabotListRepoSecretsQuerySchema>(
      dependabotListRepoSecretsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotListRepoSecretsParamSchema,
        t_DependabotListRepoSecretsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotListRepoSecrets(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotGetRepoPublicKeyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "dependabotGetRepoPublicKey",
    "/repos/:owner/:repo/dependabot/secrets/public-key",
    paramValidationFactory<t_DependabotGetRepoPublicKeyParamSchema>(
      dependabotGetRepoPublicKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_DependabotGetRepoPublicKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotGetRepoPublicKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotGetRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.get(
    "dependabotGetRepoSecret",
    "/repos/:owner/:repo/dependabot/secrets/:secretName",
    paramValidationFactory<t_DependabotGetRepoSecretParamSchema>(
      dependabotGetRepoSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_DependabotGetRepoSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotGetRepoSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotCreateOrUpdateRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const dependabotCreateOrUpdateRepoSecretBodySchema = z.object({
    encrypted_value: z.coerce.string().optional(),
    key_id: z.coerce.string().optional(),
  })

  router.put(
    "dependabotCreateOrUpdateRepoSecret",
    "/repos/:owner/:repo/dependabot/secrets/:secretName",
    paramValidationFactory<t_DependabotCreateOrUpdateRepoSecretParamSchema>(
      dependabotCreateOrUpdateRepoSecretParamSchema
    ),
    bodyValidationFactory<t_DependabotCreateOrUpdateRepoSecretBodySchema>(
      dependabotCreateOrUpdateRepoSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependabotCreateOrUpdateRepoSecretParamSchema,
        void,
        t_DependabotCreateOrUpdateRepoSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependabotCreateOrUpdateRepoSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependabotDeleteRepoSecretParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.delete(
    "dependabotDeleteRepoSecret",
    "/repos/:owner/:repo/dependabot/secrets/:secretName",
    paramValidationFactory<t_DependabotDeleteRepoSecretParamSchema>(
      dependabotDeleteRepoSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_DependabotDeleteRepoSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.dependabotDeleteRepoSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependencyGraphDiffRangeParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    basehead: z.coerce.string(),
  })

  const dependencyGraphDiffRangeQuerySchema = z.object({
    name: z.coerce.string().optional(),
  })

  router.get(
    "dependencyGraphDiffRange",
    "/repos/:owner/:repo/dependency-graph/compare/:basehead",
    paramValidationFactory<t_DependencyGraphDiffRangeParamSchema>(
      dependencyGraphDiffRangeParamSchema
    ),
    queryValidationFactory<t_DependencyGraphDiffRangeQuerySchema>(
      dependencyGraphDiffRangeQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependencyGraphDiffRangeParamSchema,
        t_DependencyGraphDiffRangeQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.dependencyGraphDiffRange(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const dependencyGraphCreateRepositorySnapshotParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const dependencyGraphCreateRepositorySnapshotBodySchema = z.object({
    version: z.coerce.number(),
    job: z.object({
      id: z.coerce.string(),
      correlator: z.coerce.string(),
      html_url: z.coerce.string().optional(),
    }),
    sha: z.coerce.string(),
    ref: z.coerce.string(),
    detector: z.object({
      name: z.coerce.string(),
      version: z.coerce.string(),
      url: z.coerce.string(),
    }),
    metadata: z.object({}).optional(),
    manifests: z.object({}).optional(),
    scanned: z.coerce.string().datetime({ offset: true }),
  })

  router.post(
    "dependencyGraphCreateRepositorySnapshot",
    "/repos/:owner/:repo/dependency-graph/snapshots",
    paramValidationFactory<t_DependencyGraphCreateRepositorySnapshotParamSchema>(
      dependencyGraphCreateRepositorySnapshotParamSchema
    ),
    bodyValidationFactory<t_DependencyGraphCreateRepositorySnapshotBodySchema>(
      dependencyGraphCreateRepositorySnapshotBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_DependencyGraphCreateRepositorySnapshotParamSchema,
        void,
        t_DependencyGraphCreateRepositorySnapshotBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.dependencyGraphCreateRepositorySnapshot(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListDeploymentsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListDeploymentsQuerySchema = z.object({
    sha: z.coerce.string().optional(),
    ref: z.coerce.string().optional(),
    task: z.coerce.string().optional(),
    environment: z.coerce.string().optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListDeployments",
    "/repos/:owner/:repo/deployments",
    paramValidationFactory<t_ReposListDeploymentsParamSchema>(
      reposListDeploymentsParamSchema
    ),
    queryValidationFactory<t_ReposListDeploymentsQuerySchema>(
      reposListDeploymentsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListDeploymentsParamSchema,
        t_ReposListDeploymentsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListDeployments(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateDeploymentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateDeploymentBodySchema = z.object({
    ref: z.coerce.string(),
    task: z.coerce.string().optional(),
    auto_merge: z.coerce.boolean().optional(),
    required_contexts: z.array(z.coerce.string()).optional(),
    payload: z.union([z.object({}), z.coerce.string()]),
    environment: z.coerce.string().optional(),
    description: z.coerce.string().optional(),
    transient_environment: z.coerce.boolean().optional(),
    production_environment: z.coerce.boolean().optional(),
  })

  router.post(
    "reposCreateDeployment",
    "/repos/:owner/:repo/deployments",
    paramValidationFactory<t_ReposCreateDeploymentParamSchema>(
      reposCreateDeploymentParamSchema
    ),
    bodyValidationFactory<t_ReposCreateDeploymentBodySchema>(
      reposCreateDeploymentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateDeploymentParamSchema,
        void,
        t_ReposCreateDeploymentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateDeployment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetDeploymentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    deployment_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeployment",
    "/repos/:owner/:repo/deployments/:deploymentId",
    paramValidationFactory<t_ReposGetDeploymentParamSchema>(
      reposGetDeploymentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetDeploymentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetDeployment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteDeploymentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    deployment_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteDeployment",
    "/repos/:owner/:repo/deployments/:deploymentId",
    paramValidationFactory<t_ReposDeleteDeploymentParamSchema>(
      reposDeleteDeploymentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteDeploymentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteDeployment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListDeploymentStatusesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    deployment_id: z.coerce.number(),
  })

  const reposListDeploymentStatusesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListDeploymentStatuses",
    "/repos/:owner/:repo/deployments/:deploymentId/statuses",
    paramValidationFactory<t_ReposListDeploymentStatusesParamSchema>(
      reposListDeploymentStatusesParamSchema
    ),
    queryValidationFactory<t_ReposListDeploymentStatusesQuerySchema>(
      reposListDeploymentStatusesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListDeploymentStatusesParamSchema,
        t_ReposListDeploymentStatusesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListDeploymentStatuses(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateDeploymentStatusParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    deployment_id: z.coerce.number(),
  })

  const reposCreateDeploymentStatusBodySchema = z.object({
    state: z.enum([
      "error",
      "failure",
      "inactive",
      "in_progress",
      "queued",
      "pending",
      "success",
    ]),
    target_url: z.coerce.string().optional(),
    log_url: z.coerce.string().optional(),
    description: z.coerce.string().optional(),
    environment: z.enum(["production", "staging", "qa"]).optional(),
    environment_url: z.coerce.string().optional(),
    auto_inactive: z.coerce.boolean().optional(),
  })

  router.post(
    "reposCreateDeploymentStatus",
    "/repos/:owner/:repo/deployments/:deploymentId/statuses",
    paramValidationFactory<t_ReposCreateDeploymentStatusParamSchema>(
      reposCreateDeploymentStatusParamSchema
    ),
    bodyValidationFactory<t_ReposCreateDeploymentStatusBodySchema>(
      reposCreateDeploymentStatusBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateDeploymentStatusParamSchema,
        void,
        t_ReposCreateDeploymentStatusBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateDeploymentStatus(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetDeploymentStatusParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    deployment_id: z.coerce.number(),
    status_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeploymentStatus",
    "/repos/:owner/:repo/deployments/:deploymentId/statuses/:statusId",
    paramValidationFactory<t_ReposGetDeploymentStatusParamSchema>(
      reposGetDeploymentStatusParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetDeploymentStatusParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetDeploymentStatus(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateDispatchEventParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateDispatchEventBodySchema = z.object({
    event_type: z.coerce.string(),
    client_payload: z.object({}).optional(),
  })

  router.post(
    "reposCreateDispatchEvent",
    "/repos/:owner/:repo/dispatches",
    paramValidationFactory<t_ReposCreateDispatchEventParamSchema>(
      reposCreateDispatchEventParamSchema
    ),
    bodyValidationFactory<t_ReposCreateDispatchEventBodySchema>(
      reposCreateDispatchEventBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateDispatchEventParamSchema,
        void,
        t_ReposCreateDispatchEventBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateDispatchEvent(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetAllEnvironmentsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposGetAllEnvironmentsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposGetAllEnvironments",
    "/repos/:owner/:repo/environments",
    paramValidationFactory<t_ReposGetAllEnvironmentsParamSchema>(
      reposGetAllEnvironmentsParamSchema
    ),
    queryValidationFactory<t_ReposGetAllEnvironmentsQuerySchema>(
      reposGetAllEnvironmentsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetAllEnvironmentsParamSchema,
        t_ReposGetAllEnvironmentsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetAllEnvironments(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetEnvironmentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
  })

  router.get(
    "reposGetEnvironment",
    "/repos/:owner/:repo/environments/:environmentName",
    paramValidationFactory<t_ReposGetEnvironmentParamSchema>(
      reposGetEnvironmentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetEnvironmentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetEnvironment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateOrUpdateEnvironmentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
  })

  const reposCreateOrUpdateEnvironmentBodySchema = z
    .object({
      wait_timer: z.coerce.number().optional(),
      reviewers: z
        .array(
          z.object({
            type: z.enum(["User", "Team"]).optional(),
            id: z.coerce.number().optional(),
          })
        )
        .optional(),
      deployment_branch_policy: z
        .object({
          protected_branches: z.coerce.boolean(),
          custom_branch_policies: z.coerce.boolean(),
        })
        .optional(),
    })
    .optional()

  router.put(
    "reposCreateOrUpdateEnvironment",
    "/repos/:owner/:repo/environments/:environmentName",
    paramValidationFactory<t_ReposCreateOrUpdateEnvironmentParamSchema>(
      reposCreateOrUpdateEnvironmentParamSchema
    ),
    bodyValidationFactory<t_ReposCreateOrUpdateEnvironmentBodySchema>(
      reposCreateOrUpdateEnvironmentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateOrUpdateEnvironmentParamSchema,
        void,
        t_ReposCreateOrUpdateEnvironmentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposCreateOrUpdateEnvironment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteAnEnvironmentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
  })

  router.delete(
    "reposDeleteAnEnvironment",
    "/repos/:owner/:repo/environments/:environmentName",
    paramValidationFactory<t_ReposDeleteAnEnvironmentParamSchema>(
      reposDeleteAnEnvironmentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteAnEnvironmentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteAnEnvironment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListDeploymentBranchPoliciesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
  })

  const reposListDeploymentBranchPoliciesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListDeploymentBranchPolicies",
    "/repos/:owner/:repo/environments/:environmentName/deployment-branch-policies",
    paramValidationFactory<t_ReposListDeploymentBranchPoliciesParamSchema>(
      reposListDeploymentBranchPoliciesParamSchema
    ),
    queryValidationFactory<t_ReposListDeploymentBranchPoliciesQuerySchema>(
      reposListDeploymentBranchPoliciesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListDeploymentBranchPoliciesParamSchema,
        t_ReposListDeploymentBranchPoliciesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposListDeploymentBranchPolicies(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateDeploymentBranchPolicyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
  })

  const reposCreateDeploymentBranchPolicyBodySchema = z.object({
    name: z.coerce.string(),
  })

  router.post(
    "reposCreateDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environmentName/deployment-branch-policies",
    paramValidationFactory<t_ReposCreateDeploymentBranchPolicyParamSchema>(
      reposCreateDeploymentBranchPolicyParamSchema
    ),
    bodyValidationFactory<t_ReposCreateDeploymentBranchPolicyBodySchema>(
      reposCreateDeploymentBranchPolicyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateDeploymentBranchPolicyParamSchema,
        void,
        t_ReposCreateDeploymentBranchPolicyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposCreateDeploymentBranchPolicy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetDeploymentBranchPolicyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
    branch_policy_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environmentName/deployment-branch-policies/:branchPolicyId",
    paramValidationFactory<t_ReposGetDeploymentBranchPolicyParamSchema>(
      reposGetDeploymentBranchPolicyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetDeploymentBranchPolicyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetDeploymentBranchPolicy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateDeploymentBranchPolicyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
    branch_policy_id: z.coerce.number(),
  })

  const reposUpdateDeploymentBranchPolicyBodySchema = z.object({
    name: z.coerce.string(),
  })

  router.put(
    "reposUpdateDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environmentName/deployment-branch-policies/:branchPolicyId",
    paramValidationFactory<t_ReposUpdateDeploymentBranchPolicyParamSchema>(
      reposUpdateDeploymentBranchPolicyParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateDeploymentBranchPolicyBodySchema>(
      reposUpdateDeploymentBranchPolicyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateDeploymentBranchPolicyParamSchema,
        void,
        t_ReposUpdateDeploymentBranchPolicyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposUpdateDeploymentBranchPolicy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteDeploymentBranchPolicyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    environment_name: z.coerce.string(),
    branch_policy_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteDeploymentBranchPolicy",
    "/repos/:owner/:repo/environments/:environmentName/deployment-branch-policies/:branchPolicyId",
    paramValidationFactory<t_ReposDeleteDeploymentBranchPolicyParamSchema>(
      reposDeleteDeploymentBranchPolicyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDeleteDeploymentBranchPolicyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDeleteDeploymentBranchPolicy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListRepoEventsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const activityListRepoEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListRepoEvents",
    "/repos/:owner/:repo/events",
    paramValidationFactory<t_ActivityListRepoEventsParamSchema>(
      activityListRepoEventsParamSchema
    ),
    queryValidationFactory<t_ActivityListRepoEventsQuerySchema>(
      activityListRepoEventsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListRepoEventsParamSchema,
        t_ActivityListRepoEventsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.activityListRepoEvents(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListForksParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListForksQuerySchema = z.object({
    sort: z.enum(["newest", "oldest", "stargazers", "watchers"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListForks",
    "/repos/:owner/:repo/forks",
    paramValidationFactory<t_ReposListForksParamSchema>(
      reposListForksParamSchema
    ),
    queryValidationFactory<t_ReposListForksQuerySchema>(
      reposListForksQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListForksParamSchema,
        t_ReposListForksQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListForks(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateForkParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateForkBodySchema = z
    .object({
      organization: z.coerce.string().optional(),
      name: z.coerce.string().optional(),
      default_branch_only: z.coerce.boolean().optional(),
    })
    .optional()

  router.post(
    "reposCreateFork",
    "/repos/:owner/:repo/forks",
    paramValidationFactory<t_ReposCreateForkParamSchema>(
      reposCreateForkParamSchema
    ),
    bodyValidationFactory<t_ReposCreateForkBodySchema>(
      reposCreateForkBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateForkParamSchema,
        void,
        t_ReposCreateForkBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateFork(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitCreateBlobParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const gitCreateBlobBodySchema = z.object({
    content: z.coerce.string(),
    encoding: z.coerce.string().optional(),
  })

  router.post(
    "gitCreateBlob",
    "/repos/:owner/:repo/git/blobs",
    paramValidationFactory<t_GitCreateBlobParamSchema>(
      gitCreateBlobParamSchema
    ),
    bodyValidationFactory<t_GitCreateBlobBodySchema>(gitCreateBlobBodySchema),
    async (
      ctx: ValidatedCtx<
        t_GitCreateBlobParamSchema,
        void,
        t_GitCreateBlobBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gitCreateBlob(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitGetBlobParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    file_sha: z.coerce.string(),
  })

  router.get(
    "gitGetBlob",
    "/repos/:owner/:repo/git/blobs/:fileSha",
    paramValidationFactory<t_GitGetBlobParamSchema>(gitGetBlobParamSchema),
    async (
      ctx: ValidatedCtx<t_GitGetBlobParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitGetBlob(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitCreateCommitParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const gitCreateCommitBodySchema = z.object({
    message: z.coerce.string(),
    tree: z.coerce.string(),
    parents: z.array(z.coerce.string()).optional(),
    author: z
      .object({
        name: z.coerce.string(),
        email: z.coerce.string(),
        date: z.coerce.string().datetime({ offset: true }).optional(),
      })
      .optional(),
    committer: z
      .object({
        name: z.coerce.string().optional(),
        email: z.coerce.string().optional(),
        date: z.coerce.string().datetime({ offset: true }).optional(),
      })
      .optional(),
    signature: z.coerce.string().optional(),
  })

  router.post(
    "gitCreateCommit",
    "/repos/:owner/:repo/git/commits",
    paramValidationFactory<t_GitCreateCommitParamSchema>(
      gitCreateCommitParamSchema
    ),
    bodyValidationFactory<t_GitCreateCommitBodySchema>(
      gitCreateCommitBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_GitCreateCommitParamSchema,
        void,
        t_GitCreateCommitBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gitCreateCommit(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitGetCommitParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    commit_sha: z.coerce.string(),
  })

  router.get(
    "gitGetCommit",
    "/repos/:owner/:repo/git/commits/:commitSha",
    paramValidationFactory<t_GitGetCommitParamSchema>(gitGetCommitParamSchema),
    async (
      ctx: ValidatedCtx<t_GitGetCommitParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitGetCommit(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitListMatchingRefsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  router.get(
    "gitListMatchingRefs",
    "/repos/:owner/:repo/git/matching-refs/:ref",
    paramValidationFactory<t_GitListMatchingRefsParamSchema>(
      gitListMatchingRefsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_GitListMatchingRefsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitListMatchingRefs(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitGetRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  router.get(
    "gitGetRef",
    "/repos/:owner/:repo/git/ref/:ref",
    paramValidationFactory<t_GitGetRefParamSchema>(gitGetRefParamSchema),
    async (
      ctx: ValidatedCtx<t_GitGetRefParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitGetRef(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitCreateRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const gitCreateRefBodySchema = z.object({
    ref: z.coerce.string(),
    sha: z.coerce.string(),
    key: z.coerce.string().optional(),
  })

  router.post(
    "gitCreateRef",
    "/repos/:owner/:repo/git/refs",
    paramValidationFactory<t_GitCreateRefParamSchema>(gitCreateRefParamSchema),
    bodyValidationFactory<t_GitCreateRefBodySchema>(gitCreateRefBodySchema),
    async (
      ctx: ValidatedCtx<
        t_GitCreateRefParamSchema,
        void,
        t_GitCreateRefBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gitCreateRef(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitUpdateRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  const gitUpdateRefBodySchema = z.object({
    sha: z.coerce.string(),
    force: z.coerce.boolean().optional(),
  })

  router.patch(
    "gitUpdateRef",
    "/repos/:owner/:repo/git/refs/:ref",
    paramValidationFactory<t_GitUpdateRefParamSchema>(gitUpdateRefParamSchema),
    bodyValidationFactory<t_GitUpdateRefBodySchema>(gitUpdateRefBodySchema),
    async (
      ctx: ValidatedCtx<
        t_GitUpdateRefParamSchema,
        void,
        t_GitUpdateRefBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gitUpdateRef(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitDeleteRefParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  router.delete(
    "gitDeleteRef",
    "/repos/:owner/:repo/git/refs/:ref",
    paramValidationFactory<t_GitDeleteRefParamSchema>(gitDeleteRefParamSchema),
    async (
      ctx: ValidatedCtx<t_GitDeleteRefParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitDeleteRef(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitCreateTagParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const gitCreateTagBodySchema = z.object({
    tag: z.coerce.string(),
    message: z.coerce.string(),
    object: z.coerce.string(),
    type: z.enum(["commit", "tree", "blob"]),
    tagger: z
      .object({
        name: z.coerce.string(),
        email: z.coerce.string(),
        date: z.coerce.string().datetime({ offset: true }).optional(),
      })
      .optional(),
  })

  router.post(
    "gitCreateTag",
    "/repos/:owner/:repo/git/tags",
    paramValidationFactory<t_GitCreateTagParamSchema>(gitCreateTagParamSchema),
    bodyValidationFactory<t_GitCreateTagBodySchema>(gitCreateTagBodySchema),
    async (
      ctx: ValidatedCtx<
        t_GitCreateTagParamSchema,
        void,
        t_GitCreateTagBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gitCreateTag(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitGetTagParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    tag_sha: z.coerce.string(),
  })

  router.get(
    "gitGetTag",
    "/repos/:owner/:repo/git/tags/:tagSha",
    paramValidationFactory<t_GitGetTagParamSchema>(gitGetTagParamSchema),
    async (
      ctx: ValidatedCtx<t_GitGetTagParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitGetTag(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitCreateTreeParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const gitCreateTreeBodySchema = z.object({
    tree: z.array(
      z.object({
        path: z.coerce.string().optional(),
        mode: z
          .enum(["100644", "100755", "040000", "160000", "120000"])
          .optional(),
        type: z.enum(["blob", "tree", "commit"]).optional(),
        sha: z.coerce.string().optional(),
        content: z.coerce.string().optional(),
      })
    ),
    base_tree: z.coerce.string().optional(),
  })

  router.post(
    "gitCreateTree",
    "/repos/:owner/:repo/git/trees",
    paramValidationFactory<t_GitCreateTreeParamSchema>(
      gitCreateTreeParamSchema
    ),
    bodyValidationFactory<t_GitCreateTreeBodySchema>(gitCreateTreeBodySchema),
    async (
      ctx: ValidatedCtx<
        t_GitCreateTreeParamSchema,
        void,
        t_GitCreateTreeBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gitCreateTree(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gitGetTreeParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    tree_sha: z.coerce.string(),
  })

  const gitGetTreeQuerySchema = z.object({
    recursive: z.coerce.string().optional(),
  })

  router.get(
    "gitGetTree",
    "/repos/:owner/:repo/git/trees/:treeSha",
    paramValidationFactory<t_GitGetTreeParamSchema>(gitGetTreeParamSchema),
    queryValidationFactory<t_GitGetTreeQuerySchema>(gitGetTreeQuerySchema),
    async (
      ctx: ValidatedCtx<t_GitGetTreeParamSchema, t_GitGetTreeQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.gitGetTree(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListWebhooksParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListWebhooksQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListWebhooks",
    "/repos/:owner/:repo/hooks",
    paramValidationFactory<t_ReposListWebhooksParamSchema>(
      reposListWebhooksParamSchema
    ),
    queryValidationFactory<t_ReposListWebhooksQuerySchema>(
      reposListWebhooksQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListWebhooksParamSchema,
        t_ReposListWebhooksQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListWebhooks(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateWebhookParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateWebhookBodySchema = z
    .object({
      name: z.coerce.string().optional(),
      config: z
        .object({
          url: z.coerce.string().optional(),
          content_type: z.coerce.string().optional(),
          secret: z.coerce.string().optional(),
          insecure_ssl: z.union([z.coerce.string(), z.coerce.number()]),
          token: z.coerce.string().optional(),
          digest: z.coerce.string().optional(),
        })
        .optional(),
      events: z.array(z.coerce.string()).optional(),
      active: z.coerce.boolean().optional(),
    })
    .optional()

  router.post(
    "reposCreateWebhook",
    "/repos/:owner/:repo/hooks",
    paramValidationFactory<t_ReposCreateWebhookParamSchema>(
      reposCreateWebhookParamSchema
    ),
    bodyValidationFactory<t_ReposCreateWebhookBodySchema>(
      reposCreateWebhookBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateWebhookParamSchema,
        void,
        t_ReposCreateWebhookBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetWebhookParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "reposGetWebhook",
    "/repos/:owner/:repo/hooks/:hookId",
    paramValidationFactory<t_ReposGetWebhookParamSchema>(
      reposGetWebhookParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetWebhookParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateWebhookParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  const reposUpdateWebhookBodySchema = z.object({
    config: z
      .object({
        url: z.coerce.string(),
        content_type: z.coerce.string().optional(),
        secret: z.coerce.string().optional(),
        insecure_ssl: z.union([z.coerce.string(), z.coerce.number()]),
        address: z.coerce.string().optional(),
        room: z.coerce.string().optional(),
      })
      .optional(),
    events: z.array(z.coerce.string()).optional(),
    add_events: z.array(z.coerce.string()).optional(),
    remove_events: z.array(z.coerce.string()).optional(),
    active: z.coerce.boolean().optional(),
  })

  router.patch(
    "reposUpdateWebhook",
    "/repos/:owner/:repo/hooks/:hookId",
    paramValidationFactory<t_ReposUpdateWebhookParamSchema>(
      reposUpdateWebhookParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateWebhookBodySchema>(
      reposUpdateWebhookBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateWebhookParamSchema,
        void,
        t_ReposUpdateWebhookBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUpdateWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteWebhookParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteWebhook",
    "/repos/:owner/:repo/hooks/:hookId",
    paramValidationFactory<t_ReposDeleteWebhookParamSchema>(
      reposDeleteWebhookParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteWebhookParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetWebhookConfigForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.get(
    "reposGetWebhookConfigForRepo",
    "/repos/:owner/:repo/hooks/:hookId/config",
    paramValidationFactory<t_ReposGetWebhookConfigForRepoParamSchema>(
      reposGetWebhookConfigForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetWebhookConfigForRepoParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposGetWebhookConfigForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateWebhookConfigForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  const reposUpdateWebhookConfigForRepoBodySchema = z
    .object({
      url: z.coerce.string().optional(),
      content_type: z.coerce.string().optional(),
      secret: z.coerce.string().optional(),
      insecure_ssl: z.union([z.coerce.string(), z.coerce.number()]),
    })
    .optional()

  router.patch(
    "reposUpdateWebhookConfigForRepo",
    "/repos/:owner/:repo/hooks/:hookId/config",
    paramValidationFactory<t_ReposUpdateWebhookConfigForRepoParamSchema>(
      reposUpdateWebhookConfigForRepoParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateWebhookConfigForRepoBodySchema>(
      reposUpdateWebhookConfigForRepoBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateWebhookConfigForRepoParamSchema,
        void,
        t_ReposUpdateWebhookConfigForRepoBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposUpdateWebhookConfigForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListWebhookDeliveriesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  const reposListWebhookDeliveriesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    cursor: z.coerce.string().optional(),
    redelivery: z.coerce.boolean().optional(),
  })

  router.get(
    "reposListWebhookDeliveries",
    "/repos/:owner/:repo/hooks/:hookId/deliveries",
    paramValidationFactory<t_ReposListWebhookDeliveriesParamSchema>(
      reposListWebhookDeliveriesParamSchema
    ),
    queryValidationFactory<t_ReposListWebhookDeliveriesQuerySchema>(
      reposListWebhookDeliveriesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListWebhookDeliveriesParamSchema,
        t_ReposListWebhookDeliveriesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListWebhookDeliveries(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetWebhookDeliveryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.get(
    "reposGetWebhookDelivery",
    "/repos/:owner/:repo/hooks/:hookId/deliveries/:deliveryId",
    paramValidationFactory<t_ReposGetWebhookDeliveryParamSchema>(
      reposGetWebhookDeliveryParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetWebhookDeliveryParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetWebhookDelivery(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRedeliverWebhookDeliveryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
    delivery_id: z.coerce.number(),
  })

  router.post(
    "reposRedeliverWebhookDelivery",
    "/repos/:owner/:repo/hooks/:hookId/deliveries/:deliveryId/attempts",
    paramValidationFactory<t_ReposRedeliverWebhookDeliveryParamSchema>(
      reposRedeliverWebhookDeliveryParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposRedeliverWebhookDeliveryParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposRedeliverWebhookDelivery(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposPingWebhookParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.post(
    "reposPingWebhook",
    "/repos/:owner/:repo/hooks/:hookId/pings",
    paramValidationFactory<t_ReposPingWebhookParamSchema>(
      reposPingWebhookParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposPingWebhookParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposPingWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposTestPushWebhookParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    hook_id: z.coerce.number(),
  })

  router.post(
    "reposTestPushWebhook",
    "/repos/:owner/:repo/hooks/:hookId/tests",
    paramValidationFactory<t_ReposTestPushWebhookParamSchema>(
      reposTestPushWebhookParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposTestPushWebhookParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposTestPushWebhook(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsGetImportStatusParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "migrationsGetImportStatus",
    "/repos/:owner/:repo/import",
    paramValidationFactory<t_MigrationsGetImportStatusParamSchema>(
      migrationsGetImportStatusParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_MigrationsGetImportStatusParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsGetImportStatus(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsStartImportParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const migrationsStartImportBodySchema = z.object({
    vcs_url: z.coerce.string(),
    vcs: z.enum(["subversion", "git", "mercurial", "tfvc"]).optional(),
    vcs_username: z.coerce.string().optional(),
    vcs_password: z.coerce.string().optional(),
    tfvc_project: z.coerce.string().optional(),
  })

  router.put(
    "migrationsStartImport",
    "/repos/:owner/:repo/import",
    paramValidationFactory<t_MigrationsStartImportParamSchema>(
      migrationsStartImportParamSchema
    ),
    bodyValidationFactory<t_MigrationsStartImportBodySchema>(
      migrationsStartImportBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsStartImportParamSchema,
        void,
        t_MigrationsStartImportBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsStartImport(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsUpdateImportParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const migrationsUpdateImportBodySchema = z
    .object({
      vcs_username: z.coerce.string().optional(),
      vcs_password: z.coerce.string().optional(),
      vcs: z.enum(["subversion", "tfvc", "git", "mercurial"]).optional(),
      tfvc_project: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "migrationsUpdateImport",
    "/repos/:owner/:repo/import",
    paramValidationFactory<t_MigrationsUpdateImportParamSchema>(
      migrationsUpdateImportParamSchema
    ),
    bodyValidationFactory<t_MigrationsUpdateImportBodySchema>(
      migrationsUpdateImportBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsUpdateImportParamSchema,
        void,
        t_MigrationsUpdateImportBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsUpdateImport(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsCancelImportParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "migrationsCancelImport",
    "/repos/:owner/:repo/import",
    paramValidationFactory<t_MigrationsCancelImportParamSchema>(
      migrationsCancelImportParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_MigrationsCancelImportParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsCancelImport(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsGetCommitAuthorsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const migrationsGetCommitAuthorsQuerySchema = z.object({
    since: z.coerce.number().optional(),
  })

  router.get(
    "migrationsGetCommitAuthors",
    "/repos/:owner/:repo/import/authors",
    paramValidationFactory<t_MigrationsGetCommitAuthorsParamSchema>(
      migrationsGetCommitAuthorsParamSchema
    ),
    queryValidationFactory<t_MigrationsGetCommitAuthorsQuerySchema>(
      migrationsGetCommitAuthorsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsGetCommitAuthorsParamSchema,
        t_MigrationsGetCommitAuthorsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsGetCommitAuthors(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsMapCommitAuthorParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    author_id: z.coerce.number(),
  })

  const migrationsMapCommitAuthorBodySchema = z
    .object({
      email: z.coerce.string().optional(),
      name: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "migrationsMapCommitAuthor",
    "/repos/:owner/:repo/import/authors/:authorId",
    paramValidationFactory<t_MigrationsMapCommitAuthorParamSchema>(
      migrationsMapCommitAuthorParamSchema
    ),
    bodyValidationFactory<t_MigrationsMapCommitAuthorBodySchema>(
      migrationsMapCommitAuthorBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsMapCommitAuthorParamSchema,
        void,
        t_MigrationsMapCommitAuthorBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsMapCommitAuthor(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsGetLargeFilesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "migrationsGetLargeFiles",
    "/repos/:owner/:repo/import/large_files",
    paramValidationFactory<t_MigrationsGetLargeFilesParamSchema>(
      migrationsGetLargeFilesParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_MigrationsGetLargeFilesParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsGetLargeFiles(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsSetLfsPreferenceParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const migrationsSetLfsPreferenceBodySchema = z.object({
    use_lfs: z.enum(["opt_in", "opt_out"]),
  })

  router.patch(
    "migrationsSetLfsPreference",
    "/repos/:owner/:repo/import/lfs",
    paramValidationFactory<t_MigrationsSetLfsPreferenceParamSchema>(
      migrationsSetLfsPreferenceParamSchema
    ),
    bodyValidationFactory<t_MigrationsSetLfsPreferenceBodySchema>(
      migrationsSetLfsPreferenceBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsSetLfsPreferenceParamSchema,
        void,
        t_MigrationsSetLfsPreferenceBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.migrationsSetLfsPreference(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetRepoInstallationParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "appsGetRepoInstallation",
    "/repos/:owner/:repo/installation",
    paramValidationFactory<t_AppsGetRepoInstallationParamSchema>(
      appsGetRepoInstallationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsGetRepoInstallationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsGetRepoInstallation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const interactionsGetRestrictionsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "interactionsGetRestrictionsForRepo",
    "/repos/:owner/:repo/interaction-limits",
    paramValidationFactory<t_InteractionsGetRestrictionsForRepoParamSchema>(
      interactionsGetRestrictionsForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_InteractionsGetRestrictionsForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.interactionsGetRestrictionsForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const interactionsSetRestrictionsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const interactionsSetRestrictionsForRepoBodySchema = z.object({
    limit: z.enum([
      "existing_users",
      "contributors_only",
      "collaborators_only",
    ]),
    expiry: z
      .enum(["one_day", "three_days", "one_week", "one_month", "six_months"])
      .optional(),
  })

  router.put(
    "interactionsSetRestrictionsForRepo",
    "/repos/:owner/:repo/interaction-limits",
    paramValidationFactory<t_InteractionsSetRestrictionsForRepoParamSchema>(
      interactionsSetRestrictionsForRepoParamSchema
    ),
    bodyValidationFactory<t_InteractionsSetRestrictionsForRepoBodySchema>(
      interactionsSetRestrictionsForRepoBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_InteractionsSetRestrictionsForRepoParamSchema,
        void,
        t_InteractionsSetRestrictionsForRepoBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.interactionsSetRestrictionsForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const interactionsRemoveRestrictionsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "interactionsRemoveRestrictionsForRepo",
    "/repos/:owner/:repo/interaction-limits",
    paramValidationFactory<t_InteractionsRemoveRestrictionsForRepoParamSchema>(
      interactionsRemoveRestrictionsForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_InteractionsRemoveRestrictionsForRepoParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.interactionsRemoveRestrictionsForRepo(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListInvitationsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListInvitationsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListInvitations",
    "/repos/:owner/:repo/invitations",
    paramValidationFactory<t_ReposListInvitationsParamSchema>(
      reposListInvitationsParamSchema
    ),
    queryValidationFactory<t_ReposListInvitationsQuerySchema>(
      reposListInvitationsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListInvitationsParamSchema,
        t_ReposListInvitationsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListInvitations(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateInvitationParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    invitation_id: z.coerce.number(),
  })

  const reposUpdateInvitationBodySchema = z
    .object({
      permissions: z
        .enum(["read", "write", "maintain", "triage", "admin"])
        .optional(),
    })
    .optional()

  router.patch(
    "reposUpdateInvitation",
    "/repos/:owner/:repo/invitations/:invitationId",
    paramValidationFactory<t_ReposUpdateInvitationParamSchema>(
      reposUpdateInvitationParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateInvitationBodySchema>(
      reposUpdateInvitationBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateInvitationParamSchema,
        void,
        t_ReposUpdateInvitationBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUpdateInvitation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteInvitationParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    invitation_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteInvitation",
    "/repos/:owner/:repo/invitations/:invitationId",
    paramValidationFactory<t_ReposDeleteInvitationParamSchema>(
      reposDeleteInvitationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteInvitationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteInvitation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesListForRepoQuerySchema = z.object({
    milestone: z.coerce.string().optional(),
    state: z.enum(["open", "closed", "all"]).optional(),
    assignee: z.coerce.string().optional(),
    creator: z.coerce.string().optional(),
    mentioned: z.coerce.string().optional(),
    labels: z.coerce.string().optional(),
    sort: z.enum(["created", "updated", "comments"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListForRepo",
    "/repos/:owner/:repo/issues",
    paramValidationFactory<t_IssuesListForRepoParamSchema>(
      issuesListForRepoParamSchema
    ),
    queryValidationFactory<t_IssuesListForRepoQuerySchema>(
      issuesListForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListForRepoParamSchema,
        t_IssuesListForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesCreateParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesCreateBodySchema = z.object({
    title: z.union([z.coerce.string(), z.coerce.number()]),
    body: z.coerce.string().optional(),
    assignee: z.coerce.string().optional(),
    milestone: z.union([z.coerce.string(), z.coerce.number()]),
    labels: z
      .array(
        z.union([
          z.coerce.string(),
          z.object({
            id: z.coerce.number().optional(),
            name: z.coerce.string().optional(),
            description: z.coerce.string().optional(),
            color: z.coerce.string().optional(),
          }),
        ])
      )
      .optional(),
    assignees: z.array(z.coerce.string()).optional(),
  })

  router.post(
    "issuesCreate",
    "/repos/:owner/:repo/issues",
    paramValidationFactory<t_IssuesCreateParamSchema>(issuesCreateParamSchema),
    bodyValidationFactory<t_IssuesCreateBodySchema>(issuesCreateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_IssuesCreateParamSchema,
        void,
        t_IssuesCreateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesCreate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListCommentsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesListCommentsForRepoQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListCommentsForRepo",
    "/repos/:owner/:repo/issues/comments",
    paramValidationFactory<t_IssuesListCommentsForRepoParamSchema>(
      issuesListCommentsForRepoParamSchema
    ),
    queryValidationFactory<t_IssuesListCommentsForRepoQuerySchema>(
      issuesListCommentsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListCommentsForRepoParamSchema,
        t_IssuesListCommentsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListCommentsForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesGetCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "issuesGetComment",
    "/repos/:owner/:repo/issues/comments/:commentId",
    paramValidationFactory<t_IssuesGetCommentParamSchema>(
      issuesGetCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesGetCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesGetComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesUpdateCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const issuesUpdateCommentBodySchema = z.object({ body: z.coerce.string() })

  router.patch(
    "issuesUpdateComment",
    "/repos/:owner/:repo/issues/comments/:commentId",
    paramValidationFactory<t_IssuesUpdateCommentParamSchema>(
      issuesUpdateCommentParamSchema
    ),
    bodyValidationFactory<t_IssuesUpdateCommentBodySchema>(
      issuesUpdateCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesUpdateCommentParamSchema,
        void,
        t_IssuesUpdateCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesUpdateComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesDeleteCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "issuesDeleteComment",
    "/repos/:owner/:repo/issues/comments/:commentId",
    paramValidationFactory<t_IssuesDeleteCommentParamSchema>(
      issuesDeleteCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesDeleteCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesDeleteComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForIssueCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForIssueCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForIssueComment",
    "/repos/:owner/:repo/issues/comments/:commentId/reactions",
    paramValidationFactory<t_ReactionsListForIssueCommentParamSchema>(
      reactionsListForIssueCommentParamSchema
    ),
    queryValidationFactory<t_ReactionsListForIssueCommentQuerySchema>(
      reactionsListForIssueCommentQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForIssueCommentParamSchema,
        t_ReactionsListForIssueCommentQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsListForIssueComment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForIssueCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForIssueCommentBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForIssueComment",
    "/repos/:owner/:repo/issues/comments/:commentId/reactions",
    paramValidationFactory<t_ReactionsCreateForIssueCommentParamSchema>(
      reactionsCreateForIssueCommentParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForIssueCommentBodySchema>(
      reactionsCreateForIssueCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForIssueCommentParamSchema,
        void,
        t_ReactionsCreateForIssueCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsCreateForIssueComment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsDeleteForIssueCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForIssueComment",
    "/repos/:owner/:repo/issues/comments/:commentId/reactions/:reactionId",
    paramValidationFactory<t_ReactionsDeleteForIssueCommentParamSchema>(
      reactionsDeleteForIssueCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsDeleteForIssueCommentParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsDeleteForIssueComment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListEventsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesListEventsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListEventsForRepo",
    "/repos/:owner/:repo/issues/events",
    paramValidationFactory<t_IssuesListEventsForRepoParamSchema>(
      issuesListEventsForRepoParamSchema
    ),
    queryValidationFactory<t_IssuesListEventsForRepoQuerySchema>(
      issuesListEventsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListEventsForRepoParamSchema,
        t_IssuesListEventsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListEventsForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesGetEventParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    event_id: z.coerce.number(),
  })

  router.get(
    "issuesGetEvent",
    "/repos/:owner/:repo/issues/events/:eventId",
    paramValidationFactory<t_IssuesGetEventParamSchema>(
      issuesGetEventParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesGetEventParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesGetEvent(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesGetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  router.get(
    "issuesGet",
    "/repos/:owner/:repo/issues/:issueNumber",
    paramValidationFactory<t_IssuesGetParamSchema>(issuesGetParamSchema),
    async (
      ctx: ValidatedCtx<t_IssuesGetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesUpdateParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesUpdateBodySchema = z
    .object({
      title: z.union([z.coerce.string(), z.coerce.number()]),
      body: z.coerce.string().optional(),
      assignee: z.coerce.string().optional(),
      state: z.enum(["open", "closed"]).optional(),
      state_reason: z.enum(["completed", "not_planned", "reopened"]).optional(),
      milestone: z.union([z.coerce.string(), z.coerce.number()]),
      labels: z
        .array(
          z.union([
            z.coerce.string(),
            z.object({
              id: z.coerce.number().optional(),
              name: z.coerce.string().optional(),
              description: z.coerce.string().optional(),
              color: z.coerce.string().optional(),
            }),
          ])
        )
        .optional(),
      assignees: z.array(z.coerce.string()).optional(),
    })
    .optional()

  router.patch(
    "issuesUpdate",
    "/repos/:owner/:repo/issues/:issueNumber",
    paramValidationFactory<t_IssuesUpdateParamSchema>(issuesUpdateParamSchema),
    bodyValidationFactory<t_IssuesUpdateBodySchema>(issuesUpdateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_IssuesUpdateParamSchema,
        void,
        t_IssuesUpdateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesUpdate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesAddAssigneesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddAssigneesBodySchema = z
    .object({ assignees: z.array(z.coerce.string()).optional() })
    .optional()

  router.post(
    "issuesAddAssignees",
    "/repos/:owner/:repo/issues/:issueNumber/assignees",
    paramValidationFactory<t_IssuesAddAssigneesParamSchema>(
      issuesAddAssigneesParamSchema
    ),
    bodyValidationFactory<t_IssuesAddAssigneesBodySchema>(
      issuesAddAssigneesBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesAddAssigneesParamSchema,
        void,
        t_IssuesAddAssigneesBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesAddAssignees(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesRemoveAssigneesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesRemoveAssigneesBodySchema = z.object({
    assignees: z.array(z.coerce.string()).optional(),
  })

  router.delete(
    "issuesRemoveAssignees",
    "/repos/:owner/:repo/issues/:issueNumber/assignees",
    paramValidationFactory<t_IssuesRemoveAssigneesParamSchema>(
      issuesRemoveAssigneesParamSchema
    ),
    bodyValidationFactory<t_IssuesRemoveAssigneesBodySchema>(
      issuesRemoveAssigneesBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesRemoveAssigneesParamSchema,
        void,
        t_IssuesRemoveAssigneesBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesRemoveAssignees(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesCheckUserCanBeAssignedToIssueParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
    assignee: z.coerce.string(),
  })

  router.get(
    "issuesCheckUserCanBeAssignedToIssue",
    "/repos/:owner/:repo/issues/:issueNumber/assignees/:assignee",
    paramValidationFactory<t_IssuesCheckUserCanBeAssignedToIssueParamSchema>(
      issuesCheckUserCanBeAssignedToIssueParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesCheckUserCanBeAssignedToIssueParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.issuesCheckUserCanBeAssignedToIssue(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListCommentsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListCommentsQuerySchema = z.object({
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListComments",
    "/repos/:owner/:repo/issues/:issueNumber/comments",
    paramValidationFactory<t_IssuesListCommentsParamSchema>(
      issuesListCommentsParamSchema
    ),
    queryValidationFactory<t_IssuesListCommentsQuerySchema>(
      issuesListCommentsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListCommentsParamSchema,
        t_IssuesListCommentsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListComments(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesCreateCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesCreateCommentBodySchema = z.object({ body: z.coerce.string() })

  router.post(
    "issuesCreateComment",
    "/repos/:owner/:repo/issues/:issueNumber/comments",
    paramValidationFactory<t_IssuesCreateCommentParamSchema>(
      issuesCreateCommentParamSchema
    ),
    bodyValidationFactory<t_IssuesCreateCommentBodySchema>(
      issuesCreateCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesCreateCommentParamSchema,
        void,
        t_IssuesCreateCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesCreateComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListEventsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListEventsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListEvents",
    "/repos/:owner/:repo/issues/:issueNumber/events",
    paramValidationFactory<t_IssuesListEventsParamSchema>(
      issuesListEventsParamSchema
    ),
    queryValidationFactory<t_IssuesListEventsQuerySchema>(
      issuesListEventsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListEventsParamSchema,
        t_IssuesListEventsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListEvents(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListLabelsOnIssueParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListLabelsOnIssueQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListLabelsOnIssue",
    "/repos/:owner/:repo/issues/:issueNumber/labels",
    paramValidationFactory<t_IssuesListLabelsOnIssueParamSchema>(
      issuesListLabelsOnIssueParamSchema
    ),
    queryValidationFactory<t_IssuesListLabelsOnIssueQuerySchema>(
      issuesListLabelsOnIssueQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListLabelsOnIssueParamSchema,
        t_IssuesListLabelsOnIssueQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListLabelsOnIssue(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesAddLabelsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesAddLabelsBodySchema = z.union([
    z.object({ labels: z.array(z.coerce.string()).optional() }),
    z.array(z.coerce.string()),
    z.object({
      labels: z.array(z.object({ name: z.coerce.string() })).optional(),
    }),
    z.array(z.object({ name: z.coerce.string() })),
    z.coerce.string(),
  ])

  router.post(
    "issuesAddLabels",
    "/repos/:owner/:repo/issues/:issueNumber/labels",
    paramValidationFactory<t_IssuesAddLabelsParamSchema>(
      issuesAddLabelsParamSchema
    ),
    bodyValidationFactory<t_IssuesAddLabelsBodySchema>(
      issuesAddLabelsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesAddLabelsParamSchema,
        void,
        t_IssuesAddLabelsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesAddLabels(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesSetLabelsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesSetLabelsBodySchema = z.union([
    z.object({ labels: z.array(z.coerce.string()).optional() }),
    z.array(z.coerce.string()),
    z.object({
      labels: z.array(z.object({ name: z.coerce.string() })).optional(),
    }),
    z.array(z.object({ name: z.coerce.string() })),
    z.coerce.string(),
  ])

  router.put(
    "issuesSetLabels",
    "/repos/:owner/:repo/issues/:issueNumber/labels",
    paramValidationFactory<t_IssuesSetLabelsParamSchema>(
      issuesSetLabelsParamSchema
    ),
    bodyValidationFactory<t_IssuesSetLabelsBodySchema>(
      issuesSetLabelsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesSetLabelsParamSchema,
        void,
        t_IssuesSetLabelsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesSetLabels(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesRemoveAllLabelsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  router.delete(
    "issuesRemoveAllLabels",
    "/repos/:owner/:repo/issues/:issueNumber/labels",
    paramValidationFactory<t_IssuesRemoveAllLabelsParamSchema>(
      issuesRemoveAllLabelsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesRemoveAllLabelsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesRemoveAllLabels(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesRemoveLabelParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
    name: z.coerce.string(),
  })

  router.delete(
    "issuesRemoveLabel",
    "/repos/:owner/:repo/issues/:issueNumber/labels/:name",
    paramValidationFactory<t_IssuesRemoveLabelParamSchema>(
      issuesRemoveLabelParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesRemoveLabelParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesRemoveLabel(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesLockParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesLockBodySchema = z
    .object({
      lock_reason: z
        .enum(["off-topic", "too heated", "resolved", "spam"])
        .optional(),
    })
    .optional()

  router.put(
    "issuesLock",
    "/repos/:owner/:repo/issues/:issueNumber/lock",
    paramValidationFactory<t_IssuesLockParamSchema>(issuesLockParamSchema),
    bodyValidationFactory<t_IssuesLockBodySchema>(issuesLockBodySchema),
    async (
      ctx: ValidatedCtx<t_IssuesLockParamSchema, void, t_IssuesLockBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesLock(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesUnlockParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  router.delete(
    "issuesUnlock",
    "/repos/:owner/:repo/issues/:issueNumber/lock",
    paramValidationFactory<t_IssuesUnlockParamSchema>(issuesUnlockParamSchema),
    async (
      ctx: ValidatedCtx<t_IssuesUnlockParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesUnlock(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForIssueParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const reactionsListForIssueQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForIssue",
    "/repos/:owner/:repo/issues/:issueNumber/reactions",
    paramValidationFactory<t_ReactionsListForIssueParamSchema>(
      reactionsListForIssueParamSchema
    ),
    queryValidationFactory<t_ReactionsListForIssueQuerySchema>(
      reactionsListForIssueQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForIssueParamSchema,
        t_ReactionsListForIssueQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reactionsListForIssue(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForIssueParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const reactionsCreateForIssueBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForIssue",
    "/repos/:owner/:repo/issues/:issueNumber/reactions",
    paramValidationFactory<t_ReactionsCreateForIssueParamSchema>(
      reactionsCreateForIssueParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForIssueBodySchema>(
      reactionsCreateForIssueBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForIssueParamSchema,
        void,
        t_ReactionsCreateForIssueBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reactionsCreateForIssue(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsDeleteForIssueParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForIssue",
    "/repos/:owner/:repo/issues/:issueNumber/reactions/:reactionId",
    paramValidationFactory<t_ReactionsDeleteForIssueParamSchema>(
      reactionsDeleteForIssueParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReactionsDeleteForIssueParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reactionsDeleteForIssue(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListEventsForTimelineParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    issue_number: z.coerce.number(),
  })

  const issuesListEventsForTimelineQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListEventsForTimeline",
    "/repos/:owner/:repo/issues/:issueNumber/timeline",
    paramValidationFactory<t_IssuesListEventsForTimelineParamSchema>(
      issuesListEventsForTimelineParamSchema
    ),
    queryValidationFactory<t_IssuesListEventsForTimelineQuerySchema>(
      issuesListEventsForTimelineQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListEventsForTimelineParamSchema,
        t_IssuesListEventsForTimelineQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListEventsForTimeline(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListDeployKeysParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListDeployKeysQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListDeployKeys",
    "/repos/:owner/:repo/keys",
    paramValidationFactory<t_ReposListDeployKeysParamSchema>(
      reposListDeployKeysParamSchema
    ),
    queryValidationFactory<t_ReposListDeployKeysQuerySchema>(
      reposListDeployKeysQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListDeployKeysParamSchema,
        t_ReposListDeployKeysQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListDeployKeys(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateDeployKeyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateDeployKeyBodySchema = z.object({
    title: z.coerce.string().optional(),
    key: z.coerce.string(),
    read_only: z.coerce.boolean().optional(),
  })

  router.post(
    "reposCreateDeployKey",
    "/repos/:owner/:repo/keys",
    paramValidationFactory<t_ReposCreateDeployKeyParamSchema>(
      reposCreateDeployKeyParamSchema
    ),
    bodyValidationFactory<t_ReposCreateDeployKeyBodySchema>(
      reposCreateDeployKeyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateDeployKeyParamSchema,
        void,
        t_ReposCreateDeployKeyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateDeployKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetDeployKeyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    key_id: z.coerce.number(),
  })

  router.get(
    "reposGetDeployKey",
    "/repos/:owner/:repo/keys/:keyId",
    paramValidationFactory<t_ReposGetDeployKeyParamSchema>(
      reposGetDeployKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetDeployKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetDeployKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteDeployKeyParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    key_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteDeployKey",
    "/repos/:owner/:repo/keys/:keyId",
    paramValidationFactory<t_ReposDeleteDeployKeyParamSchema>(
      reposDeleteDeployKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteDeployKeyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteDeployKey(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListLabelsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesListLabelsForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListLabelsForRepo",
    "/repos/:owner/:repo/labels",
    paramValidationFactory<t_IssuesListLabelsForRepoParamSchema>(
      issuesListLabelsForRepoParamSchema
    ),
    queryValidationFactory<t_IssuesListLabelsForRepoQuerySchema>(
      issuesListLabelsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListLabelsForRepoParamSchema,
        t_IssuesListLabelsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListLabelsForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesCreateLabelParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesCreateLabelBodySchema = z.object({
    name: z.coerce.string(),
    color: z.coerce.string().optional(),
    description: z.coerce.string().optional(),
  })

  router.post(
    "issuesCreateLabel",
    "/repos/:owner/:repo/labels",
    paramValidationFactory<t_IssuesCreateLabelParamSchema>(
      issuesCreateLabelParamSchema
    ),
    bodyValidationFactory<t_IssuesCreateLabelBodySchema>(
      issuesCreateLabelBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesCreateLabelParamSchema,
        void,
        t_IssuesCreateLabelBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesCreateLabel(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesGetLabelParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.get(
    "issuesGetLabel",
    "/repos/:owner/:repo/labels/:name",
    paramValidationFactory<t_IssuesGetLabelParamSchema>(
      issuesGetLabelParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesGetLabelParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesGetLabel(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesUpdateLabelParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    name: z.coerce.string(),
  })

  const issuesUpdateLabelBodySchema = z
    .object({
      new_name: z.coerce.string().optional(),
      color: z.coerce.string().optional(),
      description: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "issuesUpdateLabel",
    "/repos/:owner/:repo/labels/:name",
    paramValidationFactory<t_IssuesUpdateLabelParamSchema>(
      issuesUpdateLabelParamSchema
    ),
    bodyValidationFactory<t_IssuesUpdateLabelBodySchema>(
      issuesUpdateLabelBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesUpdateLabelParamSchema,
        void,
        t_IssuesUpdateLabelBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesUpdateLabel(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesDeleteLabelParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.delete(
    "issuesDeleteLabel",
    "/repos/:owner/:repo/labels/:name",
    paramValidationFactory<t_IssuesDeleteLabelParamSchema>(
      issuesDeleteLabelParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesDeleteLabelParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesDeleteLabel(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListLanguagesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposListLanguages",
    "/repos/:owner/:repo/languages",
    paramValidationFactory<t_ReposListLanguagesParamSchema>(
      reposListLanguagesParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposListLanguagesParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListLanguages(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposEnableLfsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.put(
    "reposEnableLfsForRepo",
    "/repos/:owner/:repo/lfs",
    paramValidationFactory<t_ReposEnableLfsForRepoParamSchema>(
      reposEnableLfsForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposEnableLfsForRepoParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposEnableLfsForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDisableLfsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "reposDisableLfsForRepo",
    "/repos/:owner/:repo/lfs",
    paramValidationFactory<t_ReposDisableLfsForRepoParamSchema>(
      reposDisableLfsForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDisableLfsForRepoParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDisableLfsForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const licensesGetForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "licensesGetForRepo",
    "/repos/:owner/:repo/license",
    paramValidationFactory<t_LicensesGetForRepoParamSchema>(
      licensesGetForRepoParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_LicensesGetForRepoParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.licensesGetForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposMergeUpstreamParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposMergeUpstreamBodySchema = z.object({ branch: z.coerce.string() })

  router.post(
    "reposMergeUpstream",
    "/repos/:owner/:repo/merge-upstream",
    paramValidationFactory<t_ReposMergeUpstreamParamSchema>(
      reposMergeUpstreamParamSchema
    ),
    bodyValidationFactory<t_ReposMergeUpstreamBodySchema>(
      reposMergeUpstreamBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposMergeUpstreamParamSchema,
        void,
        t_ReposMergeUpstreamBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposMergeUpstream(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposMergeParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposMergeBodySchema = z.object({
    base: z.coerce.string(),
    head: z.coerce.string(),
    commit_message: z.coerce.string().optional(),
  })

  router.post(
    "reposMerge",
    "/repos/:owner/:repo/merges",
    paramValidationFactory<t_ReposMergeParamSchema>(reposMergeParamSchema),
    bodyValidationFactory<t_ReposMergeBodySchema>(reposMergeBodySchema),
    async (
      ctx: ValidatedCtx<t_ReposMergeParamSchema, void, t_ReposMergeBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposMerge(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListMilestonesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesListMilestonesQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional(),
    sort: z.enum(["due_on", "completeness"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListMilestones",
    "/repos/:owner/:repo/milestones",
    paramValidationFactory<t_IssuesListMilestonesParamSchema>(
      issuesListMilestonesParamSchema
    ),
    queryValidationFactory<t_IssuesListMilestonesQuerySchema>(
      issuesListMilestonesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListMilestonesParamSchema,
        t_IssuesListMilestonesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesListMilestones(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesCreateMilestoneParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const issuesCreateMilestoneBodySchema = z.object({
    title: z.coerce.string(),
    state: z.enum(["open", "closed"]).optional(),
    description: z.coerce.string().optional(),
    due_on: z.coerce.string().datetime({ offset: true }).optional(),
  })

  router.post(
    "issuesCreateMilestone",
    "/repos/:owner/:repo/milestones",
    paramValidationFactory<t_IssuesCreateMilestoneParamSchema>(
      issuesCreateMilestoneParamSchema
    ),
    bodyValidationFactory<t_IssuesCreateMilestoneBodySchema>(
      issuesCreateMilestoneBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesCreateMilestoneParamSchema,
        void,
        t_IssuesCreateMilestoneBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesCreateMilestone(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesGetMilestoneParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    milestone_number: z.coerce.number(),
  })

  router.get(
    "issuesGetMilestone",
    "/repos/:owner/:repo/milestones/:milestoneNumber",
    paramValidationFactory<t_IssuesGetMilestoneParamSchema>(
      issuesGetMilestoneParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesGetMilestoneParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesGetMilestone(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesUpdateMilestoneParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesUpdateMilestoneBodySchema = z
    .object({
      title: z.coerce.string().optional(),
      state: z.enum(["open", "closed"]).optional(),
      description: z.coerce.string().optional(),
      due_on: z.coerce.string().datetime({ offset: true }).optional(),
    })
    .optional()

  router.patch(
    "issuesUpdateMilestone",
    "/repos/:owner/:repo/milestones/:milestoneNumber",
    paramValidationFactory<t_IssuesUpdateMilestoneParamSchema>(
      issuesUpdateMilestoneParamSchema
    ),
    bodyValidationFactory<t_IssuesUpdateMilestoneBodySchema>(
      issuesUpdateMilestoneBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesUpdateMilestoneParamSchema,
        void,
        t_IssuesUpdateMilestoneBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesUpdateMilestone(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesDeleteMilestoneParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    milestone_number: z.coerce.number(),
  })

  router.delete(
    "issuesDeleteMilestone",
    "/repos/:owner/:repo/milestones/:milestoneNumber",
    paramValidationFactory<t_IssuesDeleteMilestoneParamSchema>(
      issuesDeleteMilestoneParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_IssuesDeleteMilestoneParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.issuesDeleteMilestone(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListLabelsForMilestoneParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    milestone_number: z.coerce.number(),
  })

  const issuesListLabelsForMilestoneQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListLabelsForMilestone",
    "/repos/:owner/:repo/milestones/:milestoneNumber/labels",
    paramValidationFactory<t_IssuesListLabelsForMilestoneParamSchema>(
      issuesListLabelsForMilestoneParamSchema
    ),
    queryValidationFactory<t_IssuesListLabelsForMilestoneQuerySchema>(
      issuesListLabelsForMilestoneQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_IssuesListLabelsForMilestoneParamSchema,
        t_IssuesListLabelsForMilestoneQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.issuesListLabelsForMilestone(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListRepoNotificationsForAuthenticatedUserParamSchema = z.object(
    { owner: z.coerce.string(), repo: z.coerce.string() }
  )

  const activityListRepoNotificationsForAuthenticatedUserQuerySchema = z.object(
    {
      all: z.coerce.boolean().optional(),
      participating: z.coerce.boolean().optional(),
      since: z.coerce.string().datetime({ offset: true }).optional(),
      before: z.coerce.string().datetime({ offset: true }).optional(),
      per_page: z.coerce.number().optional(),
      page: z.coerce.number().optional(),
    }
  )

  router.get(
    "activityListRepoNotificationsForAuthenticatedUser",
    "/repos/:owner/:repo/notifications",
    paramValidationFactory<t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema>(
      activityListRepoNotificationsForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema>(
      activityListRepoNotificationsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListRepoNotificationsForAuthenticatedUserParamSchema,
        t_ActivityListRepoNotificationsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListRepoNotificationsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityMarkRepoNotificationsAsReadParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const activityMarkRepoNotificationsAsReadBodySchema = z
    .object({
      last_read_at: z.coerce.string().datetime({ offset: true }).optional(),
    })
    .optional()

  router.put(
    "activityMarkRepoNotificationsAsRead",
    "/repos/:owner/:repo/notifications",
    paramValidationFactory<t_ActivityMarkRepoNotificationsAsReadParamSchema>(
      activityMarkRepoNotificationsAsReadParamSchema
    ),
    bodyValidationFactory<t_ActivityMarkRepoNotificationsAsReadBodySchema>(
      activityMarkRepoNotificationsAsReadBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityMarkRepoNotificationsAsReadParamSchema,
        void,
        t_ActivityMarkRepoNotificationsAsReadBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityMarkRepoNotificationsAsRead(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetPagesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetPages",
    "/repos/:owner/:repo/pages",
    paramValidationFactory<t_ReposGetPagesParamSchema>(
      reposGetPagesParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetPagesParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetPages(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreatePagesSiteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreatePagesSiteBodySchema = z.object({
    build_type: z.enum(["legacy", "workflow"]).optional(),
    source: z
      .object({
        branch: z.coerce.string(),
        path: z.enum(["/", "/docs"]).optional(),
      })
      .optional(),
  })

  router.post(
    "reposCreatePagesSite",
    "/repos/:owner/:repo/pages",
    paramValidationFactory<t_ReposCreatePagesSiteParamSchema>(
      reposCreatePagesSiteParamSchema
    ),
    bodyValidationFactory<t_ReposCreatePagesSiteBodySchema>(
      reposCreatePagesSiteBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreatePagesSiteParamSchema,
        void,
        t_ReposCreatePagesSiteBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreatePagesSite(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateInformationAboutPagesSiteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposUpdateInformationAboutPagesSiteBodySchema = z.object({
    cname: z.coerce.string().optional(),
    https_enforced: z.coerce.boolean().optional(),
    build_type: z.enum(["legacy", "workflow"]).optional(),
    source: z.object({}).optional(),
  })

  router.put(
    "reposUpdateInformationAboutPagesSite",
    "/repos/:owner/:repo/pages",
    paramValidationFactory<t_ReposUpdateInformationAboutPagesSiteParamSchema>(
      reposUpdateInformationAboutPagesSiteParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateInformationAboutPagesSiteBodySchema>(
      reposUpdateInformationAboutPagesSiteBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateInformationAboutPagesSiteParamSchema,
        void,
        t_ReposUpdateInformationAboutPagesSiteBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposUpdateInformationAboutPagesSite(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeletePagesSiteParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "reposDeletePagesSite",
    "/repos/:owner/:repo/pages",
    paramValidationFactory<t_ReposDeletePagesSiteParamSchema>(
      reposDeletePagesSiteParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeletePagesSiteParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeletePagesSite(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListPagesBuildsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListPagesBuildsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListPagesBuilds",
    "/repos/:owner/:repo/pages/builds",
    paramValidationFactory<t_ReposListPagesBuildsParamSchema>(
      reposListPagesBuildsParamSchema
    ),
    queryValidationFactory<t_ReposListPagesBuildsQuerySchema>(
      reposListPagesBuildsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListPagesBuildsParamSchema,
        t_ReposListPagesBuildsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListPagesBuilds(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposRequestPagesBuildParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.post(
    "reposRequestPagesBuild",
    "/repos/:owner/:repo/pages/builds",
    paramValidationFactory<t_ReposRequestPagesBuildParamSchema>(
      reposRequestPagesBuildParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposRequestPagesBuildParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposRequestPagesBuild(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetLatestPagesBuildParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetLatestPagesBuild",
    "/repos/:owner/:repo/pages/builds/latest",
    paramValidationFactory<t_ReposGetLatestPagesBuildParamSchema>(
      reposGetLatestPagesBuildParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetLatestPagesBuildParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetLatestPagesBuild(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetPagesBuildParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    build_id: z.coerce.number(),
  })

  router.get(
    "reposGetPagesBuild",
    "/repos/:owner/:repo/pages/builds/:buildId",
    paramValidationFactory<t_ReposGetPagesBuildParamSchema>(
      reposGetPagesBuildParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetPagesBuildParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetPagesBuild(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreatePagesDeploymentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreatePagesDeploymentBodySchema = z.object({
    artifact_url: z.coerce.string(),
    environment: z.coerce.string().optional(),
    pages_build_version: z.coerce.string(),
    oidc_token: z.coerce.string(),
  })

  router.post(
    "reposCreatePagesDeployment",
    "/repos/:owner/:repo/pages/deployment",
    paramValidationFactory<t_ReposCreatePagesDeploymentParamSchema>(
      reposCreatePagesDeploymentParamSchema
    ),
    bodyValidationFactory<t_ReposCreatePagesDeploymentBodySchema>(
      reposCreatePagesDeploymentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreatePagesDeploymentParamSchema,
        void,
        t_ReposCreatePagesDeploymentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreatePagesDeployment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetPagesHealthCheckParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetPagesHealthCheck",
    "/repos/:owner/:repo/pages/health",
    paramValidationFactory<t_ReposGetPagesHealthCheckParamSchema>(
      reposGetPagesHealthCheckParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetPagesHealthCheckParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetPagesHealthCheck(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsListForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const projectsListForRepoQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "projectsListForRepo",
    "/repos/:owner/:repo/projects",
    paramValidationFactory<t_ProjectsListForRepoParamSchema>(
      projectsListForRepoParamSchema
    ),
    queryValidationFactory<t_ProjectsListForRepoQuerySchema>(
      projectsListForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsListForRepoParamSchema,
        t_ProjectsListForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsListForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsCreateForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const projectsCreateForRepoBodySchema = z.object({
    name: z.coerce.string(),
    body: z.coerce.string().optional(),
  })

  router.post(
    "projectsCreateForRepo",
    "/repos/:owner/:repo/projects",
    paramValidationFactory<t_ProjectsCreateForRepoParamSchema>(
      projectsCreateForRepoParamSchema
    ),
    bodyValidationFactory<t_ProjectsCreateForRepoBodySchema>(
      projectsCreateForRepoBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsCreateForRepoParamSchema,
        void,
        t_ProjectsCreateForRepoBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsCreateForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const pullsListQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional(),
    head: z.coerce.string().optional(),
    base: z.coerce.string().optional(),
    sort: z
      .enum(["created", "updated", "popularity", "long-running"])
      .optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "pullsList",
    "/repos/:owner/:repo/pulls",
    paramValidationFactory<t_PullsListParamSchema>(pullsListParamSchema),
    queryValidationFactory<t_PullsListQuerySchema>(pullsListQuerySchema),
    async (
      ctx: ValidatedCtx<t_PullsListParamSchema, t_PullsListQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsList(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsCreateParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const pullsCreateBodySchema = z.object({
    title: z.coerce.string().optional(),
    head: z.coerce.string(),
    base: z.coerce.string(),
    body: z.coerce.string().optional(),
    maintainer_can_modify: z.coerce.boolean().optional(),
    draft: z.coerce.boolean().optional(),
    issue: z.coerce.number().optional(),
  })

  router.post(
    "pullsCreate",
    "/repos/:owner/:repo/pulls",
    paramValidationFactory<t_PullsCreateParamSchema>(pullsCreateParamSchema),
    bodyValidationFactory<t_PullsCreateBodySchema>(pullsCreateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_PullsCreateParamSchema,
        void,
        t_PullsCreateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsCreate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListReviewCommentsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const pullsListReviewCommentsForRepoQuerySchema = z.object({
    sort: z.enum(["created", "updated", "created_at"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "pullsListReviewCommentsForRepo",
    "/repos/:owner/:repo/pulls/comments",
    paramValidationFactory<t_PullsListReviewCommentsForRepoParamSchema>(
      pullsListReviewCommentsForRepoParamSchema
    ),
    queryValidationFactory<t_PullsListReviewCommentsForRepoQuerySchema>(
      pullsListReviewCommentsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsListReviewCommentsForRepoParamSchema,
        t_PullsListReviewCommentsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.pullsListReviewCommentsForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsGetReviewCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.get(
    "pullsGetReviewComment",
    "/repos/:owner/:repo/pulls/comments/:commentId",
    paramValidationFactory<t_PullsGetReviewCommentParamSchema>(
      pullsGetReviewCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PullsGetReviewCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsGetReviewComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsUpdateReviewCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const pullsUpdateReviewCommentBodySchema = z.object({
    body: z.coerce.string(),
  })

  router.patch(
    "pullsUpdateReviewComment",
    "/repos/:owner/:repo/pulls/comments/:commentId",
    paramValidationFactory<t_PullsUpdateReviewCommentParamSchema>(
      pullsUpdateReviewCommentParamSchema
    ),
    bodyValidationFactory<t_PullsUpdateReviewCommentBodySchema>(
      pullsUpdateReviewCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsUpdateReviewCommentParamSchema,
        void,
        t_PullsUpdateReviewCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsUpdateReviewComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsDeleteReviewCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  router.delete(
    "pullsDeleteReviewComment",
    "/repos/:owner/:repo/pulls/comments/:commentId",
    paramValidationFactory<t_PullsDeleteReviewCommentParamSchema>(
      pullsDeleteReviewCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PullsDeleteReviewCommentParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsDeleteReviewComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForPullRequestReviewCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsListForPullRequestReviewCommentQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForPullRequestReviewComment",
    "/repos/:owner/:repo/pulls/comments/:commentId/reactions",
    paramValidationFactory<t_ReactionsListForPullRequestReviewCommentParamSchema>(
      reactionsListForPullRequestReviewCommentParamSchema
    ),
    queryValidationFactory<t_ReactionsListForPullRequestReviewCommentQuerySchema>(
      reactionsListForPullRequestReviewCommentQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForPullRequestReviewCommentParamSchema,
        t_ReactionsListForPullRequestReviewCommentQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsListForPullRequestReviewComment(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForPullRequestReviewCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
  })

  const reactionsCreateForPullRequestReviewCommentBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForPullRequestReviewComment",
    "/repos/:owner/:repo/pulls/comments/:commentId/reactions",
    paramValidationFactory<t_ReactionsCreateForPullRequestReviewCommentParamSchema>(
      reactionsCreateForPullRequestReviewCommentParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForPullRequestReviewCommentBodySchema>(
      reactionsCreateForPullRequestReviewCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForPullRequestReviewCommentParamSchema,
        void,
        t_ReactionsCreateForPullRequestReviewCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsCreateForPullRequestReviewComment(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsDeleteForPullRequestCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    comment_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForPullRequestComment",
    "/repos/:owner/:repo/pulls/comments/:commentId/reactions/:reactionId",
    paramValidationFactory<t_ReactionsDeleteForPullRequestCommentParamSchema>(
      reactionsDeleteForPullRequestCommentParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsDeleteForPullRequestCommentParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsDeleteForPullRequestComment(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsGetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  router.get(
    "pullsGet",
    "/repos/:owner/:repo/pulls/:pullNumber",
    paramValidationFactory<t_PullsGetParamSchema>(pullsGetParamSchema),
    async (
      ctx: ValidatedCtx<t_PullsGetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsGet(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsUpdateParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsUpdateBodySchema = z
    .object({
      title: z.coerce.string().optional(),
      body: z.coerce.string().optional(),
      state: z.enum(["open", "closed"]).optional(),
      base: z.coerce.string().optional(),
      maintainer_can_modify: z.coerce.boolean().optional(),
    })
    .optional()

  router.patch(
    "pullsUpdate",
    "/repos/:owner/:repo/pulls/:pullNumber",
    paramValidationFactory<t_PullsUpdateParamSchema>(pullsUpdateParamSchema),
    bodyValidationFactory<t_PullsUpdateBodySchema>(pullsUpdateBodySchema),
    async (
      ctx: ValidatedCtx<
        t_PullsUpdateParamSchema,
        void,
        t_PullsUpdateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsUpdate(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesCreateWithPrForAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const codespacesCreateWithPrForAuthenticatedUserBodySchema = z.object({
    location: z.coerce.string().optional(),
    client_ip: z.coerce.string().optional(),
    machine: z.coerce.string().optional(),
    devcontainer_path: z.coerce.string().optional(),
    multi_repo_permissions_opt_out: z.coerce.boolean().optional(),
    working_directory: z.coerce.string().optional(),
    idle_timeout_minutes: z.coerce.number().optional(),
    display_name: z.coerce.string().optional(),
    retention_period_minutes: z.coerce.number().optional(),
  })

  router.post(
    "codespacesCreateWithPrForAuthenticatedUser",
    "/repos/:owner/:repo/pulls/:pullNumber/codespaces",
    paramValidationFactory<t_CodespacesCreateWithPrForAuthenticatedUserParamSchema>(
      codespacesCreateWithPrForAuthenticatedUserParamSchema
    ),
    bodyValidationFactory<t_CodespacesCreateWithPrForAuthenticatedUserBodySchema>(
      codespacesCreateWithPrForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesCreateWithPrForAuthenticatedUserParamSchema,
        void,
        t_CodespacesCreateWithPrForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesCreateWithPrForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListReviewCommentsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListReviewCommentsQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "pullsListReviewComments",
    "/repos/:owner/:repo/pulls/:pullNumber/comments",
    paramValidationFactory<t_PullsListReviewCommentsParamSchema>(
      pullsListReviewCommentsParamSchema
    ),
    queryValidationFactory<t_PullsListReviewCommentsQuerySchema>(
      pullsListReviewCommentsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsListReviewCommentsParamSchema,
        t_PullsListReviewCommentsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsListReviewComments(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsCreateReviewCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsCreateReviewCommentBodySchema = z.object({
    body: z.coerce.string(),
    commit_id: z.coerce.string(),
    path: z.coerce.string(),
    position: z.coerce.number().optional(),
    side: z.enum(["LEFT", "RIGHT"]).optional(),
    line: z.coerce.number(),
    start_line: z.coerce.number().optional(),
    start_side: z.enum(["LEFT", "RIGHT", "side"]).optional(),
    in_reply_to: z.coerce.number().optional(),
  })

  router.post(
    "pullsCreateReviewComment",
    "/repos/:owner/:repo/pulls/:pullNumber/comments",
    paramValidationFactory<t_PullsCreateReviewCommentParamSchema>(
      pullsCreateReviewCommentParamSchema
    ),
    bodyValidationFactory<t_PullsCreateReviewCommentBodySchema>(
      pullsCreateReviewCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsCreateReviewCommentParamSchema,
        void,
        t_PullsCreateReviewCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsCreateReviewComment(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsCreateReplyForReviewCommentParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
    comment_id: z.coerce.number(),
  })

  const pullsCreateReplyForReviewCommentBodySchema = z.object({
    body: z.coerce.string(),
  })

  router.post(
    "pullsCreateReplyForReviewComment",
    "/repos/:owner/:repo/pulls/:pullNumber/comments/:commentId/replies",
    paramValidationFactory<t_PullsCreateReplyForReviewCommentParamSchema>(
      pullsCreateReplyForReviewCommentParamSchema
    ),
    bodyValidationFactory<t_PullsCreateReplyForReviewCommentBodySchema>(
      pullsCreateReplyForReviewCommentBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsCreateReplyForReviewCommentParamSchema,
        void,
        t_PullsCreateReplyForReviewCommentBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.pullsCreateReplyForReviewComment(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListCommitsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListCommitsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "pullsListCommits",
    "/repos/:owner/:repo/pulls/:pullNumber/commits",
    paramValidationFactory<t_PullsListCommitsParamSchema>(
      pullsListCommitsParamSchema
    ),
    queryValidationFactory<t_PullsListCommitsQuerySchema>(
      pullsListCommitsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsListCommitsParamSchema,
        t_PullsListCommitsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsListCommits(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListFilesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListFilesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "pullsListFiles",
    "/repos/:owner/:repo/pulls/:pullNumber/files",
    paramValidationFactory<t_PullsListFilesParamSchema>(
      pullsListFilesParamSchema
    ),
    queryValidationFactory<t_PullsListFilesQuerySchema>(
      pullsListFilesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsListFilesParamSchema,
        t_PullsListFilesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsListFiles(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsCheckIfMergedParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  router.get(
    "pullsCheckIfMerged",
    "/repos/:owner/:repo/pulls/:pullNumber/merge",
    paramValidationFactory<t_PullsCheckIfMergedParamSchema>(
      pullsCheckIfMergedParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PullsCheckIfMergedParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsCheckIfMerged(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsMergeParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsMergeBodySchema = z
    .object({
      commit_title: z.coerce.string().optional(),
      commit_message: z.coerce.string().optional(),
      sha: z.coerce.string().optional(),
      merge_method: z.enum(["merge", "squash", "rebase"]).optional(),
    })
    .optional()

  router.put(
    "pullsMerge",
    "/repos/:owner/:repo/pulls/:pullNumber/merge",
    paramValidationFactory<t_PullsMergeParamSchema>(pullsMergeParamSchema),
    bodyValidationFactory<t_PullsMergeBodySchema>(pullsMergeBodySchema),
    async (
      ctx: ValidatedCtx<t_PullsMergeParamSchema, void, t_PullsMergeBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsMerge(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListRequestedReviewersParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  router.get(
    "pullsListRequestedReviewers",
    "/repos/:owner/:repo/pulls/:pullNumber/requested_reviewers",
    paramValidationFactory<t_PullsListRequestedReviewersParamSchema>(
      pullsListRequestedReviewersParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PullsListRequestedReviewersParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsListRequestedReviewers(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsRequestReviewersParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsRequestReviewersBodySchema = z
    .object({
      reviewers: z.array(z.coerce.string()).optional(),
      team_reviewers: z.array(z.coerce.string()).optional(),
    })
    .optional()

  router.post(
    "pullsRequestReviewers",
    "/repos/:owner/:repo/pulls/:pullNumber/requested_reviewers",
    paramValidationFactory<t_PullsRequestReviewersParamSchema>(
      pullsRequestReviewersParamSchema
    ),
    bodyValidationFactory<t_PullsRequestReviewersBodySchema>(
      pullsRequestReviewersBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsRequestReviewersParamSchema,
        void,
        t_PullsRequestReviewersBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsRequestReviewers(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsRemoveRequestedReviewersParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsRemoveRequestedReviewersBodySchema = z.object({
    reviewers: z.array(z.coerce.string()),
    team_reviewers: z.array(z.coerce.string()).optional(),
  })

  router.delete(
    "pullsRemoveRequestedReviewers",
    "/repos/:owner/:repo/pulls/:pullNumber/requested_reviewers",
    paramValidationFactory<t_PullsRemoveRequestedReviewersParamSchema>(
      pullsRemoveRequestedReviewersParamSchema
    ),
    bodyValidationFactory<t_PullsRemoveRequestedReviewersBodySchema>(
      pullsRemoveRequestedReviewersBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsRemoveRequestedReviewersParamSchema,
        void,
        t_PullsRemoveRequestedReviewersBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.pullsRemoveRequestedReviewers(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListReviewsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsListReviewsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "pullsListReviews",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews",
    paramValidationFactory<t_PullsListReviewsParamSchema>(
      pullsListReviewsParamSchema
    ),
    queryValidationFactory<t_PullsListReviewsQuerySchema>(
      pullsListReviewsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsListReviewsParamSchema,
        t_PullsListReviewsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsListReviews(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsCreateReviewParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsCreateReviewBodySchema = z
    .object({
      commit_id: z.coerce.string().optional(),
      body: z.coerce.string().optional(),
      event: z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]).optional(),
      comments: z
        .array(
          z.object({
            path: z.coerce.string(),
            position: z.coerce.number().optional(),
            body: z.coerce.string(),
            line: z.coerce.number().optional(),
            side: z.coerce.string().optional(),
            start_line: z.coerce.number().optional(),
            start_side: z.coerce.string().optional(),
          })
        )
        .optional(),
    })
    .optional()

  router.post(
    "pullsCreateReview",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews",
    paramValidationFactory<t_PullsCreateReviewParamSchema>(
      pullsCreateReviewParamSchema
    ),
    bodyValidationFactory<t_PullsCreateReviewBodySchema>(
      pullsCreateReviewBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsCreateReviewParamSchema,
        void,
        t_PullsCreateReviewBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsCreateReview(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsGetReviewParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  router.get(
    "pullsGetReview",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews/:reviewId",
    paramValidationFactory<t_PullsGetReviewParamSchema>(
      pullsGetReviewParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PullsGetReviewParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsGetReview(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsUpdateReviewParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsUpdateReviewBodySchema = z.object({ body: z.coerce.string() })

  router.put(
    "pullsUpdateReview",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews/:reviewId",
    paramValidationFactory<t_PullsUpdateReviewParamSchema>(
      pullsUpdateReviewParamSchema
    ),
    bodyValidationFactory<t_PullsUpdateReviewBodySchema>(
      pullsUpdateReviewBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsUpdateReviewParamSchema,
        void,
        t_PullsUpdateReviewBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsUpdateReview(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsDeletePendingReviewParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  router.delete(
    "pullsDeletePendingReview",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews/:reviewId",
    paramValidationFactory<t_PullsDeletePendingReviewParamSchema>(
      pullsDeletePendingReviewParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PullsDeletePendingReviewParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsDeletePendingReview(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsListCommentsForReviewParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsListCommentsForReviewQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "pullsListCommentsForReview",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews/:reviewId/comments",
    paramValidationFactory<t_PullsListCommentsForReviewParamSchema>(
      pullsListCommentsForReviewParamSchema
    ),
    queryValidationFactory<t_PullsListCommentsForReviewQuerySchema>(
      pullsListCommentsForReviewQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsListCommentsForReviewParamSchema,
        t_PullsListCommentsForReviewQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsListCommentsForReview(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsDismissReviewParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsDismissReviewBodySchema = z.object({
    message: z.coerce.string(),
    event: z.enum(["DISMISS"]).optional(),
  })

  router.put(
    "pullsDismissReview",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews/:reviewId/dismissals",
    paramValidationFactory<t_PullsDismissReviewParamSchema>(
      pullsDismissReviewParamSchema
    ),
    bodyValidationFactory<t_PullsDismissReviewBodySchema>(
      pullsDismissReviewBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsDismissReviewParamSchema,
        void,
        t_PullsDismissReviewBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsDismissReview(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsSubmitReviewParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
    review_id: z.coerce.number(),
  })

  const pullsSubmitReviewBodySchema = z.object({
    body: z.coerce.string().optional(),
    event: z.enum(["APPROVE", "REQUEST_CHANGES", "COMMENT"]),
  })

  router.post(
    "pullsSubmitReview",
    "/repos/:owner/:repo/pulls/:pullNumber/reviews/:reviewId/events",
    paramValidationFactory<t_PullsSubmitReviewParamSchema>(
      pullsSubmitReviewParamSchema
    ),
    bodyValidationFactory<t_PullsSubmitReviewBodySchema>(
      pullsSubmitReviewBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsSubmitReviewParamSchema,
        void,
        t_PullsSubmitReviewBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsSubmitReview(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const pullsUpdateBranchParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    pull_number: z.coerce.number(),
  })

  const pullsUpdateBranchBodySchema = z
    .object({ expected_head_sha: z.coerce.string().optional() })
    .optional()

  router.put(
    "pullsUpdateBranch",
    "/repos/:owner/:repo/pulls/:pullNumber/update-branch",
    paramValidationFactory<t_PullsUpdateBranchParamSchema>(
      pullsUpdateBranchParamSchema
    ),
    bodyValidationFactory<t_PullsUpdateBranchBodySchema>(
      pullsUpdateBranchBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PullsUpdateBranchParamSchema,
        void,
        t_PullsUpdateBranchBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.pullsUpdateBranch(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetReadmeParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposGetReadmeQuerySchema = z.object({
    ref: z.coerce.string().optional(),
  })

  router.get(
    "reposGetReadme",
    "/repos/:owner/:repo/readme",
    paramValidationFactory<t_ReposGetReadmeParamSchema>(
      reposGetReadmeParamSchema
    ),
    queryValidationFactory<t_ReposGetReadmeQuerySchema>(
      reposGetReadmeQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetReadmeParamSchema,
        t_ReposGetReadmeQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetReadme(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetReadmeInDirectoryParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    dir: z.coerce.string(),
  })

  const reposGetReadmeInDirectoryQuerySchema = z.object({
    ref: z.coerce.string().optional(),
  })

  router.get(
    "reposGetReadmeInDirectory",
    "/repos/:owner/:repo/readme/:dir",
    paramValidationFactory<t_ReposGetReadmeInDirectoryParamSchema>(
      reposGetReadmeInDirectoryParamSchema
    ),
    queryValidationFactory<t_ReposGetReadmeInDirectoryQuerySchema>(
      reposGetReadmeInDirectoryQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetReadmeInDirectoryParamSchema,
        t_ReposGetReadmeInDirectoryQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetReadmeInDirectory(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListReleasesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListReleasesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListReleases",
    "/repos/:owner/:repo/releases",
    paramValidationFactory<t_ReposListReleasesParamSchema>(
      reposListReleasesParamSchema
    ),
    queryValidationFactory<t_ReposListReleasesQuerySchema>(
      reposListReleasesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListReleasesParamSchema,
        t_ReposListReleasesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListReleases(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateReleaseBodySchema = z.object({
    tag_name: z.coerce.string(),
    target_commitish: z.coerce.string().optional(),
    name: z.coerce.string().optional(),
    body: z.coerce.string().optional(),
    draft: z.coerce.boolean().optional(),
    prerelease: z.coerce.boolean().optional(),
    discussion_category_name: z.coerce.string().optional(),
    generate_release_notes: z.coerce.boolean().optional(),
    make_latest: z.enum(["true", "false", "legacy"]).optional(),
  })

  router.post(
    "reposCreateRelease",
    "/repos/:owner/:repo/releases",
    paramValidationFactory<t_ReposCreateReleaseParamSchema>(
      reposCreateReleaseParamSchema
    ),
    bodyValidationFactory<t_ReposCreateReleaseBodySchema>(
      reposCreateReleaseBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateReleaseParamSchema,
        void,
        t_ReposCreateReleaseBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetReleaseAssetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    asset_id: z.coerce.number(),
  })

  router.get(
    "reposGetReleaseAsset",
    "/repos/:owner/:repo/releases/assets/:assetId",
    paramValidationFactory<t_ReposGetReleaseAssetParamSchema>(
      reposGetReleaseAssetParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetReleaseAssetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetReleaseAsset(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateReleaseAssetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    asset_id: z.coerce.number(),
  })

  const reposUpdateReleaseAssetBodySchema = z
    .object({
      name: z.coerce.string().optional(),
      label: z.coerce.string().optional(),
      state: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "reposUpdateReleaseAsset",
    "/repos/:owner/:repo/releases/assets/:assetId",
    paramValidationFactory<t_ReposUpdateReleaseAssetParamSchema>(
      reposUpdateReleaseAssetParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateReleaseAssetBodySchema>(
      reposUpdateReleaseAssetBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateReleaseAssetParamSchema,
        void,
        t_ReposUpdateReleaseAssetBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUpdateReleaseAsset(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteReleaseAssetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    asset_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteReleaseAsset",
    "/repos/:owner/:repo/releases/assets/:assetId",
    paramValidationFactory<t_ReposDeleteReleaseAssetParamSchema>(
      reposDeleteReleaseAssetParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteReleaseAssetParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteReleaseAsset(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGenerateReleaseNotesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposGenerateReleaseNotesBodySchema = z.object({
    tag_name: z.coerce.string(),
    target_commitish: z.coerce.string().optional(),
    previous_tag_name: z.coerce.string().optional(),
    configuration_file_path: z.coerce.string().optional(),
  })

  router.post(
    "reposGenerateReleaseNotes",
    "/repos/:owner/:repo/releases/generate-notes",
    paramValidationFactory<t_ReposGenerateReleaseNotesParamSchema>(
      reposGenerateReleaseNotesParamSchema
    ),
    bodyValidationFactory<t_ReposGenerateReleaseNotesBodySchema>(
      reposGenerateReleaseNotesBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGenerateReleaseNotesParamSchema,
        void,
        t_ReposGenerateReleaseNotesBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGenerateReleaseNotes(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetLatestReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetLatestRelease",
    "/repos/:owner/:repo/releases/latest",
    paramValidationFactory<t_ReposGetLatestReleaseParamSchema>(
      reposGetLatestReleaseParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetLatestReleaseParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetLatestRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetReleaseByTagParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    tag: z.coerce.string(),
  })

  router.get(
    "reposGetReleaseByTag",
    "/repos/:owner/:repo/releases/tags/:tag",
    paramValidationFactory<t_ReposGetReleaseByTagParamSchema>(
      reposGetReleaseByTagParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetReleaseByTagParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetReleaseByTag(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
  })

  router.get(
    "reposGetRelease",
    "/repos/:owner/:repo/releases/:releaseId",
    paramValidationFactory<t_ReposGetReleaseParamSchema>(
      reposGetReleaseParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetReleaseParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUpdateReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
  })

  const reposUpdateReleaseBodySchema = z
    .object({
      tag_name: z.coerce.string().optional(),
      target_commitish: z.coerce.string().optional(),
      name: z.coerce.string().optional(),
      body: z.coerce.string().optional(),
      draft: z.coerce.boolean().optional(),
      prerelease: z.coerce.boolean().optional(),
      make_latest: z.enum(["true", "false", "legacy"]).optional(),
      discussion_category_name: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "reposUpdateRelease",
    "/repos/:owner/:repo/releases/:releaseId",
    paramValidationFactory<t_ReposUpdateReleaseParamSchema>(
      reposUpdateReleaseParamSchema
    ),
    bodyValidationFactory<t_ReposUpdateReleaseBodySchema>(
      reposUpdateReleaseBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUpdateReleaseParamSchema,
        void,
        t_ReposUpdateReleaseBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUpdateRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteRelease",
    "/repos/:owner/:repo/releases/:releaseId",
    paramValidationFactory<t_ReposDeleteReleaseParamSchema>(
      reposDeleteReleaseParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteReleaseParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListReleaseAssetsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
  })

  const reposListReleaseAssetsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListReleaseAssets",
    "/repos/:owner/:repo/releases/:releaseId/assets",
    paramValidationFactory<t_ReposListReleaseAssetsParamSchema>(
      reposListReleaseAssetsParamSchema
    ),
    queryValidationFactory<t_ReposListReleaseAssetsQuerySchema>(
      reposListReleaseAssetsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListReleaseAssetsParamSchema,
        t_ReposListReleaseAssetsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListReleaseAssets(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposUploadReleaseAssetParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
  })

  const reposUploadReleaseAssetQuerySchema = z.object({
    name: z.coerce.string(),
    label: z.coerce.string().optional(),
  })

  const reposUploadReleaseAssetBodySchema = z.coerce.string().optional()

  router.post(
    "reposUploadReleaseAsset",
    "/repos/:owner/:repo/releases/:releaseId/assets",
    paramValidationFactory<t_ReposUploadReleaseAssetParamSchema>(
      reposUploadReleaseAssetParamSchema
    ),
    queryValidationFactory<t_ReposUploadReleaseAssetQuerySchema>(
      reposUploadReleaseAssetQuerySchema
    ),
    bodyValidationFactory<t_ReposUploadReleaseAssetBodySchema>(
      reposUploadReleaseAssetBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposUploadReleaseAssetParamSchema,
        t_ReposUploadReleaseAssetQuerySchema,
        t_ReposUploadReleaseAssetBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposUploadReleaseAsset(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
  })

  const reactionsListForReleaseQuerySchema = z.object({
    content: z
      .enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForRelease",
    "/repos/:owner/:repo/releases/:releaseId/reactions",
    paramValidationFactory<t_ReactionsListForReleaseParamSchema>(
      reactionsListForReleaseParamSchema
    ),
    queryValidationFactory<t_ReactionsListForReleaseQuerySchema>(
      reactionsListForReleaseQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForReleaseParamSchema,
        t_ReactionsListForReleaseQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reactionsListForRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
  })

  const reactionsCreateForReleaseBodySchema = z.object({
    content: z.enum(["+1", "laugh", "heart", "hooray", "rocket", "eyes"]),
  })

  router.post(
    "reactionsCreateForRelease",
    "/repos/:owner/:repo/releases/:releaseId/reactions",
    paramValidationFactory<t_ReactionsCreateForReleaseParamSchema>(
      reactionsCreateForReleaseParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForReleaseBodySchema>(
      reactionsCreateForReleaseBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForReleaseParamSchema,
        void,
        t_ReactionsCreateForReleaseBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reactionsCreateForRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsDeleteForReleaseParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    release_id: z.coerce.number(),
    reaction_id: z.coerce.number(),
  })

  router.delete(
    "reactionsDeleteForRelease",
    "/repos/:owner/:repo/releases/:releaseId/reactions/:reactionId",
    paramValidationFactory<t_ReactionsDeleteForReleaseParamSchema>(
      reactionsDeleteForReleaseParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReactionsDeleteForReleaseParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reactionsDeleteForRelease(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningListAlertsForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const secretScanningListAlertsForRepoQuerySchema = z.object({
    state: z.enum(["open", "resolved"]).optional(),
    secret_type: z.coerce.string().optional(),
    resolution: z.coerce.string().optional(),
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
    before: z.coerce.string().optional(),
    after: z.coerce.string().optional(),
  })

  router.get(
    "secretScanningListAlertsForRepo",
    "/repos/:owner/:repo/secret-scanning/alerts",
    paramValidationFactory<t_SecretScanningListAlertsForRepoParamSchema>(
      secretScanningListAlertsForRepoParamSchema
    ),
    queryValidationFactory<t_SecretScanningListAlertsForRepoQuerySchema>(
      secretScanningListAlertsForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningListAlertsForRepoParamSchema,
        t_SecretScanningListAlertsForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.secretScanningListAlertsForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningGetAlertParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  router.get(
    "secretScanningGetAlert",
    "/repos/:owner/:repo/secret-scanning/alerts/:alertNumber",
    paramValidationFactory<t_SecretScanningGetAlertParamSchema>(
      secretScanningGetAlertParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_SecretScanningGetAlertParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.secretScanningGetAlert(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningUpdateAlertParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  const secretScanningUpdateAlertBodySchema = z.object({
    state: z.enum(["open", "resolved"]),
    resolution: z
      .enum(["null", "false_positive", "wont_fix", "revoked", "used_in_tests"])
      .optional(),
    resolution_comment: z.coerce.string().optional(),
  })

  router.patch(
    "secretScanningUpdateAlert",
    "/repos/:owner/:repo/secret-scanning/alerts/:alertNumber",
    paramValidationFactory<t_SecretScanningUpdateAlertParamSchema>(
      secretScanningUpdateAlertParamSchema
    ),
    bodyValidationFactory<t_SecretScanningUpdateAlertBodySchema>(
      secretScanningUpdateAlertBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningUpdateAlertParamSchema,
        void,
        t_SecretScanningUpdateAlertBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.secretScanningUpdateAlert(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const secretScanningListLocationsForAlertParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    alert_number: z.coerce.number(),
  })

  const secretScanningListLocationsForAlertQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "secretScanningListLocationsForAlert",
    "/repos/:owner/:repo/secret-scanning/alerts/:alertNumber/locations",
    paramValidationFactory<t_SecretScanningListLocationsForAlertParamSchema>(
      secretScanningListLocationsForAlertParamSchema
    ),
    queryValidationFactory<t_SecretScanningListLocationsForAlertQuerySchema>(
      secretScanningListLocationsForAlertQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_SecretScanningListLocationsForAlertParamSchema,
        t_SecretScanningListLocationsForAlertQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.secretScanningListLocationsForAlert(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListStargazersForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const activityListStargazersForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListStargazersForRepo",
    "/repos/:owner/:repo/stargazers",
    paramValidationFactory<t_ActivityListStargazersForRepoParamSchema>(
      activityListStargazersForRepoParamSchema
    ),
    queryValidationFactory<t_ActivityListStargazersForRepoQuerySchema>(
      activityListStargazersForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListStargazersForRepoParamSchema,
        t_ActivityListStargazersForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListStargazersForRepo(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCodeFrequencyStatsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetCodeFrequencyStats",
    "/repos/:owner/:repo/stats/code_frequency",
    paramValidationFactory<t_ReposGetCodeFrequencyStatsParamSchema>(
      reposGetCodeFrequencyStatsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetCodeFrequencyStatsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetCodeFrequencyStats(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetCommitActivityStatsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetCommitActivityStats",
    "/repos/:owner/:repo/stats/commit_activity",
    paramValidationFactory<t_ReposGetCommitActivityStatsParamSchema>(
      reposGetCommitActivityStatsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetCommitActivityStatsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetCommitActivityStats(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetContributorsStatsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetContributorsStats",
    "/repos/:owner/:repo/stats/contributors",
    paramValidationFactory<t_ReposGetContributorsStatsParamSchema>(
      reposGetContributorsStatsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetContributorsStatsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetContributorsStats(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetParticipationStatsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetParticipationStats",
    "/repos/:owner/:repo/stats/participation",
    paramValidationFactory<t_ReposGetParticipationStatsParamSchema>(
      reposGetParticipationStatsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetParticipationStatsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetParticipationStats(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetPunchCardStatsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetPunchCardStats",
    "/repos/:owner/:repo/stats/punch_card",
    paramValidationFactory<t_ReposGetPunchCardStatsParamSchema>(
      reposGetPunchCardStatsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetPunchCardStatsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetPunchCardStats(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateCommitStatusParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    sha: z.coerce.string(),
  })

  const reposCreateCommitStatusBodySchema = z.object({
    state: z.enum(["error", "failure", "pending", "success"]),
    target_url: z.coerce.string().optional(),
    description: z.coerce.string().optional(),
    context: z.coerce.string().optional(),
  })

  router.post(
    "reposCreateCommitStatus",
    "/repos/:owner/:repo/statuses/:sha",
    paramValidationFactory<t_ReposCreateCommitStatusParamSchema>(
      reposCreateCommitStatusParamSchema
    ),
    bodyValidationFactory<t_ReposCreateCommitStatusBodySchema>(
      reposCreateCommitStatusBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateCommitStatusParamSchema,
        void,
        t_ReposCreateCommitStatusBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateCommitStatus(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListWatchersForRepoParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const activityListWatchersForRepoQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListWatchersForRepo",
    "/repos/:owner/:repo/subscribers",
    paramValidationFactory<t_ActivityListWatchersForRepoParamSchema>(
      activityListWatchersForRepoParamSchema
    ),
    queryValidationFactory<t_ActivityListWatchersForRepoQuerySchema>(
      activityListWatchersForRepoQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListWatchersForRepoParamSchema,
        t_ActivityListWatchersForRepoQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.activityListWatchersForRepo(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityGetRepoSubscriptionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "activityGetRepoSubscription",
    "/repos/:owner/:repo/subscription",
    paramValidationFactory<t_ActivityGetRepoSubscriptionParamSchema>(
      activityGetRepoSubscriptionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActivityGetRepoSubscriptionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.activityGetRepoSubscription(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activitySetRepoSubscriptionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const activitySetRepoSubscriptionBodySchema = z
    .object({
      subscribed: z.coerce.boolean().optional(),
      ignored: z.coerce.boolean().optional(),
    })
    .optional()

  router.put(
    "activitySetRepoSubscription",
    "/repos/:owner/:repo/subscription",
    paramValidationFactory<t_ActivitySetRepoSubscriptionParamSchema>(
      activitySetRepoSubscriptionParamSchema
    ),
    bodyValidationFactory<t_ActivitySetRepoSubscriptionBodySchema>(
      activitySetRepoSubscriptionBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivitySetRepoSubscriptionParamSchema,
        void,
        t_ActivitySetRepoSubscriptionBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.activitySetRepoSubscription(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityDeleteRepoSubscriptionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "activityDeleteRepoSubscription",
    "/repos/:owner/:repo/subscription",
    paramValidationFactory<t_ActivityDeleteRepoSubscriptionParamSchema>(
      activityDeleteRepoSubscriptionParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityDeleteRepoSubscriptionParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityDeleteRepoSubscription(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListTagsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListTagsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListTags",
    "/repos/:owner/:repo/tags",
    paramValidationFactory<t_ReposListTagsParamSchema>(
      reposListTagsParamSchema
    ),
    queryValidationFactory<t_ReposListTagsQuerySchema>(
      reposListTagsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListTagsParamSchema,
        t_ReposListTagsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListTags(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListTagProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposListTagProtection",
    "/repos/:owner/:repo/tags/protection",
    paramValidationFactory<t_ReposListTagProtectionParamSchema>(
      reposListTagProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposListTagProtectionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListTagProtection(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateTagProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposCreateTagProtectionBodySchema = z.object({
    pattern: z.coerce.string(),
  })

  router.post(
    "reposCreateTagProtection",
    "/repos/:owner/:repo/tags/protection",
    paramValidationFactory<t_ReposCreateTagProtectionParamSchema>(
      reposCreateTagProtectionParamSchema
    ),
    bodyValidationFactory<t_ReposCreateTagProtectionBodySchema>(
      reposCreateTagProtectionBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateTagProtectionParamSchema,
        void,
        t_ReposCreateTagProtectionBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateTagProtection(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeleteTagProtectionParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    tag_protection_id: z.coerce.number(),
  })

  router.delete(
    "reposDeleteTagProtection",
    "/repos/:owner/:repo/tags/protection/:tagProtectionId",
    paramValidationFactory<t_ReposDeleteTagProtectionParamSchema>(
      reposDeleteTagProtectionParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDeleteTagProtectionParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDeleteTagProtection(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDownloadTarballArchiveParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  router.get(
    "reposDownloadTarballArchive",
    "/repos/:owner/:repo/tarball/:ref",
    paramValidationFactory<t_ReposDownloadTarballArchiveParamSchema>(
      reposDownloadTarballArchiveParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDownloadTarballArchiveParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDownloadTarballArchive(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListTeamsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposListTeamsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListTeams",
    "/repos/:owner/:repo/teams",
    paramValidationFactory<t_ReposListTeamsParamSchema>(
      reposListTeamsParamSchema
    ),
    queryValidationFactory<t_ReposListTeamsQuerySchema>(
      reposListTeamsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListTeamsParamSchema,
        t_ReposListTeamsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListTeams(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetAllTopicsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposGetAllTopicsQuerySchema = z.object({
    page: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "reposGetAllTopics",
    "/repos/:owner/:repo/topics",
    paramValidationFactory<t_ReposGetAllTopicsParamSchema>(
      reposGetAllTopicsParamSchema
    ),
    queryValidationFactory<t_ReposGetAllTopicsQuerySchema>(
      reposGetAllTopicsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetAllTopicsParamSchema,
        t_ReposGetAllTopicsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetAllTopics(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposReplaceAllTopicsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposReplaceAllTopicsBodySchema = z.object({
    names: z.array(z.coerce.string()),
  })

  router.put(
    "reposReplaceAllTopics",
    "/repos/:owner/:repo/topics",
    paramValidationFactory<t_ReposReplaceAllTopicsParamSchema>(
      reposReplaceAllTopicsParamSchema
    ),
    bodyValidationFactory<t_ReposReplaceAllTopicsBodySchema>(
      reposReplaceAllTopicsBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposReplaceAllTopicsParamSchema,
        void,
        t_ReposReplaceAllTopicsBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposReplaceAllTopics(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetClonesParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposGetClonesQuerySchema = z.object({
    per: z.enum(["", "day", "week"]).optional(),
  })

  router.get(
    "reposGetClones",
    "/repos/:owner/:repo/traffic/clones",
    paramValidationFactory<t_ReposGetClonesParamSchema>(
      reposGetClonesParamSchema
    ),
    queryValidationFactory<t_ReposGetClonesQuerySchema>(
      reposGetClonesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetClonesParamSchema,
        t_ReposGetClonesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetClones(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetTopPathsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetTopPaths",
    "/repos/:owner/:repo/traffic/popular/paths",
    paramValidationFactory<t_ReposGetTopPathsParamSchema>(
      reposGetTopPathsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetTopPathsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetTopPaths(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetTopReferrersParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposGetTopReferrers",
    "/repos/:owner/:repo/traffic/popular/referrers",
    paramValidationFactory<t_ReposGetTopReferrersParamSchema>(
      reposGetTopReferrersParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposGetTopReferrersParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetTopReferrers(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposGetViewsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposGetViewsQuerySchema = z.object({
    per: z.enum(["", "day", "week"]).optional(),
  })

  router.get(
    "reposGetViews",
    "/repos/:owner/:repo/traffic/views",
    paramValidationFactory<t_ReposGetViewsParamSchema>(
      reposGetViewsParamSchema
    ),
    queryValidationFactory<t_ReposGetViewsQuerySchema>(
      reposGetViewsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposGetViewsParamSchema,
        t_ReposGetViewsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposGetViews(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposTransferParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const reposTransferBodySchema = z.object({
    new_owner: z.coerce.string(),
    new_name: z.coerce.string().optional(),
    team_ids: z.array(z.coerce.number()).optional(),
  })

  router.post(
    "reposTransfer",
    "/repos/:owner/:repo/transfer",
    paramValidationFactory<t_ReposTransferParamSchema>(
      reposTransferParamSchema
    ),
    bodyValidationFactory<t_ReposTransferBodySchema>(reposTransferBodySchema),
    async (
      ctx: ValidatedCtx<
        t_ReposTransferParamSchema,
        void,
        t_ReposTransferBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposTransfer(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCheckVulnerabilityAlertsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "reposCheckVulnerabilityAlerts",
    "/repos/:owner/:repo/vulnerability-alerts",
    paramValidationFactory<t_ReposCheckVulnerabilityAlertsParamSchema>(
      reposCheckVulnerabilityAlertsParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposCheckVulnerabilityAlertsParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposCheckVulnerabilityAlerts(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposEnableVulnerabilityAlertsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.put(
    "reposEnableVulnerabilityAlerts",
    "/repos/:owner/:repo/vulnerability-alerts",
    paramValidationFactory<t_ReposEnableVulnerabilityAlertsParamSchema>(
      reposEnableVulnerabilityAlertsParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposEnableVulnerabilityAlertsParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposEnableVulnerabilityAlerts(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDisableVulnerabilityAlertsParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "reposDisableVulnerabilityAlerts",
    "/repos/:owner/:repo/vulnerability-alerts",
    paramValidationFactory<t_ReposDisableVulnerabilityAlertsParamSchema>(
      reposDisableVulnerabilityAlertsParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDisableVulnerabilityAlertsParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDisableVulnerabilityAlerts(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDownloadZipballArchiveParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
    ref: z.coerce.string(),
  })

  router.get(
    "reposDownloadZipballArchive",
    "/repos/:owner/:repo/zipball/:ref",
    paramValidationFactory<t_ReposDownloadZipballArchiveParamSchema>(
      reposDownloadZipballArchiveParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ReposDownloadZipballArchiveParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposDownloadZipballArchive(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateUsingTemplateParamSchema = z.object({
    template_owner: z.coerce.string(),
    template_repo: z.coerce.string(),
  })

  const reposCreateUsingTemplateBodySchema = z.object({
    owner: z.coerce.string().optional(),
    name: z.coerce.string(),
    description: z.coerce.string().optional(),
    include_all_branches: z.coerce.boolean().optional(),
    private: z.coerce.boolean().optional(),
  })

  router.post(
    "reposCreateUsingTemplate",
    "/repos/:templateOwner/:templateRepo/generate",
    paramValidationFactory<t_ReposCreateUsingTemplateParamSchema>(
      reposCreateUsingTemplateParamSchema
    ),
    bodyValidationFactory<t_ReposCreateUsingTemplateBodySchema>(
      reposCreateUsingTemplateBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposCreateUsingTemplateParamSchema,
        void,
        t_ReposCreateUsingTemplateBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposCreateUsingTemplate(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListPublicQuerySchema = z.object({
    since: z.coerce.number().optional(),
  })

  router.get(
    "reposListPublic",
    "/repositories",
    queryValidationFactory<t_ReposListPublicQuerySchema>(
      reposListPublicQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_ReposListPublicQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListPublic(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListEnvironmentSecretsParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
  })

  const actionsListEnvironmentSecretsQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListEnvironmentSecrets",
    "/repositories/:repositoryId/environments/:environmentName/secrets",
    paramValidationFactory<t_ActionsListEnvironmentSecretsParamSchema>(
      actionsListEnvironmentSecretsParamSchema
    ),
    queryValidationFactory<t_ActionsListEnvironmentSecretsQuerySchema>(
      actionsListEnvironmentSecretsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListEnvironmentSecretsParamSchema,
        t_ActionsListEnvironmentSecretsQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListEnvironmentSecrets(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetEnvironmentPublicKeyParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
  })

  router.get(
    "actionsGetEnvironmentPublicKey",
    "/repositories/:repositoryId/environments/:environmentName/secrets/public-key",
    paramValidationFactory<t_ActionsGetEnvironmentPublicKeyParamSchema>(
      actionsGetEnvironmentPublicKeyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsGetEnvironmentPublicKeyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetEnvironmentPublicKey(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetEnvironmentSecretParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.get(
    "actionsGetEnvironmentSecret",
    "/repositories/:repositoryId/environments/:environmentName/secrets/:secretName",
    paramValidationFactory<t_ActionsGetEnvironmentSecretParamSchema>(
      actionsGetEnvironmentSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetEnvironmentSecretParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.actionsGetEnvironmentSecret(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateOrUpdateEnvironmentSecretParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  const actionsCreateOrUpdateEnvironmentSecretBodySchema = z.object({
    encrypted_value: z.coerce.string(),
    key_id: z.coerce.string(),
  })

  router.put(
    "actionsCreateOrUpdateEnvironmentSecret",
    "/repositories/:repositoryId/environments/:environmentName/secrets/:secretName",
    paramValidationFactory<t_ActionsCreateOrUpdateEnvironmentSecretParamSchema>(
      actionsCreateOrUpdateEnvironmentSecretParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateOrUpdateEnvironmentSecretBodySchema>(
      actionsCreateOrUpdateEnvironmentSecretBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateOrUpdateEnvironmentSecretParamSchema,
        void,
        t_ActionsCreateOrUpdateEnvironmentSecretBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateOrUpdateEnvironmentSecret(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteEnvironmentSecretParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
    secret_name: z.coerce.string(),
  })

  router.delete(
    "actionsDeleteEnvironmentSecret",
    "/repositories/:repositoryId/environments/:environmentName/secrets/:secretName",
    paramValidationFactory<t_ActionsDeleteEnvironmentSecretParamSchema>(
      actionsDeleteEnvironmentSecretParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDeleteEnvironmentSecretParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteEnvironmentSecret(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsListEnvironmentVariablesParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
  })

  const actionsListEnvironmentVariablesQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "actionsListEnvironmentVariables",
    "/repositories/:repositoryId/environments/:environmentName/variables",
    paramValidationFactory<t_ActionsListEnvironmentVariablesParamSchema>(
      actionsListEnvironmentVariablesParamSchema
    ),
    queryValidationFactory<t_ActionsListEnvironmentVariablesQuerySchema>(
      actionsListEnvironmentVariablesQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsListEnvironmentVariablesParamSchema,
        t_ActionsListEnvironmentVariablesQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsListEnvironmentVariables(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsCreateEnvironmentVariableParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
  })

  const actionsCreateEnvironmentVariableBodySchema = z.object({
    name: z.coerce.string(),
    value: z.coerce.string(),
  })

  router.post(
    "actionsCreateEnvironmentVariable",
    "/repositories/:repositoryId/environments/:environmentName/variables",
    paramValidationFactory<t_ActionsCreateEnvironmentVariableParamSchema>(
      actionsCreateEnvironmentVariableParamSchema
    ),
    bodyValidationFactory<t_ActionsCreateEnvironmentVariableBodySchema>(
      actionsCreateEnvironmentVariableBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsCreateEnvironmentVariableParamSchema,
        void,
        t_ActionsCreateEnvironmentVariableBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsCreateEnvironmentVariable(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsGetEnvironmentVariableParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.get(
    "actionsGetEnvironmentVariable",
    "/repositories/:repositoryId/environments/:environmentName/variables/:name",
    paramValidationFactory<t_ActionsGetEnvironmentVariableParamSchema>(
      actionsGetEnvironmentVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_ActionsGetEnvironmentVariableParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsGetEnvironmentVariable(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsUpdateEnvironmentVariableParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
    name: z.coerce.string(),
  })

  const actionsUpdateEnvironmentVariableBodySchema = z.object({
    name: z.coerce.string().optional(),
    value: z.coerce.string().optional(),
  })

  router.patch(
    "actionsUpdateEnvironmentVariable",
    "/repositories/:repositoryId/environments/:environmentName/variables/:name",
    paramValidationFactory<t_ActionsUpdateEnvironmentVariableParamSchema>(
      actionsUpdateEnvironmentVariableParamSchema
    ),
    bodyValidationFactory<t_ActionsUpdateEnvironmentVariableBodySchema>(
      actionsUpdateEnvironmentVariableBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsUpdateEnvironmentVariableParamSchema,
        void,
        t_ActionsUpdateEnvironmentVariableBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsUpdateEnvironmentVariable(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const actionsDeleteEnvironmentVariableParamSchema = z.object({
    repository_id: z.coerce.number(),
    environment_name: z.coerce.string(),
    name: z.coerce.string(),
  })

  router.delete(
    "actionsDeleteEnvironmentVariable",
    "/repositories/:repositoryId/environments/:environmentName/variables/:name",
    paramValidationFactory<t_ActionsDeleteEnvironmentVariableParamSchema>(
      actionsDeleteEnvironmentVariableParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActionsDeleteEnvironmentVariableParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.actionsDeleteEnvironmentVariable(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const searchCodeQuerySchema = z.object({
    q: z.coerce.string(),
    sort: z.enum(["indexed"]).optional(),
    order: z.enum(["desc", "asc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "searchCode",
    "/search/code",
    queryValidationFactory<t_SearchCodeQuerySchema>(searchCodeQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_SearchCodeQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.searchCode(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const searchCommitsQuerySchema = z.object({
    q: z.coerce.string(),
    sort: z.enum(["author-date", "committer-date"]).optional(),
    order: z.enum(["desc", "asc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "searchCommits",
    "/search/commits",
    queryValidationFactory<t_SearchCommitsQuerySchema>(
      searchCommitsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_SearchCommitsQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.searchCommits(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const searchIssuesAndPullRequestsQuerySchema = z.object({
    q: z.coerce.string(),
    sort: z
      .enum([
        "comments",
        "reactions",
        "reactions-+1",
        "reactions--1",
        "reactions-smile",
        "reactions-thinking_face",
        "reactions-heart",
        "reactions-tada",
        "interactions",
        "created",
        "updated",
      ])
      .optional(),
    order: z.enum(["desc", "asc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "searchIssuesAndPullRequests",
    "/search/issues",
    queryValidationFactory<t_SearchIssuesAndPullRequestsQuerySchema>(
      searchIssuesAndPullRequestsQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_SearchIssuesAndPullRequestsQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.searchIssuesAndPullRequests(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const searchLabelsQuerySchema = z.object({
    repository_id: z.coerce.number(),
    q: z.coerce.string(),
    sort: z.enum(["created", "updated"]).optional(),
    order: z.enum(["desc", "asc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "searchLabels",
    "/search/labels",
    queryValidationFactory<t_SearchLabelsQuerySchema>(searchLabelsQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_SearchLabelsQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.searchLabels(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const searchReposQuerySchema = z.object({
    q: z.coerce.string(),
    sort: z
      .enum(["stars", "forks", "help-wanted-issues", "updated"])
      .optional(),
    order: z.enum(["desc", "asc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "searchRepos",
    "/search/repositories",
    queryValidationFactory<t_SearchReposQuerySchema>(searchReposQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_SearchReposQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.searchRepos(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const searchTopicsQuerySchema = z.object({
    q: z.coerce.string(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "searchTopics",
    "/search/topics",
    queryValidationFactory<t_SearchTopicsQuerySchema>(searchTopicsQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_SearchTopicsQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.searchTopics(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const searchUsersQuerySchema = z.object({
    q: z.coerce.string(),
    sort: z.enum(["followers", "repositories", "joined"]).optional(),
    order: z.enum(["desc", "asc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "searchUsers",
    "/search/users",
    queryValidationFactory<t_SearchUsersQuerySchema>(searchUsersQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_SearchUsersQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.searchUsers(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetLegacyParamSchema = z.object({ team_id: z.coerce.number() })

  router.get(
    "teamsGetLegacy",
    "/teams/:teamId",
    paramValidationFactory<t_TeamsGetLegacyParamSchema>(
      teamsGetLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsGetLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsGetLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsUpdateLegacyParamSchema = z.object({ team_id: z.coerce.number() })

  const teamsUpdateLegacyBodySchema = z.object({
    name: z.coerce.string(),
    description: z.coerce.string().optional(),
    privacy: z.enum(["secret", "closed"]).optional(),
    permission: z.enum(["pull", "push", "admin"]).optional(),
    parent_team_id: z.coerce.number().optional(),
  })

  router.patch(
    "teamsUpdateLegacy",
    "/teams/:teamId",
    paramValidationFactory<t_TeamsUpdateLegacyParamSchema>(
      teamsUpdateLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsUpdateLegacyBodySchema>(
      teamsUpdateLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsUpdateLegacyParamSchema,
        void,
        t_TeamsUpdateLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsUpdateLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsDeleteLegacyParamSchema = z.object({ team_id: z.coerce.number() })

  router.delete(
    "teamsDeleteLegacy",
    "/teams/:teamId",
    paramValidationFactory<t_TeamsDeleteLegacyParamSchema>(
      teamsDeleteLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsDeleteLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsDeleteLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListDiscussionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListDiscussionsLegacyQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListDiscussionsLegacy",
    "/teams/:teamId/discussions",
    paramValidationFactory<t_TeamsListDiscussionsLegacyParamSchema>(
      teamsListDiscussionsLegacyParamSchema
    ),
    queryValidationFactory<t_TeamsListDiscussionsLegacyQuerySchema>(
      teamsListDiscussionsLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListDiscussionsLegacyParamSchema,
        t_TeamsListDiscussionsLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListDiscussionsLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCreateDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsCreateDiscussionLegacyBodySchema = z.object({
    title: z.coerce.string(),
    body: z.coerce.string(),
    private: z.coerce.boolean().optional(),
  })

  router.post(
    "teamsCreateDiscussionLegacy",
    "/teams/:teamId/discussions",
    paramValidationFactory<t_TeamsCreateDiscussionLegacyParamSchema>(
      teamsCreateDiscussionLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsCreateDiscussionLegacyBodySchema>(
      teamsCreateDiscussionLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCreateDiscussionLegacyParamSchema,
        void,
        t_TeamsCreateDiscussionLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsCreateDiscussionLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionLegacy",
    "/teams/:teamId/discussions/:discussionNumber",
    paramValidationFactory<t_TeamsGetDiscussionLegacyParamSchema>(
      teamsGetDiscussionLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsGetDiscussionLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsGetDiscussionLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsUpdateDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionLegacyBodySchema = z
    .object({
      title: z.coerce.string().optional(),
      body: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "teamsUpdateDiscussionLegacy",
    "/teams/:teamId/discussions/:discussionNumber",
    paramValidationFactory<t_TeamsUpdateDiscussionLegacyParamSchema>(
      teamsUpdateDiscussionLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsUpdateDiscussionLegacyBodySchema>(
      teamsUpdateDiscussionLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsUpdateDiscussionLegacyParamSchema,
        void,
        t_TeamsUpdateDiscussionLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsUpdateDiscussionLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsDeleteDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionLegacy",
    "/teams/:teamId/discussions/:discussionNumber",
    paramValidationFactory<t_TeamsDeleteDiscussionLegacyParamSchema>(
      teamsDeleteDiscussionLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsDeleteDiscussionLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsDeleteDiscussionLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListDiscussionCommentsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsListDiscussionCommentsLegacyQuerySchema = z.object({
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListDiscussionCommentsLegacy",
    "/teams/:teamId/discussions/:discussionNumber/comments",
    paramValidationFactory<t_TeamsListDiscussionCommentsLegacyParamSchema>(
      teamsListDiscussionCommentsLegacyParamSchema
    ),
    queryValidationFactory<t_TeamsListDiscussionCommentsLegacyQuerySchema>(
      teamsListDiscussionCommentsLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListDiscussionCommentsLegacyParamSchema,
        t_TeamsListDiscussionCommentsLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsListDiscussionCommentsLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCreateDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const teamsCreateDiscussionCommentLegacyBodySchema = z.object({
    body: z.coerce.string(),
  })

  router.post(
    "teamsCreateDiscussionCommentLegacy",
    "/teams/:teamId/discussions/:discussionNumber/comments",
    paramValidationFactory<t_TeamsCreateDiscussionCommentLegacyParamSchema>(
      teamsCreateDiscussionCommentLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsCreateDiscussionCommentLegacyBodySchema>(
      teamsCreateDiscussionCommentLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCreateDiscussionCommentLegacyParamSchema,
        void,
        t_TeamsCreateDiscussionCommentLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsCreateDiscussionCommentLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.get(
    "teamsGetDiscussionCommentLegacy",
    "/teams/:teamId/discussions/:discussionNumber/comments/:commentNumber",
    paramValidationFactory<t_TeamsGetDiscussionCommentLegacyParamSchema>(
      teamsGetDiscussionCommentLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsGetDiscussionCommentLegacyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsGetDiscussionCommentLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsUpdateDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const teamsUpdateDiscussionCommentLegacyBodySchema = z.object({
    body: z.coerce.string(),
  })

  router.patch(
    "teamsUpdateDiscussionCommentLegacy",
    "/teams/:teamId/discussions/:discussionNumber/comments/:commentNumber",
    paramValidationFactory<t_TeamsUpdateDiscussionCommentLegacyParamSchema>(
      teamsUpdateDiscussionCommentLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsUpdateDiscussionCommentLegacyBodySchema>(
      teamsUpdateDiscussionCommentLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsUpdateDiscussionCommentLegacyParamSchema,
        void,
        t_TeamsUpdateDiscussionCommentLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsUpdateDiscussionCommentLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsDeleteDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  router.delete(
    "teamsDeleteDiscussionCommentLegacy",
    "/teams/:teamId/discussions/:discussionNumber/comments/:commentNumber",
    paramValidationFactory<t_TeamsDeleteDiscussionCommentLegacyParamSchema>(
      teamsDeleteDiscussionCommentLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsDeleteDiscussionCommentLegacyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsDeleteDiscussionCommentLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForTeamDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionCommentLegacyQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForTeamDiscussionCommentLegacy",
    "/teams/:teamId/discussions/:discussionNumber/comments/:commentNumber/reactions",
    paramValidationFactory<t_ReactionsListForTeamDiscussionCommentLegacyParamSchema>(
      reactionsListForTeamDiscussionCommentLegacyParamSchema
    ),
    queryValidationFactory<t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema>(
      reactionsListForTeamDiscussionCommentLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForTeamDiscussionCommentLegacyParamSchema,
        t_ReactionsListForTeamDiscussionCommentLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsListForTeamDiscussionCommentLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForTeamDiscussionCommentLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
    comment_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionCommentLegacyBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionCommentLegacy",
    "/teams/:teamId/discussions/:discussionNumber/comments/:commentNumber/reactions",
    paramValidationFactory<t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema>(
      reactionsCreateForTeamDiscussionCommentLegacyParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForTeamDiscussionCommentLegacyBodySchema>(
      reactionsCreateForTeamDiscussionCommentLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForTeamDiscussionCommentLegacyParamSchema,
        void,
        t_ReactionsCreateForTeamDiscussionCommentLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsCreateForTeamDiscussionCommentLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsListForTeamDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const reactionsListForTeamDiscussionLegacyQuerySchema = z.object({
    content: z
      .enum([
        "+1",
        "-1",
        "laugh",
        "confused",
        "heart",
        "hooray",
        "rocket",
        "eyes",
      ])
      .optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reactionsListForTeamDiscussionLegacy",
    "/teams/:teamId/discussions/:discussionNumber/reactions",
    paramValidationFactory<t_ReactionsListForTeamDiscussionLegacyParamSchema>(
      reactionsListForTeamDiscussionLegacyParamSchema
    ),
    queryValidationFactory<t_ReactionsListForTeamDiscussionLegacyQuerySchema>(
      reactionsListForTeamDiscussionLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsListForTeamDiscussionLegacyParamSchema,
        t_ReactionsListForTeamDiscussionLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsListForTeamDiscussionLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reactionsCreateForTeamDiscussionLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    discussion_number: z.coerce.number(),
  })

  const reactionsCreateForTeamDiscussionLegacyBodySchema = z.object({
    content: z.enum([
      "+1",
      "-1",
      "laugh",
      "confused",
      "heart",
      "hooray",
      "rocket",
      "eyes",
    ]),
  })

  router.post(
    "reactionsCreateForTeamDiscussionLegacy",
    "/teams/:teamId/discussions/:discussionNumber/reactions",
    paramValidationFactory<t_ReactionsCreateForTeamDiscussionLegacyParamSchema>(
      reactionsCreateForTeamDiscussionLegacyParamSchema
    ),
    bodyValidationFactory<t_ReactionsCreateForTeamDiscussionLegacyBodySchema>(
      reactionsCreateForTeamDiscussionLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReactionsCreateForTeamDiscussionLegacyParamSchema,
        void,
        t_ReactionsCreateForTeamDiscussionLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reactionsCreateForTeamDiscussionLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListPendingInvitationsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListPendingInvitationsLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListPendingInvitationsLegacy",
    "/teams/:teamId/invitations",
    paramValidationFactory<t_TeamsListPendingInvitationsLegacyParamSchema>(
      teamsListPendingInvitationsLegacyParamSchema
    ),
    queryValidationFactory<t_TeamsListPendingInvitationsLegacyQuerySchema>(
      teamsListPendingInvitationsLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListPendingInvitationsLegacyParamSchema,
        t_TeamsListPendingInvitationsLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsListPendingInvitationsLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListMembersLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListMembersLegacyQuerySchema = z.object({
    role: z.enum(["member", "maintainer", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListMembersLegacy",
    "/teams/:teamId/members",
    paramValidationFactory<t_TeamsListMembersLegacyParamSchema>(
      teamsListMembersLegacyParamSchema
    ),
    queryValidationFactory<t_TeamsListMembersLegacyQuerySchema>(
      teamsListMembersLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListMembersLegacyParamSchema,
        t_TeamsListMembersLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListMembersLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.get(
    "teamsGetMemberLegacy",
    "/teams/:teamId/members/:username",
    paramValidationFactory<t_TeamsGetMemberLegacyParamSchema>(
      teamsGetMemberLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsGetMemberLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsGetMemberLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsAddMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.put(
    "teamsAddMemberLegacy",
    "/teams/:teamId/members/:username",
    paramValidationFactory<t_TeamsAddMemberLegacyParamSchema>(
      teamsAddMemberLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsAddMemberLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsAddMemberLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsRemoveMemberLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.delete(
    "teamsRemoveMemberLegacy",
    "/teams/:teamId/members/:username",
    paramValidationFactory<t_TeamsRemoveMemberLegacyParamSchema>(
      teamsRemoveMemberLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsRemoveMemberLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsRemoveMemberLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsGetMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.get(
    "teamsGetMembershipForUserLegacy",
    "/teams/:teamId/memberships/:username",
    paramValidationFactory<t_TeamsGetMembershipForUserLegacyParamSchema>(
      teamsGetMembershipForUserLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsGetMembershipForUserLegacyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsGetMembershipForUserLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsAddOrUpdateMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  const teamsAddOrUpdateMembershipForUserLegacyBodySchema = z
    .object({ role: z.enum(["member", "maintainer"]).optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateMembershipForUserLegacy",
    "/teams/:teamId/memberships/:username",
    paramValidationFactory<t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema>(
      teamsAddOrUpdateMembershipForUserLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsAddOrUpdateMembershipForUserLegacyBodySchema>(
      teamsAddOrUpdateMembershipForUserLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsAddOrUpdateMembershipForUserLegacyParamSchema,
        void,
        t_TeamsAddOrUpdateMembershipForUserLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsAddOrUpdateMembershipForUserLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsRemoveMembershipForUserLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.delete(
    "teamsRemoveMembershipForUserLegacy",
    "/teams/:teamId/memberships/:username",
    paramValidationFactory<t_TeamsRemoveMembershipForUserLegacyParamSchema>(
      teamsRemoveMembershipForUserLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsRemoveMembershipForUserLegacyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsRemoveMembershipForUserLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListProjectsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListProjectsLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListProjectsLegacy",
    "/teams/:teamId/projects",
    paramValidationFactory<t_TeamsListProjectsLegacyParamSchema>(
      teamsListProjectsLegacyParamSchema
    ),
    queryValidationFactory<t_TeamsListProjectsLegacyQuerySchema>(
      teamsListProjectsLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListProjectsLegacyParamSchema,
        t_TeamsListProjectsLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListProjectsLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCheckPermissionsForProjectLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  router.get(
    "teamsCheckPermissionsForProjectLegacy",
    "/teams/:teamId/projects/:projectId",
    paramValidationFactory<t_TeamsCheckPermissionsForProjectLegacyParamSchema>(
      teamsCheckPermissionsForProjectLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCheckPermissionsForProjectLegacyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsCheckPermissionsForProjectLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsAddOrUpdateProjectPermissionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  const teamsAddOrUpdateProjectPermissionsLegacyBodySchema = z
    .object({ permission: z.enum(["read", "write", "admin"]).optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateProjectPermissionsLegacy",
    "/teams/:teamId/projects/:projectId",
    paramValidationFactory<t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema>(
      teamsAddOrUpdateProjectPermissionsLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsAddOrUpdateProjectPermissionsLegacyBodySchema>(
      teamsAddOrUpdateProjectPermissionsLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsAddOrUpdateProjectPermissionsLegacyParamSchema,
        void,
        t_TeamsAddOrUpdateProjectPermissionsLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsAddOrUpdateProjectPermissionsLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsRemoveProjectLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    project_id: z.coerce.number(),
  })

  router.delete(
    "teamsRemoveProjectLegacy",
    "/teams/:teamId/projects/:projectId",
    paramValidationFactory<t_TeamsRemoveProjectLegacyParamSchema>(
      teamsRemoveProjectLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsRemoveProjectLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsRemoveProjectLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListReposLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListReposLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListReposLegacy",
    "/teams/:teamId/repos",
    paramValidationFactory<t_TeamsListReposLegacyParamSchema>(
      teamsListReposLegacyParamSchema
    ),
    queryValidationFactory<t_TeamsListReposLegacyQuerySchema>(
      teamsListReposLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListReposLegacyParamSchema,
        t_TeamsListReposLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListReposLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsCheckPermissionsForRepoLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "teamsCheckPermissionsForRepoLegacy",
    "/teams/:teamId/repos/:owner/:repo",
    paramValidationFactory<t_TeamsCheckPermissionsForRepoLegacyParamSchema>(
      teamsCheckPermissionsForRepoLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsCheckPermissionsForRepoLegacyParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsCheckPermissionsForRepoLegacy(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsAddOrUpdateRepoPermissionsLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  const teamsAddOrUpdateRepoPermissionsLegacyBodySchema = z
    .object({ permission: z.enum(["pull", "push", "admin"]).optional() })
    .optional()

  router.put(
    "teamsAddOrUpdateRepoPermissionsLegacy",
    "/teams/:teamId/repos/:owner/:repo",
    paramValidationFactory<t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema>(
      teamsAddOrUpdateRepoPermissionsLegacyParamSchema
    ),
    bodyValidationFactory<t_TeamsAddOrUpdateRepoPermissionsLegacyBodySchema>(
      teamsAddOrUpdateRepoPermissionsLegacyBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsAddOrUpdateRepoPermissionsLegacyParamSchema,
        void,
        t_TeamsAddOrUpdateRepoPermissionsLegacyBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsAddOrUpdateRepoPermissionsLegacy(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsRemoveRepoLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "teamsRemoveRepoLegacy",
    "/teams/:teamId/repos/:owner/:repo",
    paramValidationFactory<t_TeamsRemoveRepoLegacyParamSchema>(
      teamsRemoveRepoLegacyParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_TeamsRemoveRepoLegacyParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsRemoveRepoLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListChildLegacyParamSchema = z.object({
    team_id: z.coerce.number(),
  })

  const teamsListChildLegacyQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListChildLegacy",
    "/teams/:teamId/teams",
    paramValidationFactory<t_TeamsListChildLegacyParamSchema>(
      teamsListChildLegacyParamSchema
    ),
    queryValidationFactory<t_TeamsListChildLegacyQuerySchema>(
      teamsListChildLegacyQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_TeamsListChildLegacyParamSchema,
        t_TeamsListChildLegacyQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.teamsListChildLegacy(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "usersGetAuthenticated",
    "/user",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.usersGetAuthenticated(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersUpdateAuthenticatedBodySchema = z
    .object({
      name: z.coerce.string().optional(),
      email: z.coerce.string().optional(),
      blog: z.coerce.string().optional(),
      twitter_username: z.coerce.string().optional(),
      company: z.coerce.string().optional(),
      location: z.coerce.string().optional(),
      hireable: z.coerce.boolean().optional(),
      bio: z.coerce.string().optional(),
    })
    .optional()

  router.patch(
    "usersUpdateAuthenticated",
    "/user",
    bodyValidationFactory<t_UsersUpdateAuthenticatedBodySchema>(
      usersUpdateAuthenticatedBodySchema
    ),
    async (
      ctx: ValidatedCtx<void, void, t_UsersUpdateAuthenticatedBodySchema>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersUpdateAuthenticated(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListBlockedByAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListBlockedByAuthenticatedUser",
    "/user/blocks",
    queryValidationFactory<t_UsersListBlockedByAuthenticatedUserQuerySchema>(
      usersListBlockedByAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListBlockedByAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListBlockedByAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersCheckBlockedParamSchema = z.object({ username: z.coerce.string() })

  router.get(
    "usersCheckBlocked",
    "/user/blocks/:username",
    paramValidationFactory<t_UsersCheckBlockedParamSchema>(
      usersCheckBlockedParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_UsersCheckBlockedParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersCheckBlocked(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersBlockParamSchema = z.object({ username: z.coerce.string() })

  router.put(
    "usersBlock",
    "/user/blocks/:username",
    paramValidationFactory<t_UsersBlockParamSchema>(usersBlockParamSchema),
    async (
      ctx: ValidatedCtx<t_UsersBlockParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersBlock(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersUnblockParamSchema = z.object({ username: z.coerce.string() })

  router.delete(
    "usersUnblock",
    "/user/blocks/:username",
    paramValidationFactory<t_UsersUnblockParamSchema>(usersUnblockParamSchema),
    async (
      ctx: ValidatedCtx<t_UsersUnblockParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersUnblock(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    repository_id: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListForAuthenticatedUser",
    "/user/codespaces",
    queryValidationFactory<t_CodespacesListForAuthenticatedUserQuerySchema>(
      codespacesListForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_CodespacesListForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesListForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesCreateForAuthenticatedUserBodySchema = z.union([
    z.object({
      repository_id: z.coerce.number(),
      ref: z.coerce.string().optional(),
      location: z.coerce.string().optional(),
      client_ip: z.coerce.string().optional(),
      machine: z.coerce.string().optional(),
      devcontainer_path: z.coerce.string().optional(),
      multi_repo_permissions_opt_out: z.coerce.boolean().optional(),
      working_directory: z.coerce.string().optional(),
      idle_timeout_minutes: z.coerce.number().optional(),
      display_name: z.coerce.string().optional(),
      retention_period_minutes: z.coerce.number().optional(),
    }),
    z.object({
      pull_request: z.object({
        pull_request_number: z.coerce.number(),
        repository_id: z.coerce.number(),
      }),
      location: z.coerce.string().optional(),
      machine: z.coerce.string().optional(),
      devcontainer_path: z.coerce.string().optional(),
      working_directory: z.coerce.string().optional(),
      idle_timeout_minutes: z.coerce.number().optional(),
    }),
  ])

  router.post(
    "codespacesCreateForAuthenticatedUser",
    "/user/codespaces",
    bodyValidationFactory<t_CodespacesCreateForAuthenticatedUserBodySchema>(
      codespacesCreateForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_CodespacesCreateForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesCreateForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListSecretsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "codespacesListSecretsForAuthenticatedUser",
    "/user/codespaces/secrets",
    queryValidationFactory<t_CodespacesListSecretsForAuthenticatedUserQuerySchema>(
      codespacesListSecretsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_CodespacesListSecretsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesListSecretsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "codespacesGetPublicKeyForAuthenticatedUser",
    "/user/codespaces/secrets/public-key",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } =
        await implementation.codespacesGetPublicKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetSecretForAuthenticatedUserParamSchema = z.object({
    secret_name: z.coerce.string(),
  })

  router.get(
    "codespacesGetSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesGetSecretForAuthenticatedUserParamSchema>(
      codespacesGetSecretForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesGetSecretForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesGetSecretForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.coerce.string() })

  const codespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema = z.object(
    {
      encrypted_value: z.coerce.string().optional(),
      key_id: z.coerce.string(),
      selected_repository_ids: z.array(z.coerce.string()).optional(),
    }
  )

  router.put(
    "codespacesCreateOrUpdateSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema>(
      codespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema
    ),
    bodyValidationFactory<t_CodespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema>(
      codespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesCreateOrUpdateSecretForAuthenticatedUserParamSchema,
        void,
        t_CodespacesCreateOrUpdateSecretForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesCreateOrUpdateSecretForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesDeleteSecretForAuthenticatedUserParamSchema = z.object({
    secret_name: z.coerce.string(),
  })

  router.delete(
    "codespacesDeleteSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secretName",
    paramValidationFactory<t_CodespacesDeleteSecretForAuthenticatedUserParamSchema>(
      codespacesDeleteSecretForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesDeleteSecretForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesDeleteSecretForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesListRepositoriesForSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.coerce.string() })

  router.get(
    "codespacesListRepositoriesForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secretName/repositories",
    paramValidationFactory<t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema>(
      codespacesListRepositoriesForSecretForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesListRepositoriesForSecretForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesListRepositoriesForSecretForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema =
    z.object({ secret_name: z.coerce.string() })

  const codespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema =
    z.object({ selected_repository_ids: z.array(z.coerce.number()) })

  router.put(
    "codespacesSetRepositoriesForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secretName/repositories",
    paramValidationFactory<t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema>(
      codespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema
    ),
    bodyValidationFactory<t_CodespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema>(
      codespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesSetRepositoriesForSecretForAuthenticatedUserParamSchema,
        void,
        t_CodespacesSetRepositoriesForSecretForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesSetRepositoriesForSecretForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesAddRepositoryForSecretForAuthenticatedUserParamSchema =
    z.object({
      secret_name: z.coerce.string(),
      repository_id: z.coerce.number(),
    })

  router.put(
    "codespacesAddRepositoryForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema>(
      codespacesAddRepositoryForSecretForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesAddRepositoryForSecretForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesAddRepositoryForSecretForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema =
    z.object({
      secret_name: z.coerce.string(),
      repository_id: z.coerce.number(),
    })

  router.delete(
    "codespacesRemoveRepositoryForSecretForAuthenticatedUser",
    "/user/codespaces/secrets/:secretName/repositories/:repositoryId",
    paramValidationFactory<t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema>(
      codespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesRemoveRepositoryForSecretForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesRemoveRepositoryForSecretForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  router.get(
    "codespacesGetForAuthenticatedUser",
    "/user/codespaces/:codespaceName",
    paramValidationFactory<t_CodespacesGetForAuthenticatedUserParamSchema>(
      codespacesGetForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesGetForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesGetForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesUpdateForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  const codespacesUpdateForAuthenticatedUserBodySchema = z
    .object({
      machine: z.coerce.string().optional(),
      display_name: z.coerce.string().optional(),
      recent_folders: z.array(z.coerce.string()).optional(),
    })
    .optional()

  router.patch(
    "codespacesUpdateForAuthenticatedUser",
    "/user/codespaces/:codespaceName",
    paramValidationFactory<t_CodespacesUpdateForAuthenticatedUserParamSchema>(
      codespacesUpdateForAuthenticatedUserParamSchema
    ),
    bodyValidationFactory<t_CodespacesUpdateForAuthenticatedUserBodySchema>(
      codespacesUpdateForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesUpdateForAuthenticatedUserParamSchema,
        void,
        t_CodespacesUpdateForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesUpdateForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesDeleteForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  router.delete(
    "codespacesDeleteForAuthenticatedUser",
    "/user/codespaces/:codespaceName",
    paramValidationFactory<t_CodespacesDeleteForAuthenticatedUserParamSchema>(
      codespacesDeleteForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesDeleteForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesDeleteForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesExportForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  router.post(
    "codespacesExportForAuthenticatedUser",
    "/user/codespaces/:codespaceName/exports",
    paramValidationFactory<t_CodespacesExportForAuthenticatedUserParamSchema>(
      codespacesExportForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesExportForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesExportForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesGetExportDetailsForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
    export_id: z.coerce.string(),
  })

  router.get(
    "codespacesGetExportDetailsForAuthenticatedUser",
    "/user/codespaces/:codespaceName/exports/:exportId",
    paramValidationFactory<t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema>(
      codespacesGetExportDetailsForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesGetExportDetailsForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesGetExportDetailsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesCodespaceMachinesForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  router.get(
    "codespacesCodespaceMachinesForAuthenticatedUser",
    "/user/codespaces/:codespaceName/machines",
    paramValidationFactory<t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema>(
      codespacesCodespaceMachinesForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesCodespaceMachinesForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesCodespaceMachinesForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesPublishForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  const codespacesPublishForAuthenticatedUserBodySchema = z.object({
    name: z.coerce.string().optional(),
    private: z.coerce.boolean().optional(),
  })

  router.post(
    "codespacesPublishForAuthenticatedUser",
    "/user/codespaces/:codespaceName/publish",
    paramValidationFactory<t_CodespacesPublishForAuthenticatedUserParamSchema>(
      codespacesPublishForAuthenticatedUserParamSchema
    ),
    bodyValidationFactory<t_CodespacesPublishForAuthenticatedUserBodySchema>(
      codespacesPublishForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesPublishForAuthenticatedUserParamSchema,
        void,
        t_CodespacesPublishForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesPublishForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesStartForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  router.post(
    "codespacesStartForAuthenticatedUser",
    "/user/codespaces/:codespaceName/start",
    paramValidationFactory<t_CodespacesStartForAuthenticatedUserParamSchema>(
      codespacesStartForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesStartForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesStartForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const codespacesStopForAuthenticatedUserParamSchema = z.object({
    codespace_name: z.coerce.string(),
  })

  router.post(
    "codespacesStopForAuthenticatedUser",
    "/user/codespaces/:codespaceName/stop",
    paramValidationFactory<t_CodespacesStopForAuthenticatedUserParamSchema>(
      codespacesStopForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_CodespacesStopForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.codespacesStopForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema = z.object(
    { visibility: z.enum(["public", "private"]) }
  )

  router.patch(
    "usersSetPrimaryEmailVisibilityForAuthenticatedUser",
    "/user/email/visibility",
    bodyValidationFactory<t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema>(
      usersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersSetPrimaryEmailVisibilityForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListEmailsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListEmailsForAuthenticatedUser",
    "/user/emails",
    queryValidationFactory<t_UsersListEmailsForAuthenticatedUserQuerySchema>(
      usersListEmailsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListEmailsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListEmailsForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersAddEmailForAuthenticatedUserBodySchema = z.union([
    z.object({ emails: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
    z.coerce.string(),
  ])

  router.post(
    "usersAddEmailForAuthenticatedUser",
    "/user/emails",
    bodyValidationFactory<t_UsersAddEmailForAuthenticatedUserBodySchema>(
      usersAddEmailForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_UsersAddEmailForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersAddEmailForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersDeleteEmailForAuthenticatedUserBodySchema = z.union([
    z.object({ emails: z.array(z.coerce.string()) }),
    z.array(z.coerce.string()),
    z.coerce.string(),
  ])

  router.delete(
    "usersDeleteEmailForAuthenticatedUser",
    "/user/emails",
    bodyValidationFactory<t_UsersDeleteEmailForAuthenticatedUserBodySchema>(
      usersDeleteEmailForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_UsersDeleteEmailForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersDeleteEmailForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListFollowersForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListFollowersForAuthenticatedUser",
    "/user/followers",
    queryValidationFactory<t_UsersListFollowersForAuthenticatedUserQuerySchema>(
      usersListFollowersForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListFollowersForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListFollowersForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListFollowedByAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListFollowedByAuthenticatedUser",
    "/user/following",
    queryValidationFactory<t_UsersListFollowedByAuthenticatedUserQuerySchema>(
      usersListFollowedByAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListFollowedByAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListFollowedByAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersCheckPersonIsFollowedByAuthenticatedParamSchema = z.object({
    username: z.coerce.string(),
  })

  router.get(
    "usersCheckPersonIsFollowedByAuthenticated",
    "/user/following/:username",
    paramValidationFactory<t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema>(
      usersCheckPersonIsFollowedByAuthenticatedParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersCheckPersonIsFollowedByAuthenticatedParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersCheckPersonIsFollowedByAuthenticated(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersFollowParamSchema = z.object({ username: z.coerce.string() })

  router.put(
    "usersFollow",
    "/user/following/:username",
    paramValidationFactory<t_UsersFollowParamSchema>(usersFollowParamSchema),
    async (
      ctx: ValidatedCtx<t_UsersFollowParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersFollow(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersUnfollowParamSchema = z.object({ username: z.coerce.string() })

  router.delete(
    "usersUnfollow",
    "/user/following/:username",
    paramValidationFactory<t_UsersUnfollowParamSchema>(
      usersUnfollowParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_UsersUnfollowParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersUnfollow(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListGpgKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListGpgKeysForAuthenticatedUser",
    "/user/gpg_keys",
    queryValidationFactory<t_UsersListGpgKeysForAuthenticatedUserQuerySchema>(
      usersListGpgKeysForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListGpgKeysForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListGpgKeysForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersCreateGpgKeyForAuthenticatedUserBodySchema = z.object({
    name: z.coerce.string().optional(),
    armored_public_key: z.coerce.string(),
  })

  router.post(
    "usersCreateGpgKeyForAuthenticatedUser",
    "/user/gpg_keys",
    bodyValidationFactory<t_UsersCreateGpgKeyForAuthenticatedUserBodySchema>(
      usersCreateGpgKeyForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_UsersCreateGpgKeyForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersCreateGpgKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersGetGpgKeyForAuthenticatedUserParamSchema = z.object({
    gpg_key_id: z.coerce.number(),
  })

  router.get(
    "usersGetGpgKeyForAuthenticatedUser",
    "/user/gpg_keys/:gpgKeyId",
    paramValidationFactory<t_UsersGetGpgKeyForAuthenticatedUserParamSchema>(
      usersGetGpgKeyForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersGetGpgKeyForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersGetGpgKeyForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersDeleteGpgKeyForAuthenticatedUserParamSchema = z.object({
    gpg_key_id: z.coerce.number(),
  })

  router.delete(
    "usersDeleteGpgKeyForAuthenticatedUser",
    "/user/gpg_keys/:gpgKeyId",
    paramValidationFactory<t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema>(
      usersDeleteGpgKeyForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersDeleteGpgKeyForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersDeleteGpgKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListInstallationsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListInstallationsForAuthenticatedUser",
    "/user/installations",
    queryValidationFactory<t_AppsListInstallationsForAuthenticatedUserQuerySchema>(
      appsListInstallationsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_AppsListInstallationsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsListInstallationsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListInstallationReposForAuthenticatedUserParamSchema = z.object({
    installation_id: z.coerce.number(),
  })

  const appsListInstallationReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListInstallationReposForAuthenticatedUser",
    "/user/installations/:installationId/repositories",
    paramValidationFactory<t_AppsListInstallationReposForAuthenticatedUserParamSchema>(
      appsListInstallationReposForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_AppsListInstallationReposForAuthenticatedUserQuerySchema>(
      appsListInstallationReposForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsListInstallationReposForAuthenticatedUserParamSchema,
        t_AppsListInstallationReposForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsListInstallationReposForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsAddRepoToInstallationForAuthenticatedUserParamSchema = z.object({
    installation_id: z.coerce.number(),
    repository_id: z.coerce.number(),
  })

  router.put(
    "appsAddRepoToInstallationForAuthenticatedUser",
    "/user/installations/:installationId/repositories/:repositoryId",
    paramValidationFactory<t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema>(
      appsAddRepoToInstallationForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsAddRepoToInstallationForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsAddRepoToInstallationForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsRemoveRepoFromInstallationForAuthenticatedUserParamSchema =
    z.object({
      installation_id: z.coerce.number(),
      repository_id: z.coerce.number(),
    })

  router.delete(
    "appsRemoveRepoFromInstallationForAuthenticatedUser",
    "/user/installations/:installationId/repositories/:repositoryId",
    paramValidationFactory<t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema>(
      appsRemoveRepoFromInstallationForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_AppsRemoveRepoFromInstallationForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsRemoveRepoFromInstallationForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "interactionsGetRestrictionsForAuthenticatedUser",
    "/user/interaction-limits",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } =
        await implementation.interactionsGetRestrictionsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const interactionsSetRestrictionsForAuthenticatedUserBodySchema = z.object({
    limit: z.enum([
      "existing_users",
      "contributors_only",
      "collaborators_only",
    ]),
    expiry: z
      .enum(["one_day", "three_days", "one_week", "one_month", "six_months"])
      .optional(),
  })

  router.put(
    "interactionsSetRestrictionsForAuthenticatedUser",
    "/user/interaction-limits",
    bodyValidationFactory<t_InteractionsSetRestrictionsForAuthenticatedUserBodySchema>(
      interactionsSetRestrictionsForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_InteractionsSetRestrictionsForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.interactionsSetRestrictionsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.delete(
    "interactionsRemoveRestrictionsForAuthenticatedUser",
    "/user/interaction-limits",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } =
        await implementation.interactionsRemoveRestrictionsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const issuesListForAuthenticatedUserQuerySchema = z.object({
    filter: z
      .enum(["assigned", "created", "mentioned", "subscribed", "repos", "all"])
      .optional(),
    state: z.enum(["open", "closed", "all"]).optional(),
    labels: z.coerce.string().optional(),
    sort: z.enum(["created", "updated", "comments"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "issuesListForAuthenticatedUser",
    "/user/issues",
    queryValidationFactory<t_IssuesListForAuthenticatedUserQuerySchema>(
      issuesListForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_IssuesListForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.issuesListForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListPublicSshKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListPublicSshKeysForAuthenticatedUser",
    "/user/keys",
    queryValidationFactory<t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema>(
      usersListPublicSshKeysForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListPublicSshKeysForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListPublicSshKeysForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersCreatePublicSshKeyForAuthenticatedUserBodySchema = z.object({
    title: z.coerce.string().optional(),
    key: z.coerce.string(),
  })

  router.post(
    "usersCreatePublicSshKeyForAuthenticatedUser",
    "/user/keys",
    bodyValidationFactory<t_UsersCreatePublicSshKeyForAuthenticatedUserBodySchema>(
      usersCreatePublicSshKeyForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_UsersCreatePublicSshKeyForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersCreatePublicSshKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersGetPublicSshKeyForAuthenticatedUserParamSchema = z.object({
    key_id: z.coerce.number(),
  })

  router.get(
    "usersGetPublicSshKeyForAuthenticatedUser",
    "/user/keys/:keyId",
    paramValidationFactory<t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema>(
      usersGetPublicSshKeyForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersGetPublicSshKeyForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersGetPublicSshKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersDeletePublicSshKeyForAuthenticatedUserParamSchema = z.object({
    key_id: z.coerce.number(),
  })

  router.delete(
    "usersDeletePublicSshKeyForAuthenticatedUser",
    "/user/keys/:keyId",
    paramValidationFactory<t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema>(
      usersDeletePublicSshKeyForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersDeletePublicSshKeyForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersDeletePublicSshKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListSubscriptionsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListSubscriptionsForAuthenticatedUser",
    "/user/marketplace_purchases",
    queryValidationFactory<t_AppsListSubscriptionsForAuthenticatedUserQuerySchema>(
      appsListSubscriptionsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_AppsListSubscriptionsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsListSubscriptionsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsListSubscriptionsForAuthenticatedUserStubbedQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "appsListSubscriptionsForAuthenticatedUserStubbed",
    "/user/marketplace_purchases/stubbed",
    queryValidationFactory<t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema>(
      appsListSubscriptionsForAuthenticatedUserStubbedQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_AppsListSubscriptionsForAuthenticatedUserStubbedQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.appsListSubscriptionsForAuthenticatedUserStubbed(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListMembershipsForAuthenticatedUserQuerySchema = z.object({
    state: z.enum(["active", "pending"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListMembershipsForAuthenticatedUser",
    "/user/memberships/orgs",
    queryValidationFactory<t_OrgsListMembershipsForAuthenticatedUserQuerySchema>(
      orgsListMembershipsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_OrgsListMembershipsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsListMembershipsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsGetMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.coerce.string(),
  })

  router.get(
    "orgsGetMembershipForAuthenticatedUser",
    "/user/memberships/orgs/:org",
    paramValidationFactory<t_OrgsGetMembershipForAuthenticatedUserParamSchema>(
      orgsGetMembershipForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsGetMembershipForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsGetMembershipForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsUpdateMembershipForAuthenticatedUserParamSchema = z.object({
    org: z.coerce.string(),
  })

  const orgsUpdateMembershipForAuthenticatedUserBodySchema = z.object({
    state: z.enum(["active"]),
  })

  router.patch(
    "orgsUpdateMembershipForAuthenticatedUser",
    "/user/memberships/orgs/:org",
    paramValidationFactory<t_OrgsUpdateMembershipForAuthenticatedUserParamSchema>(
      orgsUpdateMembershipForAuthenticatedUserParamSchema
    ),
    bodyValidationFactory<t_OrgsUpdateMembershipForAuthenticatedUserBodySchema>(
      orgsUpdateMembershipForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsUpdateMembershipForAuthenticatedUserParamSchema,
        void,
        t_OrgsUpdateMembershipForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsUpdateMembershipForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "migrationsListForAuthenticatedUser",
    "/user/migrations",
    queryValidationFactory<t_MigrationsListForAuthenticatedUserQuerySchema>(
      migrationsListForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_MigrationsListForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsListForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsStartForAuthenticatedUserBodySchema = z.object({
    lock_repositories: z.coerce.boolean().optional(),
    exclude_metadata: z.coerce.boolean().optional(),
    exclude_git_data: z.coerce.boolean().optional(),
    exclude_attachments: z.coerce.boolean().optional(),
    exclude_releases: z.coerce.boolean().optional(),
    exclude_owner_projects: z.coerce.boolean().optional(),
    org_metadata_only: z.coerce.boolean().optional(),
    exclude: z.array(z.enum(["repositories"])).optional(),
    repositories: z.array(z.coerce.string()),
  })

  router.post(
    "migrationsStartForAuthenticatedUser",
    "/user/migrations",
    bodyValidationFactory<t_MigrationsStartForAuthenticatedUserBodySchema>(
      migrationsStartForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_MigrationsStartForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsStartForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsGetStatusForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsGetStatusForAuthenticatedUserQuerySchema = z.object({
    exclude: z.array(z.coerce.string()).optional(),
  })

  router.get(
    "migrationsGetStatusForAuthenticatedUser",
    "/user/migrations/:migrationId",
    paramValidationFactory<t_MigrationsGetStatusForAuthenticatedUserParamSchema>(
      migrationsGetStatusForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_MigrationsGetStatusForAuthenticatedUserQuerySchema>(
      migrationsGetStatusForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsGetStatusForAuthenticatedUserParamSchema,
        t_MigrationsGetStatusForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsGetStatusForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsGetArchiveForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  router.get(
    "migrationsGetArchiveForAuthenticatedUser",
    "/user/migrations/:migrationId/archive",
    paramValidationFactory<t_MigrationsGetArchiveForAuthenticatedUserParamSchema>(
      migrationsGetArchiveForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsGetArchiveForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsGetArchiveForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsDeleteArchiveForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  router.delete(
    "migrationsDeleteArchiveForAuthenticatedUser",
    "/user/migrations/:migrationId/archive",
    paramValidationFactory<t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema>(
      migrationsDeleteArchiveForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsDeleteArchiveForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsDeleteArchiveForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsUnlockRepoForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
    repo_name: z.coerce.string(),
  })

  router.delete(
    "migrationsUnlockRepoForAuthenticatedUser",
    "/user/migrations/:migrationId/repos/:repoName/lock",
    paramValidationFactory<t_MigrationsUnlockRepoForAuthenticatedUserParamSchema>(
      migrationsUnlockRepoForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsUnlockRepoForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsUnlockRepoForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const migrationsListReposForAuthenticatedUserParamSchema = z.object({
    migration_id: z.coerce.number(),
  })

  const migrationsListReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "migrationsListReposForAuthenticatedUser",
    "/user/migrations/:migrationId/repositories",
    paramValidationFactory<t_MigrationsListReposForAuthenticatedUserParamSchema>(
      migrationsListReposForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_MigrationsListReposForAuthenticatedUserQuerySchema>(
      migrationsListReposForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_MigrationsListReposForAuthenticatedUserParamSchema,
        t_MigrationsListReposForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.migrationsListReposForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListForAuthenticatedUser",
    "/user/orgs",
    queryValidationFactory<t_OrgsListForAuthenticatedUserQuerySchema>(
      orgsListForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_OrgsListForAuthenticatedUserQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.orgsListForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesListPackagesForAuthenticatedUserQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
  })

  router.get(
    "packagesListPackagesForAuthenticatedUser",
    "/user/packages",
    queryValidationFactory<t_PackagesListPackagesForAuthenticatedUserQuerySchema>(
      packagesListPackagesForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_PackagesListPackagesForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesListPackagesForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetPackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
  })

  router.get(
    "packagesGetPackageForAuthenticatedUser",
    "/user/packages/:packageType/:packageName",
    paramValidationFactory<t_PackagesGetPackageForAuthenticatedUserParamSchema>(
      packagesGetPackageForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetPackageForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetPackageForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesDeletePackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
  })

  router.delete(
    "packagesDeletePackageForAuthenticatedUser",
    "/user/packages/:packageType/:packageName",
    paramValidationFactory<t_PackagesDeletePackageForAuthenticatedUserParamSchema>(
      packagesDeletePackageForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesDeletePackageForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesDeletePackageForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesRestorePackageForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
  })

  const packagesRestorePackageForAuthenticatedUserQuerySchema = z.object({
    token: z.coerce.string().optional(),
  })

  router.post(
    "packagesRestorePackageForAuthenticatedUser",
    "/user/packages/:packageType/:packageName/restore",
    paramValidationFactory<t_PackagesRestorePackageForAuthenticatedUserParamSchema>(
      packagesRestorePackageForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_PackagesRestorePackageForAuthenticatedUserQuerySchema>(
      packagesRestorePackageForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesRestorePackageForAuthenticatedUserParamSchema,
        t_PackagesRestorePackageForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesRestorePackageForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema =
    z.object({
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.coerce.string(),
    })

  const packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema =
    z.object({
      page: z.coerce.number().optional(),
      per_page: z.coerce.number().optional(),
      state: z.enum(["active", "deleted"]).optional(),
    })

  router.get(
    "packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
    "/user/packages/:packageType/:packageName/versions",
    paramValidationFactory<t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema>(
      packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema>(
      packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamSchema,
        t_PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetPackageVersionForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    package_version_id: z.coerce.number(),
  })

  router.get(
    "packagesGetPackageVersionForAuthenticatedUser",
    "/user/packages/:packageType/:packageName/versions/:packageVersionId",
    paramValidationFactory<t_PackagesGetPackageVersionForAuthenticatedUserParamSchema>(
      packagesGetPackageVersionForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetPackageVersionForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetPackageVersionForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesDeletePackageVersionForAuthenticatedUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    package_version_id: z.coerce.number(),
  })

  router.delete(
    "packagesDeletePackageVersionForAuthenticatedUser",
    "/user/packages/:packageType/:packageName/versions/:packageVersionId",
    paramValidationFactory<t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema>(
      packagesDeletePackageVersionForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesDeletePackageVersionForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesDeletePackageVersionForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesRestorePackageVersionForAuthenticatedUserParamSchema = z.object(
    {
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.coerce.string(),
      package_version_id: z.coerce.number(),
    }
  )

  router.post(
    "packagesRestorePackageVersionForAuthenticatedUser",
    "/user/packages/:packageType/:packageName/versions/:packageVersionId/restore",
    paramValidationFactory<t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema>(
      packagesRestorePackageVersionForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesRestorePackageVersionForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesRestorePackageVersionForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsCreateForAuthenticatedUserBodySchema = z.object({
    name: z.coerce.string(),
    body: z.coerce.string().optional(),
  })

  router.post(
    "projectsCreateForAuthenticatedUser",
    "/user/projects",
    bodyValidationFactory<t_ProjectsCreateForAuthenticatedUserBodySchema>(
      projectsCreateForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_ProjectsCreateForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.projectsCreateForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListPublicEmailsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListPublicEmailsForAuthenticatedUser",
    "/user/public_emails",
    queryValidationFactory<t_UsersListPublicEmailsForAuthenticatedUserQuerySchema>(
      usersListPublicEmailsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListPublicEmailsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListPublicEmailsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListForAuthenticatedUserQuerySchema = z.object({
    visibility: z.enum(["all", "public", "private"]).optional(),
    affiliation: z.coerce.string().optional(),
    type: z.enum(["all", "owner", "public", "private", "member"]).optional(),
    sort: z.enum(["created", "updated", "pushed", "full_name"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
    since: z.coerce.string().datetime({ offset: true }).optional(),
    before: z.coerce.string().datetime({ offset: true }).optional(),
  })

  router.get(
    "reposListForAuthenticatedUser",
    "/user/repos",
    queryValidationFactory<t_ReposListForAuthenticatedUserQuerySchema>(
      reposListForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_ReposListForAuthenticatedUserQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposListForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposCreateForAuthenticatedUserBodySchema = z.object({
    name: z.coerce.string(),
    description: z.coerce.string().optional(),
    homepage: z.coerce.string().optional(),
    private: z.coerce.boolean().optional(),
    has_issues: z.coerce.boolean().optional(),
    has_projects: z.coerce.boolean().optional(),
    has_wiki: z.coerce.boolean().optional(),
    has_discussions: z.coerce.boolean().optional(),
    team_id: z.coerce.number().optional(),
    auto_init: z.coerce.boolean().optional(),
    gitignore_template: z.coerce.string().optional(),
    license_template: z.coerce.string().optional(),
    allow_squash_merge: z.coerce.boolean().optional(),
    allow_merge_commit: z.coerce.boolean().optional(),
    allow_rebase_merge: z.coerce.boolean().optional(),
    allow_auto_merge: z.coerce.boolean().optional(),
    delete_branch_on_merge: z.coerce.boolean().optional(),
    squash_merge_commit_title: z
      .enum(["PR_TITLE", "COMMIT_OR_PR_TITLE"])
      .optional(),
    squash_merge_commit_message: z
      .enum(["PR_BODY", "COMMIT_MESSAGES", "BLANK"])
      .optional(),
    merge_commit_title: z.enum(["PR_TITLE", "MERGE_MESSAGE"]).optional(),
    merge_commit_message: z.enum(["PR_BODY", "PR_TITLE", "BLANK"]).optional(),
    has_downloads: z.coerce.boolean().optional(),
    is_template: z.coerce.boolean().optional(),
  })

  router.post(
    "reposCreateForAuthenticatedUser",
    "/user/repos",
    bodyValidationFactory<t_ReposCreateForAuthenticatedUserBodySchema>(
      reposCreateForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_ReposCreateForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposCreateForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListInvitationsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListInvitationsForAuthenticatedUser",
    "/user/repository_invitations",
    queryValidationFactory<t_ReposListInvitationsForAuthenticatedUserQuerySchema>(
      reposListInvitationsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_ReposListInvitationsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposListInvitationsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposAcceptInvitationForAuthenticatedUserParamSchema = z.object({
    invitation_id: z.coerce.number(),
  })

  router.patch(
    "reposAcceptInvitationForAuthenticatedUser",
    "/user/repository_invitations/:invitationId",
    paramValidationFactory<t_ReposAcceptInvitationForAuthenticatedUserParamSchema>(
      reposAcceptInvitationForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposAcceptInvitationForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposAcceptInvitationForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposDeclineInvitationForAuthenticatedUserParamSchema = z.object({
    invitation_id: z.coerce.number(),
  })

  router.delete(
    "reposDeclineInvitationForAuthenticatedUser",
    "/user/repository_invitations/:invitationId",
    paramValidationFactory<t_ReposDeclineInvitationForAuthenticatedUserParamSchema>(
      reposDeclineInvitationForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposDeclineInvitationForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.reposDeclineInvitationForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListSshSigningKeysForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListSshSigningKeysForAuthenticatedUser",
    "/user/ssh_signing_keys",
    queryValidationFactory<t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema>(
      usersListSshSigningKeysForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_UsersListSshSigningKeysForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListSshSigningKeysForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersCreateSshSigningKeyForAuthenticatedUserBodySchema = z.object({
    title: z.coerce.string().optional(),
    key: z.coerce.string(),
  })

  router.post(
    "usersCreateSshSigningKeyForAuthenticatedUser",
    "/user/ssh_signing_keys",
    bodyValidationFactory<t_UsersCreateSshSigningKeyForAuthenticatedUserBodySchema>(
      usersCreateSshSigningKeyForAuthenticatedUserBodySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        void,
        t_UsersCreateSshSigningKeyForAuthenticatedUserBodySchema
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersCreateSshSigningKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersGetSshSigningKeyForAuthenticatedUserParamSchema = z.object({
    ssh_signing_key_id: z.coerce.number(),
  })

  router.get(
    "usersGetSshSigningKeyForAuthenticatedUser",
    "/user/ssh_signing_keys/:sshSigningKeyId",
    paramValidationFactory<t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema>(
      usersGetSshSigningKeyForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersGetSshSigningKeyForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersGetSshSigningKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersDeleteSshSigningKeyForAuthenticatedUserParamSchema = z.object({
    ssh_signing_key_id: z.coerce.number(),
  })

  router.delete(
    "usersDeleteSshSigningKeyForAuthenticatedUser",
    "/user/ssh_signing_keys/:sshSigningKeyId",
    paramValidationFactory<t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema>(
      usersDeleteSshSigningKeyForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersDeleteSshSigningKeyForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersDeleteSshSigningKeyForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListReposStarredByAuthenticatedUserQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListReposStarredByAuthenticatedUser",
    "/user/starred",
    queryValidationFactory<t_ActivityListReposStarredByAuthenticatedUserQuerySchema>(
      activityListReposStarredByAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_ActivityListReposStarredByAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListReposStarredByAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityCheckRepoIsStarredByAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.get(
    "activityCheckRepoIsStarredByAuthenticatedUser",
    "/user/starred/:owner/:repo",
    paramValidationFactory<t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema>(
      activityCheckRepoIsStarredByAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityCheckRepoIsStarredByAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityCheckRepoIsStarredByAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityStarRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.put(
    "activityStarRepoForAuthenticatedUser",
    "/user/starred/:owner/:repo",
    paramValidationFactory<t_ActivityStarRepoForAuthenticatedUserParamSchema>(
      activityStarRepoForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityStarRepoForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityStarRepoForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityUnstarRepoForAuthenticatedUserParamSchema = z.object({
    owner: z.coerce.string(),
    repo: z.coerce.string(),
  })

  router.delete(
    "activityUnstarRepoForAuthenticatedUser",
    "/user/starred/:owner/:repo",
    paramValidationFactory<t_ActivityUnstarRepoForAuthenticatedUserParamSchema>(
      activityUnstarRepoForAuthenticatedUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityUnstarRepoForAuthenticatedUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityUnstarRepoForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListWatchedReposForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListWatchedReposForAuthenticatedUser",
    "/user/subscriptions",
    queryValidationFactory<t_ActivityListWatchedReposForAuthenticatedUserQuerySchema>(
      activityListWatchedReposForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        void,
        t_ActivityListWatchedReposForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListWatchedReposForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const teamsListForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "teamsListForAuthenticatedUser",
    "/user/teams",
    queryValidationFactory<t_TeamsListForAuthenticatedUserQuerySchema>(
      teamsListForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<void, t_TeamsListForAuthenticatedUserQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.teamsListForAuthenticatedUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListQuerySchema = z.object({
    since: z.coerce.number().optional(),
    per_page: z.coerce.number().optional(),
  })

  router.get(
    "usersList",
    "/users",
    queryValidationFactory<t_UsersListQuerySchema>(usersListQuerySchema),
    async (
      ctx: ValidatedCtx<void, t_UsersListQuerySchema, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersList(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersGetByUsernameParamSchema = z.object({
    username: z.coerce.string(),
  })

  router.get(
    "usersGetByUsername",
    "/users/:username",
    paramValidationFactory<t_UsersGetByUsernameParamSchema>(
      usersGetByUsernameParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_UsersGetByUsernameParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersGetByUsername(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListEventsForAuthenticatedUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const activityListEventsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListEventsForAuthenticatedUser",
    "/users/:username/events",
    paramValidationFactory<t_ActivityListEventsForAuthenticatedUserParamSchema>(
      activityListEventsForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_ActivityListEventsForAuthenticatedUserQuerySchema>(
      activityListEventsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListEventsForAuthenticatedUserParamSchema,
        t_ActivityListEventsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListEventsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListOrgEventsForAuthenticatedUserParamSchema = z.object({
    username: z.coerce.string(),
    org: z.coerce.string(),
  })

  const activityListOrgEventsForAuthenticatedUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListOrgEventsForAuthenticatedUser",
    "/users/:username/events/orgs/:org",
    paramValidationFactory<t_ActivityListOrgEventsForAuthenticatedUserParamSchema>(
      activityListOrgEventsForAuthenticatedUserParamSchema
    ),
    queryValidationFactory<t_ActivityListOrgEventsForAuthenticatedUserQuerySchema>(
      activityListOrgEventsForAuthenticatedUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListOrgEventsForAuthenticatedUserParamSchema,
        t_ActivityListOrgEventsForAuthenticatedUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListOrgEventsForAuthenticatedUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListPublicEventsForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const activityListPublicEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListPublicEventsForUser",
    "/users/:username/events/public",
    paramValidationFactory<t_ActivityListPublicEventsForUserParamSchema>(
      activityListPublicEventsForUserParamSchema
    ),
    queryValidationFactory<t_ActivityListPublicEventsForUserQuerySchema>(
      activityListPublicEventsForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListPublicEventsForUserParamSchema,
        t_ActivityListPublicEventsForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListPublicEventsForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListFollowersForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const usersListFollowersForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListFollowersForUser",
    "/users/:username/followers",
    paramValidationFactory<t_UsersListFollowersForUserParamSchema>(
      usersListFollowersForUserParamSchema
    ),
    queryValidationFactory<t_UsersListFollowersForUserQuerySchema>(
      usersListFollowersForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersListFollowersForUserParamSchema,
        t_UsersListFollowersForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.usersListFollowersForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListFollowingForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const usersListFollowingForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListFollowingForUser",
    "/users/:username/following",
    paramValidationFactory<t_UsersListFollowingForUserParamSchema>(
      usersListFollowingForUserParamSchema
    ),
    queryValidationFactory<t_UsersListFollowingForUserQuerySchema>(
      usersListFollowingForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersListFollowingForUserParamSchema,
        t_UsersListFollowingForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.usersListFollowingForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersCheckFollowingForUserParamSchema = z.object({
    username: z.coerce.string(),
    target_user: z.coerce.string(),
  })

  router.get(
    "usersCheckFollowingForUser",
    "/users/:username/following/:targetUser",
    paramValidationFactory<t_UsersCheckFollowingForUserParamSchema>(
      usersCheckFollowingForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_UsersCheckFollowingForUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.usersCheckFollowingForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const gistsListForUserParamSchema = z.object({ username: z.coerce.string() })

  const gistsListForUserQuerySchema = z.object({
    since: z.coerce.string().datetime({ offset: true }).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "gistsListForUser",
    "/users/:username/gists",
    paramValidationFactory<t_GistsListForUserParamSchema>(
      gistsListForUserParamSchema
    ),
    queryValidationFactory<t_GistsListForUserQuerySchema>(
      gistsListForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_GistsListForUserParamSchema,
        t_GistsListForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.gistsListForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListGpgKeysForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const usersListGpgKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListGpgKeysForUser",
    "/users/:username/gpg_keys",
    paramValidationFactory<t_UsersListGpgKeysForUserParamSchema>(
      usersListGpgKeysForUserParamSchema
    ),
    queryValidationFactory<t_UsersListGpgKeysForUserQuerySchema>(
      usersListGpgKeysForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersListGpgKeysForUserParamSchema,
        t_UsersListGpgKeysForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.usersListGpgKeysForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersGetContextForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const usersGetContextForUserQuerySchema = z.object({
    subject_type: z
      .enum(["organization", "repository", "issue", "pull_request"])
      .optional(),
    subject_id: z.coerce.string().optional(),
  })

  router.get(
    "usersGetContextForUser",
    "/users/:username/hovercard",
    paramValidationFactory<t_UsersGetContextForUserParamSchema>(
      usersGetContextForUserParamSchema
    ),
    queryValidationFactory<t_UsersGetContextForUserQuerySchema>(
      usersGetContextForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersGetContextForUserParamSchema,
        t_UsersGetContextForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.usersGetContextForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const appsGetUserInstallationParamSchema = z.object({
    username: z.coerce.string(),
  })

  router.get(
    "appsGetUserInstallation",
    "/users/:username/installation",
    paramValidationFactory<t_AppsGetUserInstallationParamSchema>(
      appsGetUserInstallationParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_AppsGetUserInstallationParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.appsGetUserInstallation(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListPublicKeysForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const usersListPublicKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListPublicKeysForUser",
    "/users/:username/keys",
    paramValidationFactory<t_UsersListPublicKeysForUserParamSchema>(
      usersListPublicKeysForUserParamSchema
    ),
    queryValidationFactory<t_UsersListPublicKeysForUserQuerySchema>(
      usersListPublicKeysForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersListPublicKeysForUserParamSchema,
        t_UsersListPublicKeysForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.usersListPublicKeysForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const orgsListForUserParamSchema = z.object({ username: z.coerce.string() })

  const orgsListForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "orgsListForUser",
    "/users/:username/orgs",
    paramValidationFactory<t_OrgsListForUserParamSchema>(
      orgsListForUserParamSchema
    ),
    queryValidationFactory<t_OrgsListForUserQuerySchema>(
      orgsListForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_OrgsListForUserParamSchema,
        t_OrgsListForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.orgsListForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesListPackagesForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const packagesListPackagesForUserQuerySchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    visibility: z.enum(["public", "private", "internal"]).optional(),
  })

  router.get(
    "packagesListPackagesForUser",
    "/users/:username/packages",
    paramValidationFactory<t_PackagesListPackagesForUserParamSchema>(
      packagesListPackagesForUserParamSchema
    ),
    queryValidationFactory<t_PackagesListPackagesForUserQuerySchema>(
      packagesListPackagesForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesListPackagesForUserParamSchema,
        t_PackagesListPackagesForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.packagesListPackagesForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetPackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.get(
    "packagesGetPackageForUser",
    "/users/:username/packages/:packageType/:packageName",
    paramValidationFactory<t_PackagesGetPackageForUserParamSchema>(
      packagesGetPackageForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PackagesGetPackageForUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } = await implementation.packagesGetPackageForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesDeletePackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    username: z.coerce.string(),
  })

  router.delete(
    "packagesDeletePackageForUser",
    "/users/:username/packages/:packageType/:packageName",
    paramValidationFactory<t_PackagesDeletePackageForUserParamSchema>(
      packagesDeletePackageForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<t_PackagesDeletePackageForUserParamSchema, void, void>,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesDeletePackageForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesRestorePackageForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    username: z.coerce.string(),
  })

  const packagesRestorePackageForUserQuerySchema = z.object({
    token: z.coerce.string().optional(),
  })

  router.post(
    "packagesRestorePackageForUser",
    "/users/:username/packages/:packageType/:packageName/restore",
    paramValidationFactory<t_PackagesRestorePackageForUserParamSchema>(
      packagesRestorePackageForUserParamSchema
    ),
    queryValidationFactory<t_PackagesRestorePackageForUserQuerySchema>(
      packagesRestorePackageForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesRestorePackageForUserParamSchema,
        t_PackagesRestorePackageForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesRestorePackageForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetAllPackageVersionsForPackageOwnedByUserParamSchema =
    z.object({
      package_type: z.enum([
        "npm",
        "maven",
        "rubygems",
        "docker",
        "nuget",
        "container",
      ]),
      package_name: z.coerce.string(),
      username: z.coerce.string(),
    })

  router.get(
    "packagesGetAllPackageVersionsForPackageOwnedByUser",
    "/users/:username/packages/:packageType/:packageName/versions",
    paramValidationFactory<t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema>(
      packagesGetAllPackageVersionsForPackageOwnedByUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetAllPackageVersionsForPackageOwnedByUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetAllPackageVersionsForPackageOwnedByUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesGetPackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    package_version_id: z.coerce.number(),
    username: z.coerce.string(),
  })

  router.get(
    "packagesGetPackageVersionForUser",
    "/users/:username/packages/:packageType/:packageName/versions/:packageVersionId",
    paramValidationFactory<t_PackagesGetPackageVersionForUserParamSchema>(
      packagesGetPackageVersionForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesGetPackageVersionForUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesGetPackageVersionForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesDeletePackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    username: z.coerce.string(),
    package_version_id: z.coerce.number(),
  })

  router.delete(
    "packagesDeletePackageVersionForUser",
    "/users/:username/packages/:packageType/:packageName/versions/:packageVersionId",
    paramValidationFactory<t_PackagesDeletePackageVersionForUserParamSchema>(
      packagesDeletePackageVersionForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesDeletePackageVersionForUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesDeletePackageVersionForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const packagesRestorePackageVersionForUserParamSchema = z.object({
    package_type: z.enum([
      "npm",
      "maven",
      "rubygems",
      "docker",
      "nuget",
      "container",
    ]),
    package_name: z.coerce.string(),
    username: z.coerce.string(),
    package_version_id: z.coerce.number(),
  })

  router.post(
    "packagesRestorePackageVersionForUser",
    "/users/:username/packages/:packageType/:packageName/versions/:packageVersionId/restore",
    paramValidationFactory<t_PackagesRestorePackageVersionForUserParamSchema>(
      packagesRestorePackageVersionForUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_PackagesRestorePackageVersionForUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.packagesRestorePackageVersionForUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const projectsListForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const projectsListForUserQuerySchema = z.object({
    state: z.enum(["open", "closed", "all"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "projectsListForUser",
    "/users/:username/projects",
    paramValidationFactory<t_ProjectsListForUserParamSchema>(
      projectsListForUserParamSchema
    ),
    queryValidationFactory<t_ProjectsListForUserQuerySchema>(
      projectsListForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ProjectsListForUserParamSchema,
        t_ProjectsListForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.projectsListForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListReceivedEventsForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const activityListReceivedEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListReceivedEventsForUser",
    "/users/:username/received_events",
    paramValidationFactory<t_ActivityListReceivedEventsForUserParamSchema>(
      activityListReceivedEventsForUserParamSchema
    ),
    queryValidationFactory<t_ActivityListReceivedEventsForUserQuerySchema>(
      activityListReceivedEventsForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListReceivedEventsForUserParamSchema,
        t_ActivityListReceivedEventsForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListReceivedEventsForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListReceivedPublicEventsForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const activityListReceivedPublicEventsForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListReceivedPublicEventsForUser",
    "/users/:username/received_events/public",
    paramValidationFactory<t_ActivityListReceivedPublicEventsForUserParamSchema>(
      activityListReceivedPublicEventsForUserParamSchema
    ),
    queryValidationFactory<t_ActivityListReceivedPublicEventsForUserQuerySchema>(
      activityListReceivedPublicEventsForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListReceivedPublicEventsForUserParamSchema,
        t_ActivityListReceivedPublicEventsForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListReceivedPublicEventsForUser(
          ctx.state,
          ctx
        )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const reposListForUserParamSchema = z.object({ username: z.coerce.string() })

  const reposListForUserQuerySchema = z.object({
    type: z.enum(["all", "owner", "member"]).optional(),
    sort: z.enum(["created", "updated", "pushed", "full_name"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "reposListForUser",
    "/users/:username/repos",
    paramValidationFactory<t_ReposListForUserParamSchema>(
      reposListForUserParamSchema
    ),
    queryValidationFactory<t_ReposListForUserQuerySchema>(
      reposListForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ReposListForUserParamSchema,
        t_ReposListForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } = await implementation.reposListForUser(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const billingGetGithubActionsBillingUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  router.get(
    "billingGetGithubActionsBillingUser",
    "/users/:username/settings/billing/actions",
    paramValidationFactory<t_BillingGetGithubActionsBillingUserParamSchema>(
      billingGetGithubActionsBillingUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_BillingGetGithubActionsBillingUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.billingGetGithubActionsBillingUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const billingGetGithubPackagesBillingUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  router.get(
    "billingGetGithubPackagesBillingUser",
    "/users/:username/settings/billing/packages",
    paramValidationFactory<t_BillingGetGithubPackagesBillingUserParamSchema>(
      billingGetGithubPackagesBillingUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_BillingGetGithubPackagesBillingUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.billingGetGithubPackagesBillingUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const billingGetSharedStorageBillingUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  router.get(
    "billingGetSharedStorageBillingUser",
    "/users/:username/settings/billing/shared-storage",
    paramValidationFactory<t_BillingGetSharedStorageBillingUserParamSchema>(
      billingGetSharedStorageBillingUserParamSchema
    ),
    async (
      ctx: ValidatedCtx<
        t_BillingGetSharedStorageBillingUserParamSchema,
        void,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.billingGetSharedStorageBillingUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const usersListSshSigningKeysForUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const usersListSshSigningKeysForUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "usersListSshSigningKeysForUser",
    "/users/:username/ssh_signing_keys",
    paramValidationFactory<t_UsersListSshSigningKeysForUserParamSchema>(
      usersListSshSigningKeysForUserParamSchema
    ),
    queryValidationFactory<t_UsersListSshSigningKeysForUserQuerySchema>(
      usersListSshSigningKeysForUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_UsersListSshSigningKeysForUserParamSchema,
        t_UsersListSshSigningKeysForUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.usersListSshSigningKeysForUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListReposStarredByUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const activityListReposStarredByUserQuerySchema = z.object({
    sort: z.enum(["created", "updated"]).optional(),
    direction: z.enum(["asc", "desc"]).optional(),
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListReposStarredByUser",
    "/users/:username/starred",
    paramValidationFactory<t_ActivityListReposStarredByUserParamSchema>(
      activityListReposStarredByUserParamSchema
    ),
    queryValidationFactory<t_ActivityListReposStarredByUserQuerySchema>(
      activityListReposStarredByUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListReposStarredByUserParamSchema,
        t_ActivityListReposStarredByUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListReposStarredByUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  const activityListReposWatchedByUserParamSchema = z.object({
    username: z.coerce.string(),
  })

  const activityListReposWatchedByUserQuerySchema = z.object({
    per_page: z.coerce.number().optional(),
    page: z.coerce.number().optional(),
  })

  router.get(
    "activityListReposWatchedByUser",
    "/users/:username/subscriptions",
    paramValidationFactory<t_ActivityListReposWatchedByUserParamSchema>(
      activityListReposWatchedByUserParamSchema
    ),
    queryValidationFactory<t_ActivityListReposWatchedByUserQuerySchema>(
      activityListReposWatchedByUserQuerySchema
    ),
    async (
      ctx: ValidatedCtx<
        t_ActivityListReposWatchedByUserParamSchema,
        t_ActivityListReposWatchedByUserQuerySchema,
        void
      >,
      next: Next
    ) => {
      const { status, body } =
        await implementation.activityListReposWatchedByUser(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "metaGetAllVersions",
    "/versions",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.metaGetAllVersions(
        ctx.state,
        ctx
      )
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  router.get(
    "metaGetZen",
    "/zen",
    async (ctx: ValidatedCtx<void, void, void>, next: Next) => {
      const { status, body } = await implementation.metaGetZen(ctx.state, ctx)
      ctx.status = status
      ctx.body = body
      return next()
    }
  )

  return startServer({
    middleware: [],
    router,
    port: config.port,
  })
}
