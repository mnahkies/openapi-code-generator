/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import type {
  t_Azure_Core_Foundations_Error,
  t_Azure_Core_Foundations_ErrorResponse,
  t_Azure_Core_Foundations_OperationState,
  t_GetServiceStatusQuerySchema,
  t_GetServiceStatusRequestHeaderSchema,
  t_Manufacturer,
  t_ManufacturersCreateOrReplaceManufacturerParamSchema,
  t_ManufacturersCreateOrReplaceManufacturerQuerySchema,
  t_ManufacturersCreateOrReplaceManufacturerRequestBodySchema,
  t_ManufacturersCreateOrReplaceManufacturerRequestHeaderSchema,
  t_ManufacturersDeleteManufacturerParamSchema,
  t_ManufacturersDeleteManufacturerQuerySchema,
  t_ManufacturersDeleteManufacturerRequestHeaderSchema,
  t_ManufacturersGetManufacturerOperationStatusParamSchema,
  t_ManufacturersGetManufacturerOperationStatusQuerySchema,
  t_ManufacturersGetManufacturerParamSchema,
  t_ManufacturersGetManufacturerQuerySchema,
  t_ManufacturersGetManufacturerRequestHeaderSchema,
  t_ManufacturersListManufacturersQuerySchema,
  t_ManufacturersListManufacturersRequestHeaderSchema,
  t_PagedManufacturer,
  t_PagedWidget,
  t_PagedWidgetPart,
  t_Widget,
  t_WidgetAnalytics,
  t_WidgetPart,
  t_WidgetPartsCreateWidgetPartParamSchema,
  t_WidgetPartsCreateWidgetPartQuerySchema,
  t_WidgetPartsCreateWidgetPartRequestBodySchema,
  t_WidgetPartsCreateWidgetPartRequestHeaderSchema,
  t_WidgetPartsDeleteWidgetPartParamSchema,
  t_WidgetPartsDeleteWidgetPartQuerySchema,
  t_WidgetPartsDeleteWidgetPartRequestHeaderSchema,
  t_WidgetPartsGetWidgetPartOperationStatusParamSchema,
  t_WidgetPartsGetWidgetPartOperationStatusQuerySchema,
  t_WidgetPartsGetWidgetPartParamSchema,
  t_WidgetPartsGetWidgetPartQuerySchema,
  t_WidgetPartsGetWidgetPartRequestHeaderSchema,
  t_WidgetPartsListWidgetPartsParamSchema,
  t_WidgetPartsListWidgetPartsQuerySchema,
  t_WidgetPartsListWidgetPartsRequestHeaderSchema,
  t_WidgetPartsReorderPartsParamSchema,
  t_WidgetPartsReorderPartsQuerySchema,
  t_WidgetPartsReorderPartsRequestBodySchema,
  t_WidgetPartsReorderPartsRequestHeaderSchema,
  t_WidgetRepairRequest,
  t_WidgetRepairState,
  t_WidgetsCreateOrUpdateWidgetParamSchema,
  t_WidgetsCreateOrUpdateWidgetQuerySchema,
  t_WidgetsCreateOrUpdateWidgetRequestBodySchema,
  t_WidgetsCreateOrUpdateWidgetRequestHeaderSchema,
  t_WidgetsDeleteWidgetParamSchema,
  t_WidgetsDeleteWidgetQuerySchema,
  t_WidgetsDeleteWidgetRequestHeaderSchema,
  t_WidgetsGetAnalyticsParamSchema,
  t_WidgetsGetAnalyticsQuerySchema,
  t_WidgetsGetAnalyticsRequestHeaderSchema,
  t_WidgetsGetRepairStatusParamSchema,
  t_WidgetsGetRepairStatusQuerySchema,
  t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema,
  t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema,
  t_WidgetsGetWidgetParamSchema,
  t_WidgetsGetWidgetQuerySchema,
  t_WidgetsGetWidgetRequestHeaderSchema,
  t_WidgetsListWidgetsQuerySchema,
  t_WidgetsListWidgetsRequestHeaderSchema,
  t_WidgetsScheduleRepairsParamSchema,
  t_WidgetsScheduleRepairsQuerySchema,
  t_WidgetsScheduleRepairsRequestBodySchema,
  t_WidgetsScheduleRepairsRequestHeaderSchema,
  t_WidgetsUpdateAnalyticsParamSchema,
  t_WidgetsUpdateAnalyticsQuerySchema,
  t_WidgetsUpdateAnalyticsRequestBodySchema,
  t_WidgetsUpdateAnalyticsRequestHeaderSchema,
} from "./models"
import {
  s_Azure_Core_Foundations_Error,
  s_Azure_Core_Foundations_ErrorResponse,
  s_Azure_Core_Foundations_OperationState,
  s_Azure_Core_uuid,
  s_Manufacturer,
  s_PagedManufacturer,
  s_PagedWidget,
  s_PagedWidgetPart,
  s_Widget,
  s_WidgetAnalytics,
  s_WidgetAnalyticsCreateOrUpdate,
  s_WidgetCreateOrUpdate,
  s_WidgetPart,
  s_WidgetPartReorderRequest,
  s_WidgetRepairRequest,
  s_WidgetRepairState,
} from "./schemas"
import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  type ServerConfig,
  SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v4"
import {type NextFunction, type Request, type Response, Router} from "express"
import {z} from "zod/v4"

export type GetServiceStatusResponder = {
  with200(): ExpressRuntimeResponse<{
    statusString: string
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type GetServiceStatus = (
  params: Params<
    void,
    t_GetServiceStatusQuerySchema,
    void,
    t_GetServiceStatusRequestHeaderSchema
  >,
  respond: GetServiceStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponder =
  {
    with200(): ExpressRuntimeResponse<
      | {
          error?: t_Azure_Core_Foundations_Error | undefined
          id: string
          result?: t_Widget | undefined
          status: t_Azure_Core_Foundations_OperationState
        }
      | {
          error?: t_Azure_Core_Foundations_Error | undefined
          id: string
          status: t_Azure_Core_Foundations_OperationState
        }
    >
    withDefault(
      status: StatusCode,
    ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
  } & ExpressRuntimeResponder

export type WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus =
  (
    params: Params<
      t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema,
      t_WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema,
      void,
      void
    >,
    respond: WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponder,
    req: Request,
    res: Response,
    next: NextFunction,
  ) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsCreateOrUpdateWidgetResponder = {
  with200(): ExpressRuntimeResponse<t_Widget>
  with201(): ExpressRuntimeResponse<t_Widget>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsCreateOrUpdateWidget = (
  params: Params<
    t_WidgetsCreateOrUpdateWidgetParamSchema,
    t_WidgetsCreateOrUpdateWidgetQuerySchema,
    t_WidgetsCreateOrUpdateWidgetRequestBodySchema,
    t_WidgetsCreateOrUpdateWidgetRequestHeaderSchema
  >,
  respond: WidgetsCreateOrUpdateWidgetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsGetWidgetResponder = {
  with200(): ExpressRuntimeResponse<t_Widget>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsGetWidget = (
  params: Params<
    t_WidgetsGetWidgetParamSchema,
    t_WidgetsGetWidgetQuerySchema,
    void,
    t_WidgetsGetWidgetRequestHeaderSchema
  >,
  respond: WidgetsGetWidgetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsDeleteWidgetResponder = {
  with202(): ExpressRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error | undefined
    id: string
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsDeleteWidget = (
  params: Params<
    t_WidgetsDeleteWidgetParamSchema,
    t_WidgetsDeleteWidgetQuerySchema,
    void,
    t_WidgetsDeleteWidgetRequestHeaderSchema
  >,
  respond: WidgetsDeleteWidgetResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsListWidgetsResponder = {
  with200(): ExpressRuntimeResponse<t_PagedWidget>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsListWidgets = (
  params: Params<
    void,
    t_WidgetsListWidgetsQuerySchema,
    void,
    t_WidgetsListWidgetsRequestHeaderSchema
  >,
  respond: WidgetsListWidgetsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsGetAnalyticsResponder = {
  with200(): ExpressRuntimeResponse<t_WidgetAnalytics>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsGetAnalytics = (
  params: Params<
    t_WidgetsGetAnalyticsParamSchema,
    t_WidgetsGetAnalyticsQuerySchema,
    void,
    t_WidgetsGetAnalyticsRequestHeaderSchema
  >,
  respond: WidgetsGetAnalyticsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsUpdateAnalyticsResponder = {
  with200(): ExpressRuntimeResponse<t_WidgetAnalytics>
  with201(): ExpressRuntimeResponse<t_WidgetAnalytics>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsUpdateAnalytics = (
  params: Params<
    t_WidgetsUpdateAnalyticsParamSchema,
    t_WidgetsUpdateAnalyticsQuerySchema,
    t_WidgetsUpdateAnalyticsRequestBodySchema,
    t_WidgetsUpdateAnalyticsRequestHeaderSchema
  >,
  respond: WidgetsUpdateAnalyticsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsGetRepairStatusResponder = {
  with200(): ExpressRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error | undefined
    id: string
    result?: t_WidgetRepairRequest | undefined
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsGetRepairStatus = (
  params: Params<
    t_WidgetsGetRepairStatusParamSchema,
    t_WidgetsGetRepairStatusQuerySchema,
    void,
    void
  >,
  respond: WidgetsGetRepairStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetsScheduleRepairsResponder = {
  with202(): ExpressRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error | undefined
    id: string
    result?:
      | {
          completedDateTime: string
          createdDateTime: string
          requestState: t_WidgetRepairState
          scheduledDateTime: string
          updatedDateTime: string
        }
      | undefined
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetsScheduleRepairs = (
  params: Params<
    t_WidgetsScheduleRepairsParamSchema,
    t_WidgetsScheduleRepairsQuerySchema,
    t_WidgetsScheduleRepairsRequestBodySchema,
    t_WidgetsScheduleRepairsRequestHeaderSchema
  >,
  respond: WidgetsScheduleRepairsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetPartsGetWidgetPartOperationStatusResponder = {
  with200(): ExpressRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error | undefined
    id: string
    result?: t_WidgetPart | undefined
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetPartsGetWidgetPartOperationStatus = (
  params: Params<
    t_WidgetPartsGetWidgetPartOperationStatusParamSchema,
    t_WidgetPartsGetWidgetPartOperationStatusQuerySchema,
    void,
    void
  >,
  respond: WidgetPartsGetWidgetPartOperationStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetPartsCreateWidgetPartResponder = {
  with201(): ExpressRuntimeResponse<void>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetPartsCreateWidgetPart = (
  params: Params<
    t_WidgetPartsCreateWidgetPartParamSchema,
    t_WidgetPartsCreateWidgetPartQuerySchema,
    t_WidgetPartsCreateWidgetPartRequestBodySchema,
    t_WidgetPartsCreateWidgetPartRequestHeaderSchema
  >,
  respond: WidgetPartsCreateWidgetPartResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetPartsListWidgetPartsResponder = {
  with200(): ExpressRuntimeResponse<t_PagedWidgetPart>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetPartsListWidgetParts = (
  params: Params<
    t_WidgetPartsListWidgetPartsParamSchema,
    t_WidgetPartsListWidgetPartsQuerySchema,
    void,
    t_WidgetPartsListWidgetPartsRequestHeaderSchema
  >,
  respond: WidgetPartsListWidgetPartsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetPartsGetWidgetPartResponder = {
  with200(): ExpressRuntimeResponse<t_WidgetPart>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetPartsGetWidgetPart = (
  params: Params<
    t_WidgetPartsGetWidgetPartParamSchema,
    t_WidgetPartsGetWidgetPartQuerySchema,
    void,
    t_WidgetPartsGetWidgetPartRequestHeaderSchema
  >,
  respond: WidgetPartsGetWidgetPartResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetPartsDeleteWidgetPartResponder = {
  with204(): ExpressRuntimeResponse<void>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetPartsDeleteWidgetPart = (
  params: Params<
    t_WidgetPartsDeleteWidgetPartParamSchema,
    t_WidgetPartsDeleteWidgetPartQuerySchema,
    void,
    t_WidgetPartsDeleteWidgetPartRequestHeaderSchema
  >,
  respond: WidgetPartsDeleteWidgetPartResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type WidgetPartsReorderPartsResponder = {
  with202(): ExpressRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error | undefined
    id: string
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type WidgetPartsReorderParts = (
  params: Params<
    t_WidgetPartsReorderPartsParamSchema,
    t_WidgetPartsReorderPartsQuerySchema,
    t_WidgetPartsReorderPartsRequestBodySchema,
    t_WidgetPartsReorderPartsRequestHeaderSchema
  >,
  respond: WidgetPartsReorderPartsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ManufacturersGetManufacturerOperationStatusResponder = {
  with200(): ExpressRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error | undefined
    id: string
    result?: t_Manufacturer | undefined
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type ManufacturersGetManufacturerOperationStatus = (
  params: Params<
    t_ManufacturersGetManufacturerOperationStatusParamSchema,
    t_ManufacturersGetManufacturerOperationStatusQuerySchema,
    void,
    void
  >,
  respond: ManufacturersGetManufacturerOperationStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ManufacturersCreateOrReplaceManufacturerResponder = {
  with200(): ExpressRuntimeResponse<t_Manufacturer>
  with201(): ExpressRuntimeResponse<t_Manufacturer>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type ManufacturersCreateOrReplaceManufacturer = (
  params: Params<
    t_ManufacturersCreateOrReplaceManufacturerParamSchema,
    t_ManufacturersCreateOrReplaceManufacturerQuerySchema,
    t_ManufacturersCreateOrReplaceManufacturerRequestBodySchema,
    t_ManufacturersCreateOrReplaceManufacturerRequestHeaderSchema
  >,
  respond: ManufacturersCreateOrReplaceManufacturerResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ManufacturersGetManufacturerResponder = {
  with200(): ExpressRuntimeResponse<t_Manufacturer>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type ManufacturersGetManufacturer = (
  params: Params<
    t_ManufacturersGetManufacturerParamSchema,
    t_ManufacturersGetManufacturerQuerySchema,
    void,
    t_ManufacturersGetManufacturerRequestHeaderSchema
  >,
  respond: ManufacturersGetManufacturerResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ManufacturersDeleteManufacturerResponder = {
  with202(): ExpressRuntimeResponse<{
    error?: t_Azure_Core_Foundations_Error | undefined
    id: string
    status: t_Azure_Core_Foundations_OperationState
  }>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type ManufacturersDeleteManufacturer = (
  params: Params<
    t_ManufacturersDeleteManufacturerParamSchema,
    t_ManufacturersDeleteManufacturerQuerySchema,
    void,
    t_ManufacturersDeleteManufacturerRequestHeaderSchema
  >,
  respond: ManufacturersDeleteManufacturerResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ManufacturersListManufacturersResponder = {
  with200(): ExpressRuntimeResponse<t_PagedManufacturer>
  withDefault(
    status: StatusCode,
  ): ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>
} & ExpressRuntimeResponder

export type ManufacturersListManufacturers = (
  params: Params<
    void,
    t_ManufacturersListManufacturersQuerySchema,
    void,
    t_ManufacturersListManufacturersRequestHeaderSchema
  >,
  respond: ManufacturersListManufacturersResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  getServiceStatus: GetServiceStatus
  widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus: WidgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus
  widgetsCreateOrUpdateWidget: WidgetsCreateOrUpdateWidget
  widgetsGetWidget: WidgetsGetWidget
  widgetsDeleteWidget: WidgetsDeleteWidget
  widgetsListWidgets: WidgetsListWidgets
  widgetsGetAnalytics: WidgetsGetAnalytics
  widgetsUpdateAnalytics: WidgetsUpdateAnalytics
  widgetsGetRepairStatus: WidgetsGetRepairStatus
  widgetsScheduleRepairs: WidgetsScheduleRepairs
  widgetPartsGetWidgetPartOperationStatus: WidgetPartsGetWidgetPartOperationStatus
  widgetPartsCreateWidgetPart: WidgetPartsCreateWidgetPart
  widgetPartsListWidgetParts: WidgetPartsListWidgetParts
  widgetPartsGetWidgetPart: WidgetPartsGetWidgetPart
  widgetPartsDeleteWidgetPart: WidgetPartsDeleteWidgetPart
  widgetPartsReorderParts: WidgetPartsReorderParts
  manufacturersGetManufacturerOperationStatus: ManufacturersGetManufacturerOperationStatus
  manufacturersCreateOrReplaceManufacturer: ManufacturersCreateOrReplaceManufacturer
  manufacturersGetManufacturer: ManufacturersGetManufacturer
  manufacturersDeleteManufacturer: ManufacturersDeleteManufacturer
  manufacturersListManufacturers: ManufacturersListManufacturers
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const getServiceStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const getServiceStatusRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const getServiceStatusResponseBodyValidator = responseValidationFactory(
    [["200", z.object({statusString: z.string()})]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // getServiceStatus
  router.get(
    `/service-status`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getServiceStatusQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            getServiceStatusRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              statusString: string
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getServiceStatus(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getServiceStatusResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema =
    z.object({widgetName: z.string(), operationId: z.string()})

  const widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema =
    z.object({"api-version": z.string().min(1)})

  const widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.union([
            z.object({
              id: z.string(),
              status: s_Azure_Core_Foundations_OperationState,
              error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
              result: s_Widget.optional(),
            }),
            z.object({
              id: z.string(),
              status: s_Azure_Core_Foundations_OperationState,
              error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
            }),
          ]),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus
  router.get(
    `/widgets/:widgetName/operations/:operationId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<
              | {
                  error?: t_Azure_Core_Foundations_Error | undefined
                  id: string
                  result?: t_Widget | undefined
                  status: t_Azure_Core_Foundations_OperationState
                }
              | {
                  error?: t_Azure_Core_Foundations_Error | undefined
                  id: string
                  status: t_Azure_Core_Foundations_OperationState
                }
            >(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatus(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            widgetsGetWidgetOperationStatusWidgetsGetWidgetDeleteOperationStatusResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsCreateOrUpdateWidgetParamSchema = z.object({
    widgetName: z.string(),
  })

  const widgetsCreateOrUpdateWidgetQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsCreateOrUpdateWidgetRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsCreateOrUpdateWidgetRequestBodySchema = s_WidgetCreateOrUpdate

  const widgetsCreateOrUpdateWidgetResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_Widget],
        ["201", s_Widget],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetsCreateOrUpdateWidget
  router.patch(
    `/widgets/:widgetName`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsCreateOrUpdateWidgetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsCreateOrUpdateWidgetQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            widgetsCreateOrUpdateWidgetRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            widgetsCreateOrUpdateWidgetRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Widget>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_Widget>(201)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsCreateOrUpdateWidget(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            widgetsCreateOrUpdateWidgetResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsGetWidgetParamSchema = z.object({widgetName: z.string()})

  const widgetsGetWidgetQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsGetWidgetRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsGetWidgetResponseBodyValidator = responseValidationFactory(
    [["200", s_Widget]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // widgetsGetWidget
  router.get(
    `/widgets/:widgetName`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsGetWidgetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsGetWidgetQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            widgetsGetWidgetRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Widget>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsGetWidget(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetsGetWidgetResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsDeleteWidgetParamSchema = z.object({widgetName: z.string()})

  const widgetsDeleteWidgetQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsDeleteWidgetRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsDeleteWidgetResponseBodyValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({
          id: z.string(),
          status: s_Azure_Core_Foundations_OperationState,
          error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
        }),
      ],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // widgetsDeleteWidget
  router.delete(
    `/widgets/:widgetName`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsDeleteWidgetParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsDeleteWidgetQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            widgetsDeleteWidgetRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              error?: t_Azure_Core_Foundations_Error | undefined
              id: string
              status: t_Azure_Core_Foundations_OperationState
            }>(202)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsDeleteWidget(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetsDeleteWidgetResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsListWidgetsQuerySchema = z.object({
    "api-version": z.string().min(1),
    top: z.coerce.number().optional(),
    skip: z.coerce.number().optional().default(0),
    maxpagesize: z.coerce.number().optional(),
    select: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()),
      )
      .optional(),
  })

  const widgetsListWidgetsRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsListWidgetsResponseBodyValidator = responseValidationFactory(
    [["200", s_PagedWidget]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // widgetsListWidgets
  router.get(
    `/widgets`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            widgetsListWidgetsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            widgetsListWidgetsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_PagedWidget>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsListWidgets(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetsListWidgetsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsGetAnalyticsParamSchema = z.object({widgetName: z.string()})

  const widgetsGetAnalyticsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsGetAnalyticsRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsGetAnalyticsResponseBodyValidator = responseValidationFactory(
    [["200", s_WidgetAnalytics]],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // widgetsGetAnalytics
  router.get(
    `/widgets/:widgetName/analytics/current`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsGetAnalyticsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsGetAnalyticsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            widgetsGetAnalyticsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_WidgetAnalytics>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsGetAnalytics(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetsGetAnalyticsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsUpdateAnalyticsParamSchema = z.object({widgetName: z.string()})

  const widgetsUpdateAnalyticsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsUpdateAnalyticsRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsUpdateAnalyticsRequestBodySchema =
    s_WidgetAnalyticsCreateOrUpdate

  const widgetsUpdateAnalyticsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_WidgetAnalytics],
      ["201", s_WidgetAnalytics],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // widgetsUpdateAnalytics
  router.patch(
    `/widgets/:widgetName/analytics/current`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsUpdateAnalyticsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsUpdateAnalyticsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            widgetsUpdateAnalyticsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            widgetsUpdateAnalyticsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_WidgetAnalytics>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_WidgetAnalytics>(201)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsUpdateAnalytics(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetsUpdateAnalyticsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsGetRepairStatusParamSchema = z.object({
    widgetId: z.string(),
    operationId: z.string(),
  })

  const widgetsGetRepairStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsGetRepairStatusResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          id: z.string(),
          status: s_Azure_Core_Foundations_OperationState,
          error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
          result: s_WidgetRepairRequest.optional(),
        }),
      ],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // widgetsGetRepairStatus
  router.get(
    `/widgets/:widgetId/repairs/:operationId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsGetRepairStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsGetRepairStatusQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              error?: t_Azure_Core_Foundations_Error | undefined
              id: string
              result?: t_WidgetRepairRequest | undefined
              status: t_Azure_Core_Foundations_OperationState
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsGetRepairStatus(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetsGetRepairStatusResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetsScheduleRepairsParamSchema = z.object({widgetName: z.string()})

  const widgetsScheduleRepairsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetsScheduleRepairsRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetsScheduleRepairsRequestBodySchema = s_WidgetRepairRequest

  const widgetsScheduleRepairsResponseBodyValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({
          id: z.string(),
          status: s_Azure_Core_Foundations_OperationState,
          error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
          result: z
            .object({
              requestState: s_WidgetRepairState,
              scheduledDateTime: z.iso.datetime({offset: true}),
              createdDateTime: z.iso.datetime({offset: true}),
              updatedDateTime: z.iso.datetime({offset: true}),
              completedDateTime: z.iso.datetime({offset: true}),
            })
            .optional(),
        }),
      ],
    ],
    s_Azure_Core_Foundations_ErrorResponse,
  )

  // widgetsScheduleRepairs
  router.post(
    `/widgets/:widgetName:scheduleRepairs`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetsScheduleRepairsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetsScheduleRepairsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            widgetsScheduleRepairsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            widgetsScheduleRepairsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              error?: t_Azure_Core_Foundations_Error | undefined
              id: string
              result?:
                | {
                    completedDateTime: string
                    createdDateTime: string
                    requestState: t_WidgetRepairState
                    scheduledDateTime: string
                    updatedDateTime: string
                  }
                | undefined
              status: t_Azure_Core_Foundations_OperationState
            }>(202)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetsScheduleRepairs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetsScheduleRepairsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetPartsGetWidgetPartOperationStatusParamSchema = z.object({
    widgetName: z.string(),
    widgetPartName: z.string(),
    operationId: z.string(),
  })

  const widgetPartsGetWidgetPartOperationStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsGetWidgetPartOperationStatusResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            id: z.string(),
            status: s_Azure_Core_Foundations_OperationState,
            error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
            result: s_WidgetPart.optional(),
          }),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetPartsGetWidgetPartOperationStatus
  router.get(
    `/widgets/:widgetName/parts/:widgetPartName/operations/:operationId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetPartsGetWidgetPartOperationStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetPartsGetWidgetPartOperationStatusQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              error?: t_Azure_Core_Foundations_Error | undefined
              id: string
              result?: t_WidgetPart | undefined
              status: t_Azure_Core_Foundations_OperationState
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetPartsGetWidgetPartOperationStatus(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            widgetPartsGetWidgetPartOperationStatusResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetPartsCreateWidgetPartParamSchema = z.object({
    widgetName: z.string(),
  })

  const widgetPartsCreateWidgetPartQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsCreateWidgetPartRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsCreateWidgetPartRequestBodySchema = s_WidgetPart

  const widgetPartsCreateWidgetPartResponseBodyValidator =
    responseValidationFactory(
      [["201", z.undefined()]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetPartsCreateWidgetPart
  router.post(
    `/widgets/:widgetName/parts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetPartsCreateWidgetPartParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetPartsCreateWidgetPartQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            widgetPartsCreateWidgetPartRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            widgetPartsCreateWidgetPartRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<void>(201)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetPartsCreateWidgetPart(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            widgetPartsCreateWidgetPartResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetPartsListWidgetPartsParamSchema = z.object({
    widgetName: z.string(),
  })

  const widgetPartsListWidgetPartsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsListWidgetPartsRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsListWidgetPartsResponseBodyValidator =
    responseValidationFactory(
      [["200", s_PagedWidgetPart]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetPartsListWidgetParts
  router.get(
    `/widgets/:widgetName/parts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetPartsListWidgetPartsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetPartsListWidgetPartsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            widgetPartsListWidgetPartsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_PagedWidgetPart>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetPartsListWidgetParts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            widgetPartsListWidgetPartsResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetPartsGetWidgetPartParamSchema = z.object({
    widgetName: z.string(),
    widgetPartName: z.string(),
  })

  const widgetPartsGetWidgetPartQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsGetWidgetPartRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsGetWidgetPartResponseBodyValidator =
    responseValidationFactory(
      [["200", s_WidgetPart]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetPartsGetWidgetPart
  router.get(
    `/widgets/:widgetName/parts/:widgetPartName`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetPartsGetWidgetPartParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetPartsGetWidgetPartQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            widgetPartsGetWidgetPartRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_WidgetPart>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetPartsGetWidgetPart(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetPartsGetWidgetPartResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetPartsDeleteWidgetPartParamSchema = z.object({
    widgetName: z.string(),
    widgetPartName: z.string(),
  })

  const widgetPartsDeleteWidgetPartQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsDeleteWidgetPartRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsDeleteWidgetPartResponseBodyValidator =
    responseValidationFactory(
      [["204", z.undefined()]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetPartsDeleteWidgetPart
  router.delete(
    `/widgets/:widgetName/parts/:widgetPartName`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetPartsDeleteWidgetPartParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetPartsDeleteWidgetPartQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            widgetPartsDeleteWidgetPartRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetPartsDeleteWidgetPart(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            widgetPartsDeleteWidgetPartResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const widgetPartsReorderPartsParamSchema = z.object({widgetName: z.string()})

  const widgetPartsReorderPartsQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const widgetPartsReorderPartsRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const widgetPartsReorderPartsRequestBodySchema = s_WidgetPartReorderRequest

  const widgetPartsReorderPartsResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "202",
          z.object({
            id: z.string(),
            status: s_Azure_Core_Foundations_OperationState,
            error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
          }),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // widgetPartsReorderParts
  router.post(
    `/widgets/:widgetName/parts:reorderParts`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            widgetPartsReorderPartsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            widgetPartsReorderPartsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            widgetPartsReorderPartsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            widgetPartsReorderPartsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              error?: t_Azure_Core_Foundations_Error | undefined
              id: string
              status: t_Azure_Core_Foundations_OperationState
            }>(202)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .widgetPartsReorderParts(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(widgetPartsReorderPartsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const manufacturersGetManufacturerOperationStatusParamSchema = z.object({
    manufacturerId: z.string(),
    operationId: z.string(),
  })

  const manufacturersGetManufacturerOperationStatusQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersGetManufacturerOperationStatusResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "200",
          z.object({
            id: z.string(),
            status: s_Azure_Core_Foundations_OperationState,
            error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
            result: s_Manufacturer.optional(),
          }),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // manufacturersGetManufacturerOperationStatus
  router.get(
    `/manufacturers/:manufacturerId/operations/:operationId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            manufacturersGetManufacturerOperationStatusParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            manufacturersGetManufacturerOperationStatusQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              error?: t_Azure_Core_Foundations_Error | undefined
              id: string
              result?: t_Manufacturer | undefined
              status: t_Azure_Core_Foundations_OperationState
            }>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .manufacturersGetManufacturerOperationStatus(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            manufacturersGetManufacturerOperationStatusResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const manufacturersCreateOrReplaceManufacturerParamSchema = z.object({
    manufacturerId: z.string(),
  })

  const manufacturersCreateOrReplaceManufacturerQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersCreateOrReplaceManufacturerRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersCreateOrReplaceManufacturerRequestBodySchema =
    s_Manufacturer

  const manufacturersCreateOrReplaceManufacturerResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_Manufacturer],
        ["201", s_Manufacturer],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // manufacturersCreateOrReplaceManufacturer
  router.put(
    `/manufacturers/:manufacturerId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            manufacturersCreateOrReplaceManufacturerParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            manufacturersCreateOrReplaceManufacturerQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: parseRequestInput(
            manufacturersCreateOrReplaceManufacturerRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            manufacturersCreateOrReplaceManufacturerRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Manufacturer>(200)
          },
          with201() {
            return new ExpressRuntimeResponse<t_Manufacturer>(201)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .manufacturersCreateOrReplaceManufacturer(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            manufacturersCreateOrReplaceManufacturerResponseBodyValidator(
              status,
              body,
            ),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const manufacturersGetManufacturerParamSchema = z.object({
    manufacturerId: z.string(),
  })

  const manufacturersGetManufacturerQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersGetManufacturerRequestHeaderSchema = z.object({
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersGetManufacturerResponseBodyValidator =
    responseValidationFactory(
      [["200", s_Manufacturer]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // manufacturersGetManufacturer
  router.get(
    `/manufacturers/:manufacturerId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            manufacturersGetManufacturerParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            manufacturersGetManufacturerQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            manufacturersGetManufacturerRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Manufacturer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .manufacturersGetManufacturer(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            manufacturersGetManufacturerResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const manufacturersDeleteManufacturerParamSchema = z.object({
    manufacturerId: z.string(),
  })

  const manufacturersDeleteManufacturerQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersDeleteManufacturerRequestHeaderSchema = z.object({
    "repeatability-request-id": z.string().optional(),
    "repeatability-first-sent": z.string().optional(),
    "if-match": z.string().optional(),
    "if-none-match": z.string().optional(),
    "if-unmodified-since": z.string().optional(),
    "if-modified-since": z.string().optional(),
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersDeleteManufacturerResponseBodyValidator =
    responseValidationFactory(
      [
        [
          "202",
          z.object({
            id: z.string(),
            status: s_Azure_Core_Foundations_OperationState,
            error: z.lazy(() => s_Azure_Core_Foundations_Error.optional()),
          }),
        ],
      ],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // manufacturersDeleteManufacturer
  router.delete(
    `/manufacturers/:manufacturerId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            manufacturersDeleteManufacturerParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            manufacturersDeleteManufacturerQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            manufacturersDeleteManufacturerRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              error?: t_Azure_Core_Foundations_Error | undefined
              id: string
              status: t_Azure_Core_Foundations_OperationState
            }>(202)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .manufacturersDeleteManufacturer(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            manufacturersDeleteManufacturerResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const manufacturersListManufacturersQuerySchema = z.object({
    "api-version": z.string().min(1),
  })

  const manufacturersListManufacturersRequestHeaderSchema = z.object({
    "x-ms-client-request-id": s_Azure_Core_uuid.optional(),
  })

  const manufacturersListManufacturersResponseBodyValidator =
    responseValidationFactory(
      [["200", s_PagedManufacturer]],
      s_Azure_Core_Foundations_ErrorResponse,
    )

  // manufacturersListManufacturers
  router.get(
    `/manufacturers`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            manufacturersListManufacturersQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: parseRequestInput(
            manufacturersListManufacturersRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_PagedManufacturer>(200)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<t_Azure_Core_Foundations_ErrorResponse>(
              status,
            )
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .manufacturersListManufacturers(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(
            manufacturersListManufacturersResponseBodyValidator(status, body),
          )
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Contoso Widget Manager
  return startServer(config)
}
