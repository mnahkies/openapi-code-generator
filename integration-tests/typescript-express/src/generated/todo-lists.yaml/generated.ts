/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  type ServerConfig,
  SkipResponse,
  type StatusCode,
  type StatusCode4xx,
  type StatusCode5xx,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v4"
import {parseQueryParameters} from "@nahkies/typescript-koa-runtime/server"
import {type NextFunction, type Request, type Response, Router} from "express"
import {z} from "zod/v4"
import type {
  t_CreateTodoListItemParamSchema,
  t_CreateTodoListItemRequestBody,
  t_CreateUpdateTodoList,
  t_DeleteTodoListByIdParamSchema,
  t_Error,
  t_GetTodoListByIdParamSchema,
  t_GetTodoListItemsParamSchema,
  t_GetTodoListsQuerySchema,
  t_TodoList,
  t_UnknownObject,
  t_UpdateTodoListByIdParamSchema,
} from "./models.ts"
import {
  s_CreateTodoListItemRequestBody,
  s_CreateUpdateTodoList,
  s_Error,
  s_Statuses,
  s_TodoList,
  s_UnknownObject,
} from "./schemas.ts"

export type GetTodoListsResponder = {
  with200(): ExpressRuntimeResponse<t_TodoList[]>
} & ExpressRuntimeResponder

export type GetTodoLists = (
  params: Params<void, t_GetTodoListsQuerySchema, void, void>,
  respond: GetTodoListsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTodoListByIdResponder = {
  with200(): ExpressRuntimeResponse<t_TodoList>
  withStatusCode4xx(status: StatusCode4xx): ExpressRuntimeResponse<t_Error>
  withDefault(status: StatusCode): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type GetTodoListById = (
  params: Params<t_GetTodoListByIdParamSchema, void, void, void>,
  respond: GetTodoListByIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UpdateTodoListByIdResponder = {
  with200(): ExpressRuntimeResponse<t_TodoList>
  withStatusCode4xx(status: StatusCode4xx): ExpressRuntimeResponse<t_Error>
  withDefault(status: StatusCode): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type UpdateTodoListById = (
  params: Params<
    t_UpdateTodoListByIdParamSchema,
    void,
    t_CreateUpdateTodoList,
    void
  >,
  respond: UpdateTodoListByIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteTodoListByIdResponder = {
  with204(): ExpressRuntimeResponse<void>
  withStatusCode4xx(status: StatusCode4xx): ExpressRuntimeResponse<t_Error>
  withDefault(status: StatusCode): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type DeleteTodoListById = (
  params: Params<t_DeleteTodoListByIdParamSchema, void, void, void>,
  respond: DeleteTodoListByIdResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetTodoListItemsResponder = {
  with200(): ExpressRuntimeResponse<{
    completedAt?: string | undefined
    content: string
    createdAt: string
    id: string
  }>
  withStatusCode5xx(status: StatusCode5xx): ExpressRuntimeResponse<{
    code: string
    message: string
  }>
} & ExpressRuntimeResponder

export type GetTodoListItems = (
  params: Params<t_GetTodoListItemsParamSchema, void, void, void>,
  respond: GetTodoListItemsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CreateTodoListItemResponder = {
  with204(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type CreateTodoListItem = (
  params: Params<
    t_CreateTodoListItemParamSchema,
    void,
    t_CreateTodoListItemRequestBody,
    void
  >,
  respond: CreateTodoListItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListAttachmentsResponder = {
  with200(): ExpressRuntimeResponse<t_UnknownObject[]>
} & ExpressRuntimeResponder

export type ListAttachments = (
  params: Params<void, void, void, void>,
  respond: ListAttachmentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UploadAttachmentResponder = {
  with202(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type UploadAttachment = (
  params: Params<void, void, never, void>,
  respond: UploadAttachmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  getTodoLists: GetTodoLists
  getTodoListById: GetTodoListById
  updateTodoListById: UpdateTodoListById
  deleteTodoListById: DeleteTodoListById
  getTodoListItems: GetTodoListItems
  createTodoListItem: CreateTodoListItem
  listAttachments: ListAttachments
  uploadAttachment: UploadAttachment
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const getTodoListsQuerySchema = z.object({
    created: z.iso.datetime({offset: true}).optional(),
    statuses: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        s_Statuses,
      )
      .optional(),
    tags: z
      .preprocess(
        (it: unknown) => (Array.isArray(it) || it === undefined ? it : [it]),
        z.array(z.string()),
      )
      .optional(),
  })

  const getTodoListsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_TodoList)]],
    undefined,
  )

  // getTodoLists
  router.get(
    `/list`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getTodoListsQuerySchema,
            parseQueryParameters(
              new URL(`http://localhost${req.originalUrl}`).search,
              [
                {
                  name: "created",
                  explode: true,
                  style: "form",
                  schema: {type: "string"},
                },
                {
                  name: "statuses",
                  explode: true,
                  style: "form",
                  schema: {type: "array", items: {type: "string"}},
                },
                {
                  name: "tags",
                  explode: true,
                  style: "form",
                  schema: {type: "array", items: {type: "string"}},
                },
              ],
            ),
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_TodoList[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTodoLists(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTodoListsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTodoListByIdParamSchema = z.object({listId: z.string()})

  const getTodoListByIdResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_TodoList],
      ["4XX", s_Error],
    ],
    z.undefined(),
  )

  // getTodoListById
  router.get(
    `/list/:listId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTodoListByIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_TodoList>(200)
          },
          withStatusCode4xx(status: StatusCode4xx) {
            return new ExpressRuntimeResponse<t_Error>(status)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<void>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTodoListById(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTodoListByIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const updateTodoListByIdParamSchema = z.object({listId: z.string()})

  const updateTodoListByIdResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_TodoList],
      ["4XX", s_Error],
    ],
    z.undefined(),
  )

  // updateTodoListById
  router.put(
    `/list/:listId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            updateTodoListByIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CreateUpdateTodoList,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_TodoList>(200)
          },
          withStatusCode4xx(status: StatusCode4xx) {
            return new ExpressRuntimeResponse<t_Error>(status)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<void>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .updateTodoListById(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(updateTodoListByIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteTodoListByIdParamSchema = z.object({listId: z.string()})

  const deleteTodoListByIdResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["4XX", s_Error],
    ],
    z.undefined(),
  )

  // deleteTodoListById
  router.delete(
    `/list/:listId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteTodoListByIdParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatusCode4xx(status: StatusCode4xx) {
            return new ExpressRuntimeResponse<t_Error>(status)
          },
          withDefault(status: StatusCode) {
            return new ExpressRuntimeResponse<void>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteTodoListById(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(deleteTodoListByIdResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getTodoListItemsParamSchema = z.object({listId: z.string()})

  const getTodoListItemsResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          id: z.string(),
          content: z.string(),
          createdAt: z.iso.datetime({offset: true}),
          completedAt: z.iso.datetime({offset: true}).optional(),
        }),
      ],
      ["5XX", z.object({message: z.string(), code: z.string()})],
    ],
    undefined,
  )

  // getTodoListItems
  router.get(
    `/list/:listId/items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getTodoListItemsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              completedAt?: string | undefined
              content: string
              createdAt: string
              id: string
            }>(200)
          },
          withStatusCode5xx(status: StatusCode5xx) {
            return new ExpressRuntimeResponse<{
              code: string
              message: string
            }>(status)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getTodoListItems(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getTodoListItemsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const createTodoListItemParamSchema = z.object({listId: z.string()})

  const createTodoListItemResponseBodyValidator = responseValidationFactory(
    [["204", z.undefined()]],
    undefined,
  )

  // createTodoListItem
  router.post(
    `/list/:listId/items`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            createTodoListItemParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_CreateTodoListItemRequestBody,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .createTodoListItem(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(createTodoListItemResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const listAttachmentsResponseBodyValidator = responseValidationFactory(
    [["200", z.array(s_UnknownObject)]],
    undefined,
  )

  // listAttachments
  router.get(
    `/attachments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_UnknownObject[]>(200)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listAttachments(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(listAttachmentsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const uploadAttachmentResponseBodyValidator = responseValidationFactory(
    [["202", z.undefined()]],
    undefined,
  )

  // uploadAttachment
  router.post(
    `/attachments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          // todo: request bodies with content-type 'multipart/form-data' not yet supported
          body: parseRequestInput(
            z.never(),
            req.body,
            RequestInputType.RequestBody,
          ) as never,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<void>(202)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .uploadAttachment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(uploadAttachmentResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Todo Lists Example API
  return startServer(config)
}
