/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {RequestInputType} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  handleImplementationError,
  handleResponse,
  type Params,
  type ServerConfig,
  type SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v4"
import {type NextFunction, type Request, type Response, Router} from "express"
import {z} from "zod/v4"
import type {
  t_AuthorizeCustomAsParamSchema,
  t_AuthorizeCustomAsQuerySchema,
  t_AuthorizeCustomAsWithPostParamSchema,
  t_AuthorizeQuerySchema,
  t_AuthorizeWithPost,
  t_BackchannelAuthorizeRequest,
  t_BackchannelAuthorizeResponse,
  t_BcAuthorizeCustomAsParamSchema,
  t_ChallengeCustomAsParamSchema,
  t_ChallengeRequest,
  t_ChallengeResponse,
  t_Client,
  t_DeleteClientParamSchema,
  t_DeviceAuthorizeCustomAsParamSchema,
  t_DeviceAuthorizeRequest,
  t_DeviceAuthorizeResponse,
  t_Error,
  t_GenerateNewClientSecretParamSchema,
  t_GetClientParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
  t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationQuerySchema,
  t_GlobalTokenRevocationRequest,
  t_IntrospectCustomAsParamSchema,
  t_IntrospectionRequest,
  t_IntrospectionResponse,
  t_ListClientsQuerySchema,
  t_LogoutCustomAsParamSchema,
  t_LogoutCustomAsQuerySchema,
  t_LogoutCustomAsWithPostParamSchema,
  t_LogoutQuerySchema,
  t_LogoutWithPost,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OauthKeysCustomAsParamSchema,
  t_OauthKeysQuerySchema,
  t_OidcMetadata,
  t_OobAuthenticateCustomAsParamSchema,
  t_OobAuthenticateRequest,
  t_OobAuthenticateResponse,
  t_ParCustomAsParamSchema,
  t_ParOptionsCustomAsParamSchema,
  t_ParOptionsCustomAsRequestHeaderSchema,
  t_ParOptionsRequestHeaderSchema,
  t_ParRequest,
  t_ParResponse,
  t_ReplaceClientParamSchema,
  t_RevokeCustomAsParamSchema,
  t_RevokeRequest,
  t_TokenCustomAsParamSchema,
  t_TokenOptionsCustomAsParamSchema,
  t_TokenOptionsCustomAsRequestHeaderSchema,
  t_TokenOptionsRequestHeaderSchema,
  t_TokenRequest,
  t_TokenResponse,
  t_UserInfo,
  t_UserinfoCustomAsParamSchema,
} from "./models.ts"
import {
  s_AcrValue,
  s_AmrValue,
  s_AuthorizeWithPost,
  s_BackchannelAuthorizeRequest,
  s_BackchannelAuthorizeResponse,
  s_ChallengeRequest,
  s_ChallengeResponse,
  s_Client,
  s_CodeChallengeMethod,
  s_DeviceAuthorizeRequest,
  s_DeviceAuthorizeResponse,
  s_Error,
  s_GlobalTokenRevocationRequest,
  s_IntrospectionRequest,
  s_IntrospectionResponse,
  s_LogoutWithPost,
  s_OAuthError,
  s_OAuthKeys,
  s_OAuthMetadata,
  s_OidcMetadata,
  s_OobAuthenticateRequest,
  s_OobAuthenticateResponse,
  s_ParRequest,
  s_ParResponse,
  s_Prompt,
  s_ResponseMode,
  s_ResponseTypesSupported,
  s_RevokeRequest,
  s_TokenRequest,
  s_TokenResponse,
  s_UserInfo,
} from "./schemas.ts"

export type GetWellKnownOpenIdConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_OidcMetadata>
  with400(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetWellKnownOpenIdConfiguration = (
  params: Params<
    void,
    t_GetWellKnownOpenIdConfigurationQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Authorize = (
  params: Params<void, t_AuthorizeQuerySchema, void, void>,
  respond: AuthorizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeWithPostResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type AuthorizeWithPost = (
  params: Params<void, void, t_AuthorizeWithPost, void>,
  respond: AuthorizeWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BcAuthorizeResponder = {
  with200(): ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type BcAuthorize = (
  params: Params<void, void, t_BackchannelAuthorizeRequest, void>,
  respond: BcAuthorizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChallengeResponder = {
  with200(): ExpressRuntimeResponse<t_ChallengeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type Challenge = (
  params: Params<void, void, t_ChallengeRequest, void>,
  respond: ChallengeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListClientsResponder = {
  with200(): ExpressRuntimeResponse<t_Client[]>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListClients = (
  params: Params<void, t_ListClientsQuerySchema, void, void>,
  respond: ListClientsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CreateClientResponder = {
  with201(): ExpressRuntimeResponse<t_Client>
  with400(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type CreateClient = (
  params: Params<void, void, t_Client, void>,
  respond: CreateClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClientResponder = {
  with200(): ExpressRuntimeResponse<t_Client>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetClient = (
  params: Params<t_GetClientParamSchema, void, void, void>,
  respond: GetClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReplaceClientResponder = {
  with200(): ExpressRuntimeResponse<t_Client>
  with400(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReplaceClient = (
  params: Params<t_ReplaceClientParamSchema, void, t_Client, void>,
  respond: ReplaceClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteClientResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeleteClient = (
  params: Params<t_DeleteClientParamSchema, void, void, void>,
  respond: DeleteClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GenerateNewClientSecretResponder = {
  with200(): ExpressRuntimeResponse<t_Client>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GenerateNewClientSecret = (
  params: Params<t_GenerateNewClientSecretParamSchema, void, void, void>,
  respond: GenerateNewClientSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeviceAuthorizeResponder = {
  with200(): ExpressRuntimeResponse<t_DeviceAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeviceAuthorize = (
  params: Params<void, void, t_DeviceAuthorizeRequest, void>,
  respond: DeviceAuthorizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GlobalTokenRevocationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GlobalTokenRevocation = (
  params: Params<void, void, t_GlobalTokenRevocationRequest, void>,
  respond: GlobalTokenRevocationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IntrospectResponder = {
  with200(): ExpressRuntimeResponse<t_IntrospectionResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Introspect = (
  params: Params<void, void, t_IntrospectionRequest, void>,
  respond: IntrospectResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OauthKeysResponder = {
  with200(): ExpressRuntimeResponse<t_OAuthKeys>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type OauthKeys = (
  params: Params<void, t_OauthKeysQuerySchema, void, void>,
  respond: OauthKeysResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Logout = (
  params: Params<void, t_LogoutQuerySchema, void, void>,
  respond: LogoutResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutWithPostResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LogoutWithPost = (
  params: Params<void, void, t_LogoutWithPost, void>,
  respond: LogoutWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OobAuthenticateResponder = {
  with200(): ExpressRuntimeResponse<t_OobAuthenticateResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type OobAuthenticate = (
  params: Params<void, void, t_OobAuthenticateRequest, void>,
  respond: OobAuthenticateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParOptionsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ParOptions = (
  params: Params<void, void, void, t_ParOptionsRequestHeaderSchema>,
  respond: ParOptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParResponder = {
  with200(): ExpressRuntimeResponse<t_ParResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Par = (
  params: Params<void, void, t_ParRequest, void>,
  respond: ParResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type RevokeResponder = {
  with200(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Revoke = (
  params: Params<void, void, t_RevokeRequest, void>,
  respond: RevokeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenOptionsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type TokenOptions = (
  params: Params<void, void, void, t_TokenOptionsRequestHeaderSchema>,
  respond: TokenOptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenResponder = {
  with200(): ExpressRuntimeResponse<t_TokenResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Token = (
  params: Params<void, void, t_TokenRequest, void>,
  respond: TokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UserinfoResponder = {
  with200(): ExpressRuntimeResponse<t_UserInfo>
  with401(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Userinfo = (
  params: Params<void, void, void, void>,
  respond: UserinfoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetWellKnownOAuthConfigurationCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OAuthMetadata>
  with400(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetWellKnownOAuthConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
    t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOAuthConfigurationCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetWellKnownOpenIdConfigurationCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OidcMetadata>
  with400(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetWellKnownOpenIdConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
    t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeCustomAsResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type AuthorizeCustomAs = (
  params: Params<
    t_AuthorizeCustomAsParamSchema,
    t_AuthorizeCustomAsQuerySchema,
    void,
    void
  >,
  respond: AuthorizeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeCustomAsWithPostResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type AuthorizeCustomAsWithPost = (
  params: Params<
    t_AuthorizeCustomAsWithPostParamSchema,
    void,
    t_AuthorizeWithPost,
    void
  >,
  respond: AuthorizeCustomAsWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BcAuthorizeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type BcAuthorizeCustomAs = (
  params: Params<
    t_BcAuthorizeCustomAsParamSchema,
    void,
    t_BackchannelAuthorizeRequest,
    void
  >,
  respond: BcAuthorizeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChallengeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_ChallengeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type ChallengeCustomAs = (
  params: Params<
    t_ChallengeCustomAsParamSchema,
    void,
    t_ChallengeRequest,
    void
  >,
  respond: ChallengeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeviceAuthorizeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_DeviceAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeviceAuthorizeCustomAs = (
  params: Params<
    t_DeviceAuthorizeCustomAsParamSchema,
    void,
    t_DeviceAuthorizeRequest,
    void
  >,
  respond: DeviceAuthorizeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IntrospectCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_IntrospectionResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type IntrospectCustomAs = (
  params: Params<
    t_IntrospectCustomAsParamSchema,
    void,
    t_IntrospectionRequest,
    void
  >,
  respond: IntrospectCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OauthKeysCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OAuthKeys>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type OauthKeysCustomAs = (
  params: Params<t_OauthKeysCustomAsParamSchema, void, void, void>,
  respond: OauthKeysCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutCustomAsResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LogoutCustomAs = (
  params: Params<
    t_LogoutCustomAsParamSchema,
    t_LogoutCustomAsQuerySchema,
    void,
    void
  >,
  respond: LogoutCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutCustomAsWithPostResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LogoutCustomAsWithPost = (
  params: Params<
    t_LogoutCustomAsWithPostParamSchema,
    void,
    t_LogoutWithPost,
    void
  >,
  respond: LogoutCustomAsWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OobAuthenticateCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OobAuthenticateResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type OobAuthenticateCustomAs = (
  params: Params<
    t_OobAuthenticateCustomAsParamSchema,
    void,
    t_OobAuthenticateRequest,
    void
  >,
  respond: OobAuthenticateCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParOptionsCustomAsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ParOptionsCustomAs = (
  params: Params<
    t_ParOptionsCustomAsParamSchema,
    void,
    void,
    t_ParOptionsCustomAsRequestHeaderSchema
  >,
  respond: ParOptionsCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_ParResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ParCustomAs = (
  params: Params<t_ParCustomAsParamSchema, void, t_ParRequest, void>,
  respond: ParCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type RevokeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type RevokeCustomAs = (
  params: Params<t_RevokeCustomAsParamSchema, void, t_RevokeRequest, void>,
  respond: RevokeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenOptionsCustomAsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type TokenOptionsCustomAs = (
  params: Params<
    t_TokenOptionsCustomAsParamSchema,
    void,
    void,
    t_TokenOptionsCustomAsRequestHeaderSchema
  >,
  respond: TokenOptionsCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_TokenResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type TokenCustomAs = (
  params: Params<t_TokenCustomAsParamSchema, void, t_TokenRequest, void>,
  respond: TokenCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UserinfoCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_UserInfo>
  with401(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type UserinfoCustomAs = (
  params: Params<t_UserinfoCustomAsParamSchema, void, void, void>,
  respond: UserinfoCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  getWellKnownOpenIdConfiguration: GetWellKnownOpenIdConfiguration
  authorize: Authorize
  authorizeWithPost: AuthorizeWithPost
  bcAuthorize: BcAuthorize
  challenge: Challenge
  listClients: ListClients
  createClient: CreateClient
  getClient: GetClient
  replaceClient: ReplaceClient
  deleteClient: DeleteClient
  generateNewClientSecret: GenerateNewClientSecret
  deviceAuthorize: DeviceAuthorize
  globalTokenRevocation: GlobalTokenRevocation
  introspect: Introspect
  oauthKeys: OauthKeys
  logout: Logout
  logoutWithPost: LogoutWithPost
  oobAuthenticate: OobAuthenticate
  parOptions: ParOptions
  par: Par
  revoke: Revoke
  tokenOptions: TokenOptions
  token: Token
  userinfo: Userinfo
  getWellKnownOAuthConfigurationCustomAs: GetWellKnownOAuthConfigurationCustomAs
  getWellKnownOpenIdConfigurationCustomAs: GetWellKnownOpenIdConfigurationCustomAs
  authorizeCustomAs: AuthorizeCustomAs
  authorizeCustomAsWithPost: AuthorizeCustomAsWithPost
  bcAuthorizeCustomAs: BcAuthorizeCustomAs
  challengeCustomAs: ChallengeCustomAs
  deviceAuthorizeCustomAs: DeviceAuthorizeCustomAs
  introspectCustomAs: IntrospectCustomAs
  oauthKeysCustomAs: OauthKeysCustomAs
  logoutCustomAs: LogoutCustomAs
  logoutCustomAsWithPost: LogoutCustomAsWithPost
  oobAuthenticateCustomAs: OobAuthenticateCustomAs
  parOptionsCustomAs: ParOptionsCustomAs
  parCustomAs: ParCustomAs
  revokeCustomAs: RevokeCustomAs
  tokenOptionsCustomAs: TokenOptionsCustomAs
  tokenCustomAs: TokenCustomAs
  userinfoCustomAs: UserinfoCustomAs
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const getWellKnownOpenIdConfigurationQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOpenIdConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OidcMetadata],
        ["400", s_Error],
      ],
      undefined,
    )

  // getWellKnownOpenIdConfiguration
  router.get(
    `/.well-known/openid-configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getWellKnownOpenIdConfigurationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OidcMetadata>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .getWellKnownOpenIdConfiguration(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              getWellKnownOpenIdConfigurationResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  const authorizeResponseBodyValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  // authorize
  router.get(
    `/oauth2/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            authorizeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .authorize(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, authorizeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeWithPostResponseBodyValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  // authorizeWithPost
  router.post(
    `/oauth2/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_AuthorizeWithPost,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .authorizeWithPost(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, authorizeWithPostResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const bcAuthorizeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_BackchannelAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // bcAuthorize
  router.post(
    `/oauth2/v1/bc/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_BackchannelAuthorizeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>(
              200,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .bcAuthorize(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, bcAuthorizeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const challengeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ChallengeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  // challenge
  router.post(
    `/oauth2/v1/challenge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_ChallengeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ChallengeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .challenge(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, challengeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const listClientsQuerySchema = z.object({
    after: z.string().optional(),
    limit: z.coerce.number().min(1).max(200).optional().default(20),
    q: z.string().optional(),
  })

  const listClientsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_Client)],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // listClients
  router.get(
    `/oauth2/v1/clients`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            listClientsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .listClients(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, listClientsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const createClientResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_Client],
      ["400", s_Error],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // createClient
  router.post(
    `/oauth2/v1/clients`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_Client,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_Client>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .createClient(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, createClientResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const getClientParamSchema = z.object({clientId: z.string()})

  const getClientResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Client],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // getClient
  router.get(
    `/oauth2/v1/clients/:clientId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getClientParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .getClient(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, getClientResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const replaceClientParamSchema = z.object({clientId: z.string()})

  const replaceClientResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Client],
      ["400", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // replaceClient
  router.put(
    `/oauth2/v1/clients/:clientId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            replaceClientParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_Client,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .replaceClient(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, replaceClientResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteClientParamSchema = z.object({clientId: z.string()})

  const deleteClientResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // deleteClient
  router.delete(
    `/oauth2/v1/clients/:clientId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteClientParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .deleteClient(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, deleteClientResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const generateNewClientSecretParamSchema = z.object({clientId: z.string()})

  const generateNewClientSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_Client],
        ["403", s_Error],
        ["404", s_Error],
        ["429", s_Error],
      ],
      undefined,
    )

  // generateNewClientSecret
  router.post(
    `/oauth2/v1/clients/:clientId/lifecycle/newSecret`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            generateNewClientSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .generateNewClientSecret(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, generateNewClientSecretResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const deviceAuthorizeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_DeviceAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // deviceAuthorize
  router.post(
    `/oauth2/v1/device/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_DeviceAuthorizeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DeviceAuthorizeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .deviceAuthorize(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, deviceAuthorizeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const globalTokenRevocationResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", z.undefined()],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // globalTokenRevocation
  router.post(
    `/oauth2/v1/global-token-revocation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_GlobalTokenRevocationRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .globalTokenRevocation(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, globalTokenRevocationResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const introspectResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_IntrospectionResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // introspect
  router.post(
    `/oauth2/v1/introspect`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_IntrospectionRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_IntrospectionResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .introspect(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, introspectResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const oauthKeysQuerySchema = z.object({client_id: z.string().optional()})

  const oauthKeysResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_OAuthKeys],
      ["429", s_Error],
    ],
    undefined,
  )

  // oauthKeys
  router.get(
    `/oauth2/v1/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            oauthKeysQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OAuthKeys>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .oauthKeys(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, oauthKeysResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  const logoutResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logout
  router.get(
    `/oauth2/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            logoutQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .logout(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, logoutResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutWithPostResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logoutWithPost
  router.post(
    `/oauth2/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_LogoutWithPost,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .logoutWithPost(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, logoutWithPostResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const oobAuthenticateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_OobAuthenticateResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  // oobAuthenticate
  router.post(
    `/oauth2/v1/oob-authenticate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_OobAuthenticateRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OobAuthenticateResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .oobAuthenticate(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, oobAuthenticateResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const parOptionsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const parOptionsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // parOptions
  router.options(
    `/oauth2/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            parOptionsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .parOptions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, parOptionsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const parResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ParResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // par
  router.post(
    `/oauth2/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_ParRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ParResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .par(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, parResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const revokeResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // revoke
  router.post(
    `/oauth2/v1/revoke`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_RevokeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .revoke(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, revokeResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenOptionsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const tokenOptionsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // tokenOptions
  router.options(
    `/oauth2/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            tokenOptionsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .tokenOptions(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, tokenOptionsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_TokenResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // token
  router.post(
    `/oauth2/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            s_TokenRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_TokenResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .token(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, tokenResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const userinfoResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_UserInfo],
      ["401", z.undefined()],
      ["403", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // userinfo
  router.get(
    `/oauth2/v1/userinfo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_UserInfo>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<void>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .userinfo(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, userinfoResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const getWellKnownOAuthConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOAuthConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOAuthConfigurationCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OAuthMetadata],
        ["400", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // getWellKnownOAuthConfigurationCustomAs
  router.get(
    `/oauth2/:authorizationServerId/.well-known/oauth-authorization-server`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getWellKnownOAuthConfigurationCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getWellKnownOAuthConfigurationCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OAuthMetadata>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .getWellKnownOAuthConfigurationCustomAs(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              getWellKnownOAuthConfigurationCustomAsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const getWellKnownOpenIdConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOpenIdConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOpenIdConfigurationCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OidcMetadata],
        ["400", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // getWellKnownOpenIdConfigurationCustomAs
  router.get(
    `/oauth2/:authorizationServerId/.well-known/openid-configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getWellKnownOpenIdConfigurationCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getWellKnownOpenIdConfigurationCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OidcMetadata>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .getWellKnownOpenIdConfigurationCustomAs(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch(handleImplementationError)
          .then(
            handleResponse(
              res,
              getWellKnownOpenIdConfigurationCustomAsResponseBodyValidator,
            ),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  const authorizeCustomAsResponseBodyValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  // authorizeCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            authorizeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            authorizeCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .authorizeCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, authorizeCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsWithPostResponseBodyValidator =
    responseValidationFactory([["429", s_Error]], undefined)

  // authorizeCustomAsWithPost
  router.post(
    `/oauth2/:authorizationServerId/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            authorizeCustomAsWithPostParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_AuthorizeWithPost,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .authorizeCustomAsWithPost(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, authorizeCustomAsWithPostResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const bcAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const bcAuthorizeCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_BackchannelAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // bcAuthorizeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/bc/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            bcAuthorizeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_BackchannelAuthorizeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>(
              200,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .bcAuthorizeCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, bcAuthorizeCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const challengeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const challengeCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ChallengeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  // challengeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/challenge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            challengeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ChallengeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ChallengeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .challengeCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, challengeCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const deviceAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const deviceAuthorizeCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_DeviceAuthorizeResponse],
        ["400", s_OAuthError],
        ["401", s_OAuthError],
        ["429", s_Error],
      ],
      undefined,
    )

  // deviceAuthorizeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/device/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deviceAuthorizeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_DeviceAuthorizeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DeviceAuthorizeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .deviceAuthorizeCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, deviceAuthorizeCustomAsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const introspectCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const introspectCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_IntrospectionResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // introspectCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/introspect`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            introspectCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_IntrospectionRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_IntrospectionResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .introspectCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, introspectCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const oauthKeysCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oauthKeysCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_OAuthKeys],
      ["429", s_Error],
    ],
    undefined,
  )

  // oauthKeysCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            oauthKeysCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OAuthKeys>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .oauthKeysCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, oauthKeysCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  const logoutCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logoutCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            logoutCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            logoutCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .logoutCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, logoutCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsWithPostResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logoutCustomAsWithPost
  router.post(
    `/oauth2/:authorizationServerId/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            logoutCustomAsWithPostParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_LogoutWithPost,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .logoutCustomAsWithPost(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, logoutCustomAsWithPostResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const oobAuthenticateCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oobAuthenticateCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OobAuthenticateResponse],
        ["400", s_OAuthError],
        ["401", s_OAuthError],
        ["403", s_OAuthError],
        ["429", s_OAuthError],
      ],
      undefined,
    )

  // oobAuthenticateCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/oob-authenticate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            oobAuthenticateCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_OobAuthenticateRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OobAuthenticateResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .oobAuthenticateCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(
            handleResponse(res, oobAuthenticateCustomAsResponseBodyValidator),
          )
      } catch (error) {
        next(error)
      }
    },
  )

  const parOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const parOptionsCustomAsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const parOptionsCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // parOptionsCustomAs
  router.options(
    `/oauth2/:authorizationServerId/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            parOptionsCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            parOptionsCustomAsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .parOptionsCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, parOptionsCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const parCustomAsParamSchema = z.object({authorizationServerId: z.string()})

  const parCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ParResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // parCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            parCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_ParRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ParResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .parCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, parCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const revokeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const revokeCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // revokeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/revoke`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            revokeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_RevokeRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .revokeCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, revokeCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const tokenOptionsCustomAsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const tokenOptionsCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // tokenOptionsCustomAs
  router.options(
    `/oauth2/:authorizationServerId/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            tokenOptionsCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            tokenOptionsCustomAsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .tokenOptionsCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, tokenOptionsCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenCustomAsParamSchema = z.object({authorizationServerId: z.string()})

  const tokenCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_TokenResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // tokenCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            tokenCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            s_TokenRequest,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_TokenResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .tokenCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, tokenCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  const userinfoCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const userinfoCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_UserInfo],
      ["401", z.undefined()],
      ["403", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // userinfoCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/userinfo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            userinfoCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_UserInfo>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<void>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        await implementation
          .userinfoCustomAs(input, responder, req, res, next)
          .catch(handleImplementationError)
          .then(handleResponse(res, userinfoCustomAsResponseBodyValidator))
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Okta OpenID Connect & OAuth 2.0
  return startServer(config)
}
