/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  t_AuthorizeCustomAsParamSchema,
  t_AuthorizeCustomAsQuerySchema,
  t_AuthorizeCustomAsWithPostParamSchema,
  t_AuthorizeCustomAsWithPostRequestBodySchema,
  t_AuthorizeQuerySchema,
  t_AuthorizeWithPostRequestBodySchema,
  t_BackchannelAuthorizeResponse,
  t_BcAuthorizeCustomAsParamSchema,
  t_BcAuthorizeCustomAsRequestBodySchema,
  t_BcAuthorizeRequestBodySchema,
  t_ChallengeCustomAsParamSchema,
  t_ChallengeCustomAsRequestBodySchema,
  t_ChallengeRequestBodySchema,
  t_ChallengeResponse,
  t_Client,
  t_CreateClientRequestBodySchema,
  t_DeleteClientParamSchema,
  t_DeviceAuthorizeCustomAsParamSchema,
  t_DeviceAuthorizeCustomAsRequestBodySchema,
  t_DeviceAuthorizeRequestBodySchema,
  t_DeviceAuthorizeResponse,
  t_Error,
  t_GenerateNewClientSecretParamSchema,
  t_GetClientParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
  t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
  t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
  t_GetWellKnownOpenIdConfigurationQuerySchema,
  t_GlobalTokenRevocationRequestBodySchema,
  t_IntrospectCustomAsParamSchema,
  t_IntrospectCustomAsRequestBodySchema,
  t_IntrospectRequestBodySchema,
  t_IntrospectionResponse,
  t_ListClientsQuerySchema,
  t_LogoutCustomAsParamSchema,
  t_LogoutCustomAsQuerySchema,
  t_LogoutCustomAsWithPostParamSchema,
  t_LogoutCustomAsWithPostRequestBodySchema,
  t_LogoutQuerySchema,
  t_LogoutWithPostRequestBodySchema,
  t_OAuthError,
  t_OAuthKeys,
  t_OAuthMetadata,
  t_OauthKeysCustomAsParamSchema,
  t_OauthKeysQuerySchema,
  t_OidcMetadata,
  t_OobAuthenticateCustomAsParamSchema,
  t_OobAuthenticateCustomAsRequestBodySchema,
  t_OobAuthenticateRequestBodySchema,
  t_OobAuthenticateResponse,
  t_ParCustomAsParamSchema,
  t_ParCustomAsRequestBodySchema,
  t_ParOptionsCustomAsParamSchema,
  t_ParOptionsCustomAsRequestHeaderSchema,
  t_ParOptionsRequestHeaderSchema,
  t_ParRequestBodySchema,
  t_ParResponse,
  t_ReplaceClientParamSchema,
  t_ReplaceClientRequestBodySchema,
  t_RevokeCustomAsParamSchema,
  t_RevokeCustomAsRequestBodySchema,
  t_RevokeRequestBodySchema,
  t_TokenCustomAsParamSchema,
  t_TokenCustomAsRequestBodySchema,
  t_TokenOptionsCustomAsParamSchema,
  t_TokenOptionsCustomAsRequestHeaderSchema,
  t_TokenOptionsRequestHeaderSchema,
  t_TokenRequestBodySchema,
  t_TokenResponse,
  t_UserInfo,
  t_UserinfoCustomAsParamSchema,
} from "./models"
import {
  s_AcrValue,
  s_AmrValue,
  s_AuthorizeWithPost,
  s_BackchannelAuthorizeRequest,
  s_BackchannelAuthorizeResponse,
  s_ChallengeRequest,
  s_ChallengeResponse,
  s_Client,
  s_CodeChallengeMethod,
  s_DeviceAuthorizeRequest,
  s_DeviceAuthorizeResponse,
  s_Error,
  s_GlobalTokenRevocationRequest,
  s_IntrospectionRequest,
  s_IntrospectionResponse,
  s_LogoutWithPost,
  s_OAuthError,
  s_OAuthKeys,
  s_OAuthMetadata,
  s_OidcMetadata,
  s_OobAuthenticateRequest,
  s_OobAuthenticateResponse,
  s_ParRequest,
  s_ParResponse,
  s_Prompt,
  s_ResponseMode,
  s_ResponseTypesSupported,
  s_RevokeRequest,
  s_TokenRequest,
  s_TokenResponse,
  s_UserInfo,
} from "./schemas"
import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  Params,
  ServerConfig,
  SkipResponse,
  StatusCode,
  sendResponse,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod"
import {NextFunction, Request, Response, Router} from "express"
import {z} from "zod"

export type GetWellKnownOpenIdConfigurationResponder = {
  with200(): ExpressRuntimeResponse<t_OidcMetadata>
  with400(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetWellKnownOpenIdConfiguration = (
  params: Params<
    void,
    t_GetWellKnownOpenIdConfigurationQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Authorize = (
  params: Params<void, t_AuthorizeQuerySchema, void, void>,
  respond: AuthorizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeWithPostResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type AuthorizeWithPost = (
  params: Params<void, void, t_AuthorizeWithPostRequestBodySchema, void>,
  respond: AuthorizeWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BcAuthorizeResponder = {
  with200(): ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type BcAuthorize = (
  params: Params<void, void, t_BcAuthorizeRequestBodySchema, void>,
  respond: BcAuthorizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChallengeResponder = {
  with200(): ExpressRuntimeResponse<t_ChallengeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type Challenge = (
  params: Params<void, void, t_ChallengeRequestBodySchema, void>,
  respond: ChallengeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ListClientsResponder = {
  with200(): ExpressRuntimeResponse<t_Client[]>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ListClients = (
  params: Params<void, t_ListClientsQuerySchema, void, void>,
  respond: ListClientsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type CreateClientResponder = {
  with201(): ExpressRuntimeResponse<t_Client>
  with400(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type CreateClient = (
  params: Params<void, void, t_CreateClientRequestBodySchema, void>,
  respond: CreateClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetClientResponder = {
  with200(): ExpressRuntimeResponse<t_Client>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetClient = (
  params: Params<t_GetClientParamSchema, void, void, void>,
  respond: GetClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReplaceClientResponder = {
  with200(): ExpressRuntimeResponse<t_Client>
  with400(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReplaceClient = (
  params: Params<
    t_ReplaceClientParamSchema,
    void,
    t_ReplaceClientRequestBodySchema,
    void
  >,
  respond: ReplaceClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeleteClientResponder = {
  with204(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeleteClient = (
  params: Params<t_DeleteClientParamSchema, void, void, void>,
  respond: DeleteClientResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GenerateNewClientSecretResponder = {
  with200(): ExpressRuntimeResponse<t_Client>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GenerateNewClientSecret = (
  params: Params<t_GenerateNewClientSecretParamSchema, void, void, void>,
  respond: GenerateNewClientSecretResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeviceAuthorizeResponder = {
  with200(): ExpressRuntimeResponse<t_DeviceAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeviceAuthorize = (
  params: Params<void, void, t_DeviceAuthorizeRequestBodySchema, void>,
  respond: DeviceAuthorizeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GlobalTokenRevocationResponder = {
  with204(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GlobalTokenRevocation = (
  params: Params<void, void, t_GlobalTokenRevocationRequestBodySchema, void>,
  respond: GlobalTokenRevocationResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IntrospectResponder = {
  with200(): ExpressRuntimeResponse<t_IntrospectionResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Introspect = (
  params: Params<void, void, t_IntrospectRequestBodySchema, void>,
  respond: IntrospectResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OauthKeysResponder = {
  with200(): ExpressRuntimeResponse<t_OAuthKeys>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type OauthKeys = (
  params: Params<void, t_OauthKeysQuerySchema, void, void>,
  respond: OauthKeysResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Logout = (
  params: Params<void, t_LogoutQuerySchema, void, void>,
  respond: LogoutResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutWithPostResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LogoutWithPost = (
  params: Params<void, void, t_LogoutWithPostRequestBodySchema, void>,
  respond: LogoutWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OobAuthenticateResponder = {
  with200(): ExpressRuntimeResponse<t_OobAuthenticateResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type OobAuthenticate = (
  params: Params<void, void, t_OobAuthenticateRequestBodySchema, void>,
  respond: OobAuthenticateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParOptionsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ParOptions = (
  params: Params<void, void, void, t_ParOptionsRequestHeaderSchema>,
  respond: ParOptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParResponder = {
  with200(): ExpressRuntimeResponse<t_ParResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Par = (
  params: Params<void, void, t_ParRequestBodySchema, void>,
  respond: ParResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type RevokeResponder = {
  with200(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Revoke = (
  params: Params<void, void, t_RevokeRequestBodySchema, void>,
  respond: RevokeResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenOptionsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type TokenOptions = (
  params: Params<void, void, void, t_TokenOptionsRequestHeaderSchema>,
  respond: TokenOptionsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenResponder = {
  with200(): ExpressRuntimeResponse<t_TokenResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Token = (
  params: Params<void, void, t_TokenRequestBodySchema, void>,
  respond: TokenResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UserinfoResponder = {
  with200(): ExpressRuntimeResponse<t_UserInfo>
  with401(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Userinfo = (
  params: Params<void, void, void, void>,
  respond: UserinfoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetWellKnownOAuthConfigurationCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OAuthMetadata>
  with400(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetWellKnownOAuthConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOAuthConfigurationCustomAsParamSchema,
    t_GetWellKnownOAuthConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOAuthConfigurationCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetWellKnownOpenIdConfigurationCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OidcMetadata>
  with400(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetWellKnownOpenIdConfigurationCustomAs = (
  params: Params<
    t_GetWellKnownOpenIdConfigurationCustomAsParamSchema,
    t_GetWellKnownOpenIdConfigurationCustomAsQuerySchema,
    void,
    void
  >,
  respond: GetWellKnownOpenIdConfigurationCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeCustomAsResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type AuthorizeCustomAs = (
  params: Params<
    t_AuthorizeCustomAsParamSchema,
    t_AuthorizeCustomAsQuerySchema,
    void,
    void
  >,
  respond: AuthorizeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthorizeCustomAsWithPostResponder = {
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type AuthorizeCustomAsWithPost = (
  params: Params<
    t_AuthorizeCustomAsWithPostParamSchema,
    void,
    t_AuthorizeCustomAsWithPostRequestBodySchema,
    void
  >,
  respond: AuthorizeCustomAsWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type BcAuthorizeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type BcAuthorizeCustomAs = (
  params: Params<
    t_BcAuthorizeCustomAsParamSchema,
    void,
    t_BcAuthorizeCustomAsRequestBodySchema,
    void
  >,
  respond: BcAuthorizeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ChallengeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_ChallengeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type ChallengeCustomAs = (
  params: Params<
    t_ChallengeCustomAsParamSchema,
    void,
    t_ChallengeCustomAsRequestBodySchema,
    void
  >,
  respond: ChallengeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type DeviceAuthorizeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_DeviceAuthorizeResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type DeviceAuthorizeCustomAs = (
  params: Params<
    t_DeviceAuthorizeCustomAsParamSchema,
    void,
    t_DeviceAuthorizeCustomAsRequestBodySchema,
    void
  >,
  respond: DeviceAuthorizeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type IntrospectCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_IntrospectionResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type IntrospectCustomAs = (
  params: Params<
    t_IntrospectCustomAsParamSchema,
    void,
    t_IntrospectCustomAsRequestBodySchema,
    void
  >,
  respond: IntrospectCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OauthKeysCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OAuthKeys>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type OauthKeysCustomAs = (
  params: Params<t_OauthKeysCustomAsParamSchema, void, void, void>,
  respond: OauthKeysCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutCustomAsResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LogoutCustomAs = (
  params: Params<
    t_LogoutCustomAsParamSchema,
    t_LogoutCustomAsQuerySchema,
    void,
    void
  >,
  respond: LogoutCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LogoutCustomAsWithPostResponder = {
  with200(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LogoutCustomAsWithPost = (
  params: Params<
    t_LogoutCustomAsWithPostParamSchema,
    void,
    t_LogoutCustomAsWithPostRequestBodySchema,
    void
  >,
  respond: LogoutCustomAsWithPostResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type OobAuthenticateCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_OobAuthenticateResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_OAuthError>
} & ExpressRuntimeResponder

export type OobAuthenticateCustomAs = (
  params: Params<
    t_OobAuthenticateCustomAsParamSchema,
    void,
    t_OobAuthenticateCustomAsRequestBodySchema,
    void
  >,
  respond: OobAuthenticateCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParOptionsCustomAsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ParOptionsCustomAs = (
  params: Params<
    t_ParOptionsCustomAsParamSchema,
    void,
    void,
    t_ParOptionsCustomAsRequestHeaderSchema
  >,
  respond: ParOptionsCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ParCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_ParResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with403(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ParCustomAs = (
  params: Params<
    t_ParCustomAsParamSchema,
    void,
    t_ParCustomAsRequestBodySchema,
    void
  >,
  respond: ParCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type RevokeCustomAsResponder = {
  with200(): ExpressRuntimeResponse<void>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type RevokeCustomAs = (
  params: Params<
    t_RevokeCustomAsParamSchema,
    void,
    t_RevokeCustomAsRequestBodySchema,
    void
  >,
  respond: RevokeCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenOptionsCustomAsResponder = {
  with204(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type TokenOptionsCustomAs = (
  params: Params<
    t_TokenOptionsCustomAsParamSchema,
    void,
    void,
    t_TokenOptionsCustomAsRequestHeaderSchema
  >,
  respond: TokenOptionsCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type TokenCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_TokenResponse>
  with400(): ExpressRuntimeResponse<t_OAuthError>
  with401(): ExpressRuntimeResponse<t_OAuthError>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type TokenCustomAs = (
  params: Params<
    t_TokenCustomAsParamSchema,
    void,
    t_TokenCustomAsRequestBodySchema,
    void
  >,
  respond: TokenCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type UserinfoCustomAsResponder = {
  with200(): ExpressRuntimeResponse<t_UserInfo>
  with401(): ExpressRuntimeResponse<void>
  with403(): ExpressRuntimeResponse<void>
  with429(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type UserinfoCustomAs = (
  params: Params<t_UserinfoCustomAsParamSchema, void, void, void>,
  respond: UserinfoCustomAsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  getWellKnownOpenIdConfiguration: GetWellKnownOpenIdConfiguration
  authorize: Authorize
  authorizeWithPost: AuthorizeWithPost
  bcAuthorize: BcAuthorize
  challenge: Challenge
  listClients: ListClients
  createClient: CreateClient
  getClient: GetClient
  replaceClient: ReplaceClient
  deleteClient: DeleteClient
  generateNewClientSecret: GenerateNewClientSecret
  deviceAuthorize: DeviceAuthorize
  globalTokenRevocation: GlobalTokenRevocation
  introspect: Introspect
  oauthKeys: OauthKeys
  logout: Logout
  logoutWithPost: LogoutWithPost
  oobAuthenticate: OobAuthenticate
  parOptions: ParOptions
  par: Par
  revoke: Revoke
  tokenOptions: TokenOptions
  token: Token
  userinfo: Userinfo
  getWellKnownOAuthConfigurationCustomAs: GetWellKnownOAuthConfigurationCustomAs
  getWellKnownOpenIdConfigurationCustomAs: GetWellKnownOpenIdConfigurationCustomAs
  authorizeCustomAs: AuthorizeCustomAs
  authorizeCustomAsWithPost: AuthorizeCustomAsWithPost
  bcAuthorizeCustomAs: BcAuthorizeCustomAs
  challengeCustomAs: ChallengeCustomAs
  deviceAuthorizeCustomAs: DeviceAuthorizeCustomAs
  introspectCustomAs: IntrospectCustomAs
  oauthKeysCustomAs: OauthKeysCustomAs
  logoutCustomAs: LogoutCustomAs
  logoutCustomAsWithPost: LogoutCustomAsWithPost
  oobAuthenticateCustomAs: OobAuthenticateCustomAs
  parOptionsCustomAs: ParOptionsCustomAs
  parCustomAs: ParCustomAs
  revokeCustomAs: RevokeCustomAs
  tokenOptionsCustomAs: TokenOptionsCustomAs
  tokenCustomAs: TokenCustomAs
  userinfoCustomAs: UserinfoCustomAs
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const getWellKnownOpenIdConfigurationQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOpenIdConfigurationResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OidcMetadata],
        ["400", s_Error],
      ],
      undefined,
    )

  // getWellKnownOpenIdConfiguration
  router.get(
    `/.well-known/openid-configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getWellKnownOpenIdConfigurationQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OidcMetadata>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getWellKnownOpenIdConfiguration(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          getWellKnownOpenIdConfigurationResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  const authorizeResponseBodyValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  // authorize
  router.get(
    `/oauth2/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            authorizeQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .authorize(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, authorizeResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeWithPostRequestBodySchema = s_AuthorizeWithPost

  const authorizeWithPostResponseBodyValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  // authorizeWithPost
  router.post(
    `/oauth2/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            authorizeWithPostRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .authorizeWithPost(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          authorizeWithPostResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const bcAuthorizeRequestBodySchema = s_BackchannelAuthorizeRequest

  const bcAuthorizeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_BackchannelAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // bcAuthorize
  router.post(
    `/oauth2/v1/bc/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            bcAuthorizeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>(
              200,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .bcAuthorize(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, bcAuthorizeResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const challengeRequestBodySchema = s_ChallengeRequest

  const challengeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ChallengeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  // challenge
  router.post(
    `/oauth2/v1/challenge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            challengeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ChallengeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .challenge(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, challengeResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const listClientsQuerySchema = z.object({
    after: z.string().optional(),
    limit: z.coerce.number().min(1).max(200).optional().default(20),
    q: z.string().optional(),
  })

  const listClientsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.array(s_Client)],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // listClients
  router.get(
    `/oauth2/v1/clients`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            listClientsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client[]>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .listClients(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, listClientsResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const createClientRequestBodySchema = s_Client

  const createClientResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_Client],
      ["400", s_Error],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // createClient
  router.post(
    `/oauth2/v1/clients`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            createClientRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_Client>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .createClient(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, createClientResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const getClientParamSchema = z.object({clientId: z.string()})

  const getClientResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Client],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // getClient
  router.get(
    `/oauth2/v1/clients/:clientId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getClientParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getClient(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, getClientResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const replaceClientParamSchema = z.object({clientId: z.string()})

  const replaceClientRequestBodySchema = s_Client

  const replaceClientResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_Client],
      ["400", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // replaceClient
  router.put(
    `/oauth2/v1/clients/:clientId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            replaceClientParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            replaceClientRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .replaceClient(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          replaceClientResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const deleteClientParamSchema = z.object({clientId: z.string()})

  const deleteClientResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // deleteClient
  router.delete(
    `/oauth2/v1/clients/:clientId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deleteClientParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deleteClient(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, deleteClientResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const generateNewClientSecretParamSchema = z.object({clientId: z.string()})

  const generateNewClientSecretResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_Client],
        ["403", s_Error],
        ["404", s_Error],
        ["429", s_Error],
      ],
      undefined,
    )

  // generateNewClientSecret
  router.post(
    `/oauth2/v1/clients/:clientId/lifecycle/newSecret`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            generateNewClientSecretParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Client>(200)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .generateNewClientSecret(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          generateNewClientSecretResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const deviceAuthorizeRequestBodySchema = s_DeviceAuthorizeRequest

  const deviceAuthorizeResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_DeviceAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // deviceAuthorize
  router.post(
    `/oauth2/v1/device/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            deviceAuthorizeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DeviceAuthorizeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deviceAuthorize(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          deviceAuthorizeResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const globalTokenRevocationRequestBodySchema = s_GlobalTokenRevocationRequest

  const globalTokenRevocationResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["400", z.undefined()],
      ["403", s_Error],
      ["429", s_Error],
    ],
    undefined,
  )

  // globalTokenRevocation
  router.post(
    `/oauth2/v1/global-token-revocation`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            globalTokenRevocationRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with400() {
            return new ExpressRuntimeResponse<void>(400)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .globalTokenRevocation(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          globalTokenRevocationResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const introspectRequestBodySchema = s_IntrospectionRequest

  const introspectResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_IntrospectionResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // introspect
  router.post(
    `/oauth2/v1/introspect`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            introspectRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_IntrospectionResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .introspect(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, introspectResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const oauthKeysQuerySchema = z.object({client_id: z.string().optional()})

  const oauthKeysResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_OAuthKeys],
      ["429", s_Error],
    ],
    undefined,
  )

  // oauthKeys
  router.get(
    `/oauth2/v1/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            oauthKeysQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OAuthKeys>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .oauthKeys(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, oauthKeysResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  const logoutResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logout
  router.get(
    `/oauth2/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            logoutQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .logout(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, logoutResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutWithPostRequestBodySchema = s_LogoutWithPost

  const logoutWithPostResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logoutWithPost
  router.post(
    `/oauth2/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            logoutWithPostRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .logoutWithPost(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          logoutWithPostResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const oobAuthenticateRequestBodySchema = s_OobAuthenticateRequest

  const oobAuthenticateResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_OobAuthenticateResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  // oobAuthenticate
  router.post(
    `/oauth2/v1/oob-authenticate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            oobAuthenticateRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OobAuthenticateResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .oobAuthenticate(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          oobAuthenticateResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const parOptionsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const parOptionsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // parOptions
  router.options(
    `/oauth2/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            parOptionsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .parOptions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, parOptionsResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const parRequestBodySchema = s_ParRequest

  const parResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ParResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // par
  router.post(
    `/oauth2/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            parRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ParResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .par(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, parResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const revokeRequestBodySchema = s_RevokeRequest

  const revokeResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // revoke
  router.post(
    `/oauth2/v1/revoke`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            revokeRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .revoke(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, revokeResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenOptionsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const tokenOptionsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // tokenOptions
  router.options(
    `/oauth2/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            tokenOptionsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .tokenOptions(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, tokenOptionsResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenRequestBodySchema = s_TokenRequest

  const tokenResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_TokenResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // token
  router.post(
    `/oauth2/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            tokenRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_TokenResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .token(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, tokenResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const userinfoResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_UserInfo],
      ["401", z.undefined()],
      ["403", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // userinfo
  router.get(
    `/oauth2/v1/userinfo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_UserInfo>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<void>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .userinfo(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, userinfoResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const getWellKnownOAuthConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOAuthConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOAuthConfigurationCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OAuthMetadata],
        ["400", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // getWellKnownOAuthConfigurationCustomAs
  router.get(
    `/oauth2/:authorizationServerId/.well-known/oauth-authorization-server`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getWellKnownOAuthConfigurationCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getWellKnownOAuthConfigurationCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OAuthMetadata>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getWellKnownOAuthConfigurationCustomAs(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          getWellKnownOAuthConfigurationCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const getWellKnownOpenIdConfigurationCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const getWellKnownOpenIdConfigurationCustomAsQuerySchema = z.object({
    client_id: z.string().optional(),
  })

  const getWellKnownOpenIdConfigurationCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OidcMetadata],
        ["400", s_Error],
        ["404", s_Error],
      ],
      undefined,
    )

  // getWellKnownOpenIdConfigurationCustomAs
  router.get(
    `/oauth2/:authorizationServerId/.well-known/openid-configuration`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            getWellKnownOpenIdConfigurationCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            getWellKnownOpenIdConfigurationCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OidcMetadata>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getWellKnownOpenIdConfigurationCustomAs(
            input,
            responder,
            req,
            res,
            next,
          )
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          getWellKnownOpenIdConfigurationCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsQuerySchema = z.object({
    acr_values: s_AcrValue.optional(),
    client_id: z.string(),
    code_challenge: z.string().optional(),
    code_challenge_method: s_CodeChallengeMethod.optional(),
    display: z.string().optional(),
    enroll_amr_values: s_AmrValue.optional(),
    idp_scope: z.string().optional(),
    idp: z.string().optional(),
    login_hint: z.string().optional(),
    max_age: z.coerce.number().optional(),
    nonce: z.string().optional(),
    prompt: s_Prompt.optional(),
    redirect_uri: z.string(),
    response_type: s_ResponseTypesSupported,
    response_mode: s_ResponseMode.optional(),
    request_uri: z.string().optional(),
    request: z.string().optional(),
    scope: z.string(),
    sessionToken: z.string().optional(),
    state: z.string(),
  })

  const authorizeCustomAsResponseBodyValidator = responseValidationFactory(
    [["429", s_Error]],
    undefined,
  )

  // authorizeCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            authorizeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            authorizeCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .authorizeCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          authorizeCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const authorizeCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const authorizeCustomAsWithPostRequestBodySchema = s_AuthorizeWithPost

  const authorizeCustomAsWithPostResponseBodyValidator =
    responseValidationFactory([["429", s_Error]], undefined)

  // authorizeCustomAsWithPost
  router.post(
    `/oauth2/:authorizationServerId/v1/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            authorizeCustomAsWithPostParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            authorizeCustomAsWithPostRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .authorizeCustomAsWithPost(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          authorizeCustomAsWithPostResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const bcAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const bcAuthorizeCustomAsRequestBodySchema = s_BackchannelAuthorizeRequest

  const bcAuthorizeCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_BackchannelAuthorizeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // bcAuthorizeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/bc/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            bcAuthorizeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            bcAuthorizeCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_BackchannelAuthorizeResponse>(
              200,
            )
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .bcAuthorizeCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          bcAuthorizeCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const challengeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const challengeCustomAsRequestBodySchema = s_ChallengeRequest

  const challengeCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ChallengeResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_OAuthError],
    ],
    undefined,
  )

  // challengeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/challenge`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            challengeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            challengeCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ChallengeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .challengeCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          challengeCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const deviceAuthorizeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const deviceAuthorizeCustomAsRequestBodySchema = s_DeviceAuthorizeRequest

  const deviceAuthorizeCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_DeviceAuthorizeResponse],
        ["400", s_OAuthError],
        ["401", s_OAuthError],
        ["429", s_Error],
      ],
      undefined,
    )

  // deviceAuthorizeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/device/authorize`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            deviceAuthorizeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            deviceAuthorizeCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DeviceAuthorizeResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .deviceAuthorizeCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          deviceAuthorizeCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const introspectCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const introspectCustomAsRequestBodySchema = s_IntrospectionRequest

  const introspectCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_IntrospectionResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // introspectCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/introspect`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            introspectCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            introspectCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_IntrospectionResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .introspectCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          introspectCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const oauthKeysCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oauthKeysCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_OAuthKeys],
      ["429", s_Error],
    ],
    undefined,
  )

  // oauthKeysCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/keys`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            oauthKeysCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OAuthKeys>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .oauthKeysCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          oauthKeysCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsQuerySchema = z.object({
    id_token_hint: z.string(),
    post_logout_redirect_uri: z.string().optional(),
    state: z.string().optional(),
  })

  const logoutCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logoutCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            logoutCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: parseRequestInput(
            logoutCustomAsQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .logoutCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          logoutCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const logoutCustomAsWithPostParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const logoutCustomAsWithPostRequestBodySchema = s_LogoutWithPost

  const logoutCustomAsWithPostResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // logoutCustomAsWithPost
  router.post(
    `/oauth2/:authorizationServerId/v1/logout`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            logoutCustomAsWithPostParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            logoutCustomAsWithPostRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .logoutCustomAsWithPost(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          logoutCustomAsWithPostResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const oobAuthenticateCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const oobAuthenticateCustomAsRequestBodySchema = s_OobAuthenticateRequest

  const oobAuthenticateCustomAsResponseBodyValidator =
    responseValidationFactory(
      [
        ["200", s_OobAuthenticateResponse],
        ["400", s_OAuthError],
        ["401", s_OAuthError],
        ["403", s_OAuthError],
        ["429", s_OAuthError],
      ],
      undefined,
    )

  // oobAuthenticateCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/oob-authenticate`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            oobAuthenticateCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            oobAuthenticateCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_OobAuthenticateResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_OAuthError>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .oobAuthenticateCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          oobAuthenticateCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const parOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const parOptionsCustomAsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const parOptionsCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // parOptionsCustomAs
  router.options(
    `/oauth2/:authorizationServerId/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            parOptionsCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            parOptionsCustomAsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .parOptionsCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          parOptionsCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const parCustomAsParamSchema = z.object({authorizationServerId: z.string()})

  const parCustomAsRequestBodySchema = s_ParRequest

  const parCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ParResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["403", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // parCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/par`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            parCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            parCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ParResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_OAuthError>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .parCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(res, status, body, parCustomAsResponseBodyValidator)
      } catch (error) {
        next(error)
      }
    },
  )

  const revokeCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const revokeCustomAsRequestBodySchema = s_RevokeRequest

  const revokeCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.undefined()],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // revokeCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/revoke`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            revokeCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            revokeCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<void>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .revokeCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          revokeCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenOptionsCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const tokenOptionsCustomAsRequestHeaderSchema = z.object({
    origin: z.string().optional(),
  })

  const tokenOptionsCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["204", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // tokenOptionsCustomAs
  router.options(
    `/oauth2/:authorizationServerId/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            tokenOptionsCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            tokenOptionsCustomAsRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .tokenOptionsCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          tokenOptionsCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const tokenCustomAsParamSchema = z.object({authorizationServerId: z.string()})

  const tokenCustomAsRequestBodySchema = s_TokenRequest

  const tokenCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_TokenResponse],
      ["400", s_OAuthError],
      ["401", s_OAuthError],
      ["429", s_Error],
    ],
    undefined,
  )

  // tokenCustomAs
  router.post(
    `/oauth2/:authorizationServerId/v1/token`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            tokenCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            tokenCustomAsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_TokenResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_OAuthError>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_OAuthError>(401)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .tokenCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          tokenCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  const userinfoCustomAsParamSchema = z.object({
    authorizationServerId: z.string(),
  })

  const userinfoCustomAsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_UserInfo],
      ["401", z.undefined()],
      ["403", z.undefined()],
      ["429", s_Error],
    ],
    undefined,
  )

  // userinfoCustomAs
  router.get(
    `/oauth2/:authorizationServerId/v1/userinfo`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            userinfoCustomAsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_UserInfo>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<void>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<void>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .userinfoCustomAs(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const {status, body} =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        await sendResponse(
          res,
          status,
          body,
          userinfoCustomAsResponseBodyValidator,
        )
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Okta OpenID Connect & OAuth 2.0
  return startServer(config)
}
